{\rtf1\windows \deff0{\fonttbl
{\f0\fswiss MS Sans Serif;}{\f1\fmodern Courier New;}{\f2\ftech Symbol;}}\fs20
\page #{\footnote hcAbout}${\footnote \pard{}About this help file}\pard{\fs24\b About this help file}\par\par\pard{}This file was made with the help of {\ul Makertf 3.12b-1}{\v hcMakertf} from the input file bison.texi.\par\par{}{{START-INFO-DIR-ENTRY\line
* bison: (bison).	GNU Project parser generator (yacc replacement).\line
END-INFO-DIR-ENTRY\par
\pard{}}}\par
{\pard{}This file documents the Bison parser generator.\par
\par
\pard{}Copyright (C) 1988, 89, 90, 91, 92, 93, 95, 98, 1999 Free Software Foundation, Inc.\par
\par
\pard{}Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.\par
\par
\pard{}Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided also that the sections entitled "GNU General Public License" and "Conditions for Using Bison" are included exactly as in the original, and provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.\par
\par
\pard{}Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions, except that the sections entitled "GNU General Public License", "Conditions for Using Bison" and this permission notice may be included in translations approved by the Free Software Foundation instead of in the original English.  }\par
\par
\page\pard Node: {\b Top}, \keepn Next: {\uldb Introduction}{\v Introduction}, Prev: {\uldb (dir)}{\v Top @dir.hlp}, Up: {\uldb (dir)}{\v Top @dir.hlp}\tab\tab{\uldb About this help file}{\v hcAbout}\line
K{\footnote K Top}
#{\footnote Top}
{\par
\pard\pard{}This manual documents version 1.28 of Bison.  }\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Introduction}{\v Introduction}\tab \par
{\uldb Conditions}{\v Conditions}\tab \par
{\uldb Copying}{\v Copying}\tab The GNU General Public License says how you can copy and share Bison\par
\par
  Tutorial sections:\par
{\uldb Concepts}{\v Concepts}\tab Basic concepts for understanding Bison.\par
{\uldb Examples}{\v Examples}\tab Three simple explained examples of using Bison.\par
\par
  Reference sections:\par
{\uldb Grammar File}{\v Grammar_File}\tab Writing Bison declarations and rules.\par
{\uldb Interface}{\v Interface}\tab C-language interface to the parser function {\f1{}yyparse}.\par
{\uldb Algorithm}{\v Algorithm}\tab How the Bison parser works at run-time.\par
{\uldb Error Recovery}{\v Error_Recovery}\tab Writing rules for error recovery.\par
{\uldb Context Dependency}{\v Context_Dependency}\tab What to do if your language syntax is too messy for Bison to handle straightforwardly.\par
{\uldb Debugging}{\v Debugging}\tab Debugging Bison parsers that parse wrong.\par
{\uldb Invocation}{\v Invocation}\tab How to run Bison (to produce the parser source file).\par
{\uldb Table of Symbols}{\v Table_of_Symbols}\tab All the keywords of the Bison language are explained.\par
{\uldb Glossary}{\v Glossary}\tab Basic concepts are explained.\par
{\uldb Index}{\v Index}\tab Cross-references to the text.\par
\par
  --- The Detailed Node Listing ---\par
\par
  The Concepts of Bison\par
\par
 \par
{\uldb Language and Grammar}{\v Language_and_Grammar}\tab Languages and context-free grammars, as mathematical ideas.\par
{\uldb Grammar in Bison}{\v Grammar_in_Bison}\tab How we represent grammars for Bison's sake.\par
{\uldb Semantic Values}{\v Semantic_Values}\tab Each token or syntactic grouping can have a semantic value (the value of an integer, the name of an identifier, etc.).\par
{\uldb Semantic Actions}{\v Semantic_Actions}\tab Each rule can have an action containing C code.\par
{\uldb Bison Parser}{\v Bison_Parser}\tab What are Bison's input and output, how is the output used?\par
{\uldb Stages}{\v Stages}\tab Stages in writing and running Bison grammars.\par
{\uldb Grammar Layout}{\v Grammar_Layout}\tab Overall structure of a Bison grammar file.\par
\par
  Examples\par
\par
 \par
{\uldb RPN Calc}{\v RPN_Calc}\tab Reverse polish notation calculator; a first example with no operator precedence.\par
{\uldb Infix Calc}{\v Infix_Calc}\tab Infix (algebraic) notation calculator. Operator precedence is introduced.\par
{\uldb Simple Error Recovery}{\v Simple_Error_Recovery}\tab Continuing after syntax errors.\par
{\uldb Multi-function Calc}{\v Multi_function_Calc}\tab Calculator with memory and trig functions. It uses multiple data-types for semantic values.\par
{\uldb Exercises}{\v Exercises}\tab Ideas for improving the multi-function calculator.\par
\par
  Reverse Polish Notation Calculator\par
\par
 \par
{\uldb Decls}{\v Rpcalc_Decls}\tab Bison and C declarations for rpcalc.\par
{\uldb Rules}{\v Rpcalc_Rules}\tab Grammar Rules for rpcalc, with explanation.\par
{\uldb Lexer}{\v Rpcalc_Lexer}\tab The lexical analyzer.\par
{\uldb Main}{\v Rpcalc_Main}\tab The controlling function.\par
{\uldb Error}{\v Rpcalc_Error}\tab The error reporting function.\par
{\uldb Gen}{\v Rpcalc_Gen}\tab Running Bison on the grammar file.\par
{\uldb Comp}{\v Rpcalc_Compile}\tab Run the C compiler on the output code.\par
\par
  Grammar Rules for {\f1{}rpcalc}\par
\par
 \par
{\uldb Rpcalc Input}{\v Rpcalc_Input}\tab \par
{\uldb Rpcalc Line}{\v Rpcalc_Line}\tab \par
{\uldb Rpcalc Expr}{\v Rpcalc_Expr}\tab \par
\par
  Multi-Function Calculator: {\f1{}mfcalc}\par
\par
 \par
{\uldb Decl}{\v Mfcalc_Decl}\tab Bison declarations for multi-function calculator.\par
{\uldb Rules}{\v Mfcalc_Rules}\tab Grammar rules for the calculator.\par
{\uldb Symtab}{\v Mfcalc_Symtab}\tab Symbol table management subroutines.\par
\par
  Bison Grammar Files\par
\par
 \par
{\uldb Grammar Outline}{\v Grammar_Outline}\tab Overall layout of the grammar file.\par
{\uldb Symbols}{\v Symbols}\tab Terminal and nonterminal symbols.\par
{\uldb Rules}{\v Rules}\tab How to write grammar rules.\par
{\uldb Recursion}{\v Recursion}\tab Writing recursive rules.\par
{\uldb Semantics}{\v Semantics}\tab Semantic values and actions.\par
{\uldb Declarations}{\v Declarations}\tab All kinds of Bison declarations are described here.\par
{\uldb Multiple Parsers}{\v Multiple_Parsers}\tab Putting more than one Bison parser in one program.\par
\par
  Outline of a Bison Grammar\par
\par
 \par
{\uldb C Declarations}{\v C_Declarations}\tab Syntax and usage of the C declarations section.\par
{\uldb Bison Declarations}{\v Bison_Declarations}\tab Syntax and usage of the Bison declarations section.\par
{\uldb Grammar Rules}{\v Grammar_Rules}\tab Syntax and usage of the grammar rules section.\par
{\uldb C Code}{\v C_Code}\tab Syntax and usage of the additional C code section.\par
\par
  Defining Language Semantics\par
\par
 \par
{\uldb Value Type}{\v Value_Type}\tab Specifying one data type for all semantic values.\par
{\uldb Multiple Types}{\v Multiple_Types}\tab Specifying several alternative data types.\par
{\uldb Actions}{\v Actions}\tab An action is the semantic definition of a grammar rule.\par
{\uldb Action Types}{\v Action_Types}\tab Specifying data types for actions to operate on.\par
{\uldb Mid-Rule Actions}{\v Mid_Rule_Actions}\tab Most actions go at the end of a rule. This says when, why and how to use the exceptional action in the middle of a rule.\par
\par
  Bison Declarations\par
\par
 \par
{\uldb Token Decl}{\v Token_Decl}\tab Declaring terminal symbols.\par
{\uldb Precedence Decl}{\v Precedence_Decl}\tab Declaring terminals with precedence and associativity.\par
{\uldb Union Decl}{\v Union_Decl}\tab Declaring the set of all semantic value types.\par
{\uldb Type Decl}{\v Type_Decl}\tab Declaring the choice of type for a nonterminal symbol.\par
{\uldb Expect Decl}{\v Expect_Decl}\tab Suppressing warnings about shift/reduce conflicts.\par
{\uldb Start Decl}{\v Start_Decl}\tab Specifying the start symbol.\par
{\uldb Pure Decl}{\v Pure_Decl}\tab Requesting a reentrant parser.\par
{\uldb Decl Summary}{\v Decl_Summary}\tab Table of all Bison declarations.\par
\par
  Parser C-Language Interface\par
\par
 \par
{\uldb Parser Function}{\v Parser_Function}\tab How to call {\f1{}yyparse} and what it returns.\par
{\uldb Lexical}{\v Lexical}\tab You must supply a function {\f1{}yylex} which reads tokens.\par
{\uldb Error Reporting}{\v Error_Reporting}\tab You must supply a function {\f1{}yyerror}.\par
{\uldb Action Features}{\v Action_Features}\tab Special features for use in actions.\par
\par
  The Lexical Analyzer Function {\f1{}yylex}\par
\par
 \par
{\uldb Calling Convention}{\v Calling_Convention}\tab How {\f1{}yyparse} calls {\f1{}yylex}.\par
{\uldb Token Values}{\v Token_Values}\tab How {\f1{}yylex} must return the semantic value of the token it has read.\par
{\uldb Token Positions}{\v Token_Positions}\tab How {\f1{}yylex} must return the text position (line number, etc.) of the token, if the actions want that.\par
{\uldb Pure Calling}{\v Pure_Calling}\tab How the calling convention differs in a pure parser (see {\uldb A Pure (Reentrant) Parser}{\v Pure_Decl}).\par
\par
  The Bison Parser Algorithm\par
\par
 \par
{\uldb Look-Ahead}{\v Look_Ahead}\tab Parser looks one token ahead when deciding what to do.\par
{\uldb Shift/Reduce}{\v Shift_Reduce}\tab Conflicts: when either shifting or reduction is valid.\par
{\uldb Precedence}{\v Precedence}\tab Operator precedence works by resolving conflicts.\par
{\uldb Contextual Precedence}{\v Contextual_Precedence}\tab When an operator's precedence depends on context.\par
{\uldb Parser States}{\v Parser_States}\tab The parser is a finite-state-machine with stack.\par
{\uldb Reduce/Reduce}{\v Reduce_Reduce}\tab When two rules are applicable in the same situation.\par
{\uldb Mystery Conflicts}{\v Mystery_Conflicts}\tab Reduce/reduce conflicts that look unjustified.\par
{\uldb Stack Overflow}{\v Stack_Overflow}\tab What happens when stack gets full.  How to avoid it.\par
\par
  Operator Precedence\par
\par
 \par
{\uldb Why Precedence}{\v Why_Precedence}\tab An example showing why precedence is needed.\par
{\uldb Using Precedence}{\v Using_Precedence}\tab How to specify precedence in Bison grammars.\par
{\uldb Precedence Examples}{\v Precedence_Examples}\tab How these features are used in the previous example.\par
{\uldb How Precedence}{\v How_Precedence}\tab How they work.\par
\par
  Handling Context Dependencies\par
\par
 \par
{\uldb Semantic Tokens}{\v Semantic_Tokens}\tab Token parsing can depend on the semantic context.\par
{\uldb Lexical Tie-ins}{\v Lexical_Tie_ins}\tab Token parsing can depend on the syntactic context.\par
{\uldb Tie-in Recovery}{\v Tie_in_Recovery}\tab Lexical tie-ins have implications for how error recovery rules must be written.\par
\par
  Invoking Bison\par
\par
 \par
{\uldb Bison Options}{\v Bison_Options}\tab All the options described in detail, in alphabetical order by short options.\par
{\uldb Option Cross Key}{\v Option_Cross_Key}\tab Alphabetical list of long options.\par
{\uldb VMS Invocation}{\v VMS_Invocation}\tab Bison command syntax on VMS.\par
\pard{}}\par
\page\pard Node: {\b Introduction}, \keepn Next: {\uldb Conditions}{\v Conditions}, Prev: {\uldb Top}{\v Top}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Introduction}
#{\footnote Introduction}
${\footnote \pard{}Introduction}\par
\pard{\fs24\b Introduction}\par
\par
\pard{}{K{\footnote K introduction}} \'A2Bison\'A2 is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a C program to parse that grammar.  Once you are proficient with Bison, you may use it to develop a wide range of language parsers, from those used in simple desk calculators to complex programming languages.\par
\par
\pard{}Bison is upward compatible with Yacc: all properly-written Yacc grammars ought to work with Bison with no change.  Anyone familiar with Yacc should be able to use Bison with little trouble.  You need to be fluent in C programming in order to use Bison or to understand this manual.\par
\par
\pard{}We begin with tutorial chapters that explain the basic concepts of using Bison and show three explained examples, each building on the last.  If you don't know Bison or Yacc, start by reading these chapters.  Reference chapters follow which describe specific aspects of Bison in detail.\par
\par
\pard{}Bison was written primarily by Robert Corbett; Richard Stallman made it Yacc-compatible.  Wilfred Hansen of Carnegie Mellon University added multicharacter string literals and other features.\par
\par
\pard{}This edition corresponds to version 1.28 of Bison.\par
\par
\page\pard Node: {\b Conditions}, \keepn Next: {\uldb Copying}{\v Copying}, Prev: {\uldb Introduction}{\v Introduction}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Conditions}
#{\footnote Conditions}
${\footnote \pard{}Conditions for Using Bison}\par
\pard{\fs24\b Conditions for Using Bison}\par
\par
\pard{}As of Bison version 1.24, we have changed the distribution terms for {\f1{}yyparse} to permit using Bison's output in non-free programs.  Formerly, Bison parsers could be used only in programs that were free software.\par
\par
\pard{}The other GNU programming tools, such as the GNU C compiler, have never had such a requirement.  They could always be used for non-free software.  The reason Bison was different was not due to a special policy decision; it resulted from applying the usual General Public License to all of the Bison source code.\par
\par
\pard{}The output of the Bison utility--the Bison parser file--contains a verbatim copy of a sizable piece of Bison, which is the code for the {\f1{}yyparse} function.  (The actions from your grammar are inserted into this function at one point, but the rest of the function is not changed.)  When we applied the GPL terms to the code for {\f1{}yyparse}, the effect was to restrict the use of Bison output to free software.\par
\par
\pard{}We didn't change the terms because of sympathy for people who want to make software proprietary.  {\b Software should be free.}  But we concluded that limiting Bison's use to free software was doing little to encourage people to make other software free.  So we decided to make the practical conditions for using Bison match the practical conditions for using the other GNU tools.\par
\par
\page\pard Node: {\b Copying}, \keepn Next: {\uldb Concepts}{\v Concepts}, Prev: {\uldb Conditions}{\v Conditions}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Copying}
#{\footnote Copying}
${\footnote \pard{}GNU GENERAL PUBLIC LICENSE}\par
\pard{\fs24\b GNU GENERAL PUBLIC LICENSE}\par
\par
\pard{}Version 2, June 1991\qc{}\par
\par
{\pard\keep\li720\f1{}Copyright (C) 1989, 1991 Free Software Foundation, Inc.\line
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA\line
\line
Everyone is permitted to copy and distribute verbatim copies\line
of this license document, but changing it is not allowed.\par
\pard\f0{}}\par
\pard{\b Preamble}\par
\par
\pard{}The licenses for most software are designed to take away your freedom to share and change it.  By contrast, the GNU General Public License is intended to guarantee your freedom to share and change free software--to make sure the software is free for all its users.  This General Public License applies to most of the Free Software Foundation's software and to any other program whose authors commit to using it.  (Some other Free Software Foundation software is covered by the GNU Library General Public License instead.)  You can apply it to your programs, too.\par
\par
\pard{}When we speak of free software, we are referring to freedom, not price.  Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs; and that you know you can do these things.\par
\par
\pard{}To protect your rights, we need to make restrictions that forbid anyone to deny you these rights or to ask you to surrender the rights.  These restrictions translate to certain responsibilities for you if you distribute copies of the software, or if you modify it.\par
\par
\pard{}For example, if you distribute copies of such a program, whether gratis or for a fee, you must give the recipients all the rights that you have.  You must make sure that they, too, receive or can get the source code.  And you must show them these terms so they know their rights.\par
\par
\pard{}We protect your rights with two steps: (1) copyright the software, and (2) offer you this license which gives you legal permission to copy, distribute and/or modify the software.\par
\par
\pard{}Also, for each author's protection and ours, we want to make certain that everyone understands that there is no warranty for this free software.  If the software is modified by someone else and passed on, we want its recipients to know that what they have is not the original, so that any problems introduced by others will not reflect on the original authors' reputations.\par
\par
\pard{}Finally, any free program is threatened constantly by software patents.  We wish to avoid the danger that redistributors of a free program will individually obtain patent licenses, in effect making the program proprietary.  To prevent this, we have made it clear that any patent must be licensed for everyone's free use or not licensed at all.\par
\par
\pard{}The precise terms and conditions for copying, distribution and modification follow.\par
\par
{\pard{}TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\qc{}\par
\par
}{\pard\fi-720\li720\tx144\tx720{}\tab{}0. \tab{}This License applies to any program or other work which contains a notice placed by the copyright holder saying it may be distributed under the terms of this General Public License.  The "Program", below, refers to any such program or work, and a "work based on the Program" means either the Program or any derivative work under copyright law: that is to say, a work containing the Program or a portion of it, either verbatim or with modifications and/or translated into another language.  (Hereinafter, translation is included without limitation in the term "modification".)  Each licensee is addressed as "you".\par
\par
\pard\li720{}Activities other than copying, distribution and modification are not covered by this License; they are outside its scope.  The act of running the Program is not restricted, and the output from the Program is covered only if its contents constitute a work based on the Program (independent of having been made by running the Program).  Whether that is true depends on what the Program does.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}1. \tab{}You may copy and distribute verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and give any other recipients of the Program a copy of this License along with the Program.\par
\par
\pard\li720{}You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}2. \tab{}You may modify your copy or copies of the Program or any portion of it, thus forming a work based on the Program, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions:\par
\par
{\pard\fi-720\li1440\tx864\tx1440{}\tab{}a.\tab{}You must cause the modified files to carry prominent notices stating that you changed the files and the date of any change.\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}b.\tab{}You must cause any work that you distribute or publish, that in whole or in part contains or is derived from the Program or any part thereof, to be licensed as a whole at no charge to all third parties under the terms of this License.\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}c.\tab{}If the modified program normally reads commands interactively when run, you must cause it, when started running for such interactive use in the most ordinary way, to print or display an announcement including an appropriate copyright notice and a notice that there is no warranty (or else, saying that you provide a warranty) and that users may redistribute the program under these conditions, and telling the user how to view a copy of this License.  (Exception: if the Program itself is interactive but does not normally print such an announcement, your work based on the Program is not required to print an announcement.)\par
\pard\li720{}}\par
\pard\li720{}These requirements apply to the modified work as a whole.  If identifiable sections of that work are not derived from the Program, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works.  But when you distribute the same sections as part of a whole which is a work based on the Program, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it.\par
\par
\pard\li720{}Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Program.\par
\par
\pard\li720{}In addition, mere aggregation of another work not based on the Program with the Program (or with a work based on the Program) on a volume of a storage or distribution medium does not bring the other work under the scope of this License.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}3. \tab{}You may copy and distribute the Program (or a work based on it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you also do one of the following:\par
\par
{\pard\fi-720\li1440\tx864\tx1440{}\tab{}a.\tab{}Accompany it with the complete corresponding machine-readable source code, which must be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or,\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}b.\tab{}Accompany it with a written offer, valid for at least three years, to give any third party, for a charge no more than your cost of physically performing source distribution, a complete machine-readable copy of the corresponding source code, to be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or,\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}c.\tab{}Accompany it with the information you received as to the offer to distribute corresponding source code.  (This alternative is allowed only for noncommercial distribution and only if you received the program in object code or executable form with such an offer, in accord with Subsection b above.)\par
\pard\li720{}}\par
\pard\li720{}The source code for a work means the preferred form of the work for making modifications to it.  For an executable work, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the executable.  However, as a special exception, the source code distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable.\par
\par
\pard\li720{}If distribution of executable or object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place counts as distribution of the source code, even though third parties are not compelled to copy the source along with the object code.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}4. \tab{}You may not copy, modify, sublicense, or distribute the Program except as expressly provided under this License.  Any attempt otherwise to copy, modify, sublicense or distribute the Program is void, and will automatically terminate your rights under this License.  However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}5. \tab{}You are not required to accept this License, since you have not signed it.  However, nothing else grants you permission to modify or distribute the Program or its derivative works.  These actions are prohibited by law if you do not accept this License.  Therefore, by modifying or distributing the Program (or any work based on the Program), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Program or works based on it.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}6. \tab{}Each time you redistribute the Program (or any work based on the Program), the recipient automatically receives a license from the original licensor to copy, distribute or modify the Program subject to these terms and conditions.  You may not impose any further restrictions on the recipients' exercise of the rights granted herein.  You are not responsible for enforcing compliance by third parties to this License.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}7. \tab{}If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License.  If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Program at all.  For example, if a patent license would not permit royalty-free redistribution of the Program by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Program.\par
\par
\pard\li720{}If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply and the section as a whole is intended to apply in other circumstances.\par
\par
\pard\li720{}It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system, which is implemented by public license practices.  Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice.\par
\par
\pard\li720{}This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}8. \tab{}If the distribution and/or use of the Program is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Program under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded.  In such case, this License incorporates the limitation as if written in the body of this License.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}9. \tab{}The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time.  Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.\par
\par
\pard\li720{}Each version is given a distinguishing version number.  If the Program specifies a version number of this License which applies to it and "any later version", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation.  If the Program does not specify a version number of this License, you may choose any version ever published by the Free Software Foundation.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}10. \tab{}If you wish to incorporate parts of the Program into other free programs whose distribution conditions are different, write to the author to ask for permission.  For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this.  Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally.\par
\par
{\pard\li720{}NO WARRANTY\qc{}\par
\par
}\pard\fi-720\li720\tx144\tx720{}\tab{}11. \tab{}BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}12. \tab{}IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\par
\pard{}}\par
{\pard{}END OF TERMS AND CONDITIONS\qc{}\par
\par
}\pard{\b How to Apply These Terms to Your New Programs}\par
\par
\pard{}If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.\par
\par
\pard{}To do so, attach the following notices to the program.  It is safest to attach them to the start of each source file to most effectively convey the exclusion of warranty; and each file should have at least the "copyright" line and a pointer to where the full notice is found.\par
\par
{{\i \pard\li720\f1{}one line to give the program's name and a brief idea of what it does.}\line
Copyright (C) 19{\i yy}  {\i name of author}\line
\line
This program is free software; you can redistribute it and/or modify\line
it under the terms of the GNU General Public License as published by\line
the Free Software Foundation; either version 2 of the License, or\line
(at your option) any later version.\line
\line
This program is distributed in the hope that it will be useful,\line
but WITHOUT ANY WARRANTY; without even the implied warranty of\line
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\line
GNU General Public License for more details.\line
\line
You should have received a copy of the GNU General Public License\line
along with this program; if not, write to the Free Software\line
Foundation, Inc., 59 Temple Place - Suite 330,\line
Boston, MA 02111-1307, USA.\par
\pard\f0{}}\par
\pard{}Also add information on how to contact you by electronic and paper mail.\par
\par
\pard{}If the program is interactive, make it output a short notice like this when it starts in an interactive mode:\par
\par
{\pard\keep\li720\f1{}Gnomovision version 69, Copyright (C) 19{\i yy} {\i name of author}\line
Gnomovision comes with ABSOLUTELY NO WARRANTY; for details\line
type `show w'.\line
This is free software, and you are welcome to redistribute it\line
under certain conditions; type `show c' for details.\par
\pard\f0{}}\par
\pard{}The hypothetical commands {\f1{}show w} and {\f1{}show c} should show the appropriate parts of the General Public License.  Of course, the commands you use may be called something other than {\f1{}show w} and {\f1{}show c}; they could even be mouse-clicks or menu items--whatever suits your program.\par
\par
\pard{}You should also get your employer (if you work as a programmer) or your school, if any, to sign a "copyright disclaimer" for the program, if necessary.  Here is a sample; alter the names:\par
\par
{\pard\keep\li720\f1{}Yoyodyne, Inc., hereby disclaims all copyright interest in the program\line
`Gnomovision' (which makes passes at compilers) written by James Hacker.\line
\line
{\i signature of Ty Coon}, 1 April 1989\line
Ty Coon, President of Vice\par
\pard\f0{}}\par
\pard{}This General Public License does not permit incorporating your program into proprietary programs.  If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library.  If this is what you want to do, use the GNU Library General Public License instead of this License.\par
\par
\page\pard Node: {\b Concepts}, \keepn Next: {\uldb Examples}{\v Examples}, Prev: {\uldb Copying}{\v Copying}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Concepts}
#{\footnote Concepts}
${\footnote \pard{}The Concepts of Bison}\par
\pard{\fs24\b The Concepts of Bison}\par
\par
\pard{}This chapter introduces many of the basic concepts without which the details of Bison will not make sense.  If you do not already know how to use Bison or Yacc, we suggest you start by reading this chapter carefully.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Language and Grammar}{\v Language_and_Grammar}\tab Languages and context-free grammars, as mathematical ideas.\par
{\uldb Grammar in Bison}{\v Grammar_in_Bison}\tab How we represent grammars for Bison's sake.\par
{\uldb Semantic Values}{\v Semantic_Values}\tab Each token or syntactic grouping can have a semantic value (the value of an integer, the name of an identifier, etc.).\par
{\uldb Semantic Actions}{\v Semantic_Actions}\tab Each rule can have an action containing C code.\par
{\uldb Bison Parser}{\v Bison_Parser}\tab What are Bison's input and output, how is the output used?\par
{\uldb Stages}{\v Stages}\tab Stages in writing and running Bison grammars.\par
{\uldb Grammar Layout}{\v Grammar_Layout}\tab Overall structure of a Bison grammar file.\par
\pard{}}\par
\page\pard Node: {\b Language and Grammar}, \keepn Next: {\uldb Grammar in Bison}{\v Grammar_in_Bison}, Prev: {\uldb }{\v }, Up: {\uldb Concepts}{\v Concepts}\line
K{\footnote K Language and Grammar}
#{\footnote Language_and_Grammar}
${\footnote \pard{}Languages and Context-Free Grammars}\par
\pard{\fs24\b Languages and Context-Free Grammars}\par
\par
\pard{}{K{\footnote K context-free grammar}}{K{\footnote K grammar, context-free}}In order for Bison to parse a language, it must be described by a \'A2context-free grammar\'A2.  This means that you specify one or more \'A2syntactic groupings\'A2 and give rules for constructing them from their parts.  For example, in the C language, one kind of grouping is called an `expression'.  One rule for making an expression might be, "An expression can be made of a minus sign and another expression".  Another would be, "An expression can be an integer".  As you can see, rules are often recursive, but there must be at least one rule which leads out of the recursion.\par
\par
\pard{}{K{\footnote K BNF}}{K{\footnote K Backus-Naur form}}The most common formal system for presenting such rules for humans to read is \'A2Backus-Naur Form\'A2 or "BNF", which was developed in order to specify the language Algol 60.  Any grammar expressed in BNF is a context-free grammar.  The input to Bison is essentially machine-readable BNF.\par
\par
\pard{}Not all context-free languages can be handled by Bison, only those that are LALR(1).  In brief, this means that it must be possible to tell how to parse any portion of an input string with just a single token of look-ahead.  Strictly speaking, that is a description of an LR(1) grammar, and LALR(1) involves additional restrictions that are hard to explain simply; but it is rare in actual practice to find an LR(1) grammar that fails to be LALR(1).  See {\uldb Mysterious Reduce/Reduce Conflicts}{\v Mystery_Conflicts}, for more information on this.\par
\par
\pard{}{K{\footnote K symbols (abstract)}}{K{\footnote K token}}{K{\footnote K syntactic grouping}}{K{\footnote K grouping, syntactic}}In the formal grammatical rules for a language, each kind of syntactic unit or grouping is named by a \'A2symbol\'A2.  Those which are built by grouping smaller constructs according to grammatical rules are called \'A2nonterminal symbols\'A2; those which can't be subdivided are called \'A2terminal symbols\'A2 or \'A2token types\'A2.  We call a piece of input corresponding to a single terminal symbol a \'A2token\'A2, and a piece corresponding to a single nonterminal symbol a \'A2grouping\'A2.\par
\par
\pard{}We can use the C language as an example of what symbols, terminal and nonterminal, mean.  The tokens of C are identifiers, constants (numeric and string), and the various keywords, arithmetic operators and punctuation marks.  So the terminal symbols of a grammar for C include `identifier', `number', `string', plus one symbol for each keyword, operator or punctuation mark: `if', `return', `const', `static', `int', `char', `plus-sign', `open-brace', `close-brace', `comma' and many more.  (These tokens can be subdivided into characters, but that is a matter of lexicography, not grammar.)\par
\par
\pard{}Here is a simple C function subdivided into tokens:\par
\par
{\pard\keep\li720\f1{}int             /* keyword `int' */\line
square (x)      /* identifier, open-paren, */\line
                /* identifier, close-paren */\line
     int x;     /* keyword `int', identifier, semicolon */\line
\'7B               /* open-brace */\line
  return x * x; /* keyword `return', identifier, */\line
                /* asterisk, identifier, semicolon */\line
\'7D               /* close-brace */\par
\pard\f0{}}\par
\pard{}The syntactic groupings of C include the expression, the statement, the declaration, and the function definition.  These are represented in the grammar of C by nonterminal symbols `expression', `statement', `declaration' and `function definition'.  The full grammar uses dozens of additional language constructs, each with its own nonterminal symbol, in order to express the meanings of these four.  The example above is a function definition; it contains one declaration, and one statement.  In the statement, each {\f1{}x} is an expression and so is {\f1{}x * x}.\par
\par
\pard{}Each nonterminal symbol must have grammatical rules showing how it is made out of simpler constructs.  For example, one kind of C statement is the {\f1{}return} statement; this would be described with a grammar rule which reads informally as follows:\par
\par
{\pard\li720{}A `statement' can be made of a `return' keyword, an `expression' and a `semicolon'.\par
\pard{}}\par
\pard{}There would be many other rules for `statement', one for each kind of statement in C.\par
\par
\pard{}{K{\footnote K start symbol}}One nonterminal symbol must be distinguished as the special one which defines a complete utterance in the language.  It is called the \'A2start symbol\'A2.  In a compiler, this means a complete input program.  In the C language, the nonterminal symbol `sequence of definitions and declarations' plays this role.\par
\par
\pard{}For example, {\f1{}1 + 2} is a valid C expression--a valid part of a C program--but it is not valid as an {\i entire} C program.  In the context-free grammar of C, this follows from the fact that `expression' is not the start symbol.\par
\par
\pard{}The Bison parser reads a sequence of tokens as its input, and groups the tokens using the grammar rules.  If the input is valid, the end result is that the entire token sequence reduces to a single grouping whose symbol is the grammar's start symbol.  If we use a grammar for C, the entire input must be a `sequence of definitions and declarations'.  If not, the parser reports a syntax error.\par
\par
\page\pard Node: {\b Grammar in Bison}, \keepn Next: {\uldb Semantic Values}{\v Semantic_Values}, Prev: {\uldb Language and Grammar}{\v Language_and_Grammar}, Up: {\uldb Concepts}{\v Concepts}\line
K{\footnote K Grammar in Bison}
#{\footnote Grammar_in_Bison}
${\footnote \pard{}From Formal Rules to Bison Input}\par
\pard{\fs24\b From Formal Rules to Bison Input}\par
\par
\pard{}{K{\footnote K Bison grammar}}{K{\footnote K grammar, Bison}}{K{\footnote K formal grammar}} A formal grammar is a mathematical construct.  To define the language for Bison, you must write a file expressing the grammar in Bison syntax: a \'A2Bison grammar\'A2 file.  See {\uldb Bison Grammar Files}{\v Grammar_File}.\par
\par
\pard{}A nonterminal symbol in the formal grammar is represented in Bison input as an identifier, like an identifier in C.  By convention, it should be in lower case, such as {\f1{}expr}, {\f1{}stmt} or {\f1{}declaration}.\par
\par
\pard{}The Bison representation for a terminal symbol is also called a \'A2token type\'A2.  Token types as well can be represented as C-like identifiers.  By convention, these identifiers should be upper case to distinguish them from nonterminals: for example, {\f1{}INTEGER}, {\f1{}IDENTIFIER}, {\f1{}IF} or {\f1{}RETURN}.  A terminal symbol that stands for a particular keyword in the language should be named after that keyword converted to upper case.  The terminal symbol {\f1{}error} is reserved for error recovery.  See {\uldb Symbols}{\v Symbols}.\par
\par
\pard{}A terminal symbol can also be represented as a character literal, just like a C character constant.  You should do this whenever a token is just a single character (parenthesis, plus-sign, etc.): use that same character in a literal as the terminal symbol for that token.\par
\par
\pard{}A third way to represent a terminal symbol is with a C string constant containing several characters.  See {\uldb Symbols}{\v Symbols}, for more information.\par
\par
\pard{}The grammar rules also have an expression in Bison syntax.  For example, here is the Bison rule for a C {\f1{}return} statement.  The semicolon in quotes is a literal character token, representing part of the C syntax for the statement; the naked semicolon, and the colon, are Bison punctuation used in every rule.\par
\par
{\pard\keep\li720\f1{}stmt:   RETURN expr ';'\line
        ;\par
\pard\f0{}}\par
\pard{}See {\uldb Syntax of Grammar Rules}{\v Rules}.\par
\par
\page\pard Node: {\b Semantic Values}, \keepn Next: {\uldb Semantic Actions}{\v Semantic_Actions}, Prev: {\uldb Grammar in Bison}{\v Grammar_in_Bison}, Up: {\uldb Concepts}{\v Concepts}\line
K{\footnote K Semantic Values}
#{\footnote Semantic_Values}
${\footnote \pard{}Semantic Values}\par
\pard{\fs24\b Semantic Values}\par
\par
\pard{}{K{\footnote K semantic value}}{K{\footnote K value, semantic}} A formal grammar selects tokens only by their classifications: for example, if a rule mentions the terminal symbol `integer constant', it means that {\i any} integer constant is grammatically valid in that position.  The precise value of the constant is irrelevant to how to parse the input: if {\f1{}x+4} is grammatical then {\f1{}x+1} or {\f1{}x+3989} is equally grammatical.\par
\par
\pard{}But the precise value is very important for what the input means once it is parsed.  A compiler is useless if it fails to distinguish between 4, 1 and 3989 as constants in the program!  Therefore, each token in a Bison grammar has both a token type and a \'A2semantic value\'A2.  See {\uldb Defining Language Semantics}{\v Semantics}, for details.\par
\par
\pard{}The token type is a terminal symbol defined in the grammar, such as {\f1{}INTEGER}, {\f1{}IDENTIFIER} or {\f1{}','}.  It tells everything you need to know to decide where the token may validly appear and how to group it with other tokens.  The grammar rules know nothing about tokens except their types.\par
\par
\pard{}The semantic value has all the rest of the information about the meaning of the token, such as the value of an integer, or the name of an identifier.  (A token such as {\f1{}','} which is just punctuation doesn't need to have any semantic value.)\par
\par
\pard{}For example, an input token might be classified as token type {\f1{}INTEGER} and have the semantic value 4.  Another input token might have the same token type {\f1{}INTEGER} but value 3989.  When a grammar rule says that {\f1{}INTEGER} is allowed, either of these tokens is acceptable because each is an {\f1{}INTEGER}.  When the parser accepts the token, it keeps track of the token's semantic value.\par
\par
\pard{}Each grouping can also have a semantic value as well as its nonterminal symbol.  For example, in a calculator, an expression typically has a semantic value that is a number.  In a compiler for a programming language, an expression typically has a semantic value that is a tree structure describing the meaning of the expression.\par
\par
\page\pard Node: {\b Semantic Actions}, \keepn Next: {\uldb Bison Parser}{\v Bison_Parser}, Prev: {\uldb Semantic Values}{\v Semantic_Values}, Up: {\uldb Concepts}{\v Concepts}\line
K{\footnote K Semantic Actions}
#{\footnote Semantic_Actions}
${\footnote \pard{}Semantic Actions}\par
\pard{\fs24\b Semantic Actions}\par
\par
\pard{}{K{\footnote K semantic actions}}{K{\footnote K actions, semantic}} In order to be useful, a program must do more than parse input; it must also produce some output based on the input.  In a Bison grammar, a grammar rule can have an \'A2action\'A2 made up of C statements.  Each time the parser recognizes a match for that rule, the action is executed.  See {\uldb Actions}{\v Actions}.\par
\par
\pard{}Most of the time, the purpose of an action is to compute the semantic value of the whole construct from the semantic values of its parts.  For example, suppose we have a rule which says an expression can be the sum of two expressions.  When the parser recognizes such a sum, each of the subexpressions has a semantic value which describes how it was built up.  The action for this rule should create a similar sort of value for the newly recognized larger expression.\par
\par
\pard{}For example, here is a rule that says an expression can be the sum of two subexpressions:\par
\par
{\pard\keep\li720\f1{}expr: expr '+' expr   \'7B $$ = $1 + $3; \'7D\line
        ;\par
\pard\f0{}}\par
\pard{}The action says how to produce the semantic value of the sum expression from the values of the two subexpressions.\par
\par
\page\pard Node: {\b Bison Parser}, \keepn Next: {\uldb Stages}{\v Stages}, Prev: {\uldb Semantic Actions}{\v Semantic_Actions}, Up: {\uldb Concepts}{\v Concepts}\line
K{\footnote K Bison Parser}
#{\footnote Bison_Parser}
${\footnote \pard{}Bison Output: the Parser File}\par
\pard{\fs24\b Bison Output: the Parser File}\par
\par
\pard{}{K{\footnote K Bison parser}}{K{\footnote K Bison utility}}{K{\footnote K lexical analyzer, purpose}}{K{\footnote K parser}} When you run Bison, you give it a Bison grammar file as input.  The output is a C source file that parses the language described by the grammar.  This file is called a \'A2Bison parser\'A2.  Keep in mind that the Bison utility and the Bison parser are two distinct programs: the Bison utility is a program whose output is the Bison parser that becomes part of your program.\par
\par
\pard{}The job of the Bison parser is to group tokens into groupings according to the grammar rules--for example, to build identifiers and operators into expressions.  As it does this, it runs the actions for the grammar rules it uses.\par
\par
\pard{}The tokens come from a function called the \'A2lexical analyzer\'A2 that you must supply in some fashion (such as by writing it in C).  The Bison parser calls the lexical analyzer each time it wants a new token.  It doesn't know what is "inside" the tokens (though their semantic values may reflect this).  Typically the lexical analyzer makes the tokens by parsing characters of text, but Bison does not depend on this.  See {\uldb The Lexical Analyzer Function {\f1{}yylex}}{\v Lexical}.\par
\par
\pard{}The Bison parser file is C code which defines a function named {\f1{}yyparse} which implements that grammar.  This function does not make a complete C program: you must supply some additional functions.  One is the lexical analyzer.  Another is an error-reporting function which the parser calls to report an error.  In addition, a complete C program must start with a function called {\f1{}main}; you have to provide this, and arrange for it to call {\f1{}yyparse} or the parser will never run.  See {\uldb Parser C-Language Interface}{\v Interface}.\par
\par
\pard{}Aside from the token type names and the symbols in the actions you write, all variable and function names used in the Bison parser file begin with {\f1{}yy} or {\f1{}YY}.  This includes interface functions such as the lexical analyzer function {\f1{}yylex}, the error reporting function {\f1{}yyerror} and the parser function {\f1{}yyparse} itself.  This also includes numerous identifiers used for internal purposes.  Therefore, you should avoid using C identifiers starting with {\f1{}yy} or {\f1{}YY} in the Bison grammar file except for the ones defined in this manual.\par
\par
\page\pard Node: {\b Stages}, \keepn Next: {\uldb Grammar Layout}{\v Grammar_Layout}, Prev: {\uldb Bison Parser}{\v Bison_Parser}, Up: {\uldb Concepts}{\v Concepts}\line
K{\footnote K Stages}
#{\footnote Stages}
${\footnote \pard{}Stages in Using Bison}\par
\pard{\fs24\b Stages in Using Bison}\par
\par
\pard{}{K{\footnote K stages in using Bison}}{K{\footnote K using Bison}} The actual language-design process using Bison, from grammar specification to a working compiler or interpreter, has these parts:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}1. \tab{}Formally specify the grammar in a form recognized by Bison (see {\uldb Bison Grammar Files}{\v Grammar_File}).  For each grammatical rule in the language, describe the action that is to be taken when an instance of that rule is recognized.  The action is described by a sequence of C statements.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}2. \tab{}Write a lexical analyzer to process input and pass tokens to the parser.  The lexical analyzer may be written by hand in C (see {\uldb The Lexical Analyzer Function {\f1{}yylex}}{\v Lexical}).  It could also be produced using Lex, but the use of Lex is not discussed in this manual.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}3. \tab{}Write a controlling function that calls the Bison-produced parser.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}4. \tab{}Write error-reporting routines.\par
\pard{}}\par
\pard{}To turn this source code as written into a runnable program, you must follow these steps:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}1. \tab{}Run Bison on the grammar to produce the parser.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}2. \tab{}Compile the code output by Bison, as well as any other source files.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}3. \tab{}Link the object files to produce the finished product.\par
\pard{}}\par
\page\pard Node: {\b Grammar Layout}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Stages}{\v Stages}, Up: {\uldb Concepts}{\v Concepts}\line
K{\footnote K Grammar Layout}
#{\footnote Grammar_Layout}
${\footnote \pard{}The Overall Layout of a Bison Grammar}\par
\pard{\fs24\b The Overall Layout of a Bison Grammar}\par
\par
\pard{}{K{\footnote K grammar file}}{K{\footnote K file format}}{K{\footnote K format of grammar file}}{K{\footnote K layout of Bison grammar}} The input file for the Bison utility is a \'A2Bison grammar file\'A2.  The general form of a Bison grammar file is as follows:\par
\par
{\pard\keep\li720\f1{}%\'7B\line
{\i C declarations}\line
%\'7D\line
\line
{\i Bison declarations}\line
\line
%%\line
{\i Grammar rules}\line
%%\line
{\i Additional C code}\par
\pard\f0{}}\par
\pard{}The {\f1{}%%}, {\f1{}%\'7B} and {\f1{}%\'7D} are punctuation that appears in every Bison grammar file to separate the sections.\par
\par
\pard{}The C declarations may define types and variables used in the actions.  You can also use preprocessor commands to define macros used there, and use {\f1{}#include} to include header files that do any of these things.\par
\par
\pard{}The Bison declarations declare the names of the terminal and nonterminal symbols, and may also describe operator precedence and the data types of semantic values of various symbols.\par
\par
\pard{}The grammar rules define how to construct each nonterminal symbol from its parts.\par
\par
\pard{}The additional C code can contain any C code you want to use.  Often the definition of the lexical analyzer {\f1{}yylex} goes here, plus subroutines called by the actions in the grammar rules.  In a simple program, all the rest of the program can go here.\par
\par
\page\pard Node: {\b Examples}, \keepn Next: {\uldb Grammar File}{\v Grammar_File}, Prev: {\uldb Concepts}{\v Concepts}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Examples}
#{\footnote Examples}
${\footnote \pard{}Examples}\par
\pard{\fs24\b Examples}\par
\par
\pard{}{K{\footnote K simple examples}}{K{\footnote K examples, simple}} Now we show and explain three sample programs written using Bison: a reverse polish notation calculator, an algebraic (infix) notation calculator, and a multi-function calculator.  All three have been tested under BSD Unix 4.3; each produces a usable, though limited, interactive desk-top calculator.\par
\par
\pard{}These examples are simple, but Bison grammars for real programming languages are written the same way.  {You can copy these examples out of the Info file and into a source file to try them.  }\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb RPN Calc}{\v RPN_Calc}\tab Reverse polish notation calculator; a first example with no operator precedence.\par
{\uldb Infix Calc}{\v Infix_Calc}\tab Infix (algebraic) notation calculator. Operator precedence is introduced.\par
{\uldb Simple Error Recovery}{\v Simple_Error_Recovery}\tab Continuing after syntax errors.\par
{\uldb Multi-function Calc}{\v Multi_function_Calc}\tab Calculator with memory and trig functions. It uses multiple data-types for semantic values.\par
{\uldb Exercises}{\v Exercises}\tab Ideas for improving the multi-function calculator.\par
\pard{}}\par
\page\pard Node: {\b RPN Calc}, \keepn Next: {\uldb Infix Calc}{\v Infix_Calc}, Prev: {\uldb }{\v }, Up: {\uldb Examples}{\v Examples}\line
K{\footnote K RPN Calc}
#{\footnote RPN_Calc}
${\footnote \pard{}Reverse Polish Notation Calculator}\par
\pard{\fs24\b Reverse Polish Notation Calculator}\par
\par
\pard{}{K{\footnote K reverse polish notation}}{K{\footnote K polish notation calculator}}{K{\footnote K {\f1{}rpcalc}}}{K{\footnote K calculator, simple}} The first example is that of a simple double-precision \'A2reverse polish notation\'A2 calculator (a calculator using postfix operators).  This example provides a good starting point, since operator precedence is not an issue.  The second example will illustrate how operator precedence is handled.\par
\par
\pard{}The source code for this calculator is named {\f1{}rpcalc.y}.  The {\f1{}.y} extension is a convention used for Bison input files.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Decls}{\v Rpcalc_Decls}\tab Bison and C declarations for rpcalc.\par
{\uldb Rules}{\v Rpcalc_Rules}\tab Grammar Rules for rpcalc, with explanation.\par
{\uldb Lexer}{\v Rpcalc_Lexer}\tab The lexical analyzer.\par
{\uldb Main}{\v Rpcalc_Main}\tab The controlling function.\par
{\uldb Error}{\v Rpcalc_Error}\tab The error reporting function.\par
{\uldb Gen}{\v Rpcalc_Gen}\tab Running Bison on the grammar file.\par
{\uldb Comp}{\v Rpcalc_Compile}\tab Run the C compiler on the output code.\par
\pard{}}\par
\page\pard Node: {\b Rpcalc Decls}, \keepn Next: {\uldb Rpcalc Rules}{\v Rpcalc_Rules}, Prev: {\uldb }{\v }, Up: {\uldb RPN Calc}{\v RPN_Calc}\line
K{\footnote K Rpcalc Decls}
#{\footnote Rpcalc_Decls}
${\footnote \pard{}Declarations for {\f1{}rpcalc}}\par
\pard{\fs24\b Declarations for {\f1{}rpcalc}}\par
\par
\pard{}Here are the C and Bison declarations for the reverse polish notation calculator.  As in C, comments are placed between {\f1{}/*...*/}.\par
\par
{\pard\keep\li720\f1{}/* Reverse polish notation calculator. */\line
\line
%\'7B\line
#define YYSTYPE double\line
#include <math.h>\line
%\'7D\line
\line
%token NUM\line
\line
%% /* Grammar rules and actions follow */\par
\pard\f0{}}\par
\pard{}The C declarations section (see {\uldb The C Declarations Section}{\v C_Declarations}) contains two preprocessor directives.\par
\par
\pard{}The {\f1{}#define} directive defines the macro {\f1{}YYSTYPE}, thus specifying the C data type for semantic values of both tokens and groupings (see {\uldb Data Types of Semantic Values}{\v Value_Type}).  The Bison parser will use whatever type {\f1{}YYSTYPE} is defined as; if you don't define it, {\f1{}int} is the default.  Because we specify {\f1{}double}, each token and each expression has an associated value, which is a floating point number.\par
\par
\pard{}The {\f1{}#include} directive is used to declare the exponentiation function {\f1{}pow}.\par
\par
\pard{}The second section, Bison declarations, provides information to Bison about the token types (see {\uldb The Bison Declarations Section}{\v Bison_Declarations}).  Each terminal symbol that is not a single-character literal must be declared here.  (Single-character literals normally don't need to be declared.)  In this example, all the arithmetic operators are designated by single-character literals, so the only terminal symbol that needs to be declared is {\f1{}NUM}, the token type for numeric constants.\par
\par
\page\pard Node: {\b Rpcalc Rules}, \keepn Next: {\uldb Rpcalc Lexer}{\v Rpcalc_Lexer}, Prev: {\uldb Rpcalc Decls}{\v Rpcalc_Decls}, Up: {\uldb RPN Calc}{\v RPN_Calc}\line
K{\footnote K Rpcalc Rules}
#{\footnote Rpcalc_Rules}
${\footnote \pard{}Grammar Rules for {\f1{}rpcalc}}\par
\pard{\fs24\b Grammar Rules for {\f1{}rpcalc}}\par
\par
\pard{}Here are the grammar rules for the reverse polish notation calculator.\par
\par
{\pard\keep\li720\f1{}input:    /* empty */\line
        | input line\line
;\line
\line
line:     '\'5Cn'\line
        | exp '\'5Cn'  \'7B printf ("\'5Ct%.10g\'5Cn", $1); \'7D\line
;\line
\line
exp:      NUM             \'7B $$ = $1;         \'7D\line
        | exp exp '+'     \'7B $$ = $1 + $2;    \'7D\line
        | exp exp '-'     \'7B $$ = $1 - $2;    \'7D\line
        | exp exp '*'     \'7B $$ = $1 * $2;    \'7D\line
        | exp exp '/'     \'7B $$ = $1 / $2;    \'7D\line
      /* Exponentiation */\line
        | exp exp '^'     \'7B $$ = pow ($1, $2); \'7D\line
      /* Unary minus    */\line
        | exp 'n'         \'7B $$ = -$1;        \'7D\line
;\line
%%\par
\pard\f0{}}\par
\pard{}The groupings of the rpcalc "language" defined here are the expression (given the name {\f1{}exp}), the line of input ({\f1{}line}), and the complete input transcript ({\f1{}input}).  Each of these nonterminal symbols has several alternate rules, joined by the {\f1{}|} punctuator which is read as "or".  The following sections explain what these rules mean.\par
\par
\pard{}The semantics of the language is determined by the actions taken when a grouping is recognized.  The actions are the C code that appears inside braces.  See {\uldb Actions}{\v Actions}.\par
\par
\pard{}You must specify these actions in C, but Bison provides the means for passing semantic values between the rules.  In each action, the pseudo-variable {\f1{}$$} stands for the semantic value for the grouping that the rule is going to construct.  Assigning a value to {\f1{}$$} is the main job of most actions.  The semantic values of the components of the rule are referred to as {\f1{}$1}, {\f1{}$2}, and so on.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Rpcalc Input}{\v Rpcalc_Input}\tab \par
{\uldb Rpcalc Line}{\v Rpcalc_Line}\tab \par
{\uldb Rpcalc Expr}{\v Rpcalc_Expr}\tab\par
\pard{}}\par
\page\pard Node: {\b Rpcalc Input}, \keepn Next: {\uldb Rpcalc Line}{\v Rpcalc_Line}, Prev: {\uldb }{\v }, Up: {\uldb Rpcalc Rules}{\v Rpcalc_Rules}\line
K{\footnote K Rpcalc Input}
#{\footnote Rpcalc_Input}
${\footnote \pard{}Explanation of {\f1{}input}}\par
\pard{\fs24\b Explanation of {\f1{}input}}\par
\par
\pard{}Consider the definition of {\f1{}input}:\par
\par
{\pard\keep\li720\f1{}input:    /* empty */\line
        | input line\line
;\par
\pard\f0{}}\par
\pard{}This definition reads as follows: "A complete input is either an empty string, or a complete input followed by an input line".  Notice that "complete input" is defined in terms of itself.  This definition is said to be \'A2left recursive\'A2 since {\f1{}input} appears always as the leftmost symbol in the sequence.  See {\uldb Recursive Rules}{\v Recursion}.\par
\par
\pard{}The first alternative is empty because there are no symbols between the colon and the first {\f1{}|}; this means that {\f1{}input} can match an empty string of input (no tokens).  We write the rules this way because it is legitimate to type {\f1{}Ctrl-d} right after you start the calculator.  It's conventional to put an empty alternative first and write the comment {\f1{}/* empty */} in it.\par
\par
\pard{}The second alternate rule ({\f1{}input line}) handles all nontrivial input.  It means, "After reading any number of lines, read one more line if possible."  The left recursion makes this rule into a loop.  Since the first alternative matches empty input, the loop can be executed zero or more times.\par
\par
\pard{}The parser function {\f1{}yyparse} continues to process input until a grammatical error is seen or the lexical analyzer says there are no more input tokens; we will arrange for the latter to happen at end of file.\par
\par
\page\pard Node: {\b Rpcalc Line}, \keepn Next: {\uldb Rpcalc Expr}{\v Rpcalc_Expr}, Prev: {\uldb Rpcalc Input}{\v Rpcalc_Input}, Up: {\uldb Rpcalc Rules}{\v Rpcalc_Rules}\line
K{\footnote K Rpcalc Line}
#{\footnote Rpcalc_Line}
${\footnote \pard{}Explanation of {\f1{}line}}\par
\pard{\fs24\b Explanation of {\f1{}line}}\par
\par
\pard{}Now consider the definition of {\f1{}line}:\par
\par
{\pard\keep\li720\f1{}line:     '\'5Cn'\line
        | exp '\'5Cn'  \'7B printf ("\'5Ct%.10g\'5Cn", $1); \'7D\line
;\par
\pard\f0{}}\par
\pard{}The first alternative is a token which is a newline character; this means that rpcalc accepts a blank line (and ignores it, since there is no action).  The second alternative is an expression followed by a newline.  This is the alternative that makes rpcalc useful.  The semantic value of the {\f1{}exp} grouping is the value of {\f1{}$1} because the {\f1{}exp} in question is the first symbol in the alternative.  The action prints this value, which is the result of the computation the user asked for.\par
\par
\pard{}This action is unusual because it does not assign a value to {\f1{}$$}.  As a consequence, the semantic value associated with the {\f1{}line} is uninitialized (its value will be unpredictable).  This would be a bug if that value were ever used, but we don't use it: once rpcalc has printed the value of the user's input line, that value is no longer needed.\par
\par
\page\pard Node: {\b Rpcalc Expr}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Rpcalc Line}{\v Rpcalc_Line}, Up: {\uldb Rpcalc Rules}{\v Rpcalc_Rules}\line
K{\footnote K Rpcalc Expr}
#{\footnote Rpcalc_Expr}
${\footnote \pard{}Explanation of {\f1{}expr}}\par
\pard{\fs24\b Explanation of {\f1{}expr}}\par
\par
\pard{}The {\f1{}exp} grouping has several rules, one for each kind of expression.  The first rule handles the simplest expressions: those that are just numbers.  The second handles an addition-expression, which looks like two expressions followed by a plus-sign.  The third handles subtraction, and so on.\par
\par
{\pard\keep\li720\f1{}exp:      NUM\line
        | exp exp '+'     \'7B $$ = $1 + $2;    \'7D\line
        | exp exp '-'     \'7B $$ = $1 - $2;    \'7D\line
        ...\line
        ;\par
\pard\f0{}}\par
\pard{}We have used {\f1{}|} to join all the rules for {\f1{}exp}, but we could equally well have written them separately:\par
\par
{\pard\keep\li720\f1{}exp:      NUM ;\line
exp:      exp exp '+'     \'7B $$ = $1 + $2;    \'7D ;\line
exp:      exp exp '-'     \'7B $$ = $1 - $2;    \'7D ;\line
        ...\par
\pard\f0{}}\par
\pard{}Most of the rules have actions that compute the value of the expression in terms of the value of its parts.  For example, in the rule for addition, {\f1{}$1} refers to the first component {\f1{}exp} and {\f1{}$2} refers to the second one.  The third component, {\f1{}'+'}, has no meaningful associated semantic value, but if it had one you could refer to it as {\f1{}$3}.  When {\f1{}yyparse} recognizes a sum expression using this rule, the sum of the two subexpressions' values is produced as the value of the entire expression.  See {\uldb Actions}{\v Actions}.\par
\par
\pard{}You don't have to give an action for every rule.  When a rule has no action, Bison by default copies the value of {\f1{}$1} into {\f1{}$$}.  This is what happens in the first rule (the one that uses {\f1{}NUM}).\par
\par
\pard{}The formatting shown here is the recommended convention, but Bison does not require it.  You can add or change whitespace as much as you wish.  For example, this:\par
\par
{\pard\keep\li720\f1{}exp   : NUM | exp exp '+' \'7B$$ = $1 + $2; \'7D | ...\par
\pard\f0{}}\par
\pard{}means the same thing as this:\par
\par
{\pard\keep\li720\f1{}exp:      NUM\line
        | exp exp '+'    \'7B $$ = $1 + $2; \'7D\line
        | ...\par
\pard\f0{}}\par
\pard{}The latter, however, is much more readable.\par
\par
\page\pard Node: {\b Rpcalc Lexer}, \keepn Next: {\uldb Rpcalc Main}{\v Rpcalc_Main}, Prev: {\uldb Rpcalc Rules}{\v Rpcalc_Rules}, Up: {\uldb RPN Calc}{\v RPN_Calc}\line
K{\footnote K Rpcalc Lexer}
#{\footnote Rpcalc_Lexer}
${\footnote \pard{}The {\f1{}rpcalc} Lexical Analyzer}\par
\pard{\fs24\b The {\f1{}rpcalc} Lexical Analyzer}\par
\par
\pard{}{K{\footnote K writing a lexical analyzer}}{K{\footnote K lexical analyzer, writing}} The lexical analyzer's job is low-level parsing: converting characters or sequences of characters into tokens.  The Bison parser gets its tokens by calling the lexical analyzer.  See {\uldb The Lexical Analyzer Function {\f1{}yylex}}{\v Lexical}.\par
\par
\pard{}Only a simple lexical analyzer is needed for the RPN calculator.  This lexical analyzer skips blanks and tabs, then reads in numbers as {\f1{}double} and returns them as {\f1{}NUM} tokens.  Any other character that isn't part of a number is a separate token.  Note that the token-code for such a single-character token is the character itself.\par
\par
\pard{}The return value of the lexical analyzer function is a numeric code which represents a token type.  The same text used in Bison rules to stand for this token type is also a C expression for the numeric code for the type.  This works in two ways.  If the token type is a character literal, then its numeric code is the ASCII code for that character; you can use the same character literal in the lexical analyzer to express the number.  If the token type is an identifier, that identifier is defined by Bison as a C macro whose definition is the appropriate number.  In this example, therefore, {\f1{}NUM} becomes a macro for {\f1{}yylex} to use.\par
\par
\pard{}The semantic value of the token (if it has one) is stored into the global variable {\f1{}yylval}, which is where the Bison parser will look for it.  (The C data type of {\f1{}yylval} is {\f1{}YYSTYPE}, which was defined at the beginning of the grammar; see {\uldb Declarations for {\f1{}rpcalc}}{\v Rpcalc_Decls}.)\par
\par
\pard{}A token type code of zero is returned if the end-of-file is encountered.  (Bison recognizes any nonpositive value as indicating the end of the input.)\par
\par
\pard{}Here is the code for the lexical analyzer:\par
\par
{{\pard\keep\li720\f1{}/* Lexical analyzer returns a double floating point\line
   number on the stack and the token NUM, or the ASCII\line
   character read if not a number.  Skips all blanks\line
   and tabs, returns 0 for EOF. */\line
\line
#include <ctype.h>\par
\pard\keep\li720{}}\line
{yylex ()\line
\'7B\line
  int c;\line
\line
  /* skip white space  */\line
  while ((c = getchar ()) == ' ' || c == '\'5Ct')\line
    ;\par
\pard\keep\li720{}}{  /* process numbers   */\line
  if (c == '.' || isdigit (c))\line
    \'7B\line
      ungetc (c, stdin);\line
      scanf ("%lf", &yylval);\line
      return NUM;\line
    \'7D\par
\pard\keep\li720{}}{  /* return end-of-file  */\line
  if (c == EOF)\line
    return 0;\line
  /* return single chars */\line
  return c;\line
\'7D\par
\pard\keep\li720{}}}\par
\page\pard Node: {\b Rpcalc Main}, \keepn Next: {\uldb Rpcalc Error}{\v Rpcalc_Error}, Prev: {\uldb Rpcalc Lexer}{\v Rpcalc_Lexer}, Up: {\uldb RPN Calc}{\v RPN_Calc}\line
K{\footnote K Rpcalc Main}
#{\footnote Rpcalc_Main}
${\footnote \pard\f0{}The Controlling Function}\par
\pard{\fs24\b The Controlling Function}\par
\par
\pard{}{K{\footnote K controlling function}}{K{\footnote K main function in simple example}} In keeping with the spirit of this example, the controlling function is kept to the bare minimum.  The only requirement is that it call {\f1{}yyparse} to start the process of parsing.\par
\par
{{\pard\keep\li720\f1{}main ()\line
\'7B\line
  yyparse ();\line
\'7D\par
\pard\keep\li720{}}}\par
\page\pard Node: {\b Rpcalc Error}, \keepn Next: {\uldb Rpcalc Gen}{\v Rpcalc_Gen}, Prev: {\uldb Rpcalc Main}{\v Rpcalc_Main}, Up: {\uldb RPN Calc}{\v RPN_Calc}\line
K{\footnote K Rpcalc Error}
#{\footnote Rpcalc_Error}
${\footnote \pard\f0{}The Error Reporting Routine}\par
\pard{\fs24\b The Error Reporting Routine}\par
\par
\pard{}{K{\footnote K error reporting routine}} When {\f1{}yyparse} detects a syntax error, it calls the error reporting function {\f1{}yyerror} to print an error message (usually but not always {\f1{}"parse error"}).  It is up to the programmer to supply {\f1{}yyerror} (see {\uldb Parser C-Language Interface}{\v Interface}), so here is the definition we will use:\par
\par
{{\pard\keep\li720\f1{}#include <stdio.h>\line
\line
yyerror (s)  /* Called by yyparse on error */\line
     char *s;\line
\'7B\line
  printf ("%s\'5Cn", s);\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}After {\f1{}yyerror} returns, the Bison parser may recover from the error and continue parsing if the grammar contains a suitable error rule (see {\uldb Error Recovery}{\v Error_Recovery}).  Otherwise, {\f1{}yyparse} returns nonzero.  We have not written any error rules in this example, so any invalid input will cause the calculator program to exit.  This is not clean behavior for a real calculator, but it is adequate in the first example.\par
\par
\page\pard Node: {\b Rpcalc Gen}, \keepn Next: {\uldb Rpcalc Compile}{\v Rpcalc_Compile}, Prev: {\uldb Rpcalc Error}{\v Rpcalc_Error}, Up: {\uldb RPN Calc}{\v RPN_Calc}\line
K{\footnote K Rpcalc Gen}
#{\footnote Rpcalc_Gen}
${\footnote \pard{}Running Bison to Make the Parser}\par
\pard{\fs24\b Running Bison to Make the Parser}\par
\par
\pard{}{K{\footnote K running Bison (introduction)}} Before running Bison to produce a parser, we need to decide how to arrange all the source code in one or more source files.  For such a simple example, the easiest thing is to put everything in one file.  The definitions of {\f1{}yylex}, {\f1{}yyerror} and {\f1{}main} go at the end, in the "additional C code" section of the file (see {\uldb The Overall Layout of a Bison Grammar}{\v Grammar_Layout}).\par
\par
\pard{}For a large project, you would probably have several source files, and use {\f1{}make} to arrange to recompile them.\par
\par
\pard{}With all the source in a single file, you use the following command to convert it into a parser file:\par
\par
{\pard\keep\li720\f1{}bison {\i file_name}.y\par
\pard\f0{}}\par
\pard{}In this example the file was called {\f1{}rpcalc.y} (for "Reverse Polish CALCulator").  Bison produces a file named {\f1{}{\i file_name}.tab.c}, removing the {\f1{}.y} from the original file name. The file output by Bison contains the source code for {\f1{}yyparse}.  The additional functions in the input file ({\f1{}yylex}, {\f1{}yyerror} and {\f1{}main}) are copied verbatim to the output.\par
\par
\page\pard Node: {\b Rpcalc Compile}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Rpcalc Gen}{\v Rpcalc_Gen}, Up: {\uldb RPN Calc}{\v RPN_Calc}\line
K{\footnote K Rpcalc Compile}
#{\footnote Rpcalc_Compile}
${\footnote \pard{}Compiling the Parser File}\par
\pard{\fs24\b Compiling the Parser File}\par
\par
\pard{}{K{\footnote K compiling the parser}} Here is how to compile and run the parser file:\par
\par
{{\pard\keep\li720\f1{}# List files in current directory.\line
% ls\line
rpcalc.tab.c  rpcalc.y\par
\pard\keep\li720{}}\line
{# Compile the Bison parser.\line
# {\f1{}-lm} tells compiler to search math library for {\f1{}pow}.\line
% cc rpcalc.tab.c -lm -o rpcalc\par
\pard\keep\li720{}}\line
{# List files again.\line
% ls\line
rpcalc  rpcalc.tab.c  rpcalc.y\par
\pard\keep\li720{}}}\par
\pard\f0{}The file {\f1{}rpcalc} now contains the executable code.  Here is an example session using {\f1{}rpcalc}.\par
\par
{\pard\keep\li720\f1{}% rpcalc\line
4 9 +\line
13\line
3 7 + 3 4 5 *+-\line
-13\line
3 7 + 3 4 5 * + - n              Note the unary minus, {\f1{}n}\line
13\line
5 6 / 4 n +\line
-3.166666667\line
3 4 ^                            Exponentiation\line
81\line
^D                               End-of-file indicator\line
%\par
\pard\f0{}}\par
\page\pard Node: {\b Infix Calc}, \keepn Next: {\uldb Simple Error Recovery}{\v Simple_Error_Recovery}, Prev: {\uldb RPN Calc}{\v RPN_Calc}, Up: {\uldb Examples}{\v Examples}\line
K{\footnote K Infix Calc}
#{\footnote Infix_Calc}
${\footnote \pard{}Infix Notation Calculator: {\f1{}calc}}\par
\pard{\fs24\b Infix Notation Calculator: {\f1{}calc}}\par
\par
\pard{}{K{\footnote K infix notation calculator}}{K{\footnote K {\f1{}calc}}}{K{\footnote K calculator, infix notation}} We now modify rpcalc to handle infix operators instead of postfix.  Infix notation involves the concept of operator precedence and the need for parentheses nested to arbitrary depth.  Here is the Bison code for {\f1{}calc.y}, an infix desk-top calculator.\par
\par
{\pard\keep\li720\f1{}/* Infix notation calculator--calc */\line
\line
%\'7B\line
#define YYSTYPE double\line
#include <math.h>\line
%\'7D\line
\line
/* BISON Declarations */\line
%token NUM\line
%left '-' '+'\line
%left '*' '/'\line
%left NEG     /* negation--unary minus */\line
%right '^'    /* exponentiation        */\line
\line
/* Grammar follows */\line
%%\line
input:    /* empty string */\line
        | input line\line
;\line
\line
line:     '\'5Cn'\line
        | exp '\'5Cn'  \'7B printf ("\'5Ct%.10g\'5Cn", $1); \'7D\line
;\line
\line
exp:      NUM                \'7B $$ = $1;         \'7D\line
        | exp '+' exp        \'7B $$ = $1 + $3;    \'7D\line
        | exp '-' exp        \'7B $$ = $1 - $3;    \'7D\line
        | exp '*' exp        \'7B $$ = $1 * $3;    \'7D\line
        | exp '/' exp        \'7B $$ = $1 / $3;    \'7D\line
        | '-' exp  %prec NEG \'7B $$ = -$2;        \'7D\line
        | exp '^' exp        \'7B $$ = pow ($1, $3); \'7D\line
        | '(' exp ')'        \'7B $$ = $2;         \'7D\line
;\line
%%\par
\pard\f0{}}\par
\pard{}The functions {\f1{}yylex}, {\f1{}yyerror} and {\f1{}main} can be the same as before.\par
\par
\pard{}There are two important new features shown in this code.\par
\par
\pard{}In the second section (Bison declarations), {\f1{}%left} declares token types and says they are left-associative operators.  The declarations {\f1{}%left} and {\f1{}%right} (right associativity) take the place of {\f1{}%token} which is used to declare a token type name without associativity.  (These tokens are single-character literals, which ordinarily don't need to be declared.  We declare them here to specify the associativity.)\par
\par
\pard{}Operator precedence is determined by the line ordering of the declarations; the higher the line number of the declaration (lower on the page or screen), the higher the precedence.  Hence, exponentiation has the highest precedence, unary minus ({\f1{}NEG}) is next, followed by {\f1{}*} and {\f1{}/}, and so on.  See {\uldb Operator Precedence}{\v Precedence}.\par
\par
\pard{}The other important new feature is the {\f1{}%prec} in the grammar section for the unary minus operator.  The {\f1{}%prec} simply instructs Bison that the rule {\f1{}| '-' exp} has the same precedence as {\f1{}NEG}--in this case the next-to-highest.  See {\uldb Context-Dependent Precedence}{\v Contextual_Precedence}.\par
\par
\pard{}Here is a sample run of {\f1{}calc.y}:\par
\par
{\pard\keep\li720\f1{}% calc\line
4 + 4.5 - (34/(8*3+-3))\line
6.880952381\line
-56 + 2\line
-54\line
3 ^ 2\line
9\par
\pard\f0{}}\par
\page\pard Node: {\b Simple Error Recovery}, \keepn Next: {\uldb Multi-function Calc}{\v Multi_function_Calc}, Prev: {\uldb Infix Calc}{\v Infix_Calc}, Up: {\uldb Examples}{\v Examples}\line
K{\footnote K Simple Error Recovery}
#{\footnote Simple_Error_Recovery}
${\footnote \pard{}Simple Error Recovery}\par
\pard{\fs24\b Simple Error Recovery}\par
\par
\pard{}{K{\footnote K error recovery, simple}} Up to this point, this manual has not addressed the issue of \'A2error recovery\'A2--how to continue parsing after the parser detects a syntax error.  All we have handled is error reporting with {\f1{}yyerror}.  Recall that by default {\f1{}yyparse} returns after calling {\f1{}yyerror}.  This means that an erroneous input line causes the calculator program to exit.  Now we show how to rectify this deficiency.\par
\par
\pard{}The Bison language itself includes the reserved word {\f1{}error}, which may be included in the grammar rules.  In the example below it has been added to one of the alternatives for {\f1{}line}:\par
\par
{{\pard\keep\li720\f1{}line:     '\'5Cn'\line
        | exp '\'5Cn'   \'7B printf ("\'5Ct%.10g\'5Cn", $1); \'7D\line
        | error '\'5Cn' \'7B yyerrok;                  \'7D\line
;\par
\pard\keep\li720{}}}\par
\pard\f0{}This addition to the grammar allows for simple error recovery in the event of a parse error.  If an expression that cannot be evaluated is read, the error will be recognized by the third rule for {\f1{}line}, and parsing will continue.  (The {\f1{}yyerror} function is still called upon to print its message as well.)  The action executes the statement {\f1{}yyerrok}, a macro defined automatically by Bison; its meaning is that error recovery is complete (see {\uldb Error Recovery}{\v Error_Recovery}).  Note the difference between {\f1{}yyerrok} and {\f1{}yyerror}; neither one is a misprint.\par
\par
\pard{}This form of error recovery deals with syntax errors.  There are other kinds of errors; for example, division by zero, which raises an exception signal that is normally fatal.  A real calculator program must handle this signal and use {\f1{}longjmp} to return to {\f1{}main} and resume parsing input lines; it would also have to discard the rest of the current line of input.  We won't discuss this issue further because it is not specific to Bison programs.\par
\par
\page\pard Node: {\b Multi-function Calc}, \keepn Next: {\uldb Exercises}{\v Exercises}, Prev: {\uldb Simple Error Recovery}{\v Simple_Error_Recovery}, Up: {\uldb Examples}{\v Examples}\line
K{\footnote K Multi-function Calc}
#{\footnote Multi_function_Calc}
${\footnote \pard{}Multi-Function Calculator: {\f1{}mfcalc}}\par
\pard{\fs24\b Multi-Function Calculator: {\f1{}mfcalc}}\par
\par
\pard{}{K{\footnote K multi-function calculator}}{K{\footnote K {\f1{}mfcalc}}}{K{\footnote K calculator, multi-function}} Now that the basics of Bison have been discussed, it is time to move on to a more advanced problem.  The above calculators provided only five functions, {\f1{}+}, {\f1{}-}, {\f1{}*}, {\f1{}/} and {\f1{}^}.  It would be nice to have a calculator that provides other mathematical functions such as {\f1{}sin}, {\f1{}cos}, etc.\par
\par
\pard{}It is easy to add new operators to the infix calculator as long as they are only single-character literals.  The lexical analyzer {\f1{}yylex} passes back all non-number characters as tokens, so new grammar rules suffice for adding a new operator.  But we want something more flexible: built-in functions whose syntax has this form:\par
\par
{{\i \pard\li720\f1{}function_name} ({\i argument})\par
\pard\f0{}}\par
\pard{}At the same time, we will add memory to the calculator, by allowing you to create named variables, store values in them, and use them later.  Here is a sample session with the multi-function calculator:\par
\par
{\pard\keep\li720\f1{}% mfcalc\line
pi = 3.141592653589\line
3.1415926536\line
sin(pi)\line
0.0000000000\line
alpha = beta1 = 2.3\line
2.3000000000\line
alpha\line
2.3000000000\line
ln(alpha)\line
0.8329091229\line
exp(ln(beta1))\line
2.3000000000\line
%\par
\pard\f0{}}\par
\pard{}Note that multiple assignment and nested function calls are permitted.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Decl}{\v Mfcalc_Decl}\tab Bison declarations for multi-function calculator.\par
{\uldb Rules}{\v Mfcalc_Rules}\tab Grammar rules for the calculator.\par
{\uldb Symtab}{\v Mfcalc_Symtab}\tab Symbol table management subroutines.\par
\pard{}}\par
\page\pard Node: {\b Mfcalc Decl}, \keepn Next: {\uldb Mfcalc Rules}{\v Mfcalc_Rules}, Prev: {\uldb }{\v }, Up: {\uldb Multi-function Calc}{\v Multi_function_Calc}\line
K{\footnote K Mfcalc Decl}
#{\footnote Mfcalc_Decl}
${\footnote \pard{}Declarations for {\f1{}mfcalc}}\par
\pard{\fs24\b Declarations for {\f1{}mfcalc}}\par
\par
\pard{}Here are the C and Bison declarations for the multi-function calculator.\par
\par
{\pard\keep\li720\f1{}%\'7B\line
#include <math.h>  /* For math functions, cos(), sin(), etc. */\line
#include "calc.h"  /* Contains definition of `symrec'        */\line
%\'7D\line
%union \'7B\line
double     val;  /* For returning numbers.                   */\line
symrec  *tptr;   /* For returning symbol-table pointers      */\line
\'7D\line
\line
%token <val>  NUM        /* Simple double precision number   */\line
%token <tptr> VAR FNCT   /* Variable and Function            */\line
%type  <val>  exp\line
\line
%right '='\line
%left '-' '+'\line
%left '*' '/'\line
%left NEG     /* Negation--unary minus */\line
%right '^'    /* Exponentiation        */\line
\line
/* Grammar follows */\line
\line
%%\par
\pard\f0{}}\par
\pard{}The above grammar introduces only two new features of the Bison language.  These features allow semantic values to have various data types (see {\uldb More Than One Value Type}{\v Multiple_Types}).\par
\par
\pard{}The {\f1{}%union} declaration specifies the entire list of possible types; this is instead of defining {\f1{}YYSTYPE}.  The allowable types are now double-floats (for {\f1{}exp} and {\f1{}NUM}) and pointers to entries in the symbol table.  See {\uldb The Collection of Value Types}{\v Union_Decl}.\par
\par
\pard{}Since values can now have various types, it is necessary to associate a type with each grammar symbol whose semantic value is used.  These symbols are {\f1{}NUM}, {\f1{}VAR}, {\f1{}FNCT}, and {\f1{}exp}.  Their declarations are augmented with information about their data type (placed between angle brackets).\par
\par
\pard{}The Bison construct {\f1{}%type} is used for declaring nonterminal symbols, just as {\f1{}%token} is used for declaring token types.  We have not used {\f1{}%type} before because nonterminal symbols are normally declared implicitly by the rules that define them.  But {\f1{}exp} must be declared explicitly so we can specify its value type.  See {\uldb Nonterminal Symbols}{\v Type_Decl}.\par
\par
\page\pard Node: {\b Mfcalc Rules}, \keepn Next: {\uldb Mfcalc Symtab}{\v Mfcalc_Symtab}, Prev: {\uldb Mfcalc Decl}{\v Mfcalc_Decl}, Up: {\uldb Multi-function Calc}{\v Multi_function_Calc}\line
K{\footnote K Mfcalc Rules}
#{\footnote Mfcalc_Rules}
${\footnote \pard{}Grammar Rules for {\f1{}mfcalc}}\par
\pard{\fs24\b Grammar Rules for {\f1{}mfcalc}}\par
\par
\pard{}Here are the grammar rules for the multi-function calculator.  Most of them are copied directly from {\f1{}calc}; three rules, those which mention {\f1{}VAR} or {\f1{}FNCT}, are new.\par
\par
{\pard\keep\li720\f1{}input:   /* empty */\line
        | input line\line
;\line
\line
line:\line
          '\'5Cn'\line
        | exp '\'5Cn'   \'7B printf ("\'5Ct%.10g\'5Cn", $1); \'7D\line
        | error '\'5Cn' \'7B yyerrok;                  \'7D\line
;\line
\line
exp:      NUM                \'7B $$ = $1;                         \'7D\line
        | VAR                \'7B $$ = $1->value.var;              \'7D\line
        | VAR '=' exp        \'7B $$ = $3; $1->value.var = $3;     \'7D\line
        | FNCT '(' exp ')'   \'7B $$ = (*($1->value.fnctptr))($3); \'7D\line
        | exp '+' exp        \'7B $$ = $1 + $3;                    \'7D\line
        | exp '-' exp        \'7B $$ = $1 - $3;                    \'7D\line
        | exp '*' exp        \'7B $$ = $1 * $3;                    \'7D\line
        | exp '/' exp        \'7B $$ = $1 / $3;                    \'7D\line
        | '-' exp  %prec NEG \'7B $$ = -$2;                        \'7D\line
        | exp '^' exp        \'7B $$ = pow ($1, $3);               \'7D\line
        | '(' exp ')'        \'7B $$ = $2;                         \'7D\line
;\line
/* End of grammar */\line
%%\par
\pard\f0{}}\par
\page\pard Node: {\b Mfcalc Symtab}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Mfcalc Rules}{\v Mfcalc_Rules}, Up: {\uldb Multi-function Calc}{\v Multi_function_Calc}\line
K{\footnote K Mfcalc Symtab}
#{\footnote Mfcalc_Symtab}
${\footnote \pard{}The {\f1{}mfcalc} Symbol Table}\par
\pard{\fs24\b The {\f1{}mfcalc} Symbol Table}\par
\par
\pard{}{K{\footnote K symbol table example}} The multi-function calculator requires a symbol table to keep track of the names and meanings of variables and functions.  This doesn't affect the grammar rules (except for the actions) or the Bison declarations, but it requires some additional C functions for support.\par
\par
\pard{}The symbol table itself consists of a linked list of records.  Its definition, which is kept in the header {\f1{}calc.h}, is as follows.  It provides for either functions or variables to be placed in the table.\par
\par
{{\pard\keep\li720\f1{}/* Data type for links in the chain of symbols.      */\line
struct symrec\line
\'7B\line
  char *name;  /* name of symbol                     */\line
  int type;    /* type of symbol: either VAR or FNCT */\line
  union \'7B\line
    double var;           /* value of a VAR          */\line
    double (*fnctptr)();  /* value of a FNCT         */\line
  \'7D value;\line
  struct symrec *next;    /* link field              */\line
\'7D;\par
\pard\keep\li720{}}\line
{typedef struct symrec symrec;\line
\line
/* The symbol table: a chain of `struct symrec'.     */\line
extern symrec *sym_table;\line
\line
symrec *putsym ();\line
symrec *getsym ();\par
\pard\keep\li720{}}}\par
\pard\f0{}The new version of {\f1{}main} includes a call to {\f1{}init_table}, a function that initializes the symbol table.  Here it is, and {\f1{}init_table} as well:\par
\par
{{\pard\keep\li720\f1{}#include <stdio.h>\line
\line
main ()\line
\'7B\line
  init_table ();\line
  yyparse ();\line
\'7D\par
\pard\keep\li720{}}\line
{yyerror (s)  /* Called by yyparse on error */\line
     char *s;\line
\'7B\line
  printf ("%s\'5Cn", s);\line
\'7D\line
\line
struct init\line
\'7B\line
  char *fname;\line
  double (*fnct)();\line
\'7D;\par
\pard\keep\li720{}}\line
{struct init arith_fncts[]\line
  = \'7B\line
      "sin", sin,\line
      "cos", cos,\line
      "atan", atan,\line
      "ln", log,\line
      "exp", exp,\line
      "sqrt", sqrt,\line
      0, 0\line
    \'7D;\line
\line
/* The symbol table: a chain of `struct symrec'.  */\line
symrec *sym_table = (symrec *)0;\par
\pard\keep\li720{}}\line
{init_table ()  /* puts arithmetic functions in table. */\line
\'7B\line
  int i;\line
  symrec *ptr;\line
  for (i = 0; arith_fncts[i].fname != 0; i++)\line
    \'7B\line
      ptr = putsym (arith_fncts[i].fname, FNCT);\line
      ptr->value.fnctptr = arith_fncts[i].fnct;\line
    \'7D\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}By simply editing the initialization list and adding the necessary include files, you can add additional functions to the calculator.\par
\par
\pard{}Two important functions allow look-up and installation of symbols in the symbol table.  The function {\f1{}putsym} is passed a name and the type ({\f1{}VAR} or {\f1{}FNCT}) of the object to be installed.  The object is linked to the front of the list, and a pointer to the object is returned.  The function {\f1{}getsym} is passed the name of the symbol to look up.  If found, a pointer to that symbol is returned; otherwise zero is returned.\par
\par
{\pard\keep\li720\f1{}symrec *\line
putsym (sym_name,sym_type)\line
     char *sym_name;\line
     int sym_type;\line
\'7B\line
  symrec *ptr;\line
  ptr = (symrec *) malloc (sizeof (symrec));\line
  ptr->name = (char *) malloc (strlen (sym_name) + 1);\line
  strcpy (ptr->name,sym_name);\line
  ptr->type = sym_type;\line
  ptr->value.var = 0; /* set value to 0 even if fctn.  */\line
  ptr->next = (struct symrec *)sym_table;\line
  sym_table = ptr;\line
  return ptr;\line
\'7D\line
\line
symrec *\line
getsym (sym_name)\line
     char *sym_name;\line
\'7B\line
  symrec *ptr;\line
  for (ptr = sym_table; ptr != (symrec *) 0;\line
       ptr = (symrec *)ptr->next)\line
    if (strcmp (ptr->name,sym_name) == 0)\line
      return ptr;\line
  return 0;\line
\'7D\par
\pard\f0{}}\par
\pard{}The function {\f1{}yylex} must now recognize variables, numeric values, and the single-character arithmetic operators.  Strings of alphanumeric characters with a leading nondigit are recognized as either variables or functions depending on what the symbol table says about them.\par
\par
\pard{}The string is passed to {\f1{}getsym} for look up in the symbol table.  If the name appears in the table, a pointer to its location and its type ({\f1{}VAR} or {\f1{}FNCT}) is returned to {\f1{}yyparse}.  If it is not already in the table, then it is installed as a {\f1{}VAR} using {\f1{}putsym}.  Again, a pointer and its type (which must be {\f1{}VAR}) is returned to {\f1{}yyparse}.\par
\par
\pard{}No change is needed in the handling of numeric values and arithmetic operators in {\f1{}yylex}.\par
\par
{{\pard\keep\li720\f1{}#include <ctype.h>\line
yylex ()\line
\'7B\line
  int c;\line
\line
  /* Ignore whitespace, get first nonwhite character.  */\line
  while ((c = getchar ()) == ' ' || c == '\'5Ct');\line
\line
  if (c == EOF)\line
    return 0;\par
\pard\keep\li720{}}\line
{  /* Char starts a number => parse the number.         */\line
  if (c == '.' || isdigit (c))\line
    \'7B\line
      ungetc (c, stdin);\line
      scanf ("%lf", &yylval.val);\line
      return NUM;\line
    \'7D\par
\pard\keep\li720{}}\line
{  /* Char starts an identifier => read the name.       */\line
  if (isalpha (c))\line
    \'7B\line
      symrec *s;\line
      static char *symbuf = 0;\line
      static int length = 0;\line
      int i;\par
\pard\keep\li720{}}\line
{      /* Initially make the buffer long enough\line
         for a 40-character symbol name.  */\line
      if (length == 0)\line
        length = 40, symbuf = (char *)malloc (length + 1);\line
\line
      i = 0;\line
      do\par
\pard\keep\li720{}}{        \'7B\line
          /* If buffer is full, make it bigger.        */\line
          if (i == length)\line
            \'7B\line
              length *= 2;\line
              symbuf = (char *)realloc (symbuf, length + 1);\line
            \'7D\line
          /* Add this character to the buffer.         */\line
          symbuf[i++] = c;\line
          /* Get another character.                    */\line
          c = getchar ();\line
        \'7D\par
\pard\keep\li720{}}{      while (c != EOF && isalnum (c));\line
\line
      ungetc (c, stdin);\line
      symbuf[i] = '\'5C0';\par
\pard\keep\li720{}}\line
{      s = getsym (symbuf);\line
      if (s == 0)\line
        s = putsym (symbuf, VAR);\line
      yylval.tptr = s;\line
      return s->type;\line
    \'7D\line
\line
  /* Any other character is a token by itself.        */\line
  return c;\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}This program is both powerful and flexible. You may easily add new functions, and it is a simple job to modify this code to install predefined variables such as {\f1{}pi} or {\f1{}e} as well.\par
\par
\page\pard Node: {\b Exercises}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Multi-function Calc}{\v Multi_function_Calc}, Up: {\uldb Examples}{\v Examples}\line
K{\footnote K Exercises}
#{\footnote Exercises}
${\footnote \pard{}Exercises}\par
\pard{\fs24\b Exercises}\par
\par
\pard{}{K{\footnote K exercises}} {\par
\pard\fi-720\li720\tx144\tx720{}\tab{}1. \tab{}Add some new functions from {\f1{}math.h} to the initialization list.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}2. \tab{}Add another array that contains constants and their values.  Then modify {\f1{}init_table} to add these constants to the symbol table.  It will be easiest to give the constants type {\f1{}VAR}.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}3. \tab{}Make the program report an error if the user refers to an uninitialized variable in any way except to store a value in it.\par
\pard{}}\par
\page\pard Node: {\b Grammar File}, \keepn Next: {\uldb Interface}{\v Interface}, Prev: {\uldb Examples}{\v Examples}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Grammar File}
#{\footnote Grammar_File}
${\footnote \pard{}Bison Grammar Files}\par
\pard{\fs24\b Bison Grammar Files}\par
\par
\pard{}Bison takes as input a context-free grammar specification and produces a C-language function that recognizes correct instances of the grammar.\par
\par
\pard{}The Bison grammar input file conventionally has a name ending in {\f1{}.y}.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Grammar Outline}{\v Grammar_Outline}\tab Overall layout of the grammar file.\par
{\uldb Symbols}{\v Symbols}\tab Terminal and nonterminal symbols.\par
{\uldb Rules}{\v Rules}\tab How to write grammar rules.\par
{\uldb Recursion}{\v Recursion}\tab Writing recursive rules.\par
{\uldb Semantics}{\v Semantics}\tab Semantic values and actions.\par
{\uldb Declarations}{\v Declarations}\tab All kinds of Bison declarations are described here.\par
{\uldb Multiple Parsers}{\v Multiple_Parsers}\tab Putting more than one Bison parser in one program.\par
\pard{}}\par
\page\pard Node: {\b Grammar Outline}, \keepn Next: {\uldb Symbols}{\v Symbols}, Prev: {\uldb }{\v }, Up: {\uldb Grammar File}{\v Grammar_File}\line
K{\footnote K Grammar Outline}
#{\footnote Grammar_Outline}
${\footnote \pard{}Outline of a Bison Grammar}\par
\pard{\fs24\b Outline of a Bison Grammar}\par
\par
\pard{}A Bison grammar file has four main sections, shown here with the appropriate delimiters:\par
\par
{\pard\keep\li720\f1{}%\'7B\line
{\i C declarations}\line
%\'7D\line
\line
{\i Bison declarations}\line
\line
%%\line
{\i Grammar rules}\line
%%\line
\line
{\i Additional C code}\par
\pard\f0{}}\par
\pard{}Comments enclosed in {\f1{}/* ... */} may appear in any of the sections.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb C Declarations}{\v C_Declarations}\tab Syntax and usage of the C declarations section.\par
{\uldb Bison Declarations}{\v Bison_Declarations}\tab Syntax and usage of the Bison declarations section.\par
{\uldb Grammar Rules}{\v Grammar_Rules}\tab Syntax and usage of the grammar rules section.\par
{\uldb C Code}{\v C_Code}\tab Syntax and usage of the additional C code section.\par
\pard{}}\par
\page\pard Node: {\b C Declarations}, \keepn Next: {\uldb Bison Declarations}{\v Bison_Declarations}, Prev: {\uldb }{\v }, Up: {\uldb Grammar Outline}{\v Grammar_Outline}\line
K{\footnote K C Declarations}
#{\footnote C_Declarations}
${\footnote \pard{}The C Declarations Section}\par
\pard{\fs24\b The C Declarations Section}\par
\par
\pard{}{K{\footnote K C declarations section}}{K{\footnote K declarations, C}} The {\i C declarations} section contains macro definitions and declarations of functions and variables that are used in the actions in the grammar rules.  These are copied to the beginning of the parser file so that they precede the definition of {\f1{}yyparse}.  You can use {\f1{}#include} to get the declarations from a header file.  If you don't need any C declarations, you may omit the {\f1{}%\'7B} and {\f1{}%\'7D} delimiters that bracket this section.\par
\par
\page\pard Node: {\b Bison Declarations}, \keepn Next: {\uldb Grammar Rules}{\v Grammar_Rules}, Prev: {\uldb C Declarations}{\v C_Declarations}, Up: {\uldb Grammar Outline}{\v Grammar_Outline}\line
K{\footnote K Bison Declarations}
#{\footnote Bison_Declarations}
${\footnote \pard{}The Bison Declarations Section}\par
\pard{\fs24\b The Bison Declarations Section}\par
\par
\pard{}{K{\footnote K Bison declarations (introduction)}}{K{\footnote K declarations, Bison (introduction)}} The {\i Bison declarations} section contains declarations that define terminal and nonterminal symbols, specify precedence, and so on.  In some simple grammars you may not need any declarations.  See {\uldb Bison Declarations}{\v Declarations}.\par
\par
\page\pard Node: {\b Grammar Rules}, \keepn Next: {\uldb C Code}{\v C_Code}, Prev: {\uldb Bison Declarations}{\v Bison_Declarations}, Up: {\uldb Grammar Outline}{\v Grammar_Outline}\line
K{\footnote K Grammar Rules}
#{\footnote Grammar_Rules}
${\footnote \pard{}The Grammar Rules Section}\par
\pard{\fs24\b The Grammar Rules Section}\par
\par
\pard{}{K{\footnote K grammar rules section}}{K{\footnote K rules section for grammar}} The \'A2grammar rules\'A2 section contains one or more Bison grammar rules, and nothing else.  See {\uldb Syntax of Grammar Rules}{\v Rules}.\par
\par
\pard{}There must always be at least one grammar rule, and the first {\f1{}%%} (which precedes the grammar rules) may never be omitted even if it is the first thing in the file.\par
\par
\page\pard Node: {\b C Code}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Grammar Rules}{\v Grammar_Rules}, Up: {\uldb Grammar Outline}{\v Grammar_Outline}\line
K{\footnote K C Code}
#{\footnote C_Code}
${\footnote \pard{}The Additional C Code Section}\par
\pard{\fs24\b The Additional C Code Section}\par
\par
\pard{}{K{\footnote K additional C code section}}{K{\footnote K C code, section for additional}} The {\i additional C code} section is copied verbatim to the end of the parser file, just as the {\i C declarations} section is copied to the beginning.  This is the most convenient place to put anything that you want to have in the parser file but which need not come before the definition of {\f1{}yyparse}.  For example, the definitions of {\f1{}yylex} and {\f1{}yyerror} often go here.  See {\uldb Parser C-Language Interface}{\v Interface}.\par
\par
\pard{}If the last section is empty, you may omit the {\f1{}%%} that separates it from the grammar rules.\par
\par
\pard{}The Bison parser itself contains many static variables whose names start with {\f1{}yy} and many macros whose names start with {\f1{}YY}.  It is a good idea to avoid using any such names (except those documented in this manual) in the additional C code section of the grammar file.\par
\par
\page\pard Node: {\b Symbols}, \keepn Next: {\uldb Rules}{\v Rules}, Prev: {\uldb Grammar Outline}{\v Grammar_Outline}, Up: {\uldb Grammar File}{\v Grammar_File}\line
K{\footnote K Symbols}
#{\footnote Symbols}
${\footnote \pard{}Symbols, Terminal and Nonterminal}\par
\pard{\fs24\b Symbols, Terminal and Nonterminal}\par
\par
\pard{}{K{\footnote K nonterminal symbol}}{K{\footnote K terminal symbol}}{K{\footnote K token type}}{K{\footnote K symbol}} \'A2Symbols\'A2 in Bison grammars represent the grammatical classifications of the language.\par
\par
\pard{}A \'A2terminal symbol\'A2 (also known as a \'A2token type\'A2) represents a class of syntactically equivalent tokens.  You use the symbol in grammar rules to mean that a token in that class is allowed.  The symbol is represented in the Bison parser by a numeric code, and the {\f1{}yylex} function returns a token type code to indicate what kind of token has been read.  You don't need to know what the code value is; you can use the symbol to stand for it.\par
\par
\pard{}A \'A2nonterminal symbol\'A2 stands for a class of syntactically equivalent groupings.  The symbol name is used in writing grammar rules.  By convention, it should be all lower case.\par
\par
\pard{}Symbol names can contain letters, digits (not at the beginning), underscores and periods.  Periods make sense only in nonterminals.\par
\par
\pard{}There are three ways of writing terminal symbols in the grammar:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}A \'A2named token type\'A2 is written with an identifier, like an identifier in C.  By convention, it should be all upper case.  Each such name must be defined with a Bison declaration such as {\f1{}%token}.  See {\uldb Token Type Names}{\v Token_Decl}.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}{K{\footnote K character token}}{K{\footnote K literal token}}{K{\footnote K single-character literal}}A \'A2character token type\'A2 (or \'A2literal character token\'A2) is written in the grammar using the same syntax used in C for character constants; for example, {\f1{}'+'} is a character token type.  A character token type doesn't need to be declared unless you need to specify its semantic value data type (see {\uldb Data Types of Semantic Values}{\v Value_Type}), associativity, or precedence (see {\uldb Operator Precedence}{\v Precedence}).\par
\par
\pard\li720{}By convention, a character token type is used only to represent a token that consists of that particular character.  Thus, the token type {\f1{}'+'} is used to represent the character {\f1{}+} as a token.  Nothing enforces this convention, but if you depart from it, your program will confuse other readers.\par
\par
\pard\li720{}All the usual escape sequences used in character literals in C can be used in Bison as well, but you must not use the null character as a character literal because its ASCII code, zero, is the code {\f1{}yylex} returns for end-of-input (see {\uldb Calling Convention\'5Cline for {\f1{}yylex}}{\v Calling_Convention}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}{K{\footnote K string token}}{K{\footnote K literal string token}}{K{\footnote K multi-character literal}}A \'A2literal string token\'A2 is written like a C string constant; for example, {\f1{}"<="} is a literal string token.  A literal string token doesn't need to be declared unless you need to specify its semantic value data type (see {\uldb Value Type}{\v Value_Type}), associativity, precedence (see {\uldb Precedence}{\v Precedence}).\par
\par
\pard\li720{}You can associate the literal string token with a symbolic name as an alias, using the {\f1{}%token} declaration (see {\uldb Token Declarations}{\v Token_Decl}).  If you don't do that, the lexical analyzer has to retrieve the token number for the literal string token from the {\f1{}yytname} table (see {\uldb Calling Convention}{\v Calling_Convention}).\par
\par
{\b \pard\li720{}WARNING}: literal string tokens do not work in Yacc.\par
\par
\pard\li720{}By convention, a literal string token is used only to represent a token that consists of that particular string.  Thus, you should use the token type {\f1{}"<="} to represent the string {\f1{}<=} as a token.  Bison does not enforces this convention, but if you depart from it, people who read your program will be confused.\par
\par
\pard\li720{}All the escape sequences used in string literals in C can be used in Bison as well.  A literal string token must contain two or more characters; for a token containing just one character, use a character token (see above).\par
\pard{}}\par
\pard{}How you choose to write a terminal symbol has no effect on its grammatical meaning.  That depends only on where it appears in rules and on when the parser function returns that symbol.\par
\par
\pard{}The value returned by {\f1{}yylex} is always one of the terminal symbols (or 0 for end-of-input).  Whichever way you write the token type in the grammar rules, you write it the same way in the definition of {\f1{}yylex}.  The numeric code for a character token type is simply the ASCII code for the character, so {\f1{}yylex} can use the identical character constant to generate the requisite code.  Each named token type becomes a C macro in the parser file, so {\f1{}yylex} can use the name to stand for the code.  (This is why periods don't make sense in terminal symbols.)  See {\uldb Calling Convention for {\f1{}yylex}}{\v Calling_Convention}.\par
\par
\pard{}If {\f1{}yylex} is defined in a separate file, you need to arrange for the token-type macro definitions to be available there.  Use the {\f1{}-d} option when you run Bison, so that it will write these macro definitions into a separate header file {\f1{}{\i name}.tab.h} which you can include in the other source files that need it.  See {\uldb Invoking Bison}{\v Invocation}.\par
\par
\pard{}The symbol {\f1{}error} is a terminal symbol reserved for error recovery (see {\uldb Error Recovery}{\v Error_Recovery}); you shouldn't use it for any other purpose.  In particular, {\f1{}yylex} should never return this value.\par
\par
\page\pard Node: {\b Rules}, \keepn Next: {\uldb Recursion}{\v Recursion}, Prev: {\uldb Symbols}{\v Symbols}, Up: {\uldb Grammar File}{\v Grammar_File}\line
K{\footnote K Rules}
#{\footnote Rules}
${\footnote \pard{}Syntax of Grammar Rules}\par
\pard{\fs24\b Syntax of Grammar Rules}\par
\par
\pard{}{K{\footnote K rule syntax}}{K{\footnote K grammar rule syntax}}{K{\footnote K syntax of grammar rules}} A Bison grammar rule has the following general form:\par
\par
{{{\i \pard\li720\f1{}result}: {\i components}...\line
        ;\par
\pard\keep\li720{}}}\par
\pard\f0{}where {\i result} is the nonterminal symbol that this rule describes and {\i components} are various terminal and nonterminal symbols that are put together by this rule (see {\uldb Symbols}{\v Symbols}).\par
\par
\pard{}For example,\par
\par
{{\pard\keep\li720\f1{}exp:      exp '+' exp\line
        ;\par
\pard\keep\li720{}}}\par
\pard\f0{}says that two groupings of type {\f1{}exp}, with a {\f1{}+} token in between, can be combined into a larger grouping of type {\f1{}exp}.\par
\par
\pard{}Whitespace in rules is significant only to separate symbols.  You can add extra whitespace as you wish.\par
\par
\pard{}Scattered among the components can be {\i actions} that determine the semantics of the rule.  An action looks like this:\par
\par
{\pard\keep\li720\f1{}\'7B{\i C statements}\'7D\par
\pard\f0{}}\par
\pard{}Usually there is only one action and it follows the components.  See {\uldb Actions}{\v Actions}.\par
\par
\pard{}{K{\footnote K |}}Multiple rules for the same {\i result} can be written separately or can be joined with the vertical-bar character {\f1{}|} as follows:\par
\par
{{{\i \pard\li720\f1{}result}:   {\i rule1-components}...\line
        | {\i rule2-components}...\line
        ...\line
        ;\par
\pard\f0{}}}\par
\pard{}They are still considered distinct rules even when joined in this way.\par
\par
\pard{}If {\i components} in a rule is empty, it means that {\i result} can match the empty string.  For example, here is how to define a comma-separated sequence of zero or more {\f1{}exp} groupings:\par
\par
{{\pard\keep\li720\f1{}expseq:   /* empty */\line
        | expseq1\line
        ;\par
\pard\keep\li720{}}\line
{expseq1:  exp\line
        | expseq1 ',' exp\line
        ;\par
\pard\keep\li720{}}}\par
\pard\f0{}It is customary to write a comment {\f1{}/* empty */} in each rule with no components.\par
\par
\page\pard Node: {\b Recursion}, \keepn Next: {\uldb Semantics}{\v Semantics}, Prev: {\uldb Rules}{\v Rules}, Up: {\uldb Grammar File}{\v Grammar_File}\line
K{\footnote K Recursion}
#{\footnote Recursion}
${\footnote \pard{}Recursive Rules}\par
\pard{\fs24\b Recursive Rules}\par
\par
\pard{}{K{\footnote K recursive rule}} A rule is called \'A2recursive\'A2 when its {\i result} nonterminal appears also on its right hand side.  Nearly all Bison grammars need to use recursion, because that is the only way to define a sequence of any number of somethings.  Consider this recursive definition of a comma-separated sequence of one or more expressions:\par
\par
{{\pard\keep\li720\f1{}expseq1:  exp\line
        | expseq1 ',' exp\line
        ;\par
\pard\keep\li720{}}}\par
\pard\f0{}{K{\footnote K left recursion}}{K{\footnote K right recursion}} Since the recursive use of {\f1{}expseq1} is the leftmost symbol in the right hand side, we call this \'A2left recursion\'A2.  By contrast, here the same construct is defined using \'A2right recursion\'A2:\par
\par
{{\pard\keep\li720\f1{}expseq1:  exp\line
        | exp ',' expseq1\line
        ;\par
\pard\keep\li720{}}}\par
\pard\f0{}Any kind of sequence can be defined using either left recursion or right recursion, but you should always use left recursion, because it can parse a sequence of any number of elements with bounded stack space.  Right recursion uses up space on the Bison stack in proportion to the number of elements in the sequence, because all the elements must be shifted onto the stack before the rule can be applied even once.  See {\uldb The Bison Parser Algorithm}{\v Algorithm}, for further explanation of this.\par
\par
\pard{}{K{\footnote K mutual recursion}}\'A2Indirect\'A2 or \'A2mutual\'A2 recursion occurs when the result of the rule does not appear directly on its right hand side, but does appear in rules for other nonterminals which do appear on its right hand side.\par
\par
\pard{}For example:\par
\par
{{\pard\keep\li720\f1{}expr:     primary\line
        | primary '+' primary\line
        ;\par
\pard\keep\li720{}}\line
{primary:  constant\line
        | '(' expr ')'\line
        ;\par
\pard\keep\li720{}}}\par
\pard\f0{}defines two mutually-recursive nonterminals, since each refers to the other.\par
\par
\page\pard Node: {\b Semantics}, \keepn Next: {\uldb Declarations}{\v Declarations}, Prev: {\uldb Recursion}{\v Recursion}, Up: {\uldb Grammar File}{\v Grammar_File}\line
K{\footnote K Semantics}
#{\footnote Semantics}
${\footnote \pard{}Defining Language Semantics}\par
\pard{\fs24\b Defining Language Semantics}\par
\par
\pard{}{K{\footnote K defining language semantics}}{K{\footnote K language semantics, defining}} The grammar rules for a language determine only the syntax.  The semantics are determined by the semantic values associated with various tokens and groupings, and by the actions taken when various groupings are recognized.\par
\par
\pard{}For example, the calculator calculates properly because the value associated with each expression is the proper number; it adds properly because the action for the grouping {\f1{}{\i x} + {\i y}} is to add the numbers associated with {\i x} and {\i y}.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Value Type}{\v Value_Type}\tab Specifying one data type for all semantic values.\par
{\uldb Multiple Types}{\v Multiple_Types}\tab Specifying several alternative data types.\par
{\uldb Actions}{\v Actions}\tab An action is the semantic definition of a grammar rule.\par
{\uldb Action Types}{\v Action_Types}\tab Specifying data types for actions to operate on.\par
{\uldb Mid-Rule Actions}{\v Mid_Rule_Actions}\tab Most actions go at the end of a rule. This says when, why and how to use the exceptional action in the middle of a rule.\par
\pard{}}\par
\page\pard Node: {\b Value Type}, \keepn Next: {\uldb Multiple Types}{\v Multiple_Types}, Prev: {\uldb }{\v }, Up: {\uldb Semantics}{\v Semantics}\line
K{\footnote K Value Type}
#{\footnote Value_Type}
${\footnote \pard{}Data Types of Semantic Values}\par
\pard{\fs24\b Data Types of Semantic Values}\par
\par
\pard{}{K{\footnote K semantic value type}}{K{\footnote K value type, semantic}}{K{\footnote K data types of semantic values}}{K{\footnote K default data type}} In a simple program it may be sufficient to use the same data type for the semantic values of all language constructs.  This was true in the RPN and infix calculator examples (see {\uldb Reverse Polish Notation Calculator}{\v RPN_Calc}).\par
\par
\pard{}Bison's default is to use type {\f1{}int} for all semantic values.  To specify some other type, define {\f1{}YYSTYPE} as a macro, like this:\par
\par
{\pard\keep\li720\f1{}#define YYSTYPE double\par
\pard\f0{}}\par
\pard{}This macro definition must go in the C declarations section of the grammar file (see {\uldb Outline of a Bison Grammar}{\v Grammar_Outline}).\par
\par
\page\pard Node: {\b Multiple Types}, \keepn Next: {\uldb Actions}{\v Actions}, Prev: {\uldb Value Type}{\v Value_Type}, Up: {\uldb Semantics}{\v Semantics}\line
K{\footnote K Multiple Types}
#{\footnote Multiple_Types}
${\footnote \pard{}More Than One Value Type}\par
\pard{\fs24\b More Than One Value Type}\par
\par
\pard{}In most programs, you will need different data types for different kinds of tokens and groupings.  For example, a numeric constant may need type {\f1{}int} or {\f1{}long}, while a string constant needs type {\f1{}char *}, and an identifier might need a pointer to an entry in the symbol table.\par
\par
\pard{}To use more than one data type for semantic values in one parser, Bison requires you to do two things:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Specify the entire collection of possible data types, with the {\f1{}%union} Bison declaration (see {\uldb The Collection of Value Types}{\v Union_Decl}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Choose one of those types for each symbol (terminal or nonterminal) for which semantic values are used.  This is done for tokens with the {\f1{}%token} Bison declaration (see {\uldb Token Type Names}{\v Token_Decl}) and for groupings with the {\f1{}%type} Bison declaration (see {\uldb Nonterminal Symbols}{\v Type_Decl}).\par
\pard{}}\par
\page\pard Node: {\b Actions}, \keepn Next: {\uldb Action Types}{\v Action_Types}, Prev: {\uldb Multiple Types}{\v Multiple_Types}, Up: {\uldb Semantics}{\v Semantics}\line
K{\footnote K Actions}
#{\footnote Actions}
${\footnote \pard{}Actions}\par
\pard{\fs24\b Actions}\par
\par
\pard{}{K{\footnote K action}}{K{\footnote K $$}}{K{\footnote K ${\i n}}} An action accompanies a syntactic rule and contains C code to be executed each time an instance of that rule is recognized.  The task of most actions is to compute a semantic value for the grouping built by the rule from the semantic values associated with tokens or smaller groupings.\par
\par
\pard{}An action consists of C statements surrounded by braces, much like a compound statement in C.  It can be placed at any position in the rule; it is executed at that position.  Most rules have just one action at the end of the rule, following all the components.  Actions in the middle of a rule are tricky and used only for special purposes (see {\uldb Actions in Mid-Rule}{\v Mid_Rule_Actions}).\par
\par
\pard{}The C code in an action can refer to the semantic values of the components matched by the rule with the construct {\f1{}${\i n}}, which stands for the value of the {\i n}th component.  The semantic value for the grouping being constructed is {\f1{}$$}.  (Bison translates both of these constructs into array element references when it copies the actions into the parser file.)\par
\par
\pard{}Here is a typical example:\par
\par
{{\pard\keep\li720\f1{}exp:    ...\line
        | exp '+' exp\line
            \'7B $$ = $1 + $3; \'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}This rule constructs an {\f1{}exp} from two smaller {\f1{}exp} groupings connected by a plus-sign token.  In the action, {\f1{}$1} and {\f1{}$3} refer to the semantic values of the two component {\f1{}exp} groupings, which are the first and third symbols on the right hand side of the rule.  The sum is stored into {\f1{}$$} so that it becomes the semantic value of the addition-expression just recognized by the rule.  If there were a useful semantic value associated with the {\f1{}+} token, it could be referred to as {\f1{}$2}.\par
\par
\pard{}{K{\footnote K default action}}If you don't specify an action for a rule, Bison supplies a default: {\f1{}$$ = $1}.  Thus, the value of the first symbol in the rule becomes the value of the whole rule.  Of course, the default rule is valid only if the two data types match.  There is no meaningful default action for an empty rule; every empty rule must have an explicit action unless the rule's value does not matter.\par
\par
{\f1{}\pard{}${\i n}} with {\i n} zero or negative is allowed for reference to tokens and groupings on the stack {\i before} those that match the current rule.  This is a very risky practice, and to use it reliably you must be certain of the context in which the rule is applied.  Here is a case in which you can use this reliably:\par
\par
{{\pard\keep\li720\f1{}foo:      expr bar '+' expr  \'7B ... \'7D\line
        | expr bar '-' expr  \'7B ... \'7D\line
        ;\par
\pard\keep\li720{}}\line
{bar:      /* empty */\line
        \'7B previous_expr = $0; \'7D\line
        ;\par
\pard\keep\li720{}}}\par
\pard\f0{}As long as {\f1{}bar} is used only in the fashion shown here, {\f1{}$0} always refers to the {\f1{}expr} which precedes {\f1{}bar} in the definition of {\f1{}foo}.\par
\par
\page\pard Node: {\b Action Types}, \keepn Next: {\uldb Mid-Rule Actions}{\v Mid_Rule_Actions}, Prev: {\uldb Actions}{\v Actions}, Up: {\uldb Semantics}{\v Semantics}\line
K{\footnote K Action Types}
#{\footnote Action_Types}
${\footnote \pard{}Data Types of Values in Actions}\par
\pard{\fs24\b Data Types of Values in Actions}\par
\par
\pard{}{K{\footnote K action data types}}{K{\footnote K data types in actions}} If you have chosen a single data type for semantic values, the {\f1{}$$} and {\f1{}${\i n}} constructs always have that data type.\par
\par
\pard{}If you have used {\f1{}%union} to specify a variety of data types, then you must declare a choice among these types for each terminal or nonterminal symbol that can have a semantic value.  Then each time you use {\f1{}$$} or {\f1{}${\i n}}, its data type is determined by which symbol it refers to in the rule.  In this example,\par
\par
{{\pard\keep\li720\f1{}exp:    ...\line
        | exp '+' exp\line
            \'7B $$ = $1 + $3; \'7D\par
\pard\keep\li720{}}}\par
{\f1{}\pard\f0{}$1} and {\f1{}$3} refer to instances of {\f1{}exp}, so they all have the data type declared for the nonterminal symbol {\f1{}exp}.  If {\f1{}$2} were used, it would have the data type declared for the terminal symbol {\f1{}'+'}, whatever that might be.\par
\par
\pard{}Alternatively, you can specify the data type when you refer to the value, by inserting {\f1{}<{\i type}>} after the {\f1{}$} at the beginning of the reference.  For example, if you have defined types as shown here:\par
\par
{{\pard\keep\li720\f1{}%union \'7B\line
  int itype;\line
  double dtype;\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}then you can write {\f1{}$<itype>1} to refer to the first subunit of the rule as an integer, or {\f1{}$<dtype>1} to refer to it as a double.\par
\par
\page\pard Node: {\b Mid-Rule Actions}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Action Types}{\v Action_Types}, Up: {\uldb Semantics}{\v Semantics}\line
K{\footnote K Mid-Rule Actions}
#{\footnote Mid_Rule_Actions}
${\footnote \pard{}Actions in Mid-Rule}\par
\pard{\fs24\b Actions in Mid-Rule}\par
\par
\pard{}{K{\footnote K actions in mid-rule}}{K{\footnote K mid-rule actions}} Occasionally it is useful to put an action in the middle of a rule.  These actions are written just like usual end-of-rule actions, but they are executed before the parser even recognizes the following components.\par
\par
\pard{}A mid-rule action may refer to the components preceding it using {\f1{}${\i n}}, but it may not refer to subsequent components because it is run before they are parsed.\par
\par
\pard{}The mid-rule action itself counts as one of the components of the rule.  This makes a difference when there is another action later in the same rule (and usually there is another at the end): you have to count the actions along with the symbols when working out which number {\i n} to use in {\f1{}${\i n}}.\par
\par
\pard{}The mid-rule action can also have a semantic value.  The action can set its value with an assignment to {\f1{}$$}, and actions later in the rule can refer to the value using {\f1{}${\i n}}.  Since there is no symbol to name the action, there is no way to declare a data type for the value in advance, so you must use the {\f1{}$<...>} construct to specify a data type each time you refer to this value.\par
\par
\pard{}There is no way to set the value of the entire rule with a mid-rule action, because assignments to {\f1{}$$} do not have that effect.  The only way to set the value for the entire rule is with an ordinary action at the end of the rule.\par
\par
\pard{}Here is an example from a hypothetical compiler, handling a {\f1{}let} statement that looks like {\f1{}let ({\i variable}) {\i statement}} and serves to create a variable named {\i variable} temporarily for the duration of {\i statement}.  To parse this construct, we must put {\i variable} into the symbol table while {\i statement} is parsed, then remove it afterward.  Here is how it is done:\par
\par
{{\pard\keep\li720\f1{}stmt:   LET '(' var ')'\line
                \'7B $<context>$ = push_context ();\line
                  declare_variable ($3); \'7D\line
        stmt    \'7B $$ = $6;\line
                  pop_context ($<context>5); \'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}As soon as {\f1{}let ({\i variable})} has been recognized, the first action is run.  It saves a copy of the current semantic context (the list of accessible variables) as its semantic value, using alternative {\f1{}context} in the data-type union.  Then it calls {\f1{}declare_variable} to add the new variable to that list.  Once the first action is finished, the embedded statement {\f1{}stmt} can be parsed.  Note that the mid-rule action is component number 5, so the {\f1{}stmt} is component number 6.\par
\par
\pard{}After the embedded statement is parsed, its semantic value becomes the value of the entire {\f1{}let}-statement.  Then the semantic value from the earlier action is used to restore the prior list of variables.  This removes the temporary {\f1{}let}-variable from the list so that it won't appear to exist while the rest of the program is parsed.\par
\par
\pard{}Taking action before a rule is completely recognized often leads to conflicts since the parser must commit to a parse in order to execute the action.  For example, the following two rules, without mid-rule actions, can coexist in a working parser because the parser can shift the open-brace token and look at what follows before deciding whether there is a declaration or not:\par
\par
{{\pard\keep\li720\f1{}compound: '\'7B' declarations statements '\'7D'\line
        | '\'7B' statements '\'7D'\line
        ;\par
\pard\keep\li720{}}}\par
\pard\f0{}But when we add a mid-rule action as follows, the rules become nonfunctional:\par
\par
{{\pard\keep\li720\f1{}compound: \'7B prepare_for_local_variables (); \'7D\line
          '\'7B' declarations statements '\'7D'\par
\pard\keep\li720{}}{        | '\'7B' statements '\'7D'\line
        ;\par
\pard\keep\li720{}}}\par
\pard\f0{}Now the parser is forced to decide whether to run the mid-rule action when it has read no farther than the open-brace.  In other words, it must commit to using one rule or the other, without sufficient information to do it correctly.  (The open-brace token is what is called the \'A2look-ahead\'A2 token at this time, since the parser is still deciding what to do about it.  See {\uldb Look-Ahead Tokens}{\v Look_Ahead}.)\par
\par
\pard{}You might think that you could correct the problem by putting identical actions into the two rules, like this:\par
\par
{{\pard\keep\li720\f1{}compound: \'7B prepare_for_local_variables (); \'7D\line
          '\'7B' declarations statements '\'7D'\line
        | \'7B prepare_for_local_variables (); \'7D\line
          '\'7B' statements '\'7D'\line
        ;\par
\pard\keep\li720{}}}\par
\pard\f0{}But this does not help, because Bison does not realize that the two actions are identical.  (Bison never tries to understand the C code in an action.)\par
\par
\pard{}If the grammar is such that a declaration can be distinguished from a statement by the first token (which is true in C), then one solution which does work is to put the action after the open-brace, like this:\par
\par
{{\pard\keep\li720\f1{}compound: '\'7B' \'7B prepare_for_local_variables (); \'7D\line
          declarations statements '\'7D'\line
        | '\'7B' statements '\'7D'\line
        ;\par
\pard\keep\li720{}}}\par
\pard\f0{}Now the first token of the following declaration or statement, which would in any case tell Bison which rule to use, can still do so.\par
\par
\pard{}Another solution is to bury the action inside a nonterminal symbol which serves as a subroutine:\par
\par
{{\pard\keep\li720\f1{}subroutine: /* empty */\line
          \'7B prepare_for_local_variables (); \'7D\line
        ;\line
\par
\pard\keep\li720{}}\line
{compound: subroutine\line
          '\'7B' declarations statements '\'7D'\line
        | subroutine\line
          '\'7B' statements '\'7D'\line
        ;\par
\pard\keep\li720{}}}\par
\pard\f0{}Now Bison can execute the action in the rule for {\f1{}subroutine} without deciding which rule for {\f1{}compound} it will eventually use.  Note that the action is now at the end of its rule.  Any mid-rule action can be converted to an end-of-rule action in this way, and this is what Bison actually does to implement mid-rule actions.\par
\par
\page\pard Node: {\b Declarations}, \keepn Next: {\uldb Multiple Parsers}{\v Multiple_Parsers}, Prev: {\uldb Semantics}{\v Semantics}, Up: {\uldb Grammar File}{\v Grammar_File}\line
K{\footnote K Declarations}
#{\footnote Declarations}
${\footnote \pard{}Bison Declarations}\par
\pard{\fs24\b Bison Declarations}\par
\par
\pard{}{K{\footnote K declarations, Bison}}{K{\footnote K Bison declarations}} The \'A2Bison declarations\'A2 section of a Bison grammar defines the symbols used in formulating the grammar and the data types of semantic values.  See {\uldb Symbols}{\v Symbols}.\par
\par
\pard{}All token type names (but not single-character literal tokens such as {\f1{}'+'} and {\f1{}'*'}) must be declared.  Nonterminal symbols must be declared if you need to specify which data type to use for the semantic value (see {\uldb More Than One Value Type}{\v Multiple_Types}).\par
\par
\pard{}The first rule in the file also specifies the start symbol, by default.  If you want some other symbol to be the start symbol, you must declare it explicitly (see {\uldb Languages and Context-Free Grammars}{\v Language_and_Grammar}).\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Token Decl}{\v Token_Decl}\tab Declaring terminal symbols.\par
{\uldb Precedence Decl}{\v Precedence_Decl}\tab Declaring terminals with precedence and associativity.\par
{\uldb Union Decl}{\v Union_Decl}\tab Declaring the set of all semantic value types.\par
{\uldb Type Decl}{\v Type_Decl}\tab Declaring the choice of type for a nonterminal symbol.\par
{\uldb Expect Decl}{\v Expect_Decl}\tab Suppressing warnings about shift/reduce conflicts.\par
{\uldb Start Decl}{\v Start_Decl}\tab Specifying the start symbol.\par
{\uldb Pure Decl}{\v Pure_Decl}\tab Requesting a reentrant parser.\par
{\uldb Decl Summary}{\v Decl_Summary}\tab Table of all Bison declarations.\par
\pard{}}\par
\page\pard Node: {\b Token Decl}, \keepn Next: {\uldb Precedence Decl}{\v Precedence_Decl}, Prev: {\uldb }{\v }, Up: {\uldb Declarations}{\v Declarations}\line
K{\footnote K Token Decl}
#{\footnote Token_Decl}
${\footnote \pard{}Token Type Names}\par
\pard{\fs24\b Token Type Names}\par
\par
\pard{}{K{\footnote K declaring token type names}}{K{\footnote K token type names, declaring}}{K{\footnote K declaring literal string tokens}}{K{\footnote K %token}} The basic way to declare a token type name (terminal symbol) is as follows:\par
\par
{\pard\keep\li720\f1{}%token {\i name}\par
\pard\f0{}}\par
\pard{}Bison will convert this into a {\f1{}#define} directive in the parser, so that the function {\f1{}yylex} (if it is in this file) can use the name {\i name} to stand for this token type's code.\par
\par
\pard{}Alternatively, you can use {\f1{}%left}, {\f1{}%right}, or {\f1{}%nonassoc} instead of {\f1{}%token}, if you wish to specify precedence.  See {\uldb Operator Precedence}{\v Precedence_Decl}.\par
\par
\pard{}You can explicitly specify the numeric code for a token type by appending an integer value in the field immediately following the token name:\par
\par
{\pard\keep\li720\f1{}%token NUM 300\par
\pard\f0{}}\par
\pard{}It is generally best, however, to let Bison choose the numeric codes for all token types.  Bison will automatically select codes that don't conflict with each other or with ASCII characters.\par
\par
\pard{}In the event that the stack type is a union, you must augment the {\f1{}%token} or other token declaration to include the data type alternative delimited by angle-brackets (see {\uldb More Than One Value Type}{\v Multiple_Types}).\par
\par
\pard{}For example:\par
\par
{{\pard\keep\li720\f1{}%union \'7B              /* define stack type */\line
  double val;\line
  symrec *tptr;\line
\'7D\line
%token <val> NUM      /* define token NUM and its type */\par
\pard\keep\li720{}}}\par
\pard\f0{}You can associate a literal string token with a token type name by writing the literal string at the end of a {\f1{}%token} declaration which declares the name.  For example:\par
\par
{\pard\keep\li720\f1{}%token arrow "=>"\par
\pard\f0{}}\par
\pard{}For example, a grammar for the C language might specify these names with equivalent literal string tokens:\par
\par
{\pard\keep\li720\f1{}%token  <operator>  OR      "||"\line
%token  <operator>  LE 134  "<="\line
%left  OR  "<="\par
\pard\f0{}}\par
\pard{}Once you equate the literal string and the token name, you can use them interchangeably in further declarations or the grammar rules.  The {\f1{}yylex} function can use the token name or the literal string to obtain the token type code number (see {\uldb Calling Convention}{\v Calling_Convention}).\par
\par
\page\pard Node: {\b Precedence Decl}, \keepn Next: {\uldb Union Decl}{\v Union_Decl}, Prev: {\uldb Token Decl}{\v Token_Decl}, Up: {\uldb Declarations}{\v Declarations}\line
K{\footnote K Precedence Decl}
#{\footnote Precedence_Decl}
${\footnote \pard{}Operator Precedence}\par
\pard{\fs24\b Operator Precedence}\par
\par
\pard{}{K{\footnote K precedence declarations}}{K{\footnote K declaring operator precedence}}{K{\footnote K operator precedence, declaring}} Use the {\f1{}%left}, {\f1{}%right} or {\f1{}%nonassoc} declaration to declare a token and specify its precedence and associativity, all at once.  These are called \'A2precedence declarations\'A2.  See {\uldb Operator Precedence}{\v Precedence}, for general information on operator precedence.\par
\par
\pard{}The syntax of a precedence declaration is the same as that of {\f1{}%token}: either\par
\par
{\pard\keep\li720\f1{}%left {\i symbols}...\par
\pard\f0{}}\par
\pard{}or\par
\par
{\pard\keep\li720\f1{}%left <{\i type}> {\i symbols}...\par
\pard\f0{}}\par
\pard{}And indeed any of these declarations serves the purposes of {\f1{}%token}.  But in addition, they specify the associativity and relative precedence for all the {\i symbols}:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The associativity of an operator {\i op} determines how repeated uses of the operator nest: whether {\f1{}{\i x} {\i op} {\i y} {\i op} {\i z}} is parsed by grouping {\i x} with {\i y} first or by grouping {\i y} with {\i z} first.  {\f1{}%left} specifies left-associativity (grouping {\i x} with {\i y} first) and {\f1{}%right} specifies right-associativity (grouping {\i y} with {\i z} first).  {\f1{}%nonassoc} specifies no associativity, which means that {\f1{}{\i x} {\i op} {\i y} {\i op} {\i z}} is considered a syntax error.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The precedence of an operator determines how it nests with other operators.  All the tokens declared in a single precedence declaration have equal precedence and nest together according to their associativity.  When two tokens declared in different precedence declarations associate, the one declared later has the higher precedence and is grouped first.\par
\pard{}}\par
\page\pard Node: {\b Union Decl}, \keepn Next: {\uldb Type Decl}{\v Type_Decl}, Prev: {\uldb Precedence Decl}{\v Precedence_Decl}, Up: {\uldb Declarations}{\v Declarations}\line
K{\footnote K Union Decl}
#{\footnote Union_Decl}
${\footnote \pard{}The Collection of Value Types}\par
\pard{\fs24\b The Collection of Value Types}\par
\par
\pard{}{K{\footnote K declaring value types}}{K{\footnote K value types, declaring}}{K{\footnote K %union}} The {\f1{}%union} declaration specifies the entire collection of possible data types for semantic values.  The keyword {\f1{}%union} is followed by a pair of braces containing the same thing that goes inside a {\f1{}union} in C.\par
\par
\pard{}For example:\par
\par
{{\pard\keep\li720\f1{}%union \'7B\line
  double val;\line
  symrec *tptr;\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}This says that the two alternative types are {\f1{}double} and {\f1{}symrec *}.  They are given names {\f1{}val} and {\f1{}tptr}; these names are used in the {\f1{}%token} and {\f1{}%type} declarations to pick one of the types for a terminal or nonterminal symbol (see {\uldb Nonterminal Symbols}{\v Type_Decl}).\par
\par
\pard{}Note that, unlike making a {\f1{}union} declaration in C, you do not write a semicolon after the closing brace.\par
\par
\page\pard Node: {\b Type Decl}, \keepn Next: {\uldb Expect Decl}{\v Expect_Decl}, Prev: {\uldb Union Decl}{\v Union_Decl}, Up: {\uldb Declarations}{\v Declarations}\line
K{\footnote K Type Decl}
#{\footnote Type_Decl}
${\footnote \pard{}Nonterminal Symbols}\par
\pard{\fs24\b Nonterminal Symbols}\par
\par
\pard{}{K{\footnote K declaring value types, nonterminals}}{K{\footnote K value types, nonterminals, declaring}}{K{\footnote K %type}}\par
\par
\pard{}When you use {\f1{}%union} to specify multiple value types, you must declare the value type of each nonterminal symbol for which values are used.  This is done with a {\f1{}%type} declaration, like this:\par
\par
{\pard\keep\li720\f1{}%type <{\i type}> {\i nonterminal}...\par
\pard\f0{}}\par
\pard{}Here {\i nonterminal} is the name of a nonterminal symbol, and {\i type} is the name given in the {\f1{}%union} to the alternative that you want (see {\uldb The Collection of Value Types}{\v Union_Decl}).  You can give any number of nonterminal symbols in the same {\f1{}%type} declaration, if they have the same value type.  Use spaces to separate the symbol names.\par
\par
\pard{}You can also declare the value type of a terminal symbol.  To do this, use the same {\f1{}<{\i type}>} construction in a declaration for the terminal symbol.  All kinds of token declarations allow {\f1{}<{\i type}>}.\par
\par
\page\pard Node: {\b Expect Decl}, \keepn Next: {\uldb Start Decl}{\v Start_Decl}, Prev: {\uldb Type Decl}{\v Type_Decl}, Up: {\uldb Declarations}{\v Declarations}\line
K{\footnote K Expect Decl}
#{\footnote Expect_Decl}
${\footnote \pard{}Suppressing Conflict Warnings}\par
\pard{\fs24\b Suppressing Conflict Warnings}\par
\par
\pard{}{K{\footnote K suppressing conflict warnings}}{K{\footnote K preventing warnings about conflicts}}{K{\footnote K warnings, preventing}}{K{\footnote K conflicts, suppressing warnings of}}{K{\footnote K %expect}} Bison normally warns if there are any conflicts in the grammar (see {\uldb Shift/Reduce Conflicts}{\v Shift_Reduce}), but most real grammars have harmless shift/reduce conflicts which are resolved in a predictable way and would be difficult to eliminate.  It is desirable to suppress the warning about these conflicts unless the number of conflicts changes.  You can do this with the {\f1{}%expect} declaration.\par
\par
\pard{}The declaration looks like this:\par
\par
{\pard\keep\li720\f1{}%expect {\i n}\par
\pard\f0{}}\par
\pard{}Here {\i n} is a decimal integer.  The declaration says there should be no warning if there are {\i n} shift/reduce conflicts and no reduce/reduce conflicts.  The usual warning is given if there are either more or fewer conflicts, or if there are any reduce/reduce conflicts.\par
\par
\pard{}In general, using {\f1{}%expect} involves these steps:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Compile your grammar without {\f1{}%expect}.  Use the {\f1{}-v} option to get a verbose list of where the conflicts occur.  Bison will also print the number of conflicts.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Check each of the conflicts to make sure that Bison's default resolution is what you really want.  If not, rewrite the grammar and go back to the beginning.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Add an {\f1{}%expect} declaration, copying the number {\i n} from the number which Bison printed.\par
\pard{}}\par
\pard{}Now Bison will stop annoying you about the conflicts you have checked, but it will warn you again if changes in the grammar result in additional conflicts.\par
\par
\page\pard Node: {\b Start Decl}, \keepn Next: {\uldb Pure Decl}{\v Pure_Decl}, Prev: {\uldb Expect Decl}{\v Expect_Decl}, Up: {\uldb Declarations}{\v Declarations}\line
K{\footnote K Start Decl}
#{\footnote Start_Decl}
${\footnote \pard{}The Start-Symbol}\par
\pard{\fs24\b The Start-Symbol}\par
\par
\pard{}{K{\footnote K declaring the start symbol}}{K{\footnote K start symbol, declaring}}{K{\footnote K default start symbol}}{K{\footnote K %start}} Bison assumes by default that the start symbol for the grammar is the first nonterminal specified in the grammar specification section.  The programmer may override this restriction with the {\f1{}%start} declaration as follows:\par
\par
{\pard\keep\li720\f1{}%start {\i symbol}\par
\pard\f0{}}\par
\page\pard Node: {\b Pure Decl}, \keepn Next: {\uldb Decl Summary}{\v Decl_Summary}, Prev: {\uldb Start Decl}{\v Start_Decl}, Up: {\uldb Declarations}{\v Declarations}\line
K{\footnote K Pure Decl}
#{\footnote Pure_Decl}
${\footnote \pard{}A Pure (Reentrant) Parser}\par
\pard{\fs24\b A Pure (Reentrant) Parser}\par
\par
\pard{}{K{\footnote K reentrant parser}}{K{\footnote K pure parser}}{K{\footnote K %pure_parser}} A \'A2reentrant\'A2 program is one which does not alter in the course of execution; in other words, it consists entirely of \'A2pure\'A2 (read-only) code.  Reentrancy is important whenever asynchronous execution is possible; for example, a nonreentrant program may not be safe to call from a signal handler.  In systems with multiple threads of control, a nonreentrant program must be called only within interlocks.\par
\par
\pard{}Normally, Bison generates a parser which is not reentrant.  This is suitable for most uses, and it permits compatibility with YACC.  (The standard YACC interfaces are inherently nonreentrant, because they use statically allocated variables for communication with {\f1{}yylex}, including {\f1{}yylval} and {\f1{}yylloc}.)\par
\par
\pard{}Alternatively, you can generate a pure, reentrant parser.  The Bison declaration {\f1{}%pure_parser} says that you want the parser to be reentrant.  It looks like this:\par
\par
{\pard\keep\li720\f1{}%pure_parser\par
\pard\f0{}}\par
\pard{}The result is that the communication variables {\f1{}yylval} and {\f1{}yylloc} become local variables in {\f1{}yyparse}, and a different calling convention is used for the lexical analyzer function {\f1{}yylex}.  See {\uldb Calling Conventions for Pure Parsers}{\v Pure_Calling}, for the details of this.  The variable {\f1{}yynerrs} also becomes local in {\f1{}yyparse} (see {\uldb The Error\'5Cline Reporting Function {\f1{}yyerror}}{\v Error_Reporting}).  The convention for calling {\f1{}yyparse} itself is unchanged.\par
\par
\pard{}Whether the parser is pure has nothing to do with the grammar rules.  You can generate either a pure parser or a nonreentrant parser from any valid grammar.\par
\par
\page\pard Node: {\b Decl Summary}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Pure Decl}{\v Pure_Decl}, Up: {\uldb Declarations}{\v Declarations}\line
K{\footnote K Decl Summary}
#{\footnote Decl_Summary}
${\footnote \pard{}Bison Declaration Summary}\par
\pard{\fs24\b Bison Declaration Summary}\par
\par
\pard{}{K{\footnote K Bison declaration summary}}{K{\footnote K declaration summary}}{K{\footnote K summary, Bison declaration}} Here is a summary of all Bison declarations:\par
\par
{\pard{}{\f1{}%union}\par
\pard\li720{}Declare the collection of data types that semantic values may have (see {\uldb The Collection of Value Types}{\v Union_Decl}).\par
\par
\pard{}{\f1{}%token}\par
\pard\li720{}Declare a terminal symbol (token type name) with no precedence or associativity specified (see {\uldb Token Type Names}{\v Token_Decl}).\par
\par
\pard{}{\f1{}%right}\par
\pard\li720{}Declare a terminal symbol (token type name) that is right-associative (see {\uldb Operator Precedence}{\v Precedence_Decl}).\par
\par
\pard{}{\f1{}%left}\par
\pard\li720{}Declare a terminal symbol (token type name) that is left-associative (see {\uldb Operator Precedence}{\v Precedence_Decl}).\par
\par
\pard{}{\f1{}%nonassoc}\par
\pard\li720{}Declare a terminal symbol (token type name) that is nonassociative (using it in a way that would be associative is a syntax error) (see {\uldb Operator Precedence}{\v Precedence_Decl}).\par
\par
\pard{}{\f1{}%type}\par
\pard\li720{}Declare the type of semantic values for a nonterminal symbol (see {\uldb Nonterminal Symbols}{\v Type_Decl}).\par
\par
\pard{}{\f1{}%start}\par
\pard\li720{}Specify the grammar's start symbol (see {\uldb The Start-Symbol}{\v Start_Decl}).\par
\par
\pard{}{\f1{}%expect}\par
\pard\li720{}Declare the expected number of shift-reduce conflicts (see {\uldb Suppressing Conflict Warnings}{\v Expect_Decl}).\par
\par
\pard{}{\f1{}%pure_parser}\par
\pard\li720{}Request a pure (reentrant) parser program (see {\uldb A Pure (Reentrant) Parser}{\v Pure_Decl}).\par
\par
\pard{}{\f1{}%no_lines}\par
\pard\li720{}Don't generate any {\f1{}#line} preprocessor commands in the parser file.  Ordinarily Bison writes these commands in the parser file so that the C compiler and debuggers will associate errors and object code with your source file (the grammar file).  This directive causes them to associate errors with the parser file, treating it an independent source file in its own right.\par
\par
\pard{}{\f1{}%raw}\par
\pard\li720{}The output file {\f1{}{\i name}.h} normally defines the tokens with Yacc-compatible token numbers.  If this option is specified, the internal Bison numbers are used instead.  (Yacc-compatible numbers start at 257 except for single character tokens; Bison assigns token numbers sequentially for all tokens starting at 3.)\par
\par
\pard{}{\f1{}%token_table}\par
\pard\li720{}Generate an array of token names in the parser file.  The name of the array is {\f1{}yytname}; {\f1{}yytname[{\i i}]} is the name of the token whose internal Bison token code number is {\i i}.  The first three elements of {\f1{}yytname} are always {\f1{}"$"}, {\f1{}"error"}, and {\f1{}"$illegal"}; after these come the symbols defined in the grammar file.\par
\par
\pard\li720{}For single-character literal tokens and literal string tokens, the name in the table includes the single-quote or double-quote characters: for example, {\f1{}"'+'"} is a single-character literal and {\f1{}"\'5C"<=\'5C""} is a literal string token.  All the characters of the literal string token appear verbatim in the string found in the table; even double-quote characters are not escaped.  For example, if the token consists of three characters {\f1{}*"*}, its string in {\f1{}yytname} contains {\f1{}"*"*"}.  (In C, that would be written as {\f1{}"\'5C"*\'5C"*\'5C""}).\par
\par
\pard\li720{}When you specify {\f1{}%token_table}, Bison also generates macro definitions for macros {\f1{}YYNTOKENS}, {\f1{}YYNNTS}, and {\f1{}YYNRULES}, and {\f1{}YYNSTATES}:\par
\par
{\pard\li720{}{\f1{}YYNTOKENS}\par
\pard\li1440{}The highest token number, plus one.\par
\par
\pard\li720{}{\f1{}YYNNTS}\par
\pard\li1440{}The number of non-terminal symbols.\par
\par
\pard\li720{}{\f1{}YYNRULES}\par
\pard\li1440{}The number of grammar rules,\par
\par
\pard\li720{}{\f1{}YYNSTATES}\par
\pard\li1440{}The number of parser states (see {\uldb Parser States}{\v Parser_States}).\par
\pard\li720{}}}\par
\page\pard Node: {\b Multiple Parsers}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Declarations}{\v Declarations}, Up: {\uldb Grammar File}{\v Grammar_File}\line
K{\footnote K Multiple Parsers}
#{\footnote Multiple_Parsers}
${\footnote \pard{}Multiple Parsers in the Same Program}\par
\pard{\fs24\b Multiple Parsers in the Same Program}\par
\par
\pard{}Most programs that use Bison parse only one language and therefore contain only one Bison parser.  But what if you want to parse more than one language with the same program?  Then you need to avoid a name conflict between different definitions of {\f1{}yyparse}, {\f1{}yylval}, and so on.\par
\par
\pard{}The easy way to do this is to use the option {\f1{}-p {\i prefix}} (see {\uldb Invoking Bison}{\v Invocation}).  This renames the interface functions and variables of the Bison parser to start with {\i prefix} instead of {\f1{}yy}.  You can use this to give each parser distinct names that do not conflict.\par
\par
\pard{}The precise list of symbols renamed is {\f1{}yyparse}, {\f1{}yylex}, {\f1{}yyerror}, {\f1{}yynerrs}, {\f1{}yylval}, {\f1{}yychar} and {\f1{}yydebug}.  For example, if you use {\f1{}-p c}, the names become {\f1{}cparse}, {\f1{}clex}, and so on.\par
\par
{\b \pard{}All the other variables and macros associated with Bison are not renamed.} These others are not global; there is no conflict if the same name is used in different parsers.  For example, {\f1{}YYSTYPE} is not renamed, but defining this in different ways in different parsers causes no trouble (see {\uldb Data Types of Semantic Values}{\v Value_Type}).\par
\par
\pard{}The {\f1{}-p} option works by adding macro definitions to the beginning of the parser source file, defining {\f1{}yyparse} as {\f1{}{\i prefix}parse}, and so on.  This effectively substitutes one name for the other in the entire parser file.\par
\par
\page\pard Node: {\b Interface}, \keepn Next: {\uldb Algorithm}{\v Algorithm}, Prev: {\uldb Grammar File}{\v Grammar_File}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Interface}
#{\footnote Interface}
${\footnote \pard{}Parser C-Language Interface}\par
\pard{\fs24\b Parser C-Language Interface}\par
\par
\pard{}{K{\footnote K C-language interface}}{K{\footnote K interface}} The Bison parser is actually a C function named {\f1{}yyparse}.  Here we describe the interface conventions of {\f1{}yyparse} and the other functions that it needs to use.\par
\par
\pard{}Keep in mind that the parser uses many C identifiers starting with {\f1{}yy} and {\f1{}YY} for internal purposes.  If you use such an identifier (aside from those in this manual) in an action or in additional C code in the grammar file, you are likely to run into trouble.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Parser Function}{\v Parser_Function}\tab How to call {\f1{}yyparse} and what it returns.\par
{\uldb Lexical}{\v Lexical}\tab You must supply a function {\f1{}yylex} which reads tokens.\par
{\uldb Error Reporting}{\v Error_Reporting}\tab You must supply a function {\f1{}yyerror}.\par
{\uldb Action Features}{\v Action_Features}\tab Special features for use in actions.\par
\pard{}}\par
\page\pard Node: {\b Parser Function}, \keepn Next: {\uldb Lexical}{\v Lexical}, Prev: {\uldb }{\v }, Up: {\uldb Interface}{\v Interface}\line
K{\footnote K Parser Function}
#{\footnote Parser_Function}
${\footnote \pard{}The Parser Function {\f1{}yyparse}}\par
\pard{\fs24\b The Parser Function {\f1{}yyparse}}\par
\par
\pard{}{K{\footnote K yyparse}} You call the function {\f1{}yyparse} to cause parsing to occur.  This function reads tokens, executes actions, and ultimately returns when it encounters end-of-input or an unrecoverable syntax error.  You can also write an action which directs {\f1{}yyparse} to return immediately without reading further.\par
\par
\pard{}The value returned by {\f1{}yyparse} is 0 if parsing was successful (return is due to end-of-input).\par
\par
\pard{}The value is 1 if parsing failed (return is due to a syntax error).\par
\par
\pard{}In an action, you can cause immediate return from {\f1{}yyparse} by using these macros:\par
\par
{\pard{}{\f1{}YYACCEPT}\par
\pard\li720{}{K{\footnote K YYACCEPT}}Return immediately with value 0 (to report success).\par
\par
\pard{}{\f1{}YYABORT}\par
\pard\li720{}{K{\footnote K YYABORT}}Return immediately with value 1 (to report failure).\par
\pard{}}\par
\page\pard Node: {\b Lexical}, \keepn Next: {\uldb Error Reporting}{\v Error_Reporting}, Prev: {\uldb Parser Function}{\v Parser_Function}, Up: {\uldb Interface}{\v Interface}\line
K{\footnote K Lexical}
#{\footnote Lexical}
${\footnote \pard{}The Lexical Analyzer Function {\f1{}yylex}}\par
\pard{\fs24\b The Lexical Analyzer Function {\f1{}yylex}}\par
\par
\pard{}{K{\footnote K yylex}}{K{\footnote K lexical analyzer}} The \'A2lexical analyzer\'A2 function, {\f1{}yylex}, recognizes tokens from the input stream and returns them to the parser.  Bison does not create this function automatically; you must write it so that {\f1{}yyparse} can call it.  The function is sometimes referred to as a lexical scanner.\par
\par
\pard{}In simple programs, {\f1{}yylex} is often defined at the end of the Bison grammar file.  If {\f1{}yylex} is defined in a separate source file, you need to arrange for the token-type macro definitions to be available there.  To do this, use the {\f1{}-d} option when you run Bison, so that it will write these macro definitions into a separate header file {\f1{}{\i name}.tab.h} which you can include in the other source files that need it.  See {\uldb Invoking Bison}{\v Invocation}.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Calling Convention}{\v Calling_Convention}\tab How {\f1{}yyparse} calls {\f1{}yylex}.\par
{\uldb Token Values}{\v Token_Values}\tab How {\f1{}yylex} must return the semantic value of the token it has read.\par
{\uldb Token Positions}{\v Token_Positions}\tab How {\f1{}yylex} must return the text position (line number, etc.) of the token, if the actions want that.\par
{\uldb Pure Calling}{\v Pure_Calling}\tab How the calling convention differs in a pure parser (see {\uldb A Pure (Reentrant) Parser}{\v Pure_Decl}).\par
\pard{}}\par
\page\pard Node: {\b Calling Convention}, \keepn Next: {\uldb Token Values}{\v Token_Values}, Prev: {\uldb }{\v }, Up: {\uldb Lexical}{\v Lexical}\line
K{\footnote K Calling Convention}
#{\footnote Calling_Convention}
${\footnote \pard{}Calling Convention for {\f1{}yylex}}\par
\pard{\fs24\b Calling Convention for {\f1{}yylex}}\par
\par
\pard{}The value that {\f1{}yylex} returns must be the numeric code for the type of token it has just found, or 0 for end-of-input.\par
\par
\pard{}When a token is referred to in the grammar rules by a name, that name in the parser file becomes a C macro whose definition is the proper numeric code for that token type.  So {\f1{}yylex} can use the name to indicate that type.  See {\uldb Symbols}{\v Symbols}.\par
\par
\pard{}When a token is referred to in the grammar rules by a character literal, the numeric code for that character is also the code for the token type.  So {\f1{}yylex} can simply return that character code.  The null character must not be used this way, because its code is zero and that is what signifies end-of-input.\par
\par
\pard{}Here is an example showing these things:\par
\par
{\pard\keep\li720\f1{}yylex ()\line
\'7B\line
  ...\line
  if (c == EOF)     /* Detect end of file. */\line
    return 0;\line
  ...\line
  if (c == '+' || c == '-')\line
    return c;      /* Assume token type for `+' is '+'. */\line
  ...\line
  return INT;      /* Return the type of the token. */\line
  ...\line
\'7D\par
\pard\f0{}}\par
\pard{}This interface has been designed so that the output from the {\f1{}lex} utility can be used without change as the definition of {\f1{}yylex}.\par
\par
\pard{}If the grammar uses literal string tokens, there are two ways that {\f1{}yylex} can determine the token type codes for them:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}If the grammar defines symbolic token names as aliases for the literal string tokens, {\f1{}yylex} can use these symbolic names like all others.  In this case, the use of the literal string tokens in the grammar file has no effect on {\f1{}yylex}.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}{\f1{}yylex} can find the multi-character token in the {\f1{}yytname} table.  The index of the token in the table is the token type's code.  The name of a multi-character token is recorded in {\f1{}yytname} with a double-quote, the token's characters, and another double-quote.  The token's characters are not escaped in any way; they appear verbatim in the contents of the string in the table.\par
\par
\pard\li720{}Here's code for looking up a token in {\f1{}yytname}, assuming that the characters of the token are stored in {\f1{}token_buffer}.\par
\par
{\pard\keep\li1440\f1{}for (i = 0; i < YYNTOKENS; i++)\line
  \'7B\line
    if (yytname[i] != 0\line
        && yytname[i][0] == '"'\line
        && strncmp (yytname[i] + 1, token_buffer,\line
                    strlen (token_buffer))\line
        && yytname[i][strlen (token_buffer) + 1] == '"'\line
        && yytname[i][strlen (token_buffer) + 2] == 0)\line
      break;\line
  \'7D\par
\pard\li720\f0{}}\par
\pard\li720{}The {\f1{}yytname} table is generated only if you use the {\f1{}%token_table} declaration.  See {\uldb Decl Summary}{\v Decl_Summary}.\par
\pard{}}\par
\page\pard Node: {\b Token Values}, \keepn Next: {\uldb Token Positions}{\v Token_Positions}, Prev: {\uldb Calling Convention}{\v Calling_Convention}, Up: {\uldb Lexical}{\v Lexical}\line
K{\footnote K Token Values}
#{\footnote Token_Values}
${\footnote \pard{}Semantic Values of Tokens}\par
\pard{\fs24\b Semantic Values of Tokens}\par
\par
\pard{}{K{\footnote K yylval}}In an ordinary (nonreentrant) parser, the semantic value of the token must be stored into the global variable {\f1{}yylval}.  When you are using just one data type for semantic values, {\f1{}yylval} has that type.  Thus, if the type is {\f1{}int} (the default), you might write this in {\f1{}yylex}:\par
\par
{{\pard\keep\li720\f1{}  ...\line
  yylval = value;  /* Put value onto Bison stack. */\line
  return INT;      /* Return the type of the token. */\line
  ...\par
\pard\keep\li720{}}}\par
\pard\f0{}When you are using multiple data types, {\f1{}yylval}'s type is a union made from the {\f1{}%union} declaration (see {\uldb The Collection of Value Types}{\v Union_Decl}).  So when you store a token's value, you must use the proper member of the union.  If the {\f1{}%union} declaration looks like this:\par
\par
{{\pard\keep\li720\f1{}%union \'7B\line
  int intval;\line
  double val;\line
  symrec *tptr;\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}then the code in {\f1{}yylex} might look like this:\par
\par
{{\pard\keep\li720\f1{}  ...\line
  yylval.intval = value; /* Put value onto Bison stack. */\line
  return INT;          /* Return the type of the token. */\line
  ...\par
\pard\keep\li720{}}}\par
\page\pard Node: {\b Token Positions}, \keepn Next: {\uldb Pure Calling}{\v Pure_Calling}, Prev: {\uldb Token Values}{\v Token_Values}, Up: {\uldb Lexical}{\v Lexical}\line
K{\footnote K Token Positions}
#{\footnote Token_Positions}
${\footnote \pard\f0{}Textual Positions of Tokens}\par
\pard{\fs24\b Textual Positions of Tokens}\par
\par
\pard{}{K{\footnote K yylloc}}If you are using the {\f1{}@{\i n}}-feature (see {\uldb Special Features for Use in Actions}{\v Action_Features}) in actions to keep track of the textual locations of tokens and groupings, then you must provide this information in {\f1{}yylex}.  The function {\f1{}yyparse} expects to find the textual location of a token just parsed in the global variable {\f1{}yylloc}.  So {\f1{}yylex} must store the proper data in that variable.  The value of {\f1{}yylloc} is a structure and you need only initialize the members that are going to be used by the actions.  The four members are called {\f1{}first_line}, {\f1{}first_column}, {\f1{}last_line} and {\f1{}last_column}.  Note that the use of this feature makes the parser noticeably slower.\par
\par
\pard{}{K{\footnote K YYLTYPE}}The data type of {\f1{}yylloc} has the name {\f1{}YYLTYPE}.\par
\par
\page\pard Node: {\b Pure Calling}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Token Positions}{\v Token_Positions}, Up: {\uldb Lexical}{\v Lexical}\line
K{\footnote K Pure Calling}
#{\footnote Pure_Calling}
${\footnote \pard{}Calling Conventions for Pure Parsers}\par
\pard{\fs24\b Calling Conventions for Pure Parsers}\par
\par
\pard{}When you use the Bison declaration {\f1{}%pure_parser} to request a pure, reentrant parser, the global communication variables {\f1{}yylval} and {\f1{}yylloc} cannot be used.  (See {\uldb A Pure (Reentrant) Parser}{\v Pure_Decl}.)  In such parsers the two global variables are replaced by pointers passed as arguments to {\f1{}yylex}.  You must declare them as shown here, and pass the information back by storing it through those pointers.\par
\par
{\pard\keep\li720\f1{}yylex (lvalp, llocp)\line
     YYSTYPE *lvalp;\line
     YYLTYPE *llocp;\line
\'7B\line
  ...\line
  *lvalp = value;  /* Put value onto Bison stack.  */\line
  return INT;      /* Return the type of the token.  */\line
  ...\line
\'7D\par
\pard\f0{}}\par
\pard{}If the grammar file does not use the {\f1{}@} constructs to refer to textual positions, then the type {\f1{}YYLTYPE} will not be defined.  In this case, omit the second argument; {\f1{}yylex} will be called with only one argument.\par
\par
\pard{}{K{\footnote K YYPARSE_PARAM}}If you use a reentrant parser, you can optionally pass additional parameter information to it in a reentrant way.  To do so, define the macro {\f1{}YYPARSE_PARAM} as a variable name.  This modifies the {\f1{}yyparse} function to accept one argument, of type {\f1{}void *}, with that name.\par
\par
\pard{}When you call {\f1{}yyparse}, pass the address of an object, casting the address to {\f1{}void *}.  The grammar actions can refer to the contents of the object by casting the pointer value back to its proper type and then dereferencing it.  Here's an example.  Write this in the parser:\par
\par
{\pard\keep\li720\f1{}%\'7B\line
struct parser_control\line
\'7B\line
  int nastiness;\line
  int randomness;\line
\'7D;\line
\line
#define YYPARSE_PARAM parm\line
%\'7D\par
\pard\f0{}}\par
\pard{}Then call the parser like this:\par
\par
{\pard\keep\li720\f1{}struct parser_control\line
\'7B\line
  int nastiness;\line
  int randomness;\line
\'7D;\line
\line
...\line
\line
\'7B\line
  struct parser_control foo;\line
  ...  /* Store proper data in {\f1{}foo}.  */\line
  value = yyparse ((void *) &foo);\line
  ...\line
\'7D\par
\pard\f0{}}\par
\pard{}In the grammar actions, use expressions like this to refer to the data:\par
\par
{\pard\keep\li720\f1{}((struct parser_control *) parm)->randomness\par
\pard\f0{}}\par
\pard{}{K{\footnote K YYLEX_PARAM}}If you wish to pass the additional parameter data to {\f1{}yylex}, define the macro {\f1{}YYLEX_PARAM} just like {\f1{}YYPARSE_PARAM}, as shown here:\par
\par
{\pard\keep\li720\f1{}%\'7B\line
struct parser_control\line
\'7B\line
  int nastiness;\line
  int randomness;\line
\'7D;\line
\line
#define YYPARSE_PARAM parm\line
#define YYLEX_PARAM parm\line
%\'7D\par
\pard\f0{}}\par
\pard{}You should then define {\f1{}yylex} to accept one additional argument--the value of {\f1{}parm}.  (This makes either two or three arguments in total, depending on whether an argument of type {\f1{}YYLTYPE} is passed.)  You can declare the argument as a pointer to the proper object type, or you can declare it as {\f1{}void *} and access the contents as shown above.\par
\par
\pard{}You can use {\f1{}%pure_parser} to request a reentrant parser without also using {\f1{}YYPARSE_PARAM}.  Then you should call {\f1{}yyparse} with no arguments, as usual.\par
\par
\page\pard Node: {\b Error Reporting}, \keepn Next: {\uldb Action Features}{\v Action_Features}, Prev: {\uldb Lexical}{\v Lexical}, Up: {\uldb Interface}{\v Interface}\line
K{\footnote K Error Reporting}
#{\footnote Error_Reporting}
${\footnote \pard{}The Error Reporting Function {\f1{}yyerror}}\par
\pard{\fs24\b The Error Reporting Function {\f1{}yyerror}}\par
\par
\pard{}{K{\footnote K error reporting function}}{K{\footnote K yyerror}}{K{\footnote K parse error}}{K{\footnote K syntax error}} The Bison parser detects a \'A2parse error\'A2 or \'A2syntax error\'A2 whenever it reads a token which cannot satisfy any syntax rule.  A action in the grammar can also explicitly proclaim an error, using the macro {\f1{}YYERROR} (see {\uldb Special Features for Use in Actions}{\v Action_Features}).\par
\par
\pard{}The Bison parser expects to report the error by calling an error reporting function named {\f1{}yyerror}, which you must supply.  It is called by {\f1{}yyparse} whenever a syntax error is found, and it receives one argument.  For a parse error, the string is normally {\f1{}"parse error"}.\par
\par
\pard{}{K{\footnote K YYERROR_VERBOSE}}If you define the macro {\f1{}YYERROR_VERBOSE} in the Bison declarations section (see {\uldb The Bison Declarations Section}{\v Bison_Declarations}), then Bison provides a more verbose and specific error message string instead of just plain {\f1{}"parse error"}.  It doesn't matter what definition you use for {\f1{}YYERROR_VERBOSE}, just whether you define it.\par
\par
\pard{}The parser can detect one other kind of error: stack overflow.  This happens when the input contains constructions that are very deeply nested.  It isn't likely you will encounter this, since the Bison parser extends its stack automatically up to a very large limit.  But if overflow happens, {\f1{}yyparse} calls {\f1{}yyerror} in the usual fashion, except that the argument string is {\f1{}"parser stack overflow"}.\par
\par
\pard{}The following definition suffices in simple programs:\par
\par
{{\pard\keep\li720\f1{}yyerror (s)\line
     char *s;\line
\'7B\par
\pard\keep\li720{}}{  fprintf (stderr, "%s\'5Cn", s);\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}After {\f1{}yyerror} returns to {\f1{}yyparse}, the latter will attempt error recovery if you have written suitable error recovery grammar rules (see {\uldb Error Recovery}{\v Error_Recovery}).  If recovery is impossible, {\f1{}yyparse} will immediately return 1.\par
\par
\pard{}{K{\footnote K yynerrs}}The variable {\f1{}yynerrs} contains the number of syntax errors encountered so far.  Normally this variable is global; but if you request a pure parser (see {\uldb A Pure (Reentrant) Parser}{\v Pure_Decl}) then it is a local variable which only the actions can access.\par
\par
\page\pard Node: {\b Action Features}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Error Reporting}{\v Error_Reporting}, Up: {\uldb Interface}{\v Interface}\line
K{\footnote K Action Features}
#{\footnote Action_Features}
${\footnote \pard{}Special Features for Use in Actions}\par
\pard{\fs24\b Special Features for Use in Actions}\par
\par
\pard{}{K{\footnote K summary, action features}}{K{\footnote K action features summary}} Here is a table of Bison constructs, variables and macros that are useful in actions.\par
\par
{\pard{}{\f1{}$$}\par
\pard\li720{}Acts like a variable that contains the semantic value for the grouping made by the current rule.  See {\uldb Actions}{\v Actions}.\par
\par
\pard{}{\f1{}${\i n}}\par
\pard\li720{}Acts like a variable that contains the semantic value for the {\i n}th component of the current rule.  See {\uldb Actions}{\v Actions}.\par
\par
\pard{}{\f1{}$<{\i typealt}>$}\par
\pard\li720{}Like {\f1{}$$} but specifies alternative {\i typealt} in the union specified by the {\f1{}%union} declaration.  See {\uldb Data Types of Values in Actions}{\v Action_Types}.\par
\par
\pard{}{\f1{}$<{\i typealt}>{\i n}}\par
\pard\li720{}Like {\f1{}${\i n}} but specifies alternative {\i typealt} in the union specified by the {\f1{}%union} declaration.  See {\uldb Data Types of Values in Actions}{\v Action_Types}.\par
\par
\pard{}{\f1{}YYABORT;}\par
\pard\li720{}Return immediately from {\f1{}yyparse}, indicating failure.  See {\uldb The Parser Function {\f1{}yyparse}}{\v Parser_Function}.\par
\par
\pard{}{\f1{}YYACCEPT;}\par
\pard\li720{}Return immediately from {\f1{}yyparse}, indicating success.  See {\uldb The Parser Function {\f1{}yyparse}}{\v Parser_Function}.\par
\par
\pard{}{\f1{}YYBACKUP ({\i token}, {\i value});}\par
\pard\li720{}{K{\footnote K YYBACKUP}}Unshift a token.  This macro is allowed only for rules that reduce a single value, and only when there is no look-ahead token.  It installs a look-ahead token with token type {\i token} and semantic value {\i value}; then it discards the value that was going to be reduced by this rule.\par
\par
\pard\li720{}If the macro is used when it is not valid, such as when there is a look-ahead token already, then it reports a syntax error with a message {\f1{}cannot back up} and performs ordinary error recovery.\par
\par
\pard\li720{}In either case, the rest of the action is not executed.\par
\par
\pard{}{\f1{}YYEMPTY}\par
\pard\li720{}{K{\footnote K YYEMPTY}}Value stored in {\f1{}yychar} when there is no look-ahead token.\par
\par
\pard{}{\f1{}YYERROR;}\par
\pard\li720{}{K{\footnote K YYERROR}}Cause an immediate syntax error.  This statement initiates error recovery just as if the parser itself had detected an error; however, it does not call {\f1{}yyerror}, and does not print any message.  If you want to print an error message, call {\f1{}yyerror} explicitly before the {\f1{}YYERROR;} statement.  See {\uldb Error Recovery}{\v Error_Recovery}.\par
\par
\pard{}{\f1{}YYRECOVERING}\par
\pard\li720{}This macro stands for an expression that has the value 1 when the parser is recovering from a syntax error, and 0 the rest of the time.  See {\uldb Error Recovery}{\v Error_Recovery}.\par
\par
\pard{}{\f1{}yychar}\par
\pard\li720{}Variable containing the current look-ahead token.  (In a pure parser, this is actually a local variable within {\f1{}yyparse}.)  When there is no look-ahead token, the value {\f1{}YYEMPTY} is stored in the variable.  See {\uldb Look-Ahead Tokens}{\v Look_Ahead}.\par
\par
\pard{}{\f1{}yyclearin;}\par
\pard\li720{}Discard the current look-ahead token.  This is useful primarily in error rules.  See {\uldb Error Recovery}{\v Error_Recovery}.\par
\par
\pard{}{\f1{}yyerrok;}\par
\pard\li720{}Resume generating error messages immediately for subsequent syntax errors.  This is useful primarily in error rules.  See {\uldb Error Recovery}{\v Error_Recovery}.\par
\par
\pard{}{\f1{}@{\i n}}\par
\pard\li720{}{K{\footnote K @{\i n}}}Acts like a structure variable containing information on the line numbers and column numbers of the {\i n}th component of the current rule.  The structure has four members, like this:\par
\par
{\pard\keep\li1440\f1{}struct \'7B\line
  int first_line, last_line;\line
  int first_column, last_column;\line
\'7D;\par
\pard\li720\f0{}}\par
\pard\li720{}Thus, to get the starting line number of the third component, you would use {\f1{}@3.first_line}.\par
\par
\pard\li720{}In order for the members of this structure to contain valid information, you must make {\f1{}yylex} supply this information about each token.  If you need only certain members, then {\f1{}yylex} need only fill in those members.\par
\par
\pard\li720{}The use of this feature makes the parser noticeably slower.\par
\pard{}}\par
\page\pard Node: {\b Algorithm}, \keepn Next: {\uldb Error Recovery}{\v Error_Recovery}, Prev: {\uldb Interface}{\v Interface}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Algorithm}
#{\footnote Algorithm}
${\footnote \pard{}The Bison Parser Algorithm}\par
\pard{\fs24\b The Bison Parser Algorithm}\par
\par
\pard{}{K{\footnote K Bison parser algorithm}}{K{\footnote K algorithm of parser}}{K{\footnote K shifting}}{K{\footnote K reduction}}{K{\footnote K parser stack}}{K{\footnote K stack, parser}} As Bison reads tokens, it pushes them onto a stack along with their semantic values.  The stack is called the \'A2parser stack\'A2.  Pushing a token is traditionally called \'A2shifting\'A2.\par
\par
\pard{}For example, suppose the infix calculator has read {\f1{}1 + 5 *}, with a {\f1{}3} to come.  The stack will have four elements, one for each token that was shifted.\par
\par
\pard{}But the stack does not always have an element for each token read.  When the last {\i n} tokens and groupings shifted match the components of a grammar rule, they can be combined according to that rule.  This is called \'A2reduction\'A2.  Those tokens and groupings are replaced on the stack by a single grouping whose symbol is the result (left hand side) of that rule.  Running the rule's action is part of the process of reduction, because this is what computes the semantic value of the resulting grouping.\par
\par
\pard{}For example, if the infix calculator's parser stack contains this:\par
\par
{\pard\keep\li720\f1{}1 + 5 * 3\par
\pard\f0{}}\par
\pard{}and the next input token is a newline character, then the last three elements can be reduced to 15 via the rule:\par
\par
{\pard\keep\li720\f1{}expr: expr '*' expr;\par
\pard\f0{}}\par
\pard{}Then the stack contains just these three elements:\par
\par
{\pard\keep\li720\f1{}1 + 15\par
\pard\f0{}}\par
\pard{}At this point, another reduction can be made, resulting in the single value 16.  Then the newline token can be shifted.\par
\par
\pard{}The parser tries, by shifts and reductions, to reduce the entire input down to a single grouping whose symbol is the grammar's start-symbol (see {\uldb Languages and Context-Free Grammars}{\v Language_and_Grammar}).\par
\par
\pard{}This kind of parser is known in the literature as a bottom-up parser.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Look-Ahead}{\v Look_Ahead}\tab Parser looks one token ahead when deciding what to do.\par
{\uldb Shift/Reduce}{\v Shift_Reduce}\tab Conflicts: when either shifting or reduction is valid.\par
{\uldb Precedence}{\v Precedence}\tab Operator precedence works by resolving conflicts.\par
{\uldb Contextual Precedence}{\v Contextual_Precedence}\tab When an operator's precedence depends on context.\par
{\uldb Parser States}{\v Parser_States}\tab The parser is a finite-state-machine with stack.\par
{\uldb Reduce/Reduce}{\v Reduce_Reduce}\tab When two rules are applicable in the same situation.\par
{\uldb Mystery Conflicts}{\v Mystery_Conflicts}\tab Reduce/reduce conflicts that look unjustified.\par
{\uldb Stack Overflow}{\v Stack_Overflow}\tab What happens when stack gets full.  How to avoid it.\par
\pard{}}\par
\page\pard Node: {\b Look-Ahead}, \keepn Next: {\uldb Shift/Reduce}{\v Shift_Reduce}, Prev: {\uldb }{\v }, Up: {\uldb Algorithm}{\v Algorithm}\line
K{\footnote K Look-Ahead}
#{\footnote Look_Ahead}
${\footnote \pard{}Look-Ahead Tokens}\par
\pard{\fs24\b Look-Ahead Tokens}\par
\par
\pard{}{K{\footnote K look-ahead token}} The Bison parser does {\i not} always reduce immediately as soon as the last {\i n} tokens and groupings match a rule.  This is because such a simple strategy is inadequate to handle most languages.  Instead, when a reduction is possible, the parser sometimes "looks ahead" at the next token in order to decide what to do.\par
\par
\pard{}When a token is read, it is not immediately shifted; first it becomes the \'A2look-ahead token\'A2, which is not on the stack.  Now the parser can perform one or more reductions of tokens and groupings on the stack, while the look-ahead token remains off to the side.  When no more reductions should take place, the look-ahead token is shifted onto the stack.  This does not mean that all possible reductions have been done; depending on the token type of the look-ahead token, some rules may choose to delay their application.\par
\par
\pard{}Here is a simple case where look-ahead is needed.  These three rules define expressions which contain binary addition operators and postfix unary factorial operators ({\f1{}!}), and allow parentheses for grouping.\par
\par
{{\pard\keep\li720\f1{}expr:     term '+' expr\line
        | term\line
        ;\par
\pard\keep\li720{}}\line
{term:     '(' expr ')'\line
        | term '!'\line
        | NUMBER\line
        ;\par
\pard\keep\li720{}}}\par
\pard\f0{}Suppose that the tokens {\f1{}1 + 2} have been read and shifted; what should be done?  If the following token is {\f1{})}, then the first three tokens must be reduced to form an {\f1{}expr}.  This is the only valid course, because shifting the {\f1{})} would produce a sequence of symbols {\f1{}term ')'}, and no rule allows this.\par
\par
\pard{}If the following token is {\f1{}!}, then it must be shifted immediately so that {\f1{}2 !} can be reduced to make a {\f1{}term}.  If instead the parser were to reduce before shifting, {\f1{}1 + 2} would become an {\f1{}expr}.  It would then be impossible to shift the {\f1{}!} because doing so would produce on the stack the sequence of symbols {\f1{}expr '!'}.  No rule allows that sequence.\par
\par
\pard{}{K{\footnote K yychar}}The current look-ahead token is stored in the variable {\f1{}yychar}.  See {\uldb Special Features for Use in Actions}{\v Action_Features}.\par
\par
\page\pard Node: {\b Shift/Reduce}, \keepn Next: {\uldb Precedence}{\v Precedence}, Prev: {\uldb Look-Ahead}{\v Look_Ahead}, Up: {\uldb Algorithm}{\v Algorithm}\line
K{\footnote K Shift/Reduce}
#{\footnote Shift_Reduce}
${\footnote \pard{}Shift/Reduce Conflicts}\par
\pard{\fs24\b Shift/Reduce Conflicts}\par
\par
\pard{}{K{\footnote K conflicts}}{K{\footnote K shift/reduce conflicts}}{K{\footnote K dangling {\f1{}else}}}{K{\footnote K {\f1{}else}, dangling}} Suppose we are parsing a language which has if-then and if-then-else statements, with a pair of rules like this:\par
\par
{{\pard\keep\li720\f1{}if_stmt:\line
          IF expr THEN stmt\line
        | IF expr THEN stmt ELSE stmt\line
        ;\par
\pard\keep\li720{}}}\par
\pard\f0{}Here we assume that {\f1{}IF}, {\f1{}THEN} and {\f1{}ELSE} are terminal symbols for specific keyword tokens.\par
\par
\pard{}When the {\f1{}ELSE} token is read and becomes the look-ahead token, the contents of the stack (assuming the input is valid) are just right for reduction by the first rule.  But it is also legitimate to shift the {\f1{}ELSE}, because that would lead to eventual reduction by the second rule.\par
\par
\pard{}This situation, where either a shift or a reduction would be valid, is called a \'A2shift/reduce conflict\'A2.  Bison is designed to resolve these conflicts by choosing to shift, unless otherwise directed by operator precedence declarations.  To see the reason for this, let's contrast it with the other alternative.\par
\par
\pard{}Since the parser prefers to shift the {\f1{}ELSE}, the result is to attach the else-clause to the innermost if-statement, making these two inputs equivalent:\par
\par
{\pard\keep\li720\f1{}if x then if y then win (); else lose;\line
\line
if x then do; if y then win (); else lose; end;\par
\pard\f0{}}\par
\pard{}But if the parser chose to reduce when possible rather than shift, the result would be to attach the else-clause to the outermost if-statement, making these two inputs equivalent:\par
\par
{\pard\keep\li720\f1{}if x then if y then win (); else lose;\line
\line
if x then do; if y then win (); end; else lose;\par
\pard\f0{}}\par
\pard{}The conflict exists because the grammar as written is ambiguous: either parsing of the simple nested if-statement is legitimate.  The established convention is that these ambiguities are resolved by attaching the else-clause to the innermost if-statement; this is what Bison accomplishes by choosing to shift rather than reduce.  (It would ideally be cleaner to write an unambiguous grammar, but that is very hard to do in this case.)  This particular ambiguity was first encountered in the specifications of Algol 60 and is called the "dangling {\f1{}else}" ambiguity.\par
\par
\pard{}To avoid warnings from Bison about predictable, legitimate shift/reduce conflicts, use the {\f1{}%expect {\i n}} declaration.  There will be no warning as long as the number of shift/reduce conflicts is exactly {\i n}.  See {\uldb Suppressing Conflict Warnings}{\v Expect_Decl}.\par
\par
\pard{}The definition of {\f1{}if_stmt} above is solely to blame for the conflict, but the conflict does not actually appear without additional rules.  Here is a complete Bison input file that actually manifests the conflict:\par
\par
{{\pard\keep\li720\f1{}%token IF THEN ELSE variable\line
%%\par
\pard\keep\li720{}}{stmt:     expr\line
        | if_stmt\line
        ;\par
\pard\keep\li720{}}\line
{if_stmt:\line
          IF expr THEN stmt\line
        | IF expr THEN stmt ELSE stmt\line
        ;\par
\pard\keep\li720{}}\line
expr:     variable\line
        ;\par
\pard\f0{}}\par
\page\pard Node: {\b Precedence}, \keepn Next: {\uldb Contextual Precedence}{\v Contextual_Precedence}, Prev: {\uldb Shift/Reduce}{\v Shift_Reduce}, Up: {\uldb Algorithm}{\v Algorithm}\line
K{\footnote K Precedence}
#{\footnote Precedence}
${\footnote \pard{}Operator Precedence}\par
\pard{\fs24\b Operator Precedence}\par
\par
\pard{}{K{\footnote K operator precedence}}{K{\footnote K precedence of operators}} Another situation where shift/reduce conflicts appear is in arithmetic expressions.  Here shifting is not always the preferred resolution; the Bison declarations for operator precedence allow you to specify when to shift and when to reduce.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Why Precedence}{\v Why_Precedence}\tab An example showing why precedence is needed.\par
{\uldb Using Precedence}{\v Using_Precedence}\tab How to specify precedence in Bison grammars.\par
{\uldb Precedence Examples}{\v Precedence_Examples}\tab How these features are used in the previous example.\par
{\uldb How Precedence}{\v How_Precedence}\tab How they work.\par
\pard{}}\par
\page\pard Node: {\b Why Precedence}, \keepn Next: {\uldb Using Precedence}{\v Using_Precedence}, Prev: {\uldb }{\v }, Up: {\uldb Precedence}{\v Precedence}\line
K{\footnote K Why Precedence}
#{\footnote Why_Precedence}
${\footnote \pard{}When Precedence is Needed}\par
\pard{\fs24\b When Precedence is Needed}\par
\par
\pard{}Consider the following ambiguous grammar fragment (ambiguous because the input {\f1{}1 - 2 * 3} can be parsed in two different ways):\par
\par
{{\pard\keep\li720\f1{}expr:     expr '-' expr\line
        | expr '*' expr\line
        | expr '<' expr\line
        | '(' expr ')'\line
        ...\line
        ;\par
\pard\keep\li720{}}}\par
\pard\f0{}Suppose the parser has seen the tokens {\f1{}1}, {\f1{}-} and {\f1{}2}; should it reduce them via the rule for the addition operator?  It depends on the next token.  Of course, if the next token is {\f1{})}, we must reduce; shifting is invalid because no single rule can reduce the token sequence {\f1{}- 2 )} or anything starting with that.  But if the next token is {\f1{}*} or {\f1{}<}, we have a choice: either shifting or reduction would allow the parse to complete, but with different results.\par
\par
\pard{}To decide which one Bison should do, we must consider the results.  If the next operator token {\i op} is shifted, then it must be reduced first in order to permit another opportunity to reduce the sum.  The result is (in effect) {\f1{}1 - (2 {\i op} 3)}.  On the other hand, if the subtraction is reduced before shifting {\i op}, the result is {\f1{}(1 - 2) {\i op} 3}.  Clearly, then, the choice of shift or reduce should depend on the relative precedence of the operators {\f1{}-} and {\i op}: {\f1{}*} should be shifted first, but not {\f1{}<}.\par
\par
\pard{}{K{\footnote K associativity}}What about input such as {\f1{}1 - 2 - 5}; should this be {\f1{}(1 - 2) - 5} or should it be {\f1{}1 - (2 - 5)}?  For most operators we prefer the former, which is called \'A2left association\'A2.  The latter alternative, \'A2right association\'A2, is desirable for assignment operators.  The choice of left or right association is a matter of whether the parser chooses to shift or reduce when the stack contains {\f1{}1 - 2} and the look-ahead token is {\f1{}-}: shifting makes right-associativity.\par
\par
\page\pard Node: {\b Using Precedence}, \keepn Next: {\uldb Precedence Examples}{\v Precedence_Examples}, Prev: {\uldb Why Precedence}{\v Why_Precedence}, Up: {\uldb Precedence}{\v Precedence}\line
K{\footnote K Using Precedence}
#{\footnote Using_Precedence}
${\footnote \pard{}Specifying Operator Precedence}\par
\pard{\fs24\b Specifying Operator Precedence}\par
\par
\pard{}{K{\footnote K %left}}{K{\footnote K %right}}{K{\footnote K %nonassoc}} Bison allows you to specify these choices with the operator precedence declarations {\f1{}%left} and {\f1{}%right}.  Each such declaration contains a list of tokens, which are operators whose precedence and associativity is being declared.  The {\f1{}%left} declaration makes all those operators left-associative and the {\f1{}%right} declaration makes them right-associative.  A third alternative is {\f1{}%nonassoc}, which declares that it is a syntax error to find the same operator twice "in a row".\par
\par
\pard{}The relative precedence of different operators is controlled by the order in which they are declared.  The first {\f1{}%left} or {\f1{}%right} declaration in the file declares the operators whose precedence is lowest, the next such declaration declares the operators whose precedence is a little higher, and so on.\par
\par
\page\pard Node: {\b Precedence Examples}, \keepn Next: {\uldb How Precedence}{\v How_Precedence}, Prev: {\uldb Using Precedence}{\v Using_Precedence}, Up: {\uldb Precedence}{\v Precedence}\line
K{\footnote K Precedence Examples}
#{\footnote Precedence_Examples}
${\footnote \pard{}Precedence Examples}\par
\pard{\fs24\b Precedence Examples}\par
\par
\pard{}In our example, we would want the following declarations:\par
\par
{\pard\keep\li720\f1{}%left '<'\line
%left '-'\line
%left '*'\par
\pard\f0{}}\par
\pard{}In a more complete example, which supports other operators as well, we would declare them in groups of equal precedence.  For example, {\f1{}'+'} is declared with {\f1{}'-'}:\par
\par
{\pard\keep\li720\f1{}%left '<' '>' '=' NE LE GE\line
%left '+' '-'\line
%left '*' '/'\par
\pard\f0{}}\par
\pard{}(Here {\f1{}NE} and so on stand for the operators for "not equal" and so on.  We assume that these tokens are more than one character long and therefore are represented by names, not character literals.)\par
\par
\page\pard Node: {\b How Precedence}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Precedence Examples}{\v Precedence_Examples}, Up: {\uldb Precedence}{\v Precedence}\line
K{\footnote K How Precedence}
#{\footnote How_Precedence}
${\footnote \pard{}How Precedence Works}\par
\pard{\fs24\b How Precedence Works}\par
\par
\pard{}The first effect of the precedence declarations is to assign precedence levels to the terminal symbols declared.  The second effect is to assign precedence levels to certain rules: each rule gets its precedence from the last terminal symbol mentioned in the components.  (You can also specify explicitly the precedence of a rule.  See {\uldb Context-Dependent Precedence}{\v Contextual_Precedence}.)\par
\par
\pard{}Finally, the resolution of conflicts works by comparing the precedence of the rule being considered with that of the look-ahead token.  If the token's precedence is higher, the choice is to shift.  If the rule's precedence is higher, the choice is to reduce.  If they have equal precedence, the choice is made based on the associativity of that precedence level.  The verbose output file made by {\f1{}-v} (see {\uldb Invoking Bison}{\v Invocation}) says how each conflict was resolved.\par
\par
\pard{}Not all rules and not all tokens have precedence.  If either the rule or the look-ahead token has no precedence, then the default is to shift.\par
\par
\page\pard Node: {\b Contextual Precedence}, \keepn Next: {\uldb Parser States}{\v Parser_States}, Prev: {\uldb Precedence}{\v Precedence}, Up: {\uldb Algorithm}{\v Algorithm}\line
K{\footnote K Contextual Precedence}
#{\footnote Contextual_Precedence}
${\footnote \pard{}Context-Dependent Precedence}\par
\pard{\fs24\b Context-Dependent Precedence}\par
\par
\pard{}{K{\footnote K context-dependent precedence}}{K{\footnote K unary operator precedence}}{K{\footnote K precedence, context-dependent}}{K{\footnote K precedence, unary operator}}{K{\footnote K %prec}} Often the precedence of an operator depends on the context.  This sounds outlandish at first, but it is really very common.  For example, a minus sign typically has a very high precedence as a unary operator, and a somewhat lower precedence (lower than multiplication) as a binary operator.\par
\par
\pard{}The Bison precedence declarations, {\f1{}%left}, {\f1{}%right} and {\f1{}%nonassoc}, can only be used once for a given token; so a token has only one precedence declared in this way.  For context-dependent precedence, you need to use an additional mechanism: the {\f1{}%prec} modifier for rules.\par
\par
\pard{}The {\f1{}%prec} modifier declares the precedence of a particular rule by specifying a terminal symbol whose precedence should be used for that rule.  It's not necessary for that symbol to appear otherwise in the rule.  The modifier's syntax is:\par
\par
{\pard\keep\li720\f1{}%prec {\i terminal-symbol}\par
\pard\f0{}}\par
\pard{}and it is written after the components of the rule.  Its effect is to assign the rule the precedence of {\i terminal-symbol}, overriding the precedence that would be deduced for it in the ordinary way.  The altered rule precedence then affects how conflicts involving that rule are resolved (see {\uldb Operator Precedence}{\v Precedence}).\par
\par
\pard{}Here is how {\f1{}%prec} solves the problem of unary minus.  First, declare a precedence for a fictitious terminal symbol named {\f1{}UMINUS}.  There are no tokens of this type, but the symbol serves to stand for its precedence:\par
\par
{\pard\keep\li720\f1{}...\line
%left '+' '-'\line
%left '*'\line
%left UMINUS\par
\pard\f0{}}\par
\pard{}Now the precedence of {\f1{}UMINUS} can be used in specific rules:\par
\par
{{\pard\keep\li720\f1{}exp:    ...\line
        | exp '-' exp\line
        ...\line
        | '-' exp %prec UMINUS\par
\pard\keep\li720{}}}\par
\page\pard Node: {\b Parser States}, \keepn Next: {\uldb Reduce/Reduce}{\v Reduce_Reduce}, Prev: {\uldb Contextual Precedence}{\v Contextual_Precedence}, Up: {\uldb Algorithm}{\v Algorithm}\line
K{\footnote K Parser States}
#{\footnote Parser_States}
${\footnote \pard\f0{}Parser States}\par
\pard{\fs24\b Parser States}\par
\par
\pard{}{K{\footnote K finite-state machine}}{K{\footnote K parser state}}{K{\footnote K state (of parser)}} The function {\f1{}yyparse} is implemented using a finite-state machine.  The values pushed on the parser stack are not simply token type codes; they represent the entire sequence of terminal and nonterminal symbols at or near the top of the stack.  The current state collects all the information about previous input which is relevant to deciding what to do next.\par
\par
\pard{}Each time a look-ahead token is read, the current parser state together with the type of look-ahead token are looked up in a table.  This table entry can say, "Shift the look-ahead token."  In this case, it also specifies the new parser state, which is pushed onto the top of the parser stack.  Or it can say, "Reduce using rule number {\i n}."  This means that a certain number of tokens or groupings are taken off the top of the stack, and replaced by one grouping.  In other words, that number of states are popped from the stack, and one new state is pushed.\par
\par
\pard{}There is one other alternative: the table can say that the look-ahead token is erroneous in the current state.  This causes error processing to begin (see {\uldb Error Recovery}{\v Error_Recovery}).\par
\par
\page\pard Node: {\b Reduce/Reduce}, \keepn Next: {\uldb Mystery Conflicts}{\v Mystery_Conflicts}, Prev: {\uldb Parser States}{\v Parser_States}, Up: {\uldb Algorithm}{\v Algorithm}\line
K{\footnote K Reduce/Reduce}
#{\footnote Reduce_Reduce}
${\footnote \pard{}Reduce/Reduce Conflicts}\par
\pard{\fs24\b Reduce/Reduce Conflicts}\par
\par
\pard{}{K{\footnote K reduce/reduce conflict}}{K{\footnote K conflicts, reduce/reduce}} A reduce/reduce conflict occurs if there are two or more rules that apply to the same sequence of input.  This usually indicates a serious error in the grammar.\par
\par
\pard{}For example, here is an erroneous attempt to define a sequence of zero or more {\f1{}word} groupings.\par
\par
{\pard\keep\li720\f1{}sequence: /* empty */\line
                \'7B printf ("empty sequence\'5Cn"); \'7D\line
        | maybeword\line
        | sequence word\line
                \'7B printf ("added word %s\'5Cn", $2); \'7D\line
        ;\line
\line
maybeword: /* empty */\line
                \'7B printf ("empty maybeword\'5Cn"); \'7D\line
        | word\line
                \'7B printf ("single word %s\'5Cn", $1); \'7D\line
        ;\par
\pard\f0{}}\par
\pard{}The error is an ambiguity: there is more than one way to parse a single {\f1{}word} into a {\f1{}sequence}.  It could be reduced to a {\f1{}maybeword} and then into a {\f1{}sequence} via the second rule.  Alternatively, nothing-at-all could be reduced into a {\f1{}sequence} via the first rule, and this could be combined with the {\f1{}word} using the third rule for {\f1{}sequence}.\par
\par
\pard{}There is also more than one way to reduce nothing-at-all into a {\f1{}sequence}.  This can be done directly via the first rule, or indirectly via {\f1{}maybeword} and then the second rule.\par
\par
\pard{}You might think that this is a distinction without a difference, because it does not change whether any particular input is valid or not.  But it does affect which actions are run.  One parsing order runs the second rule's action; the other runs the first rule's action and the third rule's action.  In this example, the output of the program changes.\par
\par
\pard{}Bison resolves a reduce/reduce conflict by choosing to use the rule that appears first in the grammar, but it is very risky to rely on this.  Every reduce/reduce conflict must be studied and usually eliminated.  Here is the proper way to define {\f1{}sequence}:\par
\par
{\pard\keep\li720\f1{}sequence: /* empty */\line
                \'7B printf ("empty sequence\'5Cn"); \'7D\line
        | sequence word\line
                \'7B printf ("added word %s\'5Cn", $2); \'7D\line
        ;\par
\pard\f0{}}\par
\pard{}Here is another common error that yields a reduce/reduce conflict:\par
\par
{\pard\keep\li720\f1{}sequence: /* empty */\line
        | sequence words\line
        | sequence redirects\line
        ;\line
\line
words:    /* empty */\line
        | words word\line
        ;\line
\line
redirects:/* empty */\line
        | redirects redirect\line
        ;\par
\pard\f0{}}\par
\pard{}The intention here is to define a sequence which can contain either {\f1{}word} or {\f1{}redirect} groupings.  The individual definitions of {\f1{}sequence}, {\f1{}words} and {\f1{}redirects} are error-free, but the three together make a subtle ambiguity: even an empty input can be parsed in infinitely many ways!\par
\par
\pard{}Consider: nothing-at-all could be a {\f1{}words}.  Or it could be two {\f1{}words} in a row, or three, or any number.  It could equally well be a {\f1{}redirects}, or two, or any number.  Or it could be a {\f1{}words} followed by three {\f1{}redirects} and another {\f1{}words}.  And so on.\par
\par
\pard{}Here are two ways to correct these rules.  First, to make it a single level of sequence:\par
\par
{\pard\keep\li720\f1{}sequence: /* empty */\line
        | sequence word\line
        | sequence redirect\line
        ;\par
\pard\f0{}}\par
\pard{}Second, to prevent either a {\f1{}words} or a {\f1{}redirects} from being empty:\par
\par
{\pard\keep\li720\f1{}sequence: /* empty */\line
        | sequence words\line
        | sequence redirects\line
        ;\line
\line
words:    word\line
        | words word\line
        ;\line
\line
redirects:redirect\line
        | redirects redirect\line
        ;\par
\pard\f0{}}\par
\page\pard Node: {\b Mystery Conflicts}, \keepn Next: {\uldb Stack Overflow}{\v Stack_Overflow}, Prev: {\uldb Reduce/Reduce}{\v Reduce_Reduce}, Up: {\uldb Algorithm}{\v Algorithm}\line
K{\footnote K Mystery Conflicts}
#{\footnote Mystery_Conflicts}
${\footnote \pard{}Mysterious Reduce/Reduce Conflicts}\par
\pard{\fs24\b Mysterious Reduce/Reduce Conflicts}\par
\par
\pard{}Sometimes reduce/reduce conflicts can occur that don't look warranted.  Here is an example:\par
\par
{{\pard\keep\li720\f1{}%token ID\line
\line
%%\line
def:    param_spec return_spec ','\line
        ;\line
param_spec:\line
             type\line
        |    name_list ':' type\line
        ;\par
\pard\keep\li720{}}{return_spec:\line
             type\line
        |    name ':' type\line
        ;\par
\pard\keep\li720{}}{type:        ID\line
        ;\par
\pard\keep\li720{}}{name:        ID\line
        ;\line
name_list:\line
             name\line
        |    name ',' name_list\line
        ;\par
\pard\keep\li720{}}}\par
\pard\f0{}It would seem that this grammar can be parsed with only a single token of look-ahead: when a {\f1{}param_spec} is being read, an {\f1{}ID} is a {\f1{}name} if a comma or colon follows, or a {\f1{}type} if another {\f1{}ID} follows.  In other words, this grammar is LR(1).\par
\par
\pard{}{K{\footnote K LR(1)}}{K{\footnote K LALR(1)}}However, Bison, like most parser generators, cannot actually handle all LR(1) grammars.  In this grammar, two contexts, that after an {\f1{}ID} at the beginning of a {\f1{}param_spec} and likewise at the beginning of a {\f1{}return_spec}, are similar enough that Bison assumes they are the same.  They appear similar because the same set of rules would be active--the rule for reducing to a {\f1{}name} and that for reducing to a {\f1{}type}.  Bison is unable to determine at that stage of processing that the rules would require different look-ahead tokens in the two contexts, so it makes a single parser state for them both.  Combining the two contexts causes a conflict later.  In parser terminology, this occurrence means that the grammar is not LALR(1).\par
\par
\pard{}In general, it is better to fix deficiencies than to document them.  But this particular deficiency is intrinsically hard to fix; parser generators that can handle LR(1) grammars are hard to write and tend to produce parsers that are very large.  In practice, Bison is more useful as it is now.\par
\par
\pard{}When the problem arises, you can often fix it by identifying the two parser states that are being confused, and adding something to make them look distinct.  In the above example, adding one rule to {\f1{}return_spec} as follows makes the problem go away:\par
\par
{{\pard\keep\li720\f1{}%token BOGUS\line
...\line
%%\line
...\line
return_spec:\line
             type\line
        |    name ':' type\line
        /* This rule is never used.  */\line
        |    ID BOGUS\line
        ;\par
\pard\keep\li720{}}}\par
\pard\f0{}This corrects the problem because it introduces the possibility of an additional active rule in the context after the {\f1{}ID} at the beginning of {\f1{}return_spec}.  This rule is not active in the corresponding context in a {\f1{}param_spec}, so the two contexts receive distinct parser states.  As long as the token {\f1{}BOGUS} is never generated by {\f1{}yylex}, the added rule cannot alter the way actual input is parsed.\par
\par
\pard{}In this particular example, there is another way to solve the problem: rewrite the rule for {\f1{}return_spec} to use {\f1{}ID} directly instead of via {\f1{}name}.  This also causes the two confusing contexts to have different sets of active rules, because the one for {\f1{}return_spec} activates the altered rule for {\f1{}return_spec} rather than the one for {\f1{}name}.\par
\par
{\pard\keep\li720\f1{}param_spec:\line
             type\line
        |    name_list ':' type\line
        ;\line
return_spec:\line
             type\line
        |    ID ':' type\line
        ;\par
\pard\f0{}}\par
\page\pard Node: {\b Stack Overflow}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Mystery Conflicts}{\v Mystery_Conflicts}, Up: {\uldb Algorithm}{\v Algorithm}\line
K{\footnote K Stack Overflow}
#{\footnote Stack_Overflow}
${\footnote \pard{}Stack Overflow, and How to Avoid It}\par
\pard{\fs24\b Stack Overflow, and How to Avoid It}\par
\par
\pard{}{K{\footnote K stack overflow}}{K{\footnote K parser stack overflow}}{K{\footnote K overflow of parser stack}} The Bison parser stack can overflow if too many tokens are shifted and not reduced.  When this happens, the parser function {\f1{}yyparse} returns a nonzero value, pausing only to call {\f1{}yyerror} to report the overflow.\par
\par
\pard{}{K{\footnote K YYMAXDEPTH}}By defining the macro {\f1{}YYMAXDEPTH}, you can control how deep the parser stack can become before a stack overflow occurs.  Define the macro with a value that is an integer.  This value is the maximum number of tokens that can be shifted (and not reduced) before overflow.  It must be a constant expression whose value is known at compile time.\par
\par
\pard{}The stack space allowed is not necessarily allocated.  If you specify a large value for {\f1{}YYMAXDEPTH}, the parser actually allocates a small stack at first, and then makes it bigger by stages as needed.  This increasing allocation happens automatically and silently.  Therefore, you do not need to make {\f1{}YYMAXDEPTH} painfully small merely to save space for ordinary inputs that do not need much stack.\par
\par
\pard{}{K{\footnote K default stack limit}}The default value of {\f1{}YYMAXDEPTH}, if you do not define it, is 10000.\par
\par
\pard{}{K{\footnote K YYINITDEPTH}}You can control how much stack is allocated initially by defining the macro {\f1{}YYINITDEPTH}.  This value too must be a compile-time constant integer.  The default is 200.\par
\par
\page\pard Node: {\b Error Recovery}, \keepn Next: {\uldb Context Dependency}{\v Context_Dependency}, Prev: {\uldb Algorithm}{\v Algorithm}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Error Recovery}
#{\footnote Error_Recovery}
${\footnote \pard{}Error Recovery}\par
\pard{\fs24\b Error Recovery}\par
\par
\pard{}{K{\footnote K error recovery}}{K{\footnote K recovery from errors}} It is not usually acceptable to have a program terminate on a parse error.  For example, a compiler should recover sufficiently to parse the rest of the input file and check it for errors; a calculator should accept another expression.\par
\par
\pard{}In a simple interactive command parser where each input is one line, it may be sufficient to allow {\f1{}yyparse} to return 1 on error and have the caller ignore the rest of the input line when that happens (and then call {\f1{}yyparse} again).  But this is inadequate for a compiler, because it forgets all the syntactic context leading up to the error.  A syntax error deep within a function in the compiler input should not cause the compiler to treat the following line like the beginning of a source file.\par
\par
\pard{}{K{\footnote K error}}You can define how to recover from a syntax error by writing rules to recognize the special token {\f1{}error}.  This is a terminal symbol that is always defined (you need not declare it) and reserved for error handling.  The Bison parser generates an {\f1{}error} token whenever a syntax error happens; if you have provided a rule to recognize this token in the current context, the parse can continue.\par
\par
\pard{}For example:\par
\par
{\pard\keep\li720\f1{}stmnts:  /* empty string */\line
        | stmnts '\'5Cn'\line
        | stmnts exp '\'5Cn'\line
        | stmnts error '\'5Cn'\par
\pard\f0{}}\par
\pard{}The fourth rule in this example says that an error followed by a newline makes a valid addition to any {\f1{}stmnts}.\par
\par
\pard{}What happens if a syntax error occurs in the middle of an {\f1{}exp}?  The error recovery rule, interpreted strictly, applies to the precise sequence of a {\f1{}stmnts}, an {\f1{}error} and a newline.  If an error occurs in the middle of an {\f1{}exp}, there will probably be some additional tokens and subexpressions on the stack after the last {\f1{}stmnts}, and there will be tokens to read before the next newline.  So the rule is not applicable in the ordinary way.\par
\par
\pard{}But Bison can force the situation to fit the rule, by discarding part of the semantic context and part of the input.  First it discards states and objects from the stack until it gets back to a state in which the {\f1{}error} token is acceptable.  (This means that the subexpressions already parsed are discarded, back to the last complete {\f1{}stmnts}.)  At this point the {\f1{}error} token can be shifted.  Then, if the old look-ahead token is not acceptable to be shifted next, the parser reads tokens and discards them until it finds a token which is acceptable.  In this example, Bison reads and discards input until the next newline so that the fourth rule can apply.\par
\par
\pard{}The choice of error rules in the grammar is a choice of strategies for error recovery.  A simple and useful strategy is simply to skip the rest of the current input line or current statement if an error is detected:\par
\par
{\pard\keep\li720\f1{}stmnt: error ';'  /* on error, skip until ';' is read */\par
\pard\f0{}}\par
\pard{}It is also useful to recover to the matching close-delimiter of an opening-delimiter that has already been parsed.  Otherwise the close-delimiter will probably appear to be unmatched, and generate another, spurious error message:\par
\par
{\pard\keep\li720\f1{}primary:  '(' expr ')'\line
        | '(' error ')'\line
        ...\line
        ;\par
\pard\f0{}}\par
\pard{}Error recovery strategies are necessarily guesses.  When they guess wrong, one syntax error often leads to another.  In the above example, the error recovery rule guesses that an error is due to bad input within one {\f1{}stmnt}.  Suppose that instead a spurious semicolon is inserted in the middle of a valid {\f1{}stmnt}.  After the error recovery rule recovers from the first error, another syntax error will be found straightaway, since the text following the spurious semicolon is also an invalid {\f1{}stmnt}.\par
\par
\pard{}To prevent an outpouring of error messages, the parser will output no error message for another syntax error that happens shortly after the first; only after three consecutive input tokens have been successfully shifted will error messages resume.\par
\par
\pard{}Note that rules which accept the {\f1{}error} token may have actions, just as any other rules can.\par
\par
\pard{}{K{\footnote K yyerrok}}You can make error messages resume immediately by using the macro {\f1{}yyerrok} in an action.  If you do this in the error rule's action, no error messages will be suppressed.  This macro requires no arguments; {\f1{}yyerrok;} is a valid C statement.\par
\par
\pard{}{K{\footnote K yyclearin}}The previous look-ahead token is reanalyzed immediately after an error.  If this is unacceptable, then the macro {\f1{}yyclearin} may be used to clear this token.  Write the statement {\f1{}yyclearin;} in the error rule's action.\par
\par
\pard{}For example, suppose that on a parse error, an error handling routine is called that advances the input stream to some point where parsing should once again commence.  The next symbol returned by the lexical scanner is probably correct.  The previous look-ahead token ought to be discarded with {\f1{}yyclearin;}.\par
\par
\pard{}{K{\footnote K YYRECOVERING}}The macro {\f1{}YYRECOVERING} stands for an expression that has the value 1 when the parser is recovering from a syntax error, and 0 the rest of the time.  A value of 1 indicates that error messages are currently suppressed for new syntax errors.\par
\par
\page\pard Node: {\b Context Dependency}, \keepn Next: {\uldb Debugging}{\v Debugging}, Prev: {\uldb Error Recovery}{\v Error_Recovery}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Context Dependency}
#{\footnote Context_Dependency}
${\footnote \pard{}Handling Context Dependencies}\par
\pard{\fs24\b Handling Context Dependencies}\par
\par
\pard{}The Bison paradigm is to parse tokens first, then group them into larger syntactic units.  In many languages, the meaning of a token is affected by its context.  Although this violates the Bison paradigm, certain techniques (known as \'A2kludges\'A2) may enable you to write Bison parsers for such languages.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Semantic Tokens}{\v Semantic_Tokens}\tab Token parsing can depend on the semantic context.\par
{\uldb Lexical Tie-ins}{\v Lexical_Tie_ins}\tab Token parsing can depend on the syntactic context.\par
{\uldb Tie-in Recovery}{\v Tie_in_Recovery}\tab Lexical tie-ins have implications for how error recovery rules must be written.\par
\pard{}}\par
\pard{}(Actually, "kludge" means any technique that gets its job done but is neither clean nor robust.)\par
\par
\page\pard Node: {\b Semantic Tokens}, \keepn Next: {\uldb Lexical Tie-ins}{\v Lexical_Tie_ins}, Prev: {\uldb }{\v }, Up: {\uldb Context Dependency}{\v Context_Dependency}\line
K{\footnote K Semantic Tokens}
#{\footnote Semantic_Tokens}
${\footnote \pard{}Semantic Info in Token Types}\par
\pard{\fs24\b Semantic Info in Token Types}\par
\par
\pard{}The C language has a context dependency: the way an identifier is used depends on what its current meaning is.  For example, consider this:\par
\par
{\pard\keep\li720\f1{}foo (x);\par
\pard\f0{}}\par
\pard{}This looks like a function call statement, but if {\f1{}foo} is a typedef name, then this is actually a declaration of {\f1{}x}.  How can a Bison parser for C decide how to parse this input?\par
\par
\pard{}The method used in GNU C is to have two different token types, {\f1{}IDENTIFIER} and {\f1{}TYPENAME}.  When {\f1{}yylex} finds an identifier, it looks up the current declaration of the identifier in order to decide which token type to return: {\f1{}TYPENAME} if the identifier is declared as a typedef, {\f1{}IDENTIFIER} otherwise.\par
\par
\pard{}The grammar rules can then express the context dependency by the choice of token type to recognize.  {\f1{}IDENTIFIER} is accepted as an expression, but {\f1{}TYPENAME} is not.  {\f1{}TYPENAME} can start a declaration, but {\f1{}IDENTIFIER} cannot.  In contexts where the meaning of the identifier is {\i not} significant, such as in declarations that can shadow a typedef name, either {\f1{}TYPENAME} or {\f1{}IDENTIFIER} is accepted--there is one rule for each of the two token types.\par
\par
\pard{}This technique is simple to use if the decision of which kinds of identifiers to allow is made at a place close to where the identifier is parsed.  But in C this is not always so: C allows a declaration to redeclare a typedef name provided an explicit type has been specified earlier:\par
\par
{\pard\keep\li720\f1{}typedef int foo, bar, lose;\line
static foo (bar);        /* redeclare {\f1{}bar} as static variable */\line
static int foo (lose);   /* redeclare {\f1{}foo} as function */\par
\pard\f0{}}\par
\pard{}Unfortunately, the name being declared is separated from the declaration construct itself by a complicated syntactic structure--the "declarator".\par
\par
\pard{}As a result, the part of Bison parser for C needs to be duplicated, with all the nonterminal names changed: once for parsing a declaration in which a typedef name can be redefined, and once for parsing a declaration in which that can't be done.  Here is a part of the duplication, with actions omitted for brevity:\par
\par
{\pard\keep\li720\f1{}initdcl:\line
          declarator maybeasm '='\line
          init\line
        | declarator maybeasm\line
        ;\line
\line
notype_initdcl:\line
          notype_declarator maybeasm '='\line
          init\line
        | notype_declarator maybeasm\line
        ;\par
\pard\f0{}}\par
\pard{}Here {\f1{}initdcl} can redeclare a typedef name, but {\f1{}notype_initdcl} cannot.  The distinction between {\f1{}declarator} and {\f1{}notype_declarator} is the same sort of thing.\par
\par
\pard{}There is some similarity between this technique and a lexical tie-in (described next), in that information which alters the lexical analysis is changed during parsing by other parts of the program.  The difference is here the information is global, and is used for other purposes in the program.  A true lexical tie-in has a special-purpose flag controlled by the syntactic context.\par
\par
\page\pard Node: {\b Lexical Tie-ins}, \keepn Next: {\uldb Tie-in Recovery}{\v Tie_in_Recovery}, Prev: {\uldb Semantic Tokens}{\v Semantic_Tokens}, Up: {\uldb Context Dependency}{\v Context_Dependency}\line
K{\footnote K Lexical Tie-ins}
#{\footnote Lexical_Tie_ins}
${\footnote \pard{}Lexical Tie-ins}\par
\pard{\fs24\b Lexical Tie-ins}\par
\par
\pard{}{K{\footnote K lexical tie-in}} One way to handle context-dependency is the \'A2lexical tie-in\'A2: a flag which is set by Bison actions, whose purpose is to alter the way tokens are parsed.\par
\par
\pard{}For example, suppose we have a language vaguely like C, but with a special construct {\f1{}hex ({\i hex-expr})}.  After the keyword {\f1{}hex} comes an expression in parentheses in which all integers are hexadecimal.  In particular, the token {\f1{}a1b} must be treated as an integer rather than as an identifier if it appears in that context.  Here is how you can do it:\par
\par
{{\pard\keep\li720\f1{}%\'7B\line
int hexflag;\line
%\'7D\line
%%\line
...\par
\pard\keep\li720{}}{expr:   IDENTIFIER\line
        | constant\line
        | HEX '('\line
                \'7B hexflag = 1; \'7D\line
          expr ')'\line
                \'7B hexflag = 0;\line
                   $$ = $4; \'7D\line
        | expr '+' expr\line
                \'7B $$ = make_sum ($1, $3); \'7D\line
        ...\line
        ;\par
\pard\keep\li720{}}\line
{constant:\line
          INTEGER\line
        | STRING\line
        ;\par
\pard\keep\li720{}}}\par
\pard\f0{}Here we assume that {\f1{}yylex} looks at the value of {\f1{}hexflag}; when it is nonzero, all integers are parsed in hexadecimal, and tokens starting with letters are parsed as integers if possible.\par
\par
\pard{}The declaration of {\f1{}hexflag} shown in the C declarations section of the parser file is needed to make it accessible to the actions (see {\uldb The C Declarations Section}{\v C_Declarations}).  You must also write the code in {\f1{}yylex} to obey the flag.\par
\par
\page\pard Node: {\b Tie-in Recovery}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Lexical Tie-ins}{\v Lexical_Tie_ins}, Up: {\uldb Context Dependency}{\v Context_Dependency}\line
K{\footnote K Tie-in Recovery}
#{\footnote Tie_in_Recovery}
${\footnote \pard{}Lexical Tie-ins and Error Recovery}\par
\pard{\fs24\b Lexical Tie-ins and Error Recovery}\par
\par
\pard{}Lexical tie-ins make strict demands on any error recovery rules you have.  See {\uldb Error Recovery}{\v Error_Recovery}.\par
\par
\pard{}The reason for this is that the purpose of an error recovery rule is to abort the parsing of one construct and resume in some larger construct.  For example, in C-like languages, a typical error recovery rule is to skip tokens until the next semicolon, and then start a new statement, like this:\par
\par
{\pard\keep\li720\f1{}stmt:   expr ';'\line
        | IF '(' expr ')' stmt \'7B ... \'7D\line
        ...\line
        error ';'\line
                \'7B hexflag = 0; \'7D\line
        ;\par
\pard\f0{}}\par
\pard{}If there is a syntax error in the middle of a {\f1{}hex ({\i expr})} construct, this error rule will apply, and then the action for the completed {\f1{}hex ({\i expr})} will never run.  So {\f1{}hexflag} would remain set for the entire rest of the input, or until the next {\f1{}hex} keyword, causing identifiers to be misinterpreted as integers.\par
\par
\pard{}To avoid this problem the error recovery rule itself clears {\f1{}hexflag}.\par
\par
\pard{}There may also be an error recovery rule that works within expressions.  For example, there could be a rule which applies within parentheses and skips to the close-parenthesis:\par
\par
{{\pard\keep\li720\f1{}expr:   ...\line
        | '(' expr ')'\line
                \'7B $$ = $2; \'7D\line
        | '(' error ')'\line
        ...\par
\pard\keep\li720{}}}\par
\pard\f0{}If this rule acts within the {\f1{}hex} construct, it is not going to abort that construct (since it applies to an inner level of parentheses within the construct).  Therefore, it should not clear the flag: the rest of the {\f1{}hex} construct should be parsed with the flag still in effect.\par
\par
\pard{}What if there is an error recovery rule which might abort out of the {\f1{}hex} construct or might not, depending on circumstances?  There is no way you can write the action to determine whether a {\f1{}hex} construct is being aborted or not.  So if you are using a lexical tie-in, you had better make sure your error recovery rules are not of this kind.  Each rule must be such that you can be sure that it always will, or always won't, have to clear the flag.\par
\par
\page\pard Node: {\b Debugging}, \keepn Next: {\uldb Invocation}{\v Invocation}, Prev: {\uldb Context Dependency}{\v Context_Dependency}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Debugging}
#{\footnote Debugging}
${\footnote \pard{}Debugging Your Parser}\par
\pard{\fs24\b Debugging Your Parser}\par
\par
\pard{}{K{\footnote K YYDEBUG}}{K{\footnote K yydebug}}{K{\footnote K debugging}}{K{\footnote K tracing the parser}} If a Bison grammar compiles properly but doesn't do what you want when it runs, the {\f1{}yydebug} parser-trace feature can help you figure out why.\par
\par
\pard{}To enable compilation of trace facilities, you must define the macro {\f1{}YYDEBUG} when you compile the parser.  You could use {\f1{}-DYYDEBUG=1} as a compiler option or you could put {\f1{}#define YYDEBUG 1} in the C declarations section of the grammar file (see {\uldb The C Declarations Section}{\v C_Declarations}).  Alternatively, use the {\f1{}-t} option when you run Bison (see {\uldb Invoking Bison}{\v Invocation}).  We always define {\f1{}YYDEBUG} so that debugging is always possible.\par
\par
\pard{}The trace facility uses {\f1{}stderr}, so you must add {\f1{}#include <stdio.h>} to the C declarations section unless it is already there.\par
\par
\pard{}Once you have compiled the program with trace facilities, the way to request a trace is to store a nonzero value in the variable {\f1{}yydebug}.  You can do this by making the C code do it (in {\f1{}main}, perhaps), or you can alter the value with a C debugger.\par
\par
\pard{}Each step taken by the parser when {\f1{}yydebug} is nonzero produces a line or two of trace information, written on {\f1{}stderr}.  The trace messages tell you these things:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Each time the parser calls {\f1{}yylex}, what kind of token was read.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Each time a token is shifted, the depth and complete contents of the state stack (see {\uldb Parser States}{\v Parser_States}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Each time a rule is reduced, which rule it is, and the complete contents of the state stack afterward.\par
\pard{}}\par
\pard{}To make sense of this information, it helps to refer to the listing file produced by the Bison {\f1{}-v} option (see {\uldb Invoking Bison}{\v Invocation}).  This file shows the meaning of each state in terms of positions in various rules, and also what each state will do with each possible input token.  As you read the successive trace messages, you can see that the parser is functioning according to its specification in the listing file.  Eventually you will arrive at the place where something undesirable happens, and you will see which parts of the grammar are to blame.\par
\par
\pard{}The parser file is a C program and you can use C debuggers on it, but it's not easy to interpret what it is doing.  The parser function is a finite-state machine interpreter, and aside from the actions it executes the same code over and over.  Only the values of variables show where in the grammar it is working.\par
\par
\pard{}{K{\footnote K YYPRINT}}The debugging information normally gives the token type of each token read, but not its semantic value.  You can optionally define a macro named {\f1{}YYPRINT} to provide a way to print the value.  If you define {\f1{}YYPRINT}, it should take three arguments.  The parser will pass a standard I/O stream, the numeric code for the token type, and the token value (from {\f1{}yylval}).\par
\par
\pard{}Here is an example of {\f1{}YYPRINT} suitable for the multi-function calculator (see {\uldb Declarations for {\f1{}mfcalc}}{\v Mfcalc_Decl}):\par
\par
{\pard\keep\li720\f1{}#define YYPRINT(file, type, value)   yyprint (file, type, value)\line
\line
static void\line
yyprint (file, type, value)\line
     FILE *file;\line
     int type;\line
     YYSTYPE value;\line
\'7B\line
  if (type == VAR)\line
    fprintf (file, " %s", value.tptr->name);\line
  else if (type == NUM)\line
    fprintf (file, " %d", value.val);\line
\'7D\par
\pard\f0{}}\par
\page\pard Node: {\b Invocation}, \keepn Next: {\uldb Table of Symbols}{\v Table_of_Symbols}, Prev: {\uldb Debugging}{\v Debugging}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Invocation}
#{\footnote Invocation}
${\footnote \pard{}Invoking Bison}\par
\pard{\fs24\b Invoking Bison}\par
\par
\pard{}{K{\footnote K invoking Bison}}{K{\footnote K Bison invocation}}{K{\footnote K options for invoking Bison}} The usual way to invoke Bison is as follows:\par
\par
{\pard\keep\li720\f1{}bison {\i infile}\par
\pard\f0{}}\par
\pard{}Here {\i infile} is the grammar file name, which usually ends in {\f1{}.y}.  The parser file's name is made by replacing the {\f1{}.y} with {\f1{}.tab.c}.  Thus, the {\f1{}bison foo.y} filename yields {\f1{}foo.tab.c}, and the {\f1{}bison hack/foo.y} filename yields {\f1{}hack/foo.tab.c}.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Bison Options}{\v Bison_Options}\tab All the options described in detail, in alphabetical order by short options.\par
{\uldb Option Cross Key}{\v Option_Cross_Key}\tab Alphabetical list of long options.\par
{\uldb VMS Invocation}{\v VMS_Invocation}\tab Bison command syntax on VMS.\par
\pard{}}\par
\page\pard Node: {\b Bison Options}, \keepn Next: {\uldb Option Cross Key}{\v Option_Cross_Key}, Prev: {\uldb }{\v }, Up: {\uldb Invocation}{\v Invocation}\line
K{\footnote K Bison Options}
#{\footnote Bison_Options}
${\footnote \pard{}Bison Options}\par
\pard{\fs24\b Bison Options}\par
\par
\pard{}Bison supports both traditional single-letter options and mnemonic long option names.  Long option names are indicated with {\f1{}--} instead of {\f1{}-}.  Abbreviations for option names are allowed as long as they are unique.  When a long option takes an argument, like {\f1{}--file-prefix}, connect the option name and the argument with {\f1{}=}.\par
\par
\pard{}Here is a list of options that can be used with Bison, alphabetized by short option.  It is followed by a cross key alphabetized by long option.\par
\par
{\pard{}{\f1{}-b {\i file-prefix}}\par
\pard{}{\f1{}--file-prefix={\i prefix}}\par
\pard\li720{}Specify a prefix to use for all Bison output file names.  The names are chosen as if the input file were named {\f1{}{\i prefix}.c}.\par
\par
\pard{}{\f1{}-d}\par
\pard{}{\f1{}--defines}\par
\pard\li720{}Write an extra output file containing macro definitions for the token type names defined in the grammar and the semantic value type {\f1{}YYSTYPE}, as well as a few {\f1{}extern} variable declarations.\par
\par
\pard\li720{}If the parser output file is named {\f1{}{\i name}.c} then this file is named {\f1{}{\i name}.h}.\par
\par
\pard\li720{}This output file is essential if you wish to put the definition of {\f1{}yylex} in a separate source file, because {\f1{}yylex} needs to be able to refer to token type codes and the variable {\f1{}yylval}.  See {\uldb Semantic Values of Tokens}{\v Token_Values}.\par
\par
\pard{}{\f1{}-l}\par
\pard{}{\f1{}--no-lines}\par
\pard\li720{}Don't put any {\f1{}#line} preprocessor commands in the parser file.  Ordinarily Bison puts them in the parser file so that the C compiler and debuggers will associate errors with your source file, the grammar file.  This option causes them to associate errors with the parser file, treating it as an independent source file in its own right.\par
\par
\pard{}{\f1{}-n}\par
\pard{}{\f1{}--no-parser}\par
\pard\li720{}Do not include any C code in the parser file; generate tables only.  The parser file contains just {\f1{}#define} directives and static variable declarations.\par
\par
\pard\li720{}This option also tells Bison to write the C code for the grammar actions into a file named {\f1{}{\i filename}.act}, in the form of a brace-surrounded body fit for a {\f1{}switch} statement.\par
\par
\pard{}{\f1{}-o {\i outfile}}\par
\pard{}{\f1{}--output-file={\i outfile}}\par
\pard\li720{}Specify the name {\i outfile} for the parser file.\par
\par
\pard\li720{}The other output files' names are constructed from {\i outfile} as described under the {\f1{}-v} and {\f1{}-d} options.\par
\par
\pard{}{\f1{}-p {\i prefix}}\par
\pard{}{\f1{}--name-prefix={\i prefix}}\par
\pard\li720{}Rename the external symbols used in the parser so that they start with {\i prefix} instead of {\f1{}yy}.  The precise list of symbols renamed is {\f1{}yyparse}, {\f1{}yylex}, {\f1{}yyerror}, {\f1{}yynerrs}, {\f1{}yylval}, {\f1{}yychar} and {\f1{}yydebug}.\par
\par
\pard\li720{}For example, if you use {\f1{}-p c}, the names become {\f1{}cparse}, {\f1{}clex}, and so on.\par
\par
\pard\li720{}See {\uldb Multiple Parsers in the Same Program}{\v Multiple_Parsers}.\par
\par
\pard{}{\f1{}-r}\par
\pard{}{\f1{}--raw}\par
\pard\li720{}Pretend that {\f1{}%raw} was specified.  See {\uldb Decl Summary}{\v Decl_Summary}.\par
\par
\pard{}{\f1{}-t}\par
\pard{}{\f1{}--debug}\par
\pard\li720{}Output a definition of the macro {\f1{}YYDEBUG} into the parser file, so that the debugging facilities are compiled.  See {\uldb Debugging Your Parser}{\v Debugging}.\par
\par
\pard{}{\f1{}-v}\par
\pard{}{\f1{}--verbose}\par
\pard\li720{}Write an extra output file containing verbose descriptions of the parser states and what is done for each type of look-ahead token in that state.\par
\par
\pard\li720{}This file also describes all the conflicts, both those resolved by operator precedence and the unresolved ones.\par
\par
\pard\li720{}The file's name is made by removing {\f1{}.tab.c} or {\f1{}.c} from the parser output file name, and adding {\f1{}.output} instead.\par
\par
\pard\li720{}Therefore, if the input file is {\f1{}foo.y}, then the parser file is called {\f1{}foo.tab.c} by default.  As a consequence, the verbose output file is called {\f1{}foo.output}.\par
\par
\pard{}{\f1{}-V}\par
\pard{}{\f1{}--version}\par
\pard\li720{}Print the version number of Bison and exit.\par
\par
\pard{}{\f1{}-h}\par
\pard{}{\f1{}--help}\par
\pard\li720{}Print a summary of the command-line options to Bison and exit.\par
\par
\pard{}{\f1{}-y}\par
\pard{}{\f1{}--yacc}\par
\pard{}{\f1{}--fixed-output-files}\par
\pard\li720{}Equivalent to {\f1{}-o y.tab.c}; the parser output file is called {\f1{}y.tab.c}, and the other outputs are called {\f1{}y.output} and {\f1{}y.tab.h}.  The purpose of this option is to imitate Yacc's output file name conventions.  Thus, the following shell script can substitute for Yacc:\par
\par
{\pard\keep\li1440\f1{}bison -y $*\par
\pard\li720\f0{}}}\par
\page\pard Node: {\b Option Cross Key}, \keepn Next: {\uldb VMS Invocation}{\v VMS_Invocation}, Prev: {\uldb Bison Options}{\v Bison_Options}, Up: {\uldb Invocation}{\v Invocation}\line
K{\footnote K Option Cross Key}
#{\footnote Option_Cross_Key}
${\footnote \pard{}Option Cross Key}\par
\pard{\fs24\b Option Cross Key}\par
\par
\pard{}Here is a list of options, alphabetized by long option, to help you find the corresponding short option.\par
\par
{{\pard\keep\li720\f1{}--debug                               -t\line
--defines                             -d\line
--file-prefix={\i prefix}                  -b {\i file-prefix}\line
--fixed-output-files --yacc           -y\line
--help                                -h\line
--name-prefix={\i prefix}                  -p {\i name-prefix}\line
--no-lines                            -l\line
--no-parser                           -n\line
--output-file={\i outfile}                 -o {\i outfile}\line
--raw                                 -r\line
--token-table                         -k\line
--verbose                             -v\line
--version                             -V\par
\pard\f0{}}}\par
\page\pard Node: {\b VMS Invocation}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Option Cross Key}{\v Option_Cross_Key}, Up: {\uldb Invocation}{\v Invocation}\line
K{\footnote K VMS Invocation}
#{\footnote VMS_Invocation}
${\footnote \pard{}Invoking Bison under VMS}\par
\pard{\fs24\b Invoking Bison under VMS}\par
\par
\pard{}{K{\footnote K invoking Bison under VMS}}{K{\footnote K VMS}} The command line syntax for Bison on VMS is a variant of the usual Bison command syntax--adapted to fit VMS conventions.\par
\par
\pard{}To find the VMS equivalent for any Bison option, start with the long option, and substitute a {\f1{}/} for the leading {\f1{}--}, and substitute a {\f1{}_} for each {\f1{}-} in the name of the long option.  For example, the following invocation under VMS:\par
\par
{\pard\keep\li720\f1{}bison /debug/name_prefix=bar foo.y\par
\pard\f0{}}\par
\pard{}is equivalent to the following command under POSIX.\par
\par
{\pard\keep\li720\f1{}bison --debug --name-prefix=bar foo.y\par
\pard\f0{}}\par
\pard{}The VMS file system does not permit filenames such as {\f1{}foo.tab.c}.  In the above example, the output file would instead be named {\f1{}foo_tab.c}.\par
\par
\page\pard Node: {\b Table of Symbols}, \keepn Next: {\uldb Glossary}{\v Glossary}, Prev: {\uldb Invocation}{\v Invocation}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Table of Symbols}
#{\footnote Table_of_Symbols}
${\footnote \pard{}Bison Symbols}\par
\pard{\fs24\b Bison Symbols}\par
\par
\pard{}{K{\footnote K Bison symbols, table of}}{K{\footnote K symbols in Bison, table of}} {\par
\pard{}{\f1{}error}\par
\pard\li720{}A token name reserved for error recovery.  This token may be used in grammar rules so as to allow the Bison parser to recognize an error in the grammar without halting the process.  In effect, a sentence containing an error may be recognized as valid.  On a parse error, the token {\f1{}error} becomes the current look-ahead token.  Actions corresponding to {\f1{}error} are then executed, and the look-ahead token is reset to the token that originally caused the violation.  See {\uldb Error Recovery}{\v Error_Recovery}.\par
\par
\pard{}{\f1{}YYABORT}\par
\pard\li720{}Macro to pretend that an unrecoverable syntax error has occurred, by making {\f1{}yyparse} return 1 immediately.  The error reporting function {\f1{}yyerror} is not called.  See {\uldb The Parser Function {\f1{}yyparse}}{\v Parser_Function}.\par
\par
\pard{}{\f1{}YYACCEPT}\par
\pard\li720{}Macro to pretend that a complete utterance of the language has been read, by making {\f1{}yyparse} return 0 immediately.  See {\uldb The Parser Function {\f1{}yyparse}}{\v Parser_Function}.\par
\par
\pard{}{\f1{}YYBACKUP}\par
\pard\li720{}Macro to discard a value from the parser stack and fake a look-ahead token.  See {\uldb Special Features for Use in Actions}{\v Action_Features}.\par
\par
\pard{}{\f1{}YYERROR}\par
\pard\li720{}Macro to pretend that a syntax error has just been detected: call {\f1{}yyerror} and then perform normal error recovery if possible (see {\uldb Error Recovery}{\v Error_Recovery}), or (if recovery is impossible) make {\f1{}yyparse} return 1.  See {\uldb Error Recovery}{\v Error_Recovery}.\par
\par
\pard{}{\f1{}YYERROR_VERBOSE}\par
\pard\li720{}Macro that you define with {\f1{}#define} in the Bison declarations section to request verbose, specific error message strings when {\f1{}yyerror} is called.\par
\par
\pard{}{\f1{}YYINITDEPTH}\par
\pard\li720{}Macro for specifying the initial size of the parser stack.  See {\uldb Stack Overflow}{\v Stack_Overflow}.\par
\par
\pard{}{\f1{}YYLEX_PARAM}\par
\pard\li720{}Macro for specifying an extra argument (or list of extra arguments) for {\f1{}yyparse} to pass to {\f1{}yylex}.  See {\uldb Calling Conventions for Pure Parsers}{\v Pure_Calling}.\par
\par
\pard{}{\f1{}YYLTYPE}\par
\pard\li720{}Macro for the data type of {\f1{}yylloc}; a structure with four members.  See {\uldb Textual Positions of Tokens}{\v Token_Positions}.\par
\par
\pard{}{\f1{}yyltype}\par
\pard\li720{}Default value for YYLTYPE.\par
\par
\pard{}{\f1{}YYMAXDEPTH}\par
\pard\li720{}Macro for specifying the maximum size of the parser stack.  See {\uldb Stack Overflow}{\v Stack_Overflow}.\par
\par
\pard{}{\f1{}YYPARSE_PARAM}\par
\pard\li720{}Macro for specifying the name of a parameter that {\f1{}yyparse} should accept.  See {\uldb Calling Conventions for Pure Parsers}{\v Pure_Calling}.\par
\par
\pard{}{\f1{}YYRECOVERING}\par
\pard\li720{}Macro whose value indicates whether the parser is recovering from a syntax error.  See {\uldb Special Features for Use in Actions}{\v Action_Features}.\par
\par
\pard{}{\f1{}YYSTYPE}\par
\pard\li720{}Macro for the data type of semantic values; {\f1{}int} by default.  See {\uldb Data Types of Semantic Values}{\v Value_Type}.\par
\par
\pard{}{\f1{}yychar}\par
\pard\li720{}External integer variable that contains the integer value of the current look-ahead token.  (In a pure parser, it is a local variable within {\f1{}yyparse}.)  Error-recovery rule actions may examine this variable.  See {\uldb Special Features for Use in Actions}{\v Action_Features}.\par
\par
\pard{}{\f1{}yyclearin}\par
\pard\li720{}Macro used in error-recovery rule actions.  It clears the previous look-ahead token.  See {\uldb Error Recovery}{\v Error_Recovery}.\par
\par
\pard{}{\f1{}yydebug}\par
\pard\li720{}External integer variable set to zero by default.  If {\f1{}yydebug} is given a nonzero value, the parser will output information on input symbols and parser action.  See {\uldb Debugging Your Parser}{\v Debugging}.\par
\par
\pard{}{\f1{}yyerrok}\par
\pard\li720{}Macro to cause parser to recover immediately to its normal mode after a parse error.  See {\uldb Error Recovery}{\v Error_Recovery}.\par
\par
\pard{}{\f1{}yyerror}\par
\pard\li720{}User-supplied function to be called by {\f1{}yyparse} on error.  The function receives one argument, a pointer to a character string containing an error message.  See {\uldb The Error Reporting Function {\f1{}yyerror}}{\v Error_Reporting}.\par
\par
\pard{}{\f1{}yylex}\par
\pard\li720{}User-supplied lexical analyzer function, called with no arguments to get the next token.  See {\uldb The Lexical Analyzer Function {\f1{}yylex}}{\v Lexical}.\par
\par
\pard{}{\f1{}yylval}\par
\pard\li720{}External variable in which {\f1{}yylex} should place the semantic value associated with a token.  (In a pure parser, it is a local variable within {\f1{}yyparse}, and its address is passed to {\f1{}yylex}.)  See {\uldb Semantic Values of Tokens}{\v Token_Values}.\par
\par
\pard{}{\f1{}yylloc}\par
\pard\li720{}External variable in which {\f1{}yylex} should place the line and column numbers associated with a token.  (In a pure parser, it is a local variable within {\f1{}yyparse}, and its address is passed to {\f1{}yylex}.)  You can ignore this variable if you don't use the {\f1{}@} feature in the grammar actions.  See {\uldb Textual Positions of Tokens}{\v Token_Positions}.\par
\par
\pard{}{\f1{}yynerrs}\par
\pard\li720{}Global variable which Bison increments each time there is a parse error.  (In a pure parser, it is a local variable within {\f1{}yyparse}.)  See {\uldb The Error Reporting Function {\f1{}yyerror}}{\v Error_Reporting}.\par
\par
\pard{}{\f1{}yyparse}\par
\pard\li720{}The parser function produced by Bison; call this function to start parsing.  See {\uldb The Parser Function {\f1{}yyparse}}{\v Parser_Function}.\par
\par
\pard{}{\f1{}%left}\par
\pard\li720{}Bison declaration to assign left associativity to token(s).  See {\uldb Operator Precedence}{\v Precedence_Decl}.\par
\par
\pard{}{\f1{}%no_lines}\par
\pard\li720{}Bison declaration to avoid generating {\f1{}#line} directives in the parser file.  See {\uldb Decl Summary}{\v Decl_Summary}.\par
\par
\pard{}{\f1{}%nonassoc}\par
\pard\li720{}Bison declaration to assign nonassociativity to token(s).  See {\uldb Operator Precedence}{\v Precedence_Decl}.\par
\par
\pard{}{\f1{}%prec}\par
\pard\li720{}Bison declaration to assign a precedence to a specific rule.  See {\uldb Context-Dependent Precedence}{\v Contextual_Precedence}.\par
\par
\pard{}{\f1{}%pure_parser}\par
\pard\li720{}Bison declaration to request a pure (reentrant) parser.  See {\uldb A Pure (Reentrant) Parser}{\v Pure_Decl}.\par
\par
\pard{}{\f1{}%raw}\par
\pard\li720{}Bison declaration to use Bison internal token code numbers in token tables instead of the usual Yacc-compatible token code numbers.  See {\uldb Decl Summary}{\v Decl_Summary}.\par
\par
\pard{}{\f1{}%right}\par
\pard\li720{}Bison declaration to assign right associativity to token(s).  See {\uldb Operator Precedence}{\v Precedence_Decl}.\par
\par
\pard{}{\f1{}%start}\par
\pard\li720{}Bison declaration to specify the start symbol.  See {\uldb The Start-Symbol}{\v Start_Decl}.\par
\par
\pard{}{\f1{}%token}\par
\pard\li720{}Bison declaration to declare token(s) without specifying precedence.  See {\uldb Token Type Names}{\v Token_Decl}.\par
\par
\pard{}{\f1{}%token_table}\par
\pard\li720{}Bison declaration to include a token name table in the parser file.  See {\uldb Decl Summary}{\v Decl_Summary}.\par
\par
\pard{}{\f1{}%type}\par
\pard\li720{}Bison declaration to declare nonterminals.  See {\uldb Nonterminal Symbols}{\v Type_Decl}.\par
\par
\pard{}{\f1{}%union}\par
\pard\li720{}Bison declaration to specify several possible data types for semantic values.  See {\uldb The Collection of Value Types}{\v Union_Decl}.\par
\pard{}}\par
\pard{}These are the punctuation and delimiters used in Bison input:\par
\par
{\pard{}{\f1{}%%}\par
\pard\li720{}Delimiter used to separate the grammar rule section from the Bison declarations section or the additional C code section.  See {\uldb The Overall Layout of a Bison Grammar}{\v Grammar_Layout}.\par
\par
\pard{}{\f1{}%\'7B %\'7D}\par
\pard\li720{}All code listed between {\f1{}%\'7B} and {\f1{}%\'7D} is copied directly to the output file uninterpreted.  Such code forms the "C declarations" section of the input file.  See {\uldb Outline of a Bison Grammar}{\v Grammar_Outline}.\par
\par
\pard{}{\f1{}/*...*/}\par
\pard\li720{}Comment delimiters, as in C.\par
\par
\pard{}{\f1{}:}\par
\pard\li720{}Separates a rule's result from its components.  See {\uldb Syntax of Grammar Rules}{\v Rules}.\par
\par
\pard{}{\f1{};}\par
\pard\li720{}Terminates a rule.  See {\uldb Syntax of Grammar Rules}{\v Rules}.\par
\par
\pard{}{\f1{}|}\par
\pard\li720{}Separates alternate rules for the same result nonterminal.  See {\uldb Syntax of Grammar Rules}{\v Rules}.\par
\pard{}}\par
\page\pard Node: {\b Glossary}, \keepn Next: {\uldb Index}{\v Index}, Prev: {\uldb Table of Symbols}{\v Table_of_Symbols}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Glossary}
#{\footnote Glossary}
${\footnote \pard{}Glossary}\par
\pard{\fs24\b Glossary}\par
\par
\pard{}{K{\footnote K glossary}} {\par
\pard{}Backus-Naur Form (BNF)\par
\pard\li720{}Formal method of specifying context-free grammars.  BNF was first used in the {\i ALGOL-60} report, 1963.  See {\uldb Languages and Context-Free Grammars}{\v Language_and_Grammar}.\par
\par
\pard{}Context-free grammars\par
\pard\li720{}Grammars specified as rules that can be applied regardless of context.  Thus, if there is a rule which says that an integer can be used as an expression, integers are allowed {\i anywhere} an expression is permitted.  See {\uldb Languages and Context-Free Grammars}{\v Language_and_Grammar}.\par
\par
\pard{}Dynamic allocation\par
\pard\li720{}Allocation of memory that occurs during execution, rather than at compile time or on entry to a function.\par
\par
\pard{}Empty string\par
\pard\li720{}Analogous to the empty set in set theory, the empty string is a character string of length zero.\par
\par
\pard{}Finite-state stack machine\par
\pard\li720{}A "machine" that has discrete states in which it is said to exist at each instant in time.  As input to the machine is processed, the machine moves from state to state as specified by the logic of the machine.  In the case of the parser, the input is the language being parsed, and the states correspond to various stages in the grammar rules.  See {\uldb The Bison Parser Algorithm}{\v Algorithm}.\par
\par
\pard{}Grouping\par
\pard\li720{}A language construct that is (in general) grammatically divisible; for example, `expression' or `declaration' in C.  See {\uldb Languages and Context-Free Grammars}{\v Language_and_Grammar}.\par
\par
\pard{}Infix operator\par
\pard\li720{}An arithmetic operator that is placed between the operands on which it performs some operation.\par
\par
\pard{}Input stream\par
\pard\li720{}A continuous flow of data between devices or programs.\par
\par
\pard{}Language construct\par
\pard\li720{}One of the typical usage schemas of the language.  For example, one of the constructs of the C language is the {\f1{}if} statement.  See {\uldb Languages and Context-Free Grammars}{\v Language_and_Grammar}.\par
\par
\pard{}Left associativity\par
\pard\li720{}Operators having left associativity are analyzed from left to right: {\f1{}a+b+c} first computes {\f1{}a+b} and then combines with {\f1{}c}.  See {\uldb Operator Precedence}{\v Precedence}.\par
\par
\pard{}Left recursion\par
\pard\li720{}A rule whose result symbol is also its first component symbol; for example, {\f1{}expseq1 : expseq1 ',' exp;}.  See {\uldb Recursive Rules}{\v Recursion}.\par
\par
\pard{}Left-to-right parsing\par
\pard\li720{}Parsing a sentence of a language by analyzing it token by token from left to right.  See {\uldb The Bison Parser Algorithm}{\v Algorithm}.\par
\par
\pard{}Lexical analyzer (scanner)\par
\pard\li720{}A function that reads an input stream and returns tokens one by one.  See {\uldb The Lexical Analyzer Function {\f1{}yylex}}{\v Lexical}.\par
\par
\pard{}Lexical tie-in\par
\pard\li720{}A flag, set by actions in the grammar rules, which alters the way tokens are parsed.  See {\uldb Lexical Tie-ins}{\v Lexical_Tie_ins}.\par
\par
\pard{}Literal string token\par
\pard\li720{}A token which constists of two or more fixed characters.  See {\uldb Symbols}{\v Symbols}.\par
\par
\pard{}Look-ahead token\par
\pard\li720{}A token already read but not yet shifted.  See {\uldb Look-Ahead Tokens}{\v Look_Ahead}.\par
\par
\pard{}LALR(1)\par
\pard\li720{}The class of context-free grammars that Bison (like most other parser generators) can handle; a subset of LR(1).  See {\uldb Mysterious Reduce/Reduce Conflicts}{\v Mystery_Conflicts}.\par
\par
\pard{}LR(1)\par
\pard\li720{}The class of context-free grammars in which at most one token of look-ahead is needed to disambiguate the parsing of any piece of input.\par
\par
\pard{}Nonterminal symbol\par
\pard\li720{}A grammar symbol standing for a grammatical construct that can be expressed through rules in terms of smaller constructs; in other words, a construct that is not a token.  See {\uldb Symbols}{\v Symbols}.\par
\par
\pard{}Parse error\par
\pard\li720{}An error encountered during parsing of an input stream due to invalid syntax.  See {\uldb Error Recovery}{\v Error_Recovery}.\par
\par
\pard{}Parser\par
\pard\li720{}A function that recognizes valid sentences of a language by analyzing the syntax structure of a set of tokens passed to it from a lexical analyzer.\par
\par
\pard{}Postfix operator\par
\pard\li720{}An arithmetic operator that is placed after the operands upon which it performs some operation.\par
\par
\pard{}Reduction\par
\pard\li720{}Replacing a string of nonterminals and/or terminals with a single nonterminal, according to a grammar rule.  See {\uldb The Bison Parser Algorithm}{\v Algorithm}.\par
\par
\pard{}Reentrant\par
\pard\li720{}A reentrant subprogram is a subprogram which can be in invoked any number of times in parallel, without interference between the various invocations.  See {\uldb A Pure (Reentrant) Parser}{\v Pure_Decl}.\par
\par
\pard{}Reverse polish notation\par
\pard\li720{}A language in which all operators are postfix operators.\par
\par
\pard{}Right recursion\par
\pard\li720{}A rule whose result symbol is also its last component symbol; for example, {\f1{}expseq1: exp ',' expseq1;}.  See {\uldb Recursive Rules}{\v Recursion}.\par
\par
\pard{}Semantics\par
\pard\li720{}In computer languages, the semantics are specified by the actions taken for each instance of the language, i.e., the meaning of each statement.  See {\uldb Defining Language Semantics}{\v Semantics}.\par
\par
\pard{}Shift\par
\pard\li720{}A parser is said to shift when it makes the choice of analyzing further input from the stream rather than reducing immediately some already-recognized rule.  See {\uldb The Bison Parser Algorithm}{\v Algorithm}.\par
\par
\pard{}Single-character literal\par
\pard\li720{}A single character that is recognized and interpreted as is.  See {\uldb From Formal Rules to Bison Input}{\v Grammar_in_Bison}.\par
\par
\pard{}Start symbol\par
\pard\li720{}The nonterminal symbol that stands for a complete valid utterance in the language being parsed.  The start symbol is usually listed as the first nonterminal symbol in a language specification.  See {\uldb The Start-Symbol}{\v Start_Decl}.\par
\par
\pard{}Symbol table\par
\pard\li720{}A data structure where symbol names and associated data are stored during parsing to allow for recognition and use of existing information in repeated uses of a symbol.  See {\uldb Multi-function Calc}{\v Multi_function_Calc}.\par
\par
\pard{}Token\par
\pard\li720{}A basic, grammatically indivisible unit of a language.  The symbol that describes a token in the grammar is a terminal symbol.  The input of the Bison parser is a stream of tokens which comes from the lexical analyzer.  See {\uldb Symbols}{\v Symbols}.\par
\par
\pard{}Terminal symbol\par
\pard\li720{}A grammar symbol that has no rules in the grammar and therefore is grammatically indivisible.  The piece of text it represents is a token.  See {\uldb Languages and Context-Free Grammars}{\v Language_and_Grammar}.\par
\pard{}}\par
\page\pard Node: {\b Index}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Glossary}{\v Glossary}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Index}
#{\footnote Index}
${\footnote \pard{}Index}\par
\pard{\fs24\b Index}\par
\par
{\fi-2880\li2880\tx2880$$:\tab {\uldb Actions}{\v Actions}.\par}{\fi-2880\li2880\tx2880${\i n}:\tab {\uldb Actions}{\v Actions}.\par}{\fi-2880\li2880\tx2880%expect:\tab {\uldb Expect Decl}{\v Expect_Decl}.\par}{\fi-2880\li2880\tx2880%left:\tab {\uldb Using Precedence}{\v Using_Precedence}.\par}{\fi-2880\li2880\tx2880%nonassoc:\tab {\uldb Using Precedence}{\v Using_Precedence}.\par}{\fi-2880\li2880\tx2880%prec:\tab {\uldb Contextual Precedence}{\v Contextual_Precedence}.\par}{\fi-2880\li2880\tx2880%pure_parser:\tab {\uldb Pure Decl}{\v Pure_Decl}.\par}{\fi-2880\li2880\tx2880%right:\tab {\uldb Using Precedence}{\v Using_Precedence}.\par}{\fi-2880\li2880\tx2880%start:\tab {\uldb Start Decl}{\v Start_Decl}.\par}{\fi-2880\li2880\tx2880%token:\tab {\uldb Token Decl}{\v Token_Decl}.\par}{\fi-2880\li2880\tx2880%type:\tab {\uldb Type Decl}{\v Type_Decl}.\par}{\fi-2880\li2880\tx2880%union:\tab {\uldb Union Decl}{\v Union_Decl}.\par}{\fi-2880\li2880\tx2880@{\i n}:\tab {\uldb Action Features}{\v Action_Features}.\par}{\fi-2880\li2880\tx2880action:\tab {\uldb Actions}{\v Actions}.\par}{\fi-2880\li2880\tx2880action data types:\tab {\uldb Action Types}{\v Action_Types}.\par}{\fi-2880\li2880\tx2880action features summary:\tab {\uldb Action Features}{\v Action_Features}.\par}{\fi-2880\li2880\tx2880actions in mid-rule:\tab {\uldb Mid-Rule Actions}{\v Mid_Rule_Actions}.\par}{\fi-2880\li2880\tx2880actions, semantic:\tab {\uldb Semantic Actions}{\v Semantic_Actions}.\par}{\fi-2880\li2880\tx2880additional C code section:\tab {\uldb C Code}{\v C_Code}.\par}{\fi-2880\li2880\tx2880algorithm of parser:\tab {\uldb Algorithm}{\v Algorithm}.\par}{\fi-2880\li2880\tx2880associativity:\tab {\uldb Why Precedence}{\v Why_Precedence}.\par}{\fi-2880\li2880\tx2880Backus-Naur form:\tab {\uldb Language and Grammar}{\v Language_and_Grammar}.\par}{\fi-2880\li2880\tx2880Bison declaration summary:\tab {\uldb Decl Summary}{\v Decl_Summary}.\par}{\fi-2880\li2880\tx2880Bison declarations:\tab {\uldb Declarations}{\v Declarations}.\par}{\fi-2880\li2880\tx2880Bison declarations (introduction):\tab {\uldb Bison Declarations}{\v Bison_Declarations}.\par}{\fi-2880\li2880\tx2880Bison grammar:\tab {\uldb Grammar in Bison}{\v Grammar_in_Bison}.\par}{\fi-2880\li2880\tx2880Bison invocation:\tab {\uldb Invocation}{\v Invocation}.\par}{\fi-2880\li2880\tx2880Bison parser:\tab {\uldb Bison Parser}{\v Bison_Parser}.\par}{\fi-2880\li2880\tx2880Bison parser algorithm:\tab {\uldb Algorithm}{\v Algorithm}.\par}{\fi-2880\li2880\tx2880Bison symbols, table of:\tab {\uldb Table of Symbols}{\v Table_of_Symbols}.\par}{\fi-2880\li2880\tx2880Bison utility:\tab {\uldb Bison Parser}{\v Bison_Parser}.\par}{\fi-2880\li2880\tx2880BNF:\tab {\uldb Language and Grammar}{\v Language_and_Grammar}.\par}{\fi-2880\li2880\tx2880C code, section for additional:\tab {\uldb C Code}{\v C_Code}.\par}{\fi-2880\li2880\tx2880C declarations section:\tab {\uldb C Declarations}{\v C_Declarations}.\par}{\fi-2880\li2880\tx2880C-language interface:\tab {\uldb Interface}{\v Interface}.\par}{\fi-2880\li2880\tx2880calculator, infix notation:\tab {\uldb Infix Calc}{\v Infix_Calc}.\par}{\fi-2880\li2880\tx2880calculator, multi-function:\tab {\uldb Multi-function Calc}{\v Multi_function_Calc}.\par}{\fi-2880\li2880\tx2880calculator, simple:\tab {\uldb RPN Calc}{\v RPN_Calc}.\par}{\fi-2880\li2880\tx2880character token:\tab {\uldb Symbols}{\v Symbols}.\par}{\fi-2880\li2880\tx2880compiling the parser:\tab {\uldb Rpcalc Compile}{\v Rpcalc_Compile}.\par}{\fi-2880\li2880\tx2880conflicts:\tab {\uldb Shift/Reduce}{\v Shift_Reduce}.\par}{\fi-2880\li2880\tx2880conflicts, reduce/reduce:\tab {\uldb Reduce/Reduce}{\v Reduce_Reduce}.\par}{\fi-2880\li2880\tx2880conflicts, suppressing warnings of:\tab {\uldb Expect Decl}{\v Expect_Decl}.\par}{\fi-2880\li2880\tx2880context-dependent precedence:\tab {\uldb Contextual Precedence}{\v Contextual_Precedence}.\par}{\fi-2880\li2880\tx2880context-free grammar:\tab {\uldb Language and Grammar}{\v Language_and_Grammar}.\par}{\fi-2880\li2880\tx2880controlling function:\tab {\uldb Rpcalc Main}{\v Rpcalc_Main}.\par}{\fi-2880\li2880\tx2880dangling {\f1{}else}:\tab {\uldb Shift/Reduce}{\v Shift_Reduce}.\par}{\fi-2880\li2880\tx2880data types in actions:\tab {\uldb Action Types}{\v Action_Types}.\par}{\fi-2880\li2880\tx2880data types of semantic values:\tab {\uldb Value Type}{\v Value_Type}.\par}{\fi-2880\li2880\tx2880debugging:\tab {\uldb Debugging}{\v Debugging}.\par}{\fi-2880\li2880\tx2880declaration summary:\tab {\uldb Decl Summary}{\v Decl_Summary}.\par}{\fi-2880\li2880\tx2880declarations, Bison:\tab {\uldb Declarations}{\v Declarations}.\par}{\fi-2880\li2880\tx2880declarations, Bison (introduction):\tab {\uldb Bison Declarations}{\v Bison_Declarations}.\par}{\fi-2880\li2880\tx2880declarations, C:\tab {\uldb C Declarations}{\v C_Declarations}.\par}{\fi-2880\li2880\tx2880declaring literal string tokens:\tab {\uldb Token Decl}{\v Token_Decl}.\par}{\fi-2880\li2880\tx2880declaring operator precedence:\tab {\uldb Precedence Decl}{\v Precedence_Decl}.\par}{\fi-2880\li2880\tx2880declaring the start symbol:\tab {\uldb Start Decl}{\v Start_Decl}.\par}{\fi-2880\li2880\tx2880declaring token type names:\tab {\uldb Token Decl}{\v Token_Decl}.\par}{\fi-2880\li2880\tx2880declaring value types:\tab {\uldb Union Decl}{\v Union_Decl}.\par}{\fi-2880\li2880\tx2880declaring value types, nonterminals:\tab {\uldb Type Decl}{\v Type_Decl}.\par}{\fi-2880\li2880\tx2880default action:\tab {\uldb Actions}{\v Actions}.\par}{\fi-2880\li2880\tx2880default data type:\tab {\uldb Value Type}{\v Value_Type}.\par}{\fi-2880\li2880\tx2880default stack limit:\tab {\uldb Stack Overflow}{\v Stack_Overflow}.\par}{\fi-2880\li2880\tx2880default start symbol:\tab {\uldb Start Decl}{\v Start_Decl}.\par}{\fi-2880\li2880\tx2880defining language semantics:\tab {\uldb Semantics}{\v Semantics}.\par}{\fi-2880\li2880\tx2880error:\tab {\uldb Error Recovery}{\v Error_Recovery}.\par}{\fi-2880\li2880\tx2880error recovery:\tab {\uldb Error Recovery}{\v Error_Recovery}.\par}{\fi-2880\li2880\tx2880error recovery, simple:\tab {\uldb Simple Error Recovery}{\v Simple_Error_Recovery}.\par}{\fi-2880\li2880\tx2880error reporting function:\tab {\uldb Error Reporting}{\v Error_Reporting}.\par}{\fi-2880\li2880\tx2880error reporting routine:\tab {\uldb Rpcalc Error}{\v Rpcalc_Error}.\par}{\fi-2880\li2880\tx2880examples, simple:\tab {\uldb Examples}{\v Examples}.\par}{\fi-2880\li2880\tx2880exercises:\tab {\uldb Exercises}{\v Exercises}.\par}{\fi-2880\li2880\tx2880file format:\tab {\uldb Grammar Layout}{\v Grammar_Layout}.\par}{\fi-2880\li2880\tx2880finite-state machine:\tab {\uldb Parser States}{\v Parser_States}.\par}{\fi-2880\li2880\tx2880formal grammar:\tab {\uldb Grammar in Bison}{\v Grammar_in_Bison}.\par}{\fi-2880\li2880\tx2880format of grammar file:\tab {\uldb Grammar Layout}{\v Grammar_Layout}.\par}{\fi-2880\li2880\tx2880glossary:\tab {\uldb Glossary}{\v Glossary}.\par}{\fi-2880\li2880\tx2880grammar file:\tab {\uldb Grammar Layout}{\v Grammar_Layout}.\par}{\fi-2880\li2880\tx2880grammar rule syntax:\tab {\uldb Rules}{\v Rules}.\par}{\fi-2880\li2880\tx2880grammar rules section:\tab {\uldb Grammar Rules}{\v Grammar_Rules}.\par}{\fi-2880\li2880\tx2880grammar, Bison:\tab {\uldb Grammar in Bison}{\v Grammar_in_Bison}.\par}{\fi-2880\li2880\tx2880grammar, context-free:\tab {\uldb Language and Grammar}{\v Language_and_Grammar}.\par}{\fi-2880\li2880\tx2880grouping, syntactic:\tab {\uldb Language and Grammar}{\v Language_and_Grammar}.\par}{\fi-2880\li2880\tx2880infix notation calculator:\tab {\uldb Infix Calc}{\v Infix_Calc}.\par}{\fi-2880\li2880\tx2880interface:\tab {\uldb Interface}{\v Interface}.\par}{\fi-2880\li2880\tx2880introduction:\tab {\uldb Introduction}{\v Introduction}.\par}{\fi-2880\li2880\tx2880invoking Bison:\tab {\uldb Invocation}{\v Invocation}.\par}{\fi-2880\li2880\tx2880invoking Bison under VMS:\tab {\uldb VMS Invocation}{\v VMS_Invocation}.\par}{\fi-2880\li2880\tx2880LALR(1):\tab {\uldb Mystery Conflicts}{\v Mystery_Conflicts}.\par}{\fi-2880\li2880\tx2880language semantics, defining:\tab {\uldb Semantics}{\v Semantics}.\par}{\fi-2880\li2880\tx2880layout of Bison grammar:\tab {\uldb Grammar Layout}{\v Grammar_Layout}.\par}{\fi-2880\li2880\tx2880left recursion:\tab {\uldb Recursion}{\v Recursion}.\par}{\fi-2880\li2880\tx2880lexical analyzer:\tab {\uldb Lexical}{\v Lexical}.\par}{\fi-2880\li2880\tx2880lexical analyzer, purpose:\tab {\uldb Bison Parser}{\v Bison_Parser}.\par}{\fi-2880\li2880\tx2880lexical analyzer, writing:\tab {\uldb Rpcalc Lexer}{\v Rpcalc_Lexer}.\par}{\fi-2880\li2880\tx2880lexical tie-in:\tab {\uldb Lexical Tie-ins}{\v Lexical_Tie_ins}.\par}{\fi-2880\li2880\tx2880literal string token:\tab {\uldb Symbols}{\v Symbols}.\par}{\fi-2880\li2880\tx2880literal token:\tab {\uldb Symbols}{\v Symbols}.\par}{\fi-2880\li2880\tx2880look-ahead token:\tab {\uldb Look-Ahead}{\v Look_Ahead}.\par}{\fi-2880\li2880\tx2880LR(1):\tab {\uldb Mystery Conflicts}{\v Mystery_Conflicts}.\par}{\fi-2880\li2880\tx2880main function in simple example:\tab {\uldb Rpcalc Main}{\v Rpcalc_Main}.\par}{\fi-2880\li2880\tx2880mid-rule actions:\tab {\uldb Mid-Rule Actions}{\v Mid_Rule_Actions}.\par}{\fi-2880\li2880\tx2880multi-character literal:\tab {\uldb Symbols}{\v Symbols}.\par}{\fi-2880\li2880\tx2880multi-function calculator:\tab {\uldb Multi-function Calc}{\v Multi_function_Calc}.\par}{\fi-2880\li2880\tx2880mutual recursion:\tab {\uldb Recursion}{\v Recursion}.\par}{\fi-2880\li2880\tx2880nonterminal symbol:\tab {\uldb Symbols}{\v Symbols}.\par}{\fi-2880\li2880\tx2880operator precedence:\tab {\uldb Precedence}{\v Precedence}.\par}{\fi-2880\li2880\tx2880operator precedence, declaring:\tab {\uldb Precedence Decl}{\v Precedence_Decl}.\par}{\fi-2880\li2880\tx2880options for invoking Bison:\tab {\uldb Invocation}{\v Invocation}.\par}{\fi-2880\li2880\tx2880overflow of parser stack:\tab {\uldb Stack Overflow}{\v Stack_Overflow}.\par}{\fi-2880\li2880\tx2880parse error:\tab {\uldb Error Reporting}{\v Error_Reporting}.\par}{\fi-2880\li2880\tx2880parser:\tab {\uldb Bison Parser}{\v Bison_Parser}.\par}{\fi-2880\li2880\tx2880parser stack:\tab {\uldb Algorithm}{\v Algorithm}.\par}{\fi-2880\li2880\tx2880parser stack overflow:\tab {\uldb Stack Overflow}{\v Stack_Overflow}.\par}{\fi-2880\li2880\tx2880parser state:\tab {\uldb Parser States}{\v Parser_States}.\par}{\fi-2880\li2880\tx2880polish notation calculator:\tab {\uldb RPN Calc}{\v RPN_Calc}.\par}{\fi-2880\li2880\tx2880precedence declarations:\tab {\uldb Precedence Decl}{\v Precedence_Decl}.\par}{\fi-2880\li2880\tx2880precedence of operators:\tab {\uldb Precedence}{\v Precedence}.\par}{\fi-2880\li2880\tx2880precedence, context-dependent:\tab {\uldb Contextual Precedence}{\v Contextual_Precedence}.\par}{\fi-2880\li2880\tx2880precedence, unary operator:\tab {\uldb Contextual Precedence}{\v Contextual_Precedence}.\par}{\fi-2880\li2880\tx2880preventing warnings about conflicts:\tab {\uldb Expect Decl}{\v Expect_Decl}.\par}{\fi-2880\li2880\tx2880pure parser:\tab {\uldb Pure Decl}{\v Pure_Decl}.\par}{\fi-2880\li2880\tx2880recovery from errors:\tab {\uldb Error Recovery}{\v Error_Recovery}.\par}{\fi-2880\li2880\tx2880recursive rule:\tab {\uldb Recursion}{\v Recursion}.\par}{\fi-2880\li2880\tx2880reduce/reduce conflict:\tab {\uldb Reduce/Reduce}{\v Reduce_Reduce}.\par}{\fi-2880\li2880\tx2880reduction:\tab {\uldb Algorithm}{\v Algorithm}.\par}{\fi-2880\li2880\tx2880reentrant parser:\tab {\uldb Pure Decl}{\v Pure_Decl}.\par}{\fi-2880\li2880\tx2880reverse polish notation:\tab {\uldb RPN Calc}{\v RPN_Calc}.\par}{\fi-2880\li2880\tx2880right recursion:\tab {\uldb Recursion}{\v Recursion}.\par}{\fi-2880\li2880\tx2880rule syntax:\tab {\uldb Rules}{\v Rules}.\par}{\fi-2880\li2880\tx2880rules section for grammar:\tab {\uldb Grammar Rules}{\v Grammar_Rules}.\par}{\fi-2880\li2880\tx2880running Bison (introduction):\tab {\uldb Rpcalc Gen}{\v Rpcalc_Gen}.\par}{\fi-2880\li2880\tx2880semantic actions:\tab {\uldb Semantic Actions}{\v Semantic_Actions}.\par}{\fi-2880\li2880\tx2880semantic value:\tab {\uldb Semantic Values}{\v Semantic_Values}.\par}{\fi-2880\li2880\tx2880semantic value type:\tab {\uldb Value Type}{\v Value_Type}.\par}{\fi-2880\li2880\tx2880shift/reduce conflicts:\tab {\uldb Shift/Reduce}{\v Shift_Reduce}.\par}{\fi-2880\li2880\tx2880shifting:\tab {\uldb Algorithm}{\v Algorithm}.\par}{\fi-2880\li2880\tx2880simple examples:\tab {\uldb Examples}{\v Examples}.\par}{\fi-2880\li2880\tx2880single-character literal:\tab {\uldb Symbols}{\v Symbols}.\par}{\fi-2880\li2880\tx2880stack overflow:\tab {\uldb Stack Overflow}{\v Stack_Overflow}.\par}{\fi-2880\li2880\tx2880stack, parser:\tab {\uldb Algorithm}{\v Algorithm}.\par}{\fi-2880\li2880\tx2880stages in using Bison:\tab {\uldb Stages}{\v Stages}.\par}{\fi-2880\li2880\tx2880start symbol:\tab {\uldb Language and Grammar}{\v Language_and_Grammar}.\par}{\fi-2880\li2880\tx2880start symbol, declaring:\tab {\uldb Start Decl}{\v Start_Decl}.\par}{\fi-2880\li2880\tx2880state (of parser):\tab {\uldb Parser States}{\v Parser_States}.\par}{\fi-2880\li2880\tx2880string token:\tab {\uldb Symbols}{\v Symbols}.\par}{\fi-2880\li2880\tx2880summary, action features:\tab {\uldb Action Features}{\v Action_Features}.\par}{\fi-2880\li2880\tx2880summary, Bison declaration:\tab {\uldb Decl Summary}{\v Decl_Summary}.\par}{\fi-2880\li2880\tx2880suppressing conflict warnings:\tab {\uldb Expect Decl}{\v Expect_Decl}.\par}{\fi-2880\li2880\tx2880symbol:\tab {\uldb Symbols}{\v Symbols}.\par}{\fi-2880\li2880\tx2880symbol table example:\tab {\uldb Mfcalc Symtab}{\v Mfcalc_Symtab}.\par}{\fi-2880\li2880\tx2880symbols (abstract):\tab {\uldb Language and Grammar}{\v Language_and_Grammar}.\par}{\fi-2880\li2880\tx2880symbols in Bison, table of:\tab {\uldb Table of Symbols}{\v Table_of_Symbols}.\par}{\fi-2880\li2880\tx2880syntactic grouping:\tab {\uldb Language and Grammar}{\v Language_and_Grammar}.\par}{\fi-2880\li2880\tx2880syntax error:\tab {\uldb Error Reporting}{\v Error_Reporting}.\par}{\fi-2880\li2880\tx2880syntax of grammar rules:\tab {\uldb Rules}{\v Rules}.\par}{\fi-2880\li2880\tx2880terminal symbol:\tab {\uldb Symbols}{\v Symbols}.\par}{\fi-2880\li2880\tx2880token:\tab {\uldb Language and Grammar}{\v Language_and_Grammar}.\par}{\fi-2880\li2880\tx2880token type:\tab {\uldb Symbols}{\v Symbols}.\par}{\fi-2880\li2880\tx2880token type names, declaring:\tab {\uldb Token Decl}{\v Token_Decl}.\par}{\fi-2880\li2880\tx2880tracing the parser:\tab {\uldb Debugging}{\v Debugging}.\par}{\fi-2880\li2880\tx2880unary operator precedence:\tab {\uldb Contextual Precedence}{\v Contextual_Precedence}.\par}{\fi-2880\li2880\tx2880using Bison:\tab {\uldb Stages}{\v Stages}.\par}{\fi-2880\li2880\tx2880value type, semantic:\tab {\uldb Value Type}{\v Value_Type}.\par}{\fi-2880\li2880\tx2880value types, declaring:\tab {\uldb Union Decl}{\v Union_Decl}.\par}{\fi-2880\li2880\tx2880value types, nonterminals, declaring:\tab {\uldb Type Decl}{\v Type_Decl}.\par}{\fi-2880\li2880\tx2880value, semantic:\tab {\uldb Semantic Values}{\v Semantic_Values}.\par}{\fi-2880\li2880\tx2880VMS:\tab {\uldb VMS Invocation}{\v VMS_Invocation}.\par}{\fi-2880\li2880\tx2880warnings, preventing:\tab {\uldb Expect Decl}{\v Expect_Decl}.\par}{\fi-2880\li2880\tx2880writing a lexical analyzer:\tab {\uldb Rpcalc Lexer}{\v Rpcalc_Lexer}.\par}{\fi-2880\li2880\tx2880YYABORT:\tab {\uldb Parser Function}{\v Parser_Function}.\par}{\fi-2880\li2880\tx2880YYACCEPT:\tab {\uldb Parser Function}{\v Parser_Function}.\par}{\fi-2880\li2880\tx2880YYBACKUP:\tab {\uldb Action Features}{\v Action_Features}.\par}{\fi-2880\li2880\tx2880yychar:\tab {\uldb Look-Ahead}{\v Look_Ahead}.\par}{\fi-2880\li2880\tx2880yyclearin:\tab {\uldb Error Recovery}{\v Error_Recovery}.\par}{\fi-2880\li2880\tx2880YYDEBUG:\tab {\uldb Debugging}{\v Debugging}.\par}{\fi-2880\li2880\tx2880yydebug:\tab {\uldb Debugging}{\v Debugging}.\par}{\fi-2880\li2880\tx2880YYEMPTY:\tab {\uldb Action Features}{\v Action_Features}.\par}{\fi-2880\li2880\tx2880yyerrok:\tab {\uldb Error Recovery}{\v Error_Recovery}.\par}{\fi-2880\li2880\tx2880yyerror:\tab {\uldb Error Reporting}{\v Error_Reporting}.\par}{\fi-2880\li2880\tx2880YYERROR:\tab {\uldb Action Features}{\v Action_Features}.\par}{\fi-2880\li2880\tx2880YYERROR_VERBOSE:\tab {\uldb Error Reporting}{\v Error_Reporting}.\par}{\fi-2880\li2880\tx2880YYINITDEPTH:\tab {\uldb Stack Overflow}{\v Stack_Overflow}.\par}{\fi-2880\li2880\tx2880yylex:\tab {\uldb Lexical}{\v Lexical}.\par}{\fi-2880\li2880\tx2880YYLEX_PARAM:\tab {\uldb Pure Calling}{\v Pure_Calling}.\par}{\fi-2880\li2880\tx2880yylloc:\tab {\uldb Token Positions}{\v Token_Positions}.\par}{\fi-2880\li2880\tx2880YYLTYPE:\tab {\uldb Token Positions}{\v Token_Positions}.\par}{\fi-2880\li2880\tx2880yylval:\tab {\uldb Token Values}{\v Token_Values}.\par}{\fi-2880\li2880\tx2880YYMAXDEPTH:\tab {\uldb Stack Overflow}{\v Stack_Overflow}.\par}{\fi-2880\li2880\tx2880yynerrs:\tab {\uldb Error Reporting}{\v Error_Reporting}.\par}{\fi-2880\li2880\tx2880yyparse:\tab {\uldb Parser Function}{\v Parser_Function}.\par}{\fi-2880\li2880\tx2880YYPARSE_PARAM:\tab {\uldb Pure Calling}{\v Pure_Calling}.\par}{\fi-2880\li2880\tx2880YYPRINT:\tab {\uldb Debugging}{\v Debugging}.\par}{\fi-2880\li2880\tx2880YYRECOVERING:\tab {\uldb Error Recovery}{\v Error_Recovery}.\par}{\fi-2880\li2880\tx2880{\f1{}calc}:\tab {\uldb Infix Calc}{\v Infix_Calc}.\par}{\fi-2880\li2880\tx2880{\f1{}else}, dangling:\tab {\uldb Shift/Reduce}{\v Shift_Reduce}.\par}{\fi-2880\li2880\tx2880{\f1{}mfcalc}:\tab {\uldb Multi-function Calc}{\v Multi_function_Calc}.\par}{\fi-2880\li2880\tx2880{\f1{}rpcalc}:\tab {\uldb RPN Calc}{\v RPN_Calc}.\par}{\fi-2880\li2880\tx2880|:\tab {\uldb Rules}{\v Rules}.\par}\page K{\footnote Makertf}#{\footnote hcMakertf}${\footnote \pard{}About Makertf}\pard{\fs24\b About Makertf}\par\par\pard{}Makertf is a program that converts "Texinfo" files into "Rich Text Format" (RTF) files. It can be used to make WinHelp Files from GNU manuals and other documentation written in Texinfo. Visit http://www.snafu.de/~cschenk/makertf for more information.}