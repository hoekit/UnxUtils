<!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>FLEX(1) manual page</TITLE>
</HEAD>
<BODY bgcolor=white>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">Name </A></H2>
flex - fast lexical analyzer generator  
<H2><A NAME="sect1" HREF="#toc1">Synopsis </A></H2>
<B>flex</B> <B>[-bcdfhilnpstvwBFILTV78+? 
-C[aefFmr] -ooutput -Pprefix -Sskeleton]</B> <B>[--help --version]</B> <I>[filename</I> ...]  
<H2><A NAME="sect2" HREF="#toc2">Overview 
</A></H2>
This manual describes <I>flex,</I> a tool for generating programs that perform 
pattern-matching on text.  The manual includes both tutorial and reference 
sections:  <BR>
 <PRE>  
      Description 
         a brief overview of the tool 
   
      Some Simple Examples 
   
      Format Of The Input File 
   
      Patterns 
         the extended regular expressions used by flex 
   
      How The Input Is Matched 
         the rules for determining what has been matched 
   
      Actions 
         how to specify what to do when a pattern is matched 
   
      The Generated Scanner 
         details regarding the scanner that flex produces; 
         how to control the input source 
   
      Start Conditions 
         introducing context into your scanners, and 
         managing "mini-scanners" 
   
      Multiple Input Buffers 
         how to manipulate multiple input sources; how to 
         scan from strings instead of files 
   
      End-of-file Rules 
         special rules for matching the end of the input 
   
      Miscellaneous Macros 
         a summary of macros available to the actions 
   
      Values Available To The User 
         a summary of values available to the actions 
   
      Interfacing With Yacc 
         connecting flex scanners together with yacc parsers 
   
      Options 
         flex command-line options, and the "%option" 
         directive 
   
      Performance Considerations 
         how to make your scanner go as fast as possible 
   
      Generating C++ Scanners 
         the (experimental) facility for generating C++ 
         scanner classes 
   
      Incompatibilities With Lex And POSIX 
         how flex differs from AT&amp;T lex and the POSIX lex 
         standard 
   
      Diagnostics 
         those error messages produced by flex (or scanners 
         it generates) whose meanings might not be apparent 
   
      Files 
         files used by flex 
   
      Deficiencies / Bugs 
         known problems with flex 
   
      See Also 
         other documentation, related tools 
   
      Author 
         includes contact information 
   
   </PRE> 
<H2><A NAME="sect3" HREF="#toc3">Description </A></H2>
<I>flex</I> is a tool for generating <I>scanners:</I> programs which 
recognized lexical patterns in text. <I>flex</I> reads the given input files, 
or its standard input if no file names are given, for a description of 
a scanner to generate.  The description is in the form of pairs of regular 
expressions and C code, called <I>rules.</I>  flex generates as output a C source 
file, <B>lex.yy.c,</B> which defines a routine <B>yylex().</B> This file is compiled and 
linked with the <B>-lfl</B> library to produce an executable.  When the executable 
is run, it analyzes its input for occurrences of the regular expressions. 
 Whenever it finds one, it executes the corresponding C code.  
<H2><A NAME="sect4" HREF="#toc4">Some Simple 
Examples </A></H2>
<P>
First some simple examples to get the flavor of how one uses 
<I>flex.</I> The following <I>flex</I> input specifies a scanner which whenever it encounters 
the string "username" will replace it with the user's login name:  <BR>
 <PRE>  
      %% 
     username    printf( "%s", getlogin() ); 
   
   </PRE>By default, any text not matched by a <I>flex</I> scanner is copied to 
the output, so the net effect of this scanner is to copy its input file 
to its output with each occurrence of "username" expanded. In this input, 
there is just one rule.  "username" is the <I>pattern</I> and the "printf" is 
the <I>action.</I> The "%%" marks the beginning of the rules. <P>
Here's another simple 
example:  <BR>
 <PRE>  
              int num_lines = 0, num_chars = 0; 
   
      %% 
     \n      ++num_lines; ++num_chars; 
     .       ++num_chars; 
   
      %% 
     main() 
             { 
             yylex(); 
             printf( "# of lines = %d, # of chars = %d\n", 
                     num_lines, num_chars ); 
             } 
   
   </PRE>This scanner counts the number of characters and the number of lines 
in its input (it produces no output other than the final report on the 
counts).  The first line declares two globals, "num_lines" and "num_chars", 
which are accessible both inside <B>yylex()</B> and in the <B>main()</B> routine declared 
after the second "%%".  There are two rules, one which matches a newline 
("\n") and increments both the line count and the character count, and 
one which matches any character other than a newline (indicated by the 
"." regular expression). <P>
A somewhat more complicated example:  <BR>
 <PRE>  
      /* scanner for a toy Pascal-like language */ 
   
      %{ 
     /* need this for the call to atof() below */ 
     #include &lt;math.h&gt; 
     %} 
   
      DIGIT    [0-9] 
     ID       [a-z][a-z0-9]* 
   
      %% 
   
      {DIGIT}+    { 
                 printf( "An integer: %s (%d)\n", yytext, 
                         atoi( yytext ) ); 
                 } 
   
      {DIGIT}+"."{DIGIT}*        { 
                 printf( "A float: %s (%g)\n", yytext, 
                         atof( yytext ) ); 
                 } 
   
      if|then|begin|end|procedure|function        { 
                 printf( "A keyword: %s\n", yytext ); 
                 } 
   
      {ID}        printf( "An identifier: %s\n", yytext ); 
   
      "+"|"-"|"*"|"/"   printf( "An operator: %s\n", yytext ); 
   
      "{"[^}\n]*"}"     /* eat up one-line comments */ 
   
      [ \t\n]+          /* eat up whitespace */ 
   
      .           printf( "Unrecognized character: %s\n", yytext ); 
   
      %% 
   
      main( argc, argv ) 
     int argc; 
     char **argv; 
         { 
         ++argv, --argc;  /* skip over program name */ 
         if ( argc &gt; 0 ) 
                 yyin = fopen( argv[0], "r" ); 
         else 
                 yyin = stdin; 
          
         yylex(); 
         } 
   
   </PRE>This is the beginnings of a simple scanner for a language like Pascal. 
 It identifies different types of <I>tokens</I> and reports on what it has seen. 
<P>
The details of this example will be explained in the following sections. 
 
<H2><A NAME="sect5" HREF="#toc5">Format of the Input File </A></H2>
The <I>flex</I> input file consists of three sections, 
separated by a line with just <B>%%</B> in it:  <BR>
 <PRE>  
      definitions 
     %% 
     rules 
     %% 
     user code 
   
   </PRE>The <I>definitions</I> section contains declarations of simple <I>name</I> definitions 
to simplify the scanner specification, and declarations of <I>start</I> conditions, 
which are explained in a later section. <P>
Name definitions have the form: 
 <BR>
 <PRE>  
      name definition 
   
   </PRE>The "name" is a word beginning with a letter or an underscore ('_') 
followed by zero or more letters, digits, '_', or '-' (dash). The definition 
is taken to begin at the first non-white-space character following the name 
and continuing to the end of the line. The definition can subsequently 
be referred to using "{name}", which will expand to "(definition)".  For 
example,  <BR>
 <PRE>  
      DIGIT    [0-9] 
     ID       [a-z][a-z0-9]* 
   
   </PRE>defines "DIGIT" to be a regular expression which matches a single 
digit, and "ID" to be a regular expression which matches a letter followed 
by zero-or-more letters-or-digits. A subsequent reference to  <BR>
 <PRE>  
      {DIGIT}+"."{DIGIT}* 
   
   </PRE>is identical to  <BR>
 <PRE>  
      ([0-9])+"."([0-9])* 
   
   </PRE>and matches one-or-more digits followed by a '.' followed by zero-or-more 
digits. <P>
The <I>rules</I> section of the <I>flex</I> input contains a series of rules 
of the form:  <BR>
 <PRE>  
      pattern   action 
   
   </PRE>where the pattern must be unindented and the action must begin on 
the same line. <P>
See below for a further description of patterns and actions. 
<P>
Finally, the user code section is simply copied to <B>lex.yy.c</B> verbatim. It 
is used for companion routines which call or are called by the scanner. 
 The presence of this section is optional; if it is missing, the second 
<B>%%</B> in the input file may be skipped, too. <P>
In the definitions and rules 
sections, any <I>indented</I> text or text enclosed in <B>%{</B> and <B>%}</B> is copied verbatim 
to the output (with the %{}'s removed). The %{}'s must appear unindented 
on lines by themselves. <P>
In the rules section, any indented or %{} text 
appearing before the first rule may be used to declare variables which 
are local to the scanning routine and (after the declarations) code which 
is to be executed whenever the scanning routine is entered. Other indented 
or %{} text in the rule section is still copied to the output, but its 
meaning is not well-defined and it may well cause compile-time errors (this 
feature is present for <I>POSIX</I> compliance; see below for other such features). 
<P>
In the definitions section (but not in the rules section), an unindented 
comment (i.e., a line beginning with "/*") is also copied verbatim to the 
output up to the next "*/".  
<H2><A NAME="sect6" HREF="#toc6">Patterns </A></H2>
The patterns in the input are written 
using an extended set of regular expressions.  These are:  <BR>
 <PRE>  
      x          match the character 'x' 
     .          any character (byte) except newline 
     [xyz]      a "character class"; in this case, the pattern 
                  matches either an 'x', a 'y', or a 'z' 
     [abj-oZ]   a "character class" with a range in it; matches 
                  an 'a', a 'b', any letter from 'j' through 'o', 
                  or a 'Z' 
     [^A-Z]     a "negated character class", i.e., any character 
                  but those in the class.  In this case, any 
                  character EXCEPT an uppercase letter. 
     [^A-Z\n]   any character EXCEPT an uppercase letter or 
                  a newline 
     r*         zero or more r's, where r is any regular expression 
     r+         one or more r's 
     r?         zero or one r's (that is, "an optional r") 
     r{2,5}     anywhere from two to five r's 
     r{2,}      two or more r's 
     r{4}       exactly 4 r's 
     {name}     the expansion of the "name" definition 
                (see above) 
     "[xyz]\"foo" 
                the literal string: [xyz]"foo 
     \X         if X is an 'a', 'b', 'f', 'n', 'r', 't', or 'v', 
                  then the ANSI-C interpretation of \x. 
                  Otherwise, a literal 'X' (used to escape 
                  operators such as '*') 
     \0         a NUL character (ASCII code 0) 
     \123       the character with octal value 123 
     \x2a       the character with hexadecimal value 2a 
     (r)        match an r; parentheses are used to override 
                  precedence (see below) 
   
  
      rs         the regular expression r followed by the 
                  regular expression s; called "concatenation" 
   
  
      r|s        either an r or an s 
   
  
      r/s        an r but only if it is followed by an s.  The 
                  text matched by s is included when determining 
                  whether this rule is the "longest match", 
                  but is then returned to the input before 
                  the action is executed.  So the action only 
                  sees the text matched by r.  This type 
                  of pattern is called trailing context". 
                  (There are some combinations of r/s that flex 
                  cannot match correctly; see notes in the 
                  Deficiencies / Bugs section below regarding 
                  "dangerous trailing context".) 
     ^r         an r, but only at the beginning of a line (i.e., 
                  which just starting to scan, or right after a 
                  newline has been scanned). 
     r$         an r, but only at the end of a line (i.e., just 
                  before a newline).  Equivalent to "r/\n". 
   
                 Note that flex's notion of "newline" is exactly 
                whatever the C compiler used to compile flex 
                interprets '\n' as; in particular, on some DOS 
                systems you must either filter out \r's in the 
                input yourself, or explicitly use r/\r\n for "r$". 
   
  
      &lt;s&gt;r       an r, but only in start condition s (see 
                  below for discussion of start conditions) 
     &lt;s1,s2,s3&gt;r 
                same, but in any of start conditions s1, 
                  s2, or s3 
     &lt;*&gt;r       an r in any start condition, even an exclusive one. 
   
  
      &lt;&lt;EOF&gt;&gt;    an end-of-file 
     &lt;s1,s2&gt;&lt;&lt;EOF&gt;&gt; 
                an end-of-file when in start condition s1 or s2 
   
   </PRE>Note that inside of a character class, all regular expression operators 
lose their special meaning except escape ('\') and the character class operators, 
'-', ']', and, at the beginning of the class, '^'. <P>
The regular expressions listed 
above are grouped according to precedence, from highest precedence at 
the top to lowest at the bottom. Those grouped together have equal precedence. 
 For example,  <BR>
 <PRE>  
      foo|bar* 
   
   </PRE>is the same as  <BR>
 <PRE>  
      (foo)|(ba(r*)) 
   
   </PRE>since the '*' operator has higher precedence than concatenation, and 
concatenation higher than alternation ('|').  This pattern therefore matches 
<I>either</I> the string "foo" <I>or</I> the string "ba" followed by zero-or-more r's. To 
match "foo" or zero-or-more "bar"'s, use:  <BR>
 <PRE>  
      foo|(bar)* 
   
   </PRE>and to match zero-or-more "foo"'s-or-"bar"'s:  <BR>
 <PRE>  
      (foo|bar)* 
   
   </PRE><P>
In addition to characters and ranges of characters, character classes 
can also contain character class <I>expressions.</I> These are expressions enclosed 
inside <B>[:</B> and <B>:]</B> delimiters (which themselves must appear between the 
'[' and ']' of the character class; other elements may occur inside the character 
class, too). The valid expressions are:  <BR>
 <PRE>  
      [:alnum:] [:alpha:] [:blank:] 
     [:cntrl:] [:digit:] [:graph:] 
     [:lower:] [:print:] [:punct:] 
     [:space:] [:upper:] [:xdigit:] 
   
   </PRE>These expressions all designate a set of characters equivalent to 
the corresponding standard C <B>isXXX</B> function.  For example, <B>[:alnum:]</B> designates 
those characters for which <B>isalnum()</B> returns true - i.e., any alphabetic 
or numeric. Some systems don't provide <B>isblank(),</B> so flex defines <B>[:blank:]</B> 
as a blank or a tab. <P>
For example, the following character classes are all 
equivalent:  <BR>
 <PRE>  
      [[:alnum:]] 
     [[:alpha:][:digit:] 
     [[:alpha:]0-9] 
     [a-zA-Z0-9] 
   
   </PRE>If your scanner is case-insensitive (the <B>-i</B> flag), then <B>[:upper:]</B> 
and <B>[:lower:]</B> are equivalent to <B>[:alpha:].</B> <P>
Some notes on patterns: 
<DL>

<DT>- </DT>
<DD>A negated 
character class such as the example "[^A-Z]" above <I>will</I> match a newline 
unless "\n" (or an equivalent escape sequence) is one of the characters 
explicitly present in the negated character class (e.g., "[^A-Z\n]").  This 
is unlike how many other regular expression tools treat negated character 
classes, but unfortunately the inconsistency is historically entrenched. 
Matching newlines means that a pattern like [^"]* can match the entire 
input unless there's another quote in the input. </DD>

<DT>- </DT>
<DD>A rule can have at most 
one instance of trailing context (the '/' operator or the '$' operator).  The 
start condition, '^', and "&lt;&lt;EOF&gt;&gt;" patterns can only occur at the beginning 
of a pattern, and, as well as with '/' and '$', cannot be grouped inside parentheses. 
 A '^' which does not occur at the beginning of a rule or a '$' which does 
not occur at the end of a rule loses its special properties and is treated 
as a normal character. </DD>

<DT>The following are illegal:  </DT>
<DD> <BR>
 <PRE>  
      foo/bar$ 
     &lt;sc1&gt;foo&lt;sc2&gt;bar 
   
   </PRE>Note that the first of these, can be written "foo/bar\n". </DD>

<DT>The following 
will result in '$' or '^' being treated as a normal character:  </DT>
<DD> <BR>
 <PRE>  
      foo|(bar$) 
     foo|^bar 
   
   </PRE>If what's wanted is a "foo" or a bar-followed-by-a-newline, the following 
could be used (the special '|' action is explained below):  <BR>
 <PRE>  
      foo      | 
     bar$     /* action goes here */ 
   
   </PRE>A similar trick will work for matching a foo or a bar-at-the-beginning-of-a-line. 
</DD>
</DL>
 
<H2><A NAME="sect7" HREF="#toc7">How the Input is Matched </A></H2>
When the generated scanner is run, it analyzes 
its input looking for strings which match any of its patterns.  If it finds 
more than one match, it takes the one matching the most text (for trailing 
context rules, this includes the length of the trailing part, even though 
it will then be returned to the input).  If it finds two or more matches 
of the same length, the rule listed first in the <I>flex</I> input file is chosen. 
<P>
Once the match is determined, the text corresponding to the match (called 
the <I>token)</I> is made available in the global character pointer <B>yytext,</B> and 
its length in the global integer <B>yyleng.</B> The <I>action</I> corresponding to the 
matched pattern is then executed (a more detailed description of actions 
follows), and then the remaining input is scanned for another match. <P>
If 
no match is found, then the <I>default</I> rule is executed: the next character 
in the input is considered matched and copied to the standard output.  
Thus, the simplest legal <I>flex</I> input is:  <BR>
 <PRE>  
      %% 
   
   </PRE>which generates a scanner that simply copies its input (one character 
at a time) to its output. <P>
Note that <B>yytext</B> can be defined in two different 
ways: either as a character <I>pointer</I> or as a character <I>array.</I> You can control 
which definition <I>flex</I> uses by including one of the special directives 
<B>%pointer</B> or <B>%array</B> in the first (definitions) section of your flex input. 
 The default is <B>%pointer,</B> unless you use the <B>-l</B> lex compatibility option, 
in which case <B>yytext</B> will be an array. The advantage of using <B>%pointer</B> 
is substantially faster scanning and no buffer overflow when matching 
very large tokens (unless you run out of dynamic memory).  The disadvantage 
is that you are restricted in how your actions can modify <B>yytext</B> (see 
the next section), and calls to the <B>unput()</B> function destroys the present 
contents of <B>yytext,</B> which can be a considerable porting headache when 
moving between different <I>lex</I> versions. <P>
The advantage of <B>%array</B> is that 
you can then modify <B>yytext</B> to your heart's content, and calls to <B>unput()</B> 
do not destroy <B>yytext</B> (see below).  Furthermore, existing <I>lex</I> programs 
sometimes access <B>yytext</B> externally using declarations of the form:  <BR>
 <PRE>    extern char yytext[]; 
  </PRE>This definition is erroneous when used with <B>%pointer,</B> but correct for 
<B>%array.</B> <P>
<B>%array</B> defines <B>yytext</B> to be an array of <B>YYLMAX</B> characters, which 
defaults to a fairly large value.  You can change the size by simply #define'ing 
<B>YYLMAX</B> to a different value in the first section of your <I>flex</I> input.  As 
mentioned above, with <B>%pointer</B> yytext grows dynamically to accommodate 
large tokens.  While this means your <B>%pointer</B> scanner can accommodate very 
large tokens (such as matching entire blocks of comments), bear in mind 
that each time the scanner must resize <B>yytext</B> it also must rescan the 
entire token from the beginning, so matching such tokens can prove slow. 
<B>yytext</B> presently does <I>not</I> dynamically grow if a call to <B>unput()</B> results 
in too much text being pushed back; instead, a run-time error results. <P>
Also 
note that you cannot use <B>%array</B> with C++ scanner classes (the <B>c++</B> option; 
see below).  
<H2><A NAME="sect8" HREF="#toc8">Actions </A></H2>
Each pattern in a rule has a corresponding action, 
which can be any arbitrary C statement.  The pattern ends at the first 
non-escaped whitespace character; the remainder of the line is its action. 
 If the action is empty, then when the pattern is matched the input token 
is simply discarded.  For example, here is the specification for a program 
which deletes all occurrences of "zap me" from its input:  <BR>
 <PRE>  
      %% 
     "zap me" 
   
   </PRE>(It will copy all other characters in the input to the output since 
they will be matched by the default rule.) <P>
Here is a program which compresses 
multiple blanks and tabs down to a single blank, and throws away whitespace 
found at the end of a line:  <BR>
 <PRE>  
      %% 
     [ \t]+        putchar( ' ' ); 
     [ \t]+$       /* ignore this token */ 
   
   </PRE><P>
If the action contains a '{', then the action spans till the balancing 
'}' is found, and the action may cross multiple lines. <I>flex</I>  knows about 
C strings and comments and won't be fooled by braces found within them, 
but also allows actions to begin with <B>%{</B> and will consider the action 
to be all the text up to the next <B>%}</B> (regardless of ordinary braces inside 
the action). <P>
An action consisting solely of a vertical bar ('|') means "same 
as the action for the next rule."  See below for an illustration. <P>
Actions 
can include arbitrary C code, including <B>return</B> statements to return a 
value to whatever routine called <B>yylex().</B> Each time <B>yylex()</B> is called it 
continues processing tokens from where it last left off until it either 
reaches the end of the file or executes a return. <P>
Actions are free to modify 
<B>yytext</B> except for lengthening it (adding characters to its end--these will 
overwrite later characters in the input stream).  This however does not 
apply when using <B>%array</B> (see above); in that case, <B>yytext</B> may be freely 
modified in any way. <P>
Actions are free to modify <B>yyleng</B> except they should 
not do so if the action also includes use of <B>yymore()</B> (see below). <P>
There 
are a number of special directives which can be included within an action: 

<DL>

<DT>- </DT>
<DD><B>ECHO</B> copies yytext to the scanner's output. </DD>

<DT>- </DT>
<DD><B>BEGIN</B> followed by the name 
of a start condition places the scanner in the corresponding start condition 
(see below). </DD>

<DT>- </DT>
<DD><B>REJECT</B> directs the scanner to proceed on to the "second best" 
rule which matched the input (or a prefix of the input).  The rule is chosen 
as described above in "How the Input is Matched", and <B>yytext</B> and <B>yyleng</B> 
set up appropriately. It may either be one which matched as much text as 
the originally chosen rule but came later in the <I>flex</I> input file, or one 
which matched less text. For example, the following will both count the 
words in the input and call the routine special() whenever "frob" is seen: 
 <BR>
 <PRE>  
              int word_count = 0; 
     %% 
   
      frob        special(); REJECT; 
     [^ \t\n]+   ++word_count; 
   
   </PRE>Without the <B>REJECT,</B> any "frob"'s in the input would not be counted 
as words, since the scanner normally executes only one action per token. 
Multiple <B>REJECT's</B> are allowed, each one finding the next best choice to 
the currently active rule.  For example, when the following scanner scans 
the token "abcd", it will write "abcdabcaba" to the output:  <BR>
 <PRE>  
      %% 
     a        | 
     ab       | 
     abc      | 
     abcd     ECHO; REJECT; 
     .|\n     /* eat up any unmatched character */ 
   
   </PRE>(The first three rules share the fourth's action since they use the 
special '|' action.) <B>REJECT</B> is a particularly expensive feature in terms of 
scanner performance; if it is used in <I>any</I> of the scanner's actions it will 
slow down <I>all</I> of the scanner's matching.  Furthermore, <B>REJECT</B> cannot be 
used with the <I>-Cf</I> or <I>-CF</I> options (see below). </DD>

<DT>Note also that unlike the other 
special actions,  </DT>
<DD><B>REJECT</B> is a <I>branch;</I> code immediately following it in 
the action will <I>not</I> be executed. </DD>

<DT>- </DT>
<DD><B>yymore()</B> tells the scanner that the next 
time it matches a rule, the corresponding token should be <I>appended</I> onto 
the current value of <B>yytext</B> rather than replacing it.  For example, given 
the input "mega-kludge" the following will write "mega-mega-kludge" to the 
output:  <BR>
 <PRE>  
      %% 
     mega-    ECHO; yymore(); 
     kludge   ECHO; 
   
   </PRE>First "mega-" is matched and echoed to the output.  Then "kludge" 
is matched, but the previous "mega-" is still hanging around at the beginning 
of <B>yytext</B> so the <B>ECHO</B> for the "kludge" rule will actually write "mega-kludge". 
</DD>
</DL>
<P>
Two notes regarding use of <B>yymore().</B> First, <B>yymore()</B> depends on the value 
of <I>yyleng</I> correctly reflecting the size of the current token, so you must 
not modify <I>yyleng</I> if you are using <B>yymore().</B> Second, the presence of <B>yymore()</B> 
in the scanner's action entails a minor performance penalty in the scanner's 
matching speed. 
<DL>

<DT>- </DT>
<DD><B><A HREF="s">yyless(n)</B></A>
 returns all but the first <I>n</I> characters of the 
current token back to the input stream, where they will be rescanned when 
the scanner looks for the next match. <B>yytext</B> and <B>yyleng</B> are adjusted appropriately 
(e.g., <B>yyleng</B> will now be equal to <I>n</I> ).  For example, on the input "foobar" 
the following will write out "foobarbar":  <BR>
 <PRE>  
      %% 
     foobar    ECHO; yyless(3); 
     [a-z]+    ECHO; 
   
   </PRE>An argument of 0 to <B>yyless</B> will cause the entire current input string 
to be scanned again.  Unless you've changed how the scanner will subsequently 
process its input (using <B>BEGIN,</B> for example), this will result in an endless 
loop. </DD>
</DL>
<P>
Note that <B>yyless</B> is a macro and can only be used in the flex input 
file, not from other source files. 
<DL>

<DT>- </DT>
<DD><B>unput(c)</B> puts the character <I>c</I> back 
onto the input stream.  It will be the next character scanned. The following 
action will take the current token and cause it to be rescanned enclosed 
in parentheses.  <BR>
 <PRE>  
      { 
     int i; 
     /* Copy yytext because unput() trashes yytext */ 
     char *yycopy = strdup( yytext ); 
     unput( ')' ); 
     for ( i = yyleng - 1; i &gt;= 0; --i ) 
         unput( yycopy[i] ); 
     unput( '(' ); 
     free( yycopy ); 
     } 
   
   </PRE>Note that since each <B>unput()</B> puts the given character back at the 
<I>beginning</I> of the input stream, pushing back strings must be done back-to-front. 
</DD>
</DL>
<P>
An important potential problem when using <B>unput()</B> is that if you are using 
<B>%pointer</B> (the default), a call to <B>unput()</B> <I>destroys</I> the contents of <I>yytext,</I> 
starting with its rightmost character and devouring one character to the 
left with each call.  If you need the value of yytext preserved after a 
call to <B>unput()</B> (as in the above example), you must either first copy 
it elsewhere, or build your scanner using <B>%array</B> instead (see How The 
Input Is Matched). <P>
Finally, note that you cannot put back <B>EOF</B> to attempt 
to mark the input stream with an end-of-file. 
<DL>

<DT>- </DT>
<DD><B>input()</B> reads the next character 
from the input stream.  For example, the following is one way to eat up 
C comments:  <BR>
 <PRE>  
      %% 
     "/*"        { 
                 register int c; 
   
                  for ( ; ; ) 
                     { 
                     while ( (c = input()) != '*' &amp;&amp; 
                             c != EOF ) 
                         ;    /* eat up text of comment */ 
   
                      if ( c == '*' ) 
                         { 
                         while ( (c = input()) == '*' ) 
                             ; 
                         if ( c == '/' ) 
                             break;    /* found the end */ 
                         } 
   
                      if ( c == EOF ) 
                         { 
                         error( "EOF in comment" ); 
                         break; 
                         } 
                     } 
                 } 
   
   </PRE>(Note that if the scanner is compiled using <B>C++,</B> then <B>input()</B> is 
instead referred to as <B>yyinput(),</B> in order to avoid a name clash with 
the <B>C++</B> stream by the name of <I>input.)</I> </DD>

<DT>- </DT>
<DD><B>YY_FLUSH_BUFFER</B> flushes the scanner's 
internal buffer so that the next time the scanner attempts to match a 
token, it will first refill the buffer using <B>YY_INPUT</B> (see The Generated 
Scanner, below).  This action is a special case of the more general <B>yy_flush_buffer()</B> 
function, described below in the section Multiple Input Buffers. </DD>

<DT>- </DT>
<DD><B>yyterminate()</B> 
can be used in lieu of a return statement in an action.  It terminates 
the scanner and returns a 0 to the scanner's caller, indicating "all done". 
By default, <B>yyterminate()</B> is also called when an end-of-file is encountered. 
 It is a macro and may be redefined. </DD>
</DL>
 
<H2><A NAME="sect9" HREF="#toc9">the Generated Scanner </A></H2>
The output 
of <I>flex</I> is the file <B>lex.yy.c,</B> which contains the scanning routine <B>yylex(),</B> 
a number of tables used by it for matching tokens, and a number of auxiliary 
routines and macros.  By default, <B>yylex()</B> is declared as follows:  <BR>
 <PRE>  
      int yylex() 
         { 
         ... various definitions and the actions in here ... 
         } 
   
   </PRE>(If your environment supports function prototypes, then it will 
be "int yylex( void )".)  This definition may be changed by defining the 
"YY_DECL" macro.  For example, you could use:  <BR>
 <PRE>  
      #define YY_DECL float lexscan( a, b ) float a, b; 
   
   </PRE>to give the scanning routine the name <I>lexscan,</I> returning a float, 
and taking two floats as arguments.  Note that if you give arguments to 
the scanning routine using a K&amp;R-style/non-prototyped function declaration, 
you must terminate the definition with a semi-colon (;). <P>
Whenever <B>yylex()</B> 
is called, it scans tokens from the global input file <I>yyin</I> (which defaults 
to stdin).  It continues until it either reaches an end-of-file (at which 
point it returns the value 0) or one of its actions executes a <I>return</I> 
statement. <P>
If the scanner reaches an end-of-file, subsequent calls are undefined 
unless either <I>yyin</I> is pointed at a new input file (in which case scanning 
continues from that file), or <B>yyrestart()</B> is called. <B>yyrestart()</B> takes 
one argument, a <B>FILE *</B> pointer (which can be nil, if you've set up <B>YY_INPUT</B> 
to scan from a source other than <I>yyin),</I> and initializes <I>yyin</I> for scanning 
from that file.  Essentially there is no difference between just assigning 
<I>yyin</I> to a new input file or using <B>yyrestart()</B> to do so; the latter is 
available for compatibility with previous versions of <I>flex,</I> and because 
it can be used to switch input files in the middle of scanning. It can 
also be used to throw away the current input buffer, by calling it with 
an argument of <I>yyin;</I> but better is to use <B>YY_FLUSH_BUFFER</B> (see above). 
Note that <B>yyrestart()</B> does <I>not</I> reset the start condition to <B>INITIAL</B> (see 
Start Conditions, below). <P>
If <B>yylex()</B> stops scanning due to executing a 
<I>return</I> statement in one of the actions, the scanner may then be called 
again and it will resume scanning where it left off. <P>
By default (and for 
purposes of efficiency), the scanner uses block-reads rather than simple 
<I>getc()</I> calls to read characters from <I>yyin.</I> The nature of how it gets its 
input can be controlled by defining the <B>YY_INPUT</B> macro. YY_INPUT's calling 
sequence is "YY_INPUT(buf,result,max_size)".  Its action is to place up 
to <I>max_size</I> characters in the character array <I>buf</I> and return in the integer 
variable <I>result</I> either the number of characters read or the constant YY_NULL 
(0 on Unix systems) to indicate EOF.  The default YY_INPUT reads from the 
global file-pointer "yyin". <P>
A sample definition of YY_INPUT (in the definitions 
section of the input file):  <BR>
 <PRE>  
      %{ 
     #define YY_INPUT(buf,result,max_size) \ 
         { \ 
         int c = getchar(); \ 
         result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \ 
         } 
     %} 
   
   </PRE>This definition will change the input processing to occur one character 
at a time. <P>
When the scanner receives an end-of-file indication from YY_INPUT, 
it then checks the <B>yywrap()</B> function.  If <B>yywrap()</B> returns false (zero), 
then it is assumed that the function has gone ahead and set up <I>yyin</I> to 
point to another input file, and scanning continues.  If it returns true 
(non-zero), then the scanner terminates, returning 0 to its caller.  Note 
that in either case, the start condition remains unchanged; it does <I>not</I> 
revert to <B>INITIAL.</B> <P>
If you do not supply your own version of <B>yywrap(),</B> then 
you must either use <B>%option noyywrap</B> (in which case the scanner behaves 
as though <B>yywrap()</B> returned 1), or you must link with <B>-lfl</B> to obtain the 
default version of the routine, which always returns 1. <P>
Three routines 
are available for scanning from in-memory buffers rather than files: <B>yy_scan_string(), 
yy_scan_bytes(),</B> and <B>yy_scan_buffer().</B> See the discussion of them below 
in the section Multiple Input Buffers. <P>
The scanner writes its <B>ECHO</B> output 
to the <I>yyout</I> global (default, stdout), which may be redefined by the user 
simply by assigning it to some other <B>FILE</B> pointer.  
<H2><A NAME="sect10" HREF="#toc10">Start Conditions </A></H2>
<I>flex</I> 
provides a mechanism for conditionally activating rules.  Any rule whose 
pattern is prefixed with "&lt;sc&gt;" will only be active when the scanner is 
in the start condition named "sc".  For example,  <BR>
 <PRE>  
      &lt;STRING&gt;[^"]*        { /* eat up the string body ... */ 
                 ... 
                 } 
   
   </PRE>will be active only when the scanner is in the "STRING" start condition, 
and  <BR>
 <PRE>  
      &lt;INITIAL,STRING,QUOTE&gt;\.        { /* handle an escape ... */ 
                 ... 
                 } 
   
   </PRE>will be active only when the current start condition is either "INITIAL", 
"STRING", or "QUOTE". <P>
Start conditions are declared in the definitions 
(first) section of the input using unindented lines beginning with either 
<B>%s</B> or <B>%x</B> followed by a list of names. The former declares <I>inclusive</I> start 
conditions, the latter <I>exclusive</I> start conditions.  A start condition is 
activated using the <B>BEGIN</B> action.  Until the next <B>BEGIN</B> action is executed, 
rules with the given start condition will be active and rules with other 
start conditions will be inactive. If the start condition is <I>inclusive,</I> 
then rules with no start conditions at all will also be active. If it is 
<I>exclusive,</I> then <I>only</I> rules qualified with the start condition will be 
active. A set of rules contingent on the same exclusive start condition 
describe a scanner which is independent of any of the other rules in the 
<I>flex</I> input.  Because of this, exclusive start conditions make it easy to 
specify "mini-scanners" which scan portions of the input that are syntactically 
different from the rest (e.g., comments). <P>
If the distinction between inclusive 
and exclusive start conditions is still a little vague, here's a simple 
example illustrating the connection between the two.  The set of rules: 
 <BR>
 <PRE>  
      %s example 
     %% 
   
      &lt;example&gt;foo   do_something(); 
   
      bar            something_else(); 
   
   </PRE>is equivalent to  <BR>
 <PRE>  
      %x example 
     %% 
   
      &lt;example&gt;foo   do_something(); 
   
      &lt;INITIAL,example&gt;bar    something_else(); 
   
   </PRE>Without the <B>&lt;INITIAL,example&gt;</B> qualifier, the <I>bar</I> pattern in the second 
example wouldn't be active (i.e., couldn't match) when in start condition 
<B>example.</B> If we just used <B>&lt;example&gt;</B> to qualify <I>bar,</I> though, then it would 
only be active in <B>example</B> and not in <B>INITIAL,</B> while in the first example 
it's active in both, because in the first example the <B>example</B> startion 
condition is an <I>inclusive</I> <B>(%s)</B> start condition. <P>
Also note that the special 
start-condition specifier <B>&lt;*&gt;</B> matches every start condition.  Thus, the above 
example could also have been written;  <BR>
 <PRE>  
      %x example 
     %% 
   
      &lt;example&gt;foo   do_something(); 
   
      &lt;*&gt;bar    something_else(); 
   
   </PRE><P>
The default rule (to <B>ECHO</B> any unmatched character) remains active 
in start conditions.  It is equivalent to:  <BR>
 <PRE>  
      &lt;*&gt;.|\n     ECHO; 
   
   </PRE><P>
<B>BEGIN(0)</B> returns to the original state where only the rules with 
no start conditions are active.  This state can also be referred to as 
the start-condition "INITIAL", so <B>BEGIN(INITIAL)</B> is equivalent to <B>BEGIN(0).</B> 
(The parentheses around the start condition name are not required but 
are considered good style.) <P>
<B>BEGIN</B> actions can also be given as indented 
code at the beginning of the rules section.  For example, the following 
will cause the scanner to enter the "SPECIAL" start condition whenever 
<B>yylex()</B> is called and the global variable <I>enter_special</I> is true:  <BR>
 <PRE>  
              int enter_special; 
   
      %x SPECIAL 
     %% 
             if ( enter_special ) 
                 BEGIN(SPECIAL); 
   
      &lt;SPECIAL&gt;blahblahblah 
     ...more rules follow... 
   
   </PRE><P>
To illustrate the uses of start conditions, here is a scanner which 
provides two different interpretations of a string like "123.456".  By default 
it will treat it as three tokens, the integer "123", a dot ('.'), and the 
integer "456". But if the string is preceded earlier in the line by the 
string "expect-floats" it will treat it as a single token, the floating-point 
number 123.456:  <BR>
 <PRE>  
      %{ 
     #include &lt;math.h&gt; 
     %} 
     %s expect 
   
      %% 
     expect-floats        BEGIN(expect); 
   
      &lt;expect&gt;[0-9]+"."[0-9]+      { 
                 printf( "found a float, = %f\n", 
                         atof( yytext ) ); 
                 } 
     &lt;expect&gt;\n           { 
                 /* that's the end of the line, so 
                  * we need another "expect-number" 
                  * before we'll recognize any more 
                  * numbers 
                  */ 
                 BEGIN(INITIAL); 
                 } 
   
      [0-9]+      { 
                 printf( "found an integer, = %d\n", 
                         atoi( yytext ) ); 
                 } 
   
      "."         printf( "found a dot\n" ); 
   
   </PRE>Here is a scanner which recognizes (and discards) C comments while 
maintaining a count of the current input line.  <BR>
 <PRE>  
      %x comment 
     %% 
             int line_num = 1; 
   
      "/*"         BEGIN(comment); 
   
      &lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */ 
     &lt;comment&gt;"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */ 
     &lt;comment&gt;\n             ++line_num; 
     &lt;comment&gt;"*"+"/"        BEGIN(INITIAL); 
   
   </PRE>This scanner goes to a bit of trouble to match as much text as possible 
with each rule.  In general, when attempting to write a high-speed scanner 
try to match as much possible in each rule, as it's a big win. <P>
Note that 
start-conditions names are really integer values and can be stored as such. 
 Thus, the above could be extended in the following fashion:  <BR>
 <PRE>  
      %x comment foo 
     %% 
             int line_num = 1; 
             int comment_caller; 
   
      "/*"         { 
                  comment_caller = INITIAL; 
                  BEGIN(comment); 
                  } 
   
      ... 
   
      &lt;foo&gt;"/*"    { 
                  comment_caller = foo; 
                  BEGIN(comment); 
                  } 
   
      &lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */ 
     &lt;comment&gt;"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */ 
     &lt;comment&gt;\n             ++line_num; 
     &lt;comment&gt;"*"+"/"        BEGIN(comment_caller); 
   
   </PRE>Furthermore, you can access the current start condition using the 
integer-valued <B>YY_START</B> macro.  For example, the above assignments to <I>comment_caller</I> 
could instead be written  <BR>
 <PRE>  
      comment_caller = YY_START; 
   
   </PRE>Flex provides <B>YYSTATE</B> as an alias for <B>YY_START</B> (since that is what's 
used by AT&amp;T <I>lex).</I> <P>
Note that start conditions do not have their own name-space; 
%s's and %x's declare names in the same fashion as #define's. <P>
Finally, here's 
an example of how to match C-style quoted strings using exclusive start 
conditions, including expanded escape sequences (but not including checking 
for a string that's too long):  <BR>
 <PRE>  
      %x str 
   
      %% 
             char string_buf[MAX_STR_CONST]; 
             char *string_buf_ptr; 
   
  
      \"      string_buf_ptr = string_buf; BEGIN(str); 
   
      &lt;str&gt;\"        { /* saw closing quote - all done */ 
             BEGIN(INITIAL); 
             *string_buf_ptr = '\0'; 
             /* return string constant token type and 
              * value to parser 
              */ 
             } 
   
      &lt;str&gt;\n        { 
             /* error - unterminated string constant */ 
             /* generate error message */ 
             } 
   
      &lt;str&gt;\\[0-7]{1,3} { 
             /* octal escape sequence */ 
             int result; 
   
              (void) sscanf( yytext + 1, "%o", &amp;result ); 
   
              if ( result &gt; 0xff ) 
                     /* error, constant is out-of-bounds */ 
   
              *string_buf_ptr++ = result; 
             } 
   
      &lt;str&gt;\\[0-9]+ { 
             /* generate error - bad escape sequence; something 
              * like '\48' or '\0777777' 
              */ 
             } 
   
      &lt;str&gt;\\n  *string_buf_ptr++ = '\n'; 
     &lt;str&gt;\\t  *string_buf_ptr++ = '\t'; 
     &lt;str&gt;\\r  *string_buf_ptr++ = '\r'; 
     &lt;str&gt;\\b  *string_buf_ptr++ = '\b'; 
     &lt;str&gt;\\f  *string_buf_ptr++ = '\f'; 
   
      &lt;str&gt;\\(.|\n)  *string_buf_ptr++ = yytext[1]; 
   
      &lt;str&gt;[^\\\n\"]+        { 
             char *yptr = yytext; 
   
              while ( *yptr ) 
                     *string_buf_ptr++ = *yptr++; 
             } 
   
   </PRE><P>
Often, such as in some of the examples above, you wind up writing 
a whole bunch of rules all preceded by the same start condition(s).  Flex 
makes this a little easier and cleaner by introducing a notion of start 
condition <I>scope.</I> A start condition scope is begun with:  <BR>
 <PRE>  
      &lt;SCs&gt;{ 
   
   </PRE>where <I>SCs</I> is a list of one or more start conditions.  Inside the 
start condition scope, every rule automatically has the prefix <I>&lt;SCs&gt;</I> applied 
to it, until a <I>'}'</I> which matches the initial <I>'{'.</I> So, for example,  <BR>
 <PRE>  
      &lt;ESC&gt;{ 
         "\\n"   return '\n'; 
         "\\r"   return '\r'; 
         "\\f"   return '\f'; 
         "\\0"   return '\0'; 
     } 
   
   </PRE>is equivalent to:  <BR>
 <PRE>  
      &lt;ESC&gt;"\\n"  return '\n'; 
     &lt;ESC&gt;"\\r"  return '\r'; 
     &lt;ESC&gt;"\\f"  return '\f'; 
     &lt;ESC&gt;"\\0"  return '\0'; 
   
   </PRE>Start condition scopes may be nested. <P>
Three routines are available 
for manipulating stacks of start conditions: 
<DL>

<DT><B>void yy_push_state(int new_state)</B> 
 </DT>
<DD>pushes the current start condition onto the top of the start condition 
stack and switches to <I>new_state</I> as though you had used <B>BEGIN new_state</B> 
(recall that start condition names are also integers). </DD>

<DT><B>void yy_pop_state()</B> 
 </DT>
<DD>pops the top of the stack and switches to it via <B>BEGIN.</B> </DD>

<DT><B>int yy_top_state()</B> 
 </DT>
<DD>returns the top of the stack without altering the stack's contents. </DD>
</DL>
<P>
The 
start condition stack grows dynamically and so has no built-in size limitation. 
 If memory is exhausted, program execution aborts. <P>
To use start condition 
stacks, your scanner must include a <B>%option stack</B> directive (see Options 
below).  
<H2><A NAME="sect11" HREF="#toc11">Multiple Input Buffers </A></H2>
Some scanners (such as those which support 
"include" files) require reading from several input streams.  As <I>flex</I> scanners 
do a large amount of buffering, one cannot control where the next input 
will be read from by simply writing a <B>YY_INPUT</B> which is sensitive to the 
scanning context. <B>YY_INPUT</B> is only called when the scanner reaches the 
end of its buffer, which may be a long time after scanning a statement 
such as an "include" which requires switching the input source. <P>
To negotiate 
these sorts of problems, <I>flex</I> provides a mechanism for creating and switching 
between multiple input buffers.  An input buffer is created by using:  
<BR>
 <PRE>  
      YY_BUFFER_STATE yy_create_buffer( FILE *file, int size ) 
   
   </PRE>which takes a <I>FILE</I> pointer and a size and creates a buffer associated 
with the given file and large enough to hold <I>size</I> characters (when in 
doubt, use <B>YY_BUF_SIZE</B> for the size).  It returns a <B>YY_BUFFER_STATE</B> handle, 
which may then be passed to other routines (see below).  The <B>YY_BUFFER_STATE</B> 
type is a pointer to an opaque <B>struct yy_buffer_state</B> structure, so you 
may safely initialize YY_BUFFER_STATE variables to <B>((YY_BUFFER_STATE) 
0)</B> if you wish, and also refer to the opaque structure in order to correctly 
declare input buffers in source files other than that of your scanner. 
 Note that the <I>FILE</I> pointer in the call to <B>yy_create_buffer</B> is only used 
as the value of <I>yyin</I> seen by <B>YY_INPUT;</B> if you redefine <B>YY_INPUT</B> so it 
no longer uses <I>yyin,</I> then you can safely pass a nil <I>FILE</I> pointer to <B>yy_create_buffer.</B> 
You select a particular buffer to scan from using:  <BR>
 <PRE>  
      void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer ) 
   
   </PRE>switches the scanner's input buffer so subsequent tokens will come 
from <I>new_buffer.</I> Note that <B>yy_switch_to_buffer()</B> may be used by yywrap() 
to set things up for continued scanning, instead of opening a new file 
and pointing <I>yyin</I> at it.  Note also that switching input sources via either 
<B>yy_switch_to_buffer()</B> or <B>yywrap()</B> does <I>not</I> change the start condition. 
 <BR>
 <PRE>  
      void yy_delete_buffer( YY_BUFFER_STATE buffer ) 
   
   </PRE>is used to reclaim the storage associated with a buffer.  ( <B>buffer</B> 
can be nil, in which case the routine does nothing.) You can also clear 
the current contents of a buffer using:  <BR>
 <PRE>  
      void yy_flush_buffer( YY_BUFFER_STATE buffer ) 
   
   </PRE>This function discards the buffer's contents, so the next time the 
scanner attempts to match a token from the buffer, it will first fill 
the buffer anew using <B>YY_INPUT.</B> <P>
<B>yy_new_buffer()</B> is an alias for <B>yy_create_buffer(),</B> 
provided for compatibility with the C++ use of <I>new</I> and <I>delete</I> for creating 
and destroying dynamic objects. <P>
Finally, the <B>YY_CURRENT_BUFFER</B> macro returns 
a <B>YY_BUFFER_STATE</B> handle to the current buffer. <P>
Here is an example of using 
these features for writing a scanner which expands include files (the 
<B>&lt;&lt;EOF&gt;&gt;</B> feature is discussed below):  <BR>
 <PRE>  
      /* the "incl" state is used for picking up the name 
      * of an include file 
      */ 
     %x incl 
   
      %{ 
     #define MAX_INCLUDE_DEPTH 10 
     YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH]; 
     int include_stack_ptr = 0; 
     %} 
   
      %% 
     include             BEGIN(incl); 
   
      [a-z]+              ECHO; 
     [^a-z\n]*\n?        ECHO; 
   
      &lt;incl&gt;[ \t]*      /* eat the whitespace */ 
     &lt;incl&gt;[^ \t\n]+   { /* got the include file name */ 
             if ( include_stack_ptr &gt;= MAX_INCLUDE_DEPTH ) 
                 { 
                 fprintf( stderr, "Includes nested too deeply" ); 
                 exit( 1 ); 
                 } 
   
              include_stack[include_stack_ptr++] = 
                 YY_CURRENT_BUFFER; 
   
              yyin = fopen( yytext, "r" ); 
   
              if ( ! yyin ) 
                 error( ... ); 
   
              yy_switch_to_buffer( 
                 yy_create_buffer( yyin, YY_BUF_SIZE ) ); 
   
              BEGIN(INITIAL); 
             } 
   
      &lt;&lt;EOF&gt;&gt; { 
             if ( --include_stack_ptr &lt; 0 ) 
                 { 
                 yyterminate(); 
                 } 
   
              else 
                 { 
                 yy_delete_buffer( YY_CURRENT_BUFFER ); 
                 yy_switch_to_buffer( 
                      include_stack[include_stack_ptr] ); 
                 } 
             } 
   
   </PRE>Three routines are available for setting up input buffers for scanning 
in-memory strings instead of files.  All of them create a new input buffer 
for scanning the string, and return a corresponding <B>YY_BUFFER_STATE</B> handle 
(which you should delete with <B>yy_delete_buffer()</B> when done with it).  They 
also switch to the new buffer using <B>yy_switch_to_buffer(),</B> so the next 
call to <B>yylex()</B> will start scanning the string. 
<DL>

<DT><B>yy_scan_string(const char 
*str)</B>  </DT>
<DD>scans a NUL-terminated string. </DD>

<DT><B>yy_scan_bytes(const char *bytes, int 
len)</B>  </DT>
<DD>scans <I>len</I> bytes (including possibly NUL's) starting at location <I>bytes.</I> 
</DD>
</DL>
<P>
Note that both of these functions create and scan a <I>copy</I> of the string 
or bytes.  (This may be desirable, since <B>yylex()</B> modifies the contents 
of the buffer it is scanning.)  You can avoid the copy by using: 
<DL>

<DT><B>yy_scan_buffer(char 
*base, yy_size_t size)</B>  </DT>
<DD>which scans in place the buffer starting at <I>base,</I> 
consisting of <I>size</I> bytes, the last two bytes of which <I>must</I> be <B>YY_END_OF_BUFFER_CHAR</B> 
(ASCII NUL). These last two bytes are not scanned; thus, scanning consists 
of <B>base[0]</B> through <B>base[size-2],</B> inclusive. </DD>

<DT>If you fail to set up  </DT>
<DD><I>base</I> 
in this manner (i.e., forget the final two <B>YY_END_OF_BUFFER_CHAR</B> bytes), 
then <B>yy_scan_buffer()</B> returns a nil pointer instead of creating a new 
input buffer. </DD>

<DT>The type  </DT>
<DD><B>yy_size_t</B> is an integral type to which you can 
cast an integer expression reflecting the size of the buffer. </DD>
</DL>
 
<H2><A NAME="sect12" HREF="#toc12">End-of-file 
Rules </A></H2>
The special rule "&lt;&lt;EOF&gt;&gt;" indicates actions which are to be taken when 
an end-of-file is encountered and yywrap() returns non-zero (i.e., indicates 
no further files to process).  The action must finish by doing one of four 
things: 
<DL>

<DT>- </DT>
<DD>assigning <I>yyin</I> to a new input file (in previous versions of flex, 
after doing the assignment you had to call the special action <B>YY_NEW_FILE;</B> 
this is no longer necessary); </DD>

<DT>- </DT>
<DD>executing a <I>return</I> statement; </DD>

<DT>- </DT>
<DD>executing 
the special <B>yyterminate()</B> action; </DD>

<DT>- </DT>
<DD>or, switching to a new buffer using 
<B>yy_switch_to_buffer()</B> as shown in the example above. </DD>
</DL>
<P>
&lt;&lt;EOF&gt;&gt; rules may not 
be used with other patterns; they may only be qualified with a list of 
start conditions.  If an unqualified &lt;&lt;EOF&gt;&gt; rule is given, it applies to <I>all</I> 
start conditions which do not already have &lt;&lt;EOF&gt;&gt; actions.  To specify an 
&lt;&lt;EOF&gt;&gt; rule for only the initial start condition, use  <BR>
 <PRE>  
      &lt;INITIAL&gt;&lt;&lt;EOF&gt;&gt; 
   
   </PRE><P>
These rules are useful for catching things like unclosed comments. 
An example:  <BR>
 <PRE>  
      %x quote 
     %% 
   
      ...other rules for dealing with quotes... 
   
      &lt;quote&gt;&lt;&lt;EOF&gt;&gt;   { 
              error( "unterminated quote" ); 
              yyterminate(); 
              } 
     &lt;&lt;EOF&gt;&gt;  { 
              if ( *++filelist ) 
                  yyin = fopen( *filelist, "r" ); 
              else 
                 yyterminate(); 
              } 
   
   </PRE> 
<H2><A NAME="sect13" HREF="#toc13">Miscellaneous Macros </A></H2>
The macro <B>YY_USER_ACTION</B> can be defined to 
provide an action which is always executed prior to the matched rule's 
action.  For example, it could be #define'd to call a routine to convert 
yytext to lower-case. When <B>YY_USER_ACTION</B> is invoked, the variable <I>yy_act</I> 
gives the number of the matched rule (rules are numbered starting with 
1). Suppose you want to profile how often each of your rules is matched. 
 The following would do the trick:  <BR>
 <PRE>  
      #define YY_USER_ACTION ++ctr[yy_act] 
   
   </PRE>where <I>ctr</I> is an array to hold the counts for the different rules. 
 Note that the macro <B>YY_NUM_RULES</B> gives the total number of rules (including 
the default rule, even if you use <B>-s),</B> so a correct declaration for <I>ctr</I> 
is:  <BR>
 <PRE>  
      int ctr[YY_NUM_RULES]; 
   
   </PRE><P>
The macro <B>YY_USER_INIT</B> may be defined to provide an action which 
is always executed before the first scan (and before the scanner's internal 
initializations are done). For example, it could be used to call a routine 
to read in a data table or open a logging file. <P>
The macro <B>yy_set_interactive(is_interactive)</B> 
can be used to control whether the current buffer is considered <I>interactive.</I> 
An interactive buffer is processed more slowly, but must be used when 
the scanner's input source is indeed interactive to avoid problems due 
to waiting to fill buffers (see the discussion of the <B>-I</B> flag below).  A 
non-zero value in the macro invocation marks the buffer as interactive, 
a zero   value as non-interactive.  Note that use of this macro overrides 
<B>%option always-interactive</B> or <B>%option never-interactive</B> (see Options below). 
<B>yy_set_interactive()</B> must be invoked prior to beginning to scan the buffer 
that is (or is not) to be considered interactive. <P>
The macro <B>yy_set_bol(at_bol)</B> 
can be used to control whether the current buffer's scanning context for 
the next token match is done as though at the beginning of a line.  A non-zero 
macro argument makes rules anchored with  <P>
The macro <B>YY_AT_BOL()</B> returns 
true if the next token scanned from the current buffer will have '^' rules 
active, false otherwise. <P>
In the generated scanner, the actions are all 
gathered in one large switch statement and separated using <B>YY_BREAK,</B> which 
may be redefined.  By default, it is simply a "break", to separate each 
rule's action from the following rule's. Redefining <B>YY_BREAK</B> allows, for 
example, C++ users to #define YY_BREAK to do nothing (while being very 
careful that every rule ends with a "break" or a "return"!) to avoid suffering 
from unreachable statement warnings where because a rule's action ends 
with "return", the <B>YY_BREAK</B> is inaccessible.  
<H2><A NAME="sect14" HREF="#toc14">Values Available to the User 
</A></H2>
This section summarizes the various values available to the user in the 
rule actions. 
<DL>

<DT>- </DT>
<DD><B>char *yytext</B> holds the text of the current token.  It may 
be modified but not lengthened (you cannot append characters to the end). 
</DD>

<DT>If the special directive  </DT>
<DD><B>%array</B> appears in the first section of the scanner 
description, then <B>yytext</B> is instead declared <B>char yytext[YYLMAX],</B> where 
<B>YYLMAX</B> is a macro definition that you can redefine in the first section 
if you don't like the default value (generally 8KB).  Using <B>%array</B> results 
in somewhat slower scanners, but the value of <B>yytext</B> becomes immune to 
calls to <I>input()</I> and <I>unput(),</I> which potentially destroy its value when 
<B>yytext</B> is a character pointer.  The opposite of <B>%array</B> is <B>%pointer,</B> which 
is the default. </DD>

<DT>You cannot use  </DT>
<DD><B>%array</B> when generating C++ scanner classes 
(the <B>-+</B> flag). </DD>

<DT>- </DT>
<DD><B>int yyleng</B> holds the length of the current token. </DD>

<DT>- </DT>
<DD><B>FILE *yyin</B> 
is the file which by default <I>flex</I> reads from.  It may be redefined but 
doing so only makes sense before scanning begins or after an EOF has been 
encountered.  Changing it in the midst of scanning will have unexpected 
results since <I>flex</I> buffers its input; use <B>yyrestart()</B> instead. Once scanning 
terminates because an end-of-file has been seen, you can assign <I>yyin</I> at 
the new input file and then call the scanner again to continue scanning. 
</DD>

<DT>- </DT>
<DD><B>void yyrestart( FILE *new_file )</B> may be called to point <I>yyin</I> at the new 
input file.  The switch-over to the new file is immediate (any previously 
buffered-up input is lost).  Note that calling <B>yyrestart()</B> with <I>yyin</I> as 
an argument thus throws away the current input buffer and continues scanning 
the same input file. </DD>

<DT>- </DT>
<DD><B>FILE *yyout</B> is the file to which <B>ECHO</B> actions are 
done.  It can be reassigned by the user. </DD>

<DT>- </DT>
<DD><B>YY_CURRENT_BUFFER</B> returns a <B>YY_BUFFER_STATE</B> 
handle to the current buffer. </DD>

<DT>- </DT>
<DD><B>YY_START</B> returns an integer value corresponding 
to the current start condition.  You can subsequently use this value with 
<B>BEGIN</B> to return to that start condition. </DD>
</DL>
 
<H2><A NAME="sect15" HREF="#toc15">Interfacing with Yacc </A></H2>
One of 
the main uses of <I>flex</I> is as a companion to the <I>yacc</I> parser-generator. <I>yacc</I> 
parsers expect to call a routine named <B>yylex()</B> to find the next input 
token.  The routine is supposed to return the type of the next token as 
well as putting any associated value in the global <B>yylval.</B> To use <I>flex</I> 
with <I>yacc,</I> one specifies the <B>-d</B> option to <I>yacc</I> to instruct it to generate 
the file <B>y.tab.h</B> containing definitions of all the <B>%tokens</B> appearing in 
the <I>yacc</I> input.  This file is then included in the <I>flex</I> scanner.  For example, 
if one of the tokens is "TOK_NUMBER", part of the scanner might look like: 
 <BR>
 <PRE>  
      %{ 
     #include "y.tab.h" 
     %} 
   
      %% 
   
      [0-9]+        yylval = atoi( yytext ); return TOK_NUMBER; 
   
   </PRE> 
<H2><A NAME="sect16" HREF="#toc16">Options </A></H2>
<I>flex</I> has the following options: 
<DL>

<DT><B>-b</B>  </DT>
<DD>Generate backing-up information 
to <I>lex.backup.</I> This is a list of scanner states which require backing up 
and the input characters on which they do so.  By adding rules one can 
remove backing-up states.  If <I>all</I> backing-up states are eliminated and <B>-Cf</B> 
or <B>-CF</B> is used, the generated scanner will run faster (see the <B>-p</B> flag). 
 Only users who wish to squeeze every last cycle out of their scanners 
need worry about this option.  (See the section on Performance Considerations 
below.) </DD>

<DT><B>-c</B>  </DT>
<DD>is a do-nothing, deprecated option included for POSIX compliance. 
</DD>

<DT><B>-d</B>  </DT>
<DD>makes the generated scanner run in <I>debug</I> mode.  Whenever a pattern is 
recognized and the global <B>yy_flex_debug</B> is non-zero (which is the default), 
the scanner will write to <I>stderr</I> a line of the form:  <BR>
 <PRE>  
      --accepting rule at line 53 ("the matched text") 
   
   </PRE>The line number refers to the location of the rule in the file defining 
the scanner (i.e., the file that was fed to flex).  Messages are also generated 
when the scanner backs up, accepts the default rule, reaches the end of 
its input buffer (or encounters a NUL; at this point, the two look the 
same as far as the scanner's concerned), or reaches an end-of-file. </DD>

<DT><B>-f</B>  </DT>
<DD>specifies 
<I>fast</I> scanner. No table compression is done and stdio is bypassed. The result 
is large but fast.  This option is equivalent to <B>-Cfr</B> (see below). </DD>

<DT><B>-h</B>  </DT>
<DD>generates 
a "help" summary of <I>flex's</I> options to <I>stdout</I>  and then exits. <B>-?</B> and <B>--help</B> 
are synonyms for <B>-h.</B> </DD>

<DT><B>-i</B>  </DT>
<DD>instructs <I>flex</I> to generate a <I>case-insensitive</I> scanner. 
 The case of letters given in the <I>flex</I> input patterns will be ignored, 
and tokens in the input will be matched regardless of case.  The matched 
text given in <I>yytext</I> will have the preserved case (i.e., it will not be 
folded). </DD>

<DT><B>-l</B>  </DT>
<DD>turns on maximum compatibility with the original AT&amp;T <I>lex</I> implementation. 
 Note that this does not mean <I>full</I> compatibility.  Use of this option costs 
a considerable amount of performance, and it cannot be used with the <B>-+, 
-f, -F, -Cf,</B> or <B>-CF</B> options.  For details on the compatibilities it provides, 
see the section "Incompatibilities With Lex And POSIX" below.  This option 
also results in the name <B>YY_FLEX_LEX_COMPAT</B> being #define'd in the generated 
scanner. </DD>

<DT><B>-n</B>  </DT>
<DD>is another do-nothing, deprecated option included only for POSIX 
compliance. </DD>

<DT><B>-p</B>  </DT>
<DD>generates a performance report to stderr.  The report consists 
of comments regarding features of the <I>flex</I> input file which will cause 
a serious loss of performance in the resulting scanner.  If you give the 
flag twice, you will also get comments regarding features that lead to 
minor performance losses. </DD>

<DT>Note that the use of  </DT>
<DD><B>REJECT,</B> <B>%option yylineno,</B> 
and variable trailing context (see the Deficiencies / Bugs section below) 
entails a substantial performance penalty; use of <I>yymore(),</I> the <B>^</B> operator, 
and the <B>-I</B> flag entail minor performance penalties. </DD>

<DT><B>-s</B>  </DT>
<DD>causes the <I>default</I> 
rule (that unmatched scanner input is echoed to <I>stdout)</I> to be suppressed. 
 If the scanner encounters input that does not match any of its rules, 
it aborts with an error.  This option is useful for finding holes in a 
scanner's rule set. </DD>

<DT><B>-t</B>  </DT>
<DD>instructs <I>flex</I> to write the scanner it generates 
to standard output instead of <B>lex.yy.c.</B> </DD>

<DT><B>-v</B>  </DT>
<DD>specifies that <I>flex</I> should write 
to <I>stderr</I> a summary of statistics regarding the scanner it generates. Most 
of the statistics are meaningless to the casual <I>flex</I> user, but the first 
line identifies the version of <I>flex</I> (same as reported by <B>-V),</B> and the next 
line the flags used when generating the scanner, including those that 
are on by default. </DD>

<DT><B>-w</B>  </DT>
<DD>suppresses warning messages. </DD>

<DT><B>-B</B>  </DT>
<DD>instructs <I>flex</I> to 
generate a <I>batch</I> scanner, the opposite of <I>interactive</I> scanners generated 
by <B>-I</B> (see below).  In general, you use <B>-B</B> when you are <I>certain</I> that your 
scanner will never be used interactively, and you want to squeeze a <I>little</I> 
more performance out of it.  If your goal is instead to squeeze out a <I>lot</I> 
more performance, you should  be using the <B>-Cf</B> or <B>-CF</B> options (discussed 
below), which turn on <B>-B</B> automatically anyway. </DD>

<DT><B>-F</B>  </DT>
<DD>specifies that the  fast 
scanner table representation should be used (and stdio bypassed).  This 
representation is about as fast as the full table representation <B>(-f),</B> 
and for some sets of patterns will be considerably smaller (and for others, 
larger).  In general, if the pattern set contains both "keywords" and a 
catch-all, "identifier" rule, such as in the set:  <BR>
 <PRE>  
      "case"    return TOK_CASE; 
     "switch"  return TOK_SWITCH; 
     ... 
     "default" return TOK_DEFAULT; 
     [a-z]+    return TOK_ID; 
   
   </PRE>then you're better off using the full table representation.  If only 
the "identifier" rule is present and you then use a hash table or some 
such to detect the keywords, you're better off using <B>-F.</B> </DD>

<DT>This option is equivalent 
to  </DT>
<DD><B>-CFr</B> (see below).  It cannot be used with <B>-+.</B> </DD>

<DT><B>-I</B>  </DT>
<DD>instructs <I>flex</I> to generate 
an <I>interactive</I> scanner.  An interactive scanner is one that only looks 
ahead to decide what token has been matched if it absolutely must.  It 
turns out that always looking one extra character ahead, even if the scanner 
has already seen enough text to disambiguate the current token, is a bit 
faster than only looking ahead when necessary.  But scanners that always 
look ahead give dreadful interactive performance; for example, when a 
user types a newline, it is not recognized as a newline token until they 
enter <I>another</I> token, which often means typing in another whole line. </DD>

<DT><I>Flex</I> 
 </DT>
<DD>scanners default to <I>interactive</I> unless you use the <B>-Cf</B> or <B>-CF</B> table-compression 
options (see below).  That's because if you're looking for high-performance 
you should be using one of these options, so if you didn't, <I>flex</I> assumes 
you'd rather trade off a bit of run-time performance for intuitive interactive 
behavior.  Note also that you <I>cannot</I> use <B>-I</B> in conjunction with <B>-Cf</B> or <B>-CF.</B> 
Thus, this option is not really needed; it is on by default for all those 
cases in which it is allowed. </DD>

<DT>You can force a scanner to  </DT>
<DD><I>not</I> be interactive 
by using <B>-B</B> (see above). </DD>

<DT><B>-L</B>  </DT>
<DD>instructs <I>flex</I> not to generate <B>#line</B> directives. 
 Without this option, <I>flex</I> peppers the generated scanner with #line directives 
so error messages in the actions will be correctly located with respect 
to either the original <I>flex</I> input file (if the errors are due to code 
in the input file), or <B>lex.yy.c</B> (if the errors are <I>flex's</I> fault -- you should 
report these sorts of errors to the email address given below). </DD>

<DT><B>-T</B>  </DT>
<DD>makes 
<I>flex</I> run in <I>trace</I> mode.  It will generate a lot of messages to <I>stderr</I> concerning 
the form of the input and the resultant non-deterministic and deterministic 
finite automata.  This option is mostly for use in maintaining <I>flex.</I> </DD>

<DT><B>-V</B>  
</DT>
<DD>prints the version number to <I>stdout</I> and exits. <B>--version</B> is a synonym for 
<B>-V.</B> </DD>

<DT><B>-7</B>  </DT>
<DD>instructs <I>flex</I> to generate a 7-bit scanner, i.e., one which can only 
recognized 7-bit characters in its input.  The advantage of using <B>-7</B> is that 
the scanner's tables can be up to half the size of those generated using 
the <B>-8</B> option (see below).  The disadvantage is that such scanners often 
hang or crash if their input contains an 8-bit character. </DD>

<DT>Note, however, 
that unless you generate your scanner using the  </DT>
<DD><B>-Cf</B> or <B>-CF</B> table compression 
options, use of <B>-7</B> will save only a small amount of table space, and make 
your scanner considerably less portable. <I>Flex's</I> default behavior is to generate 
an 8-bit scanner unless you use the <B>-Cf</B> or <B>-CF,</B> in which case <I>flex</I> defaults 
to generating 7-bit scanners unless your site was always configured to 
generate 8-bit scanners (as will often be the case with non-USA sites).  
You can tell whether flex generated a 7-bit or an 8-bit scanner by inspecting 
the flag summary in the <B>-v</B> output as described above. </DD>

<DT>Note that if you use 
 </DT>
<DD><B>-Cfe</B> or <B>-CFe</B> (those table compression options, but also using equivalence 
classes as discussed see below), flex still defaults to generating an 
8-bit scanner, since usually with these compression options full 8-bit tables 
are not much more expensive than 7-bit tables. </DD>

<DT><B>-8</B>  </DT>
<DD>instructs <I>flex</I> to generate 
an 8-bit scanner, i.e., one which can recognize 8-bit characters.  This flag 
is only needed for scanners generated using <B>-Cf</B> or <B>-CF,</B> as otherwise flex 
defaults to generating an 8-bit scanner anyway. </DD>

<DT>See the discussion of  </DT>
<DD><B>-7</B> 
above for flex's default behavior and the tradeoffs between 7-bit and 8-bit 
scanners. </DD>

<DT><B>-+</B>  </DT>
<DD>specifies that you want flex to generate a C++ scanner class. 
 See the section on Generating C++ Scanners below for details. </DD>

<DT><B>-C[aefFmr]</B> 
 </DT>
<DD>controls the degree of table compression and, more generally, trade-offs 
between small scanners and fast scanners. </DD>

<DT><B>-Ca</B>  </DT>
<DD>("align") instructs flex 
to trade off larger tables in the generated scanner for faster performance 
because the elements of the tables are better aligned for memory access 
and computation.  On some RISC architectures, fetching and manipulating 
longwords is more efficient than with smaller-sized units such as shortwords. 
 This option can double the size of the tables used by your scanner. </DD>

<DT><B>-Ce</B> 
 </DT>
<DD>directs <I>flex</I> to construct <I>equivalence</I> classes, i.e., sets of characters 
which have identical lexical properties (for example, if the only appearance 
of digits in the <I>flex</I> input is in the character class "[0-9]" then the 
digits '0', '1', ..., '9' will all be put in the same equivalence class).  Equivalence 
classes usually give dramatic reductions in the final table/object file 
sizes (typically a factor of 2-5) and are pretty cheap performance-wise 
(one array look-up per character scanned). </DD>

<DT><B>-Cf</B>  </DT>
<DD>specifies that the <I>full</I> scanner 
tables should be generated - <I>flex</I> should not compress the tables by taking 
advantages of similar transition functions for different states. </DD>

<DT><B>-CF</B>  </DT>
<DD>specifies 
that the alternate fast scanner representation (described above under 
the <B>-F</B> flag) should be used.  This option cannot be used with <B>-+.</B> </DD>

<DT><B>-Cm</B>  </DT>
<DD>directs 
<I>flex</I> to construct <I>meta-equivalence</I> classes, which are sets of equivalence 
classes (or characters, if equivalence classes are not being used) that 
are commonly used together.  Meta-equivalence classes are often a big win 
when using compressed tables, but they have a moderate performance impact 
(one or two "if" tests and one array look-up per character scanned). </DD>

<DT><B>-Cr</B> 
 </DT>
<DD>causes the generated scanner to <I>bypass</I> use of the standard I/O library 
(stdio) for input.  Instead of calling <B>fread()</B> or <B>getc(),</B> the scanner will 
use the <B>read()</B> system call, resulting in a performance gain which varies 
from system to system, but in general is probably negligible unless you 
are also using <B>-Cf</B> or <B>-CF.</B> Using <B>-Cr</B> can cause strange behavior if, for example, 
you read from <I>yyin</I> using stdio prior to calling the scanner (because the 
scanner will miss whatever text your previous reads left in the stdio 
input buffer). </DD>

<DT><B>-Cr</B>  </DT>
<DD>has no effect if you define <B>YY_INPUT</B> (see The Generated 
Scanner above). </DD>

<DT>A lone  </DT>
<DD><B>-C</B> specifies that the scanner tables should be compressed 
but neither equivalence classes nor meta-equivalence classes should be 
used. </DD>

<DT>The options  </DT>
<DD><B>-Cf</B> or <B>-CF</B> and <B>-Cm</B> do not make sense together - there is 
no opportunity for meta-equivalence classes if the table is not being compressed. 
 Otherwise the options may be freely mixed, and are cumulative. </DD>

<DT>The default 
setting is  </DT>
<DD><B>-Cem,</B> which specifies that <I>flex</I> should generate equivalence 
classes and meta-equivalence classes.  This setting provides the highest 
degree of table compression.  You can trade off faster-executing scanners 
at the cost of larger tables with the following generally being true: 
 <BR>
 <PRE>  
      slowest &amp; smallest 
           -Cem 
           -Cm 
           -Ce 
           -C 
           -C{f,F}e 
           -C{f,F} 
           -C{f,F}a 
     fastest &amp; largest 
   
   </PRE>Note that scanners with the smallest tables are usually generated 
and compiled the quickest, so during development you will usually want 
to use the default, maximal compression. </DD>

<DT><B>-Cfe</B>  </DT>
<DD>is often a good compromise 
between speed and size for production scanners. </DD>

<DT><B>-ooutput</B>  </DT>
<DD>directs flex to 
write the scanner to the file <B>output</B> instead of <B>lex.yy.c.</B> If you combine 
<B>-o</B> with the <B>-t</B> option, then the scanner is written to <I>stdout</I> but its <B>#line</B> 
directives (see the <B>\-L</B> option above) refer to the file <B>output.</B> </DD>

<DT><B>-Pprefix</B>  
</DT>
<DD>changes the default <I>yy</I> prefix used by <I>flex</I> for all globally-visible variable 
and function names to instead be <I>prefix.</I> For example, <B>-Pfoo</B> changes the 
name of <B>yytext</B> to <B>footext.</B> It also changes the name of the default output 
file from <B>lex.yy.c</B> to <B>lex.foo.c.</B> Here are all of the names affected:  <BR>
 <PRE>  
      yy_create_buffer 
     yy_delete_buffer 
     yy_flex_debug 
     yy_init_buffer 
     yy_flush_buffer 
     yy_load_buffer_state 
     yy_switch_to_buffer 
     yyin 
     yyleng 
     yylex 
     yylineno 
     yyout 
     yyrestart 
     yytext 
     yywrap 
   
   </PRE>(If you are using a C++ scanner, then only <B>yywrap</B> and <B>yyFlexLexer</B> 
are affected.) Within your scanner itself, you can still refer to the global 
variables and functions using either version of their name; but externally, 
they have the modified name. </DD>

<DT>This option lets you easily link together 
multiple  </DT>
<DD><I>flex</I> programs into the same executable.  Note, though, that using 
this option also renames <B>yywrap(),</B> so you now <I>must</I> either provide your 
own (appropriately-named) version of the routine for your scanner, or use 
<B>%option noyywrap,</B> as linking with <B>-lfl</B> no longer provides one for you by 
default. </DD>

<DT><B>-Sskeleton_file</B>  </DT>
<DD>overrides the default skeleton file from which 
<I>flex</I> constructs its scanners.  You'll never need this option unless you 
are doing <I>flex</I> maintenance or development. </DD>
</DL>
<P>
<I>flex</I> also provides a mechanism 
for controlling options within the scanner specification itself, rather 
than from the flex command-line. This is done by including <B>%option</B> directives 
in the first section of the scanner specification. You can specify multiple 
options with a single <B>%option</B> directive, and multiple directives in the 
first section of your flex input file. <P>
Most options are given simply as 
names, optionally preceded by the word "no" (with no intervening whitespace) 
to negate their meaning. A number are equivalent to flex flags or their 
negation:  <BR>
 <PRE>  
      7bit            -7 option 
     8bit            -8 option 
     align           -Ca option 
     backup          -b option 
     batch           -B option 
     c++             -+ option 
   
      caseful or 
     case-sensitive  opposite of -i (default) 
   
      case-insensitive or 
     caseless        -i option 
   
      debug           -d option 
     default         opposite of -s option 
     ecs             -Ce option 
     fast            -F option 
     full            -f option 
     interactive     -I option 
     lex-compat      -l option 
     meta-ecs        -Cm option 
     perf-report     -p option 
     read            -Cr option 
     stdout          -t option 
     verbose         -v option 
     warn            opposite of -w option 
                     (use "%option nowarn" for -w) 
   
      array           equivalent to "%array" 
     pointer         equivalent to "%pointer" (default) 
   
   </PRE>Some <B>%option's</B> provide features otherwise not available: 
<DL>

<DT><B>always-interactive</B> 
 </DT>
<DD>instructs flex to generate a scanner which always considers its input 
"interactive".  Normally, on each new input file the scanner calls <B>isatty()</B> 
in an attempt to determine whether the scanner's input source is interactive 
and thus should be read a character at a time.  When this option is used, 
however, then no such call is made. </DD>

<DT><B>main</B>  </DT>
<DD>directs flex to provide a default 
<B>main()</B> program for the scanner, which simply calls <B>yylex().</B> This option 
implies <B>noyywrap</B> (see below). </DD>

<DT><B>never-interactive</B>  </DT>
<DD>instructs flex to generate 
a scanner which never considers its input "interactive" (again, no call 
made to <B>isatty()).</B> This is the opposite of <B>always-interactive.</B> </DD>

<DT><B>stack</B>  </DT>
<DD>enables 
the use of start condition stacks (see Start Conditions above). </DD>

<DT><B>stdinit</B> 
 </DT>
<DD>if set (i.e., <B>%option stdinit)</B> initializes <I>yyin</I> and <I>yyout</I> to <I>stdin</I> and 
<I>stdout,</I> instead of the default of <I>nil.</I> Some existing <I>lex</I> programs depend 
on this behavior, even though it is not compliant with ANSI C, which does 
not require <I>stdin</I> and <I>stdout</I> to be compile-time constant. </DD>

<DT><B>yylineno</B>  </DT>
<DD>directs 
<I>flex</I> to generate a scanner that maintains the number of the current line 
read from its input in the global variable <B>yylineno.</B> This option is implied 
by <B>%option lex-compat.</B> </DD>

<DT><B>yywrap</B>  </DT>
<DD>if unset (i.e., <B>%option noyywrap),</B> makes the 
scanner not call <B>yywrap()</B> upon an end-of-file, but simply assume that there 
are no more files to scan (until the user points <I>yyin</I> at a new file and 
calls <B>yylex()</B> again). </DD>
</DL>
<P>
<I>flex</I> scans your rule actions to determine whether 
you use the <B>REJECT</B> or <B>yymore()</B> features.  The <B>reject</B> and <B>yymore</B> options 
are available to override its decision as to whether you use the options, 
either by setting them (e.g., <B>%option reject)</B> to indicate the feature is 
indeed used, or unsetting them to indicate it actually is not used (e.g., 
<B>%option noyymore).</B> <P>
Three options take string-delimited values, offset with 
'=':  <BR>
 <PRE>  
      %option outfile="ABC" 
   
   </PRE>is equivalent to <B>-oABC,</B> and  <BR>
 <PRE>  
      %option prefix="XYZ" 
   
   </PRE>is equivalent to <B>-PXYZ.</B> Finally,  <BR>
 <PRE>  
      %option yyclass="foo" 
   
   </PRE>only applies when generating a C++ scanner ( <B>-+</B> option).  It informs 
<I>flex</I> that you have derived <B>foo</B> as a subclass of <B>yyFlexLexer,</B> so <I>flex</I> will 
place your actions in the member function <B>foo::yylex()</B> instead of <B>yyFlexLexer::yylex().</B> 
It also generates a <B>yyFlexLexer::yylex()</B> member function that emits a 
run-time error (by invoking <B>yyFlexLexer::LexerError())</B> if called. See Generating 
C++ Scanners, below, for additional information. <P>
A number of options are 
available for lint purists who want to suppress the appearance of unneeded 
routines in the generated scanner.  Each of the following, if unset (e.g., 
<B>%option nounput</B> ), results in the corresponding routine not appearing 
in the generated scanner:  <BR>
 <PRE>  
      input, unput 
     yy_push_state, yy_pop_state, yy_top_state 
     yy_scan_buffer, yy_scan_bytes, yy_scan_string 
   
   </PRE>(though <B>yy_push_state()</B> and friends won't appear anyway unless you 
use <B>%option stack).</B>  
<H2><A NAME="sect17" HREF="#toc17">Performance Considerations </A></H2>
The main design goal of 
<I>flex</I> is that it generate high-performance scanners.  It has been optimized 
for dealing well with large sets of rules.  Aside from the effects on scanner 
speed of the table compression <B>-C</B> options outlined above, there are a number 
of options/actions which degrade performance.  These are, from most expensive 
to least:  <BR>
 <PRE>  
      REJECT 
     %option yylineno 
     arbitrary trailing context 
   
      pattern sets that require backing up 
     %array 
     %option interactive 
     %option always-interactive 
   
      '^' beginning-of-line operator 
     yymore() 
   
   </PRE>with the first three all being quite expensive and the last two 
being quite cheap.  Note also that <B>unput()</B> is implemented as a routine 
call that potentially does quite a bit of work, while <B>yyless()</B> is a quite-cheap 
macro; so if just putting back some excess text you scanned, use <B>yyless().</B> 
<P>
<B>REJECT</B> should be avoided at all costs when performance is important. It 
is a particularly expensive option. <P>
Getting rid of backing up is messy 
and often may be an enormous amount of work for a complicated scanner. 
 In principal, one begins by using the <B>-b </B> flag to generate a <I>lex.backup</I> 
file.  For example, on the input  <BR>
 <PRE>  
      %% 
     foo        return TOK_KEYWORD; 
     foobar     return TOK_KEYWORD; 
   
   </PRE>the file looks like:  <BR>
 <PRE>  
      State #6 is non-accepting - 
      associated rule line numbers: 
            2       3 
      out-transitions: [ o ] 
      jam-transitions: EOF [ \001-n  p-\177 ] 
   
      State #8 is non-accepting - 
      associated rule line numbers: 
            3 
      out-transitions: [ a ] 
      jam-transitions: EOF [ \001-`  b-\177 ] 
   
      State #9 is non-accepting - 
      associated rule line numbers: 
            3 
      out-transitions: [ r ] 
      jam-transitions: EOF [ \001-q  s-\177 ] 
   
      Compressed tables always back up. 
   
   </PRE>The first few lines tell us that there's a scanner state in which 
it can make a transition on an 'o' but not on any other character, and that 
in that state the currently scanned text does not match any rule.  The 
state occurs when trying to match the rules found at lines 2 and 3 in 
the input file. If the scanner is in that state and then reads something 
other than an 'o', it will have to back up to find a rule which is matched. 
 With a bit of headscratching one can see that this must be the state 
it's in when it has seen "fo".  When this has happened, if anything other 
than another 'o' is seen, the scanner will have to back up to simply match 
the 'f' (by the default rule). <P>
The comment regarding State #8 indicates there's 
a problem when "foob" has been scanned.  Indeed, on any character other 
than an 'a', the scanner will have to back up to accept "foo". Similarly, 
the comment for State #9 concerns when "fooba" has been scanned and an 
'r' does not follow. <P>
The final comment reminds us that there's no point going 
to all the trouble of removing backing up from the rules unless we're using 
<B>-Cf</B> or <B>-CF,</B> since there's no performance gain doing so with compressed scanners. 
<P>
The way to remove the backing up is to add "error" rules:  <BR>
 <PRE>  
      %% 
     foo         return TOK_KEYWORD; 
     foobar      return TOK_KEYWORD; 
   
      fooba       | 
     foob        | 
     fo          { 
                 /* false alarm, not really a keyword */ 
                 return TOK_ID; 
                 } 
   
   </PRE><P>
Eliminating backing up among a list of keywords can also be done 
using a "catch-all" rule:  <BR>
 <PRE>  
      %% 
     foo         return TOK_KEYWORD; 
     foobar      return TOK_KEYWORD; 
   
      [a-z]+      return TOK_ID; 
   
   </PRE>This is usually the best solution when appropriate. <P>
Backing up messages 
tend to cascade. With a complicated set of rules it's not uncommon to get 
hundreds of messages.  If one can decipher them, though, it often only 
takes a dozen or so rules to eliminate the backing up (though it's easy 
to make a mistake and have an error rule accidentally match a valid token. 
 A possible future <I>flex</I> feature will be to automatically add rules to 
eliminate backing up). <P>
It's important to keep in mind that you gain the 
benefits of eliminating backing up only if you eliminate <I>every</I> instance 
of backing up.  Leaving just one means you gain nothing. <P>
<I>Variable</I> trailing 
context (where both the leading and trailing parts do not have a fixed 
length) entails almost the same performance loss as <B>REJECT</B> (i.e., substantial). 
 So when possible a rule like:  <BR>
 <PRE>  
      %% 
     mouse|rat/(cat|dog)   run(); 
   
   </PRE>is better written:  <BR>
 <PRE>  
      %% 
     mouse/cat|dog         run(); 
     rat/cat|dog           run(); 
   
   </PRE>or as  <BR>
 <PRE>  
      %% 
     mouse|rat/cat         run(); 
     mouse|rat/dog         run(); 
   
   </PRE>Note that here the special '|' action does <I>not</I> provide any savings, 
and can even make things worse (see Deficiencies / Bugs below). <P>
Another 
area where the user can increase a scanner's performance (and one that's 
easier to implement) arises from the fact that the longer the tokens matched, 
the faster the scanner will run. This is because with long tokens the processing 
of most input characters takes place in the (short) inner scanning loop, 
and does not often have to go through the additional work of setting up 
the scanning environment (e.g., <B>yytext)</B> for the action.  Recall the scanner 
for C comments:  <BR>
 <PRE>  
      %x comment 
     %% 
             int line_num = 1; 
   
      "/*"         BEGIN(comment); 
   
      &lt;comment&gt;[^*\n]* 
     &lt;comment&gt;"*"+[^*/\n]* 
     &lt;comment&gt;\n             ++line_num; 
     &lt;comment&gt;"*"+"/"        BEGIN(INITIAL); 
   
   </PRE>This could be sped up by writing it as:  <BR>
 <PRE>  
      %x comment 
     %% 
             int line_num = 1; 
   
      "/*"         BEGIN(comment); 
   
      &lt;comment&gt;[^*\n]* 
     &lt;comment&gt;[^*\n]*\n      ++line_num; 
     &lt;comment&gt;"*"+[^*/\n]* 
     &lt;comment&gt;"*"+[^*/\n]*\n ++line_num; 
     &lt;comment&gt;"*"+"/"        BEGIN(INITIAL); 
   
   </PRE>Now instead of each newline requiring the processing of another 
action, recognizing the newlines is "distributed" over the other rules 
to keep the matched text as long as possible.  Note that <I>adding</I> rules does 
<I>not</I> slow down the scanner!  The speed of the scanner is independent of 
the number of rules or (modulo the considerations given at the beginning 
of this section) how complicated the rules are with regard to operators 
such as '*' and '|'. <P>
A final example in speeding up a scanner: suppose you want 
to scan through a file containing identifiers and keywords, one per line 
and with no other extraneous characters, and recognize all the keywords. 
 A natural first approach is:  <BR>
 <PRE>  
      %% 
     asm      | 
     auto     | 
     break    | 
     ... etc ... 
     volatile | 
     while    /* it's a keyword */ 
   
      .|\n     /* it's not a keyword */ 
   
   </PRE>To eliminate the back-tracking, introduce a catch-all rule:  <BR>
 <PRE>  
      %% 
     asm      | 
     auto     | 
     break    | 
     ... etc ... 
     volatile | 
     while    /* it's a keyword */ 
   
      [a-z]+   | 
     .|\n     /* it's not a keyword */ 
   
   </PRE>Now, if it's guaranteed that there's exactly one word per line, then 
we can reduce the total number of matches by a half by merging in the 
recognition of newlines with that of the other tokens:  <BR>
 <PRE>  
      %% 
     asm\n    | 
     auto\n   | 
     break\n  | 
     ... etc ... 
     volatile\n | 
     while\n  /* it's a keyword */ 
   
      [a-z]+\n | 
     .|\n     /* it's not a keyword */ 
   
   </PRE>One has to be careful here, as we have now reintroduced backing 
up into the scanner.  In particular, while <I>we</I> know that there will never 
be any characters in the input stream other than letters or newlines, 
<I>flex</I> can't figure this out, and it will plan for possibly needing to back 
up when it has scanned a token like "auto" and then the next character 
is something other than a newline or a letter.  Previously it would then 
just match the "auto" rule and be done, but now it has no "auto" rule, 
only a "auto\n" rule.  To eliminate the possibility of backing up, we could 
either duplicate all rules but without final newlines, or, since we never 
expect to encounter such an input and therefore don't how it's classified, 
we can introduce one more catch-all rule, this one which doesn't include 
a newline:  <BR>
 <PRE>  
      %% 
     asm\n    | 
     auto\n   | 
     break\n  | 
     ... etc ... 
     volatile\n | 
     while\n  /* it's a keyword */ 
   
      [a-z]+\n | 
     [a-z]+   | 
     .|\n     /* it's not a keyword */ 
   
   </PRE>Compiled with <B>-Cf,</B> this is about as fast as one can get a <I>flex</I>  scanner 
to go for this particular problem. <P>
A final note: <I>flex</I> is slow when matching 
NUL's, particularly when a token contains multiple NUL's. It's best to write 
rules which match <I>short</I> amounts of text if it's anticipated that the text 
will often include NUL's. <P>
Another final note regarding performance: as mentioned 
above in the section How the Input is Matched, dynamically resizing <B>yytext</B> 
to accommodate huge tokens is a slow process because it presently requires 
that the (huge) token be rescanned from the beginning.  Thus if performance 
is vital, you should attempt to match "large" quantities of text but not 
"huge" quantities, where the cutoff between the two is at about 8K characters/token. 
 
<H2><A NAME="sect18" HREF="#toc18">Generating C++ Scanners </A></H2>
<I>flex</I> provides two different ways to generate 
scanners for use with C++.  The first way is to simply compile a scanner 
generated by <I>flex</I> using a C++ compiler instead of a C compiler.  You should 
not encounter any compilations errors (please report any you find to the 
email address given in the Author section below).  You can then use C++ 
code in your rule actions instead of C code.  Note that the default input 
source for your scanner remains <I>yyin,</I> and default echoing is still done 
to <I>yyout.</I> Both of these remain <I>FILE</I> * variables and not C++ <I>streams.</I> <P>
You 
can also use <I>flex</I> to generate a C++ scanner class, using the <B>-+</B> option 
(or, equivalently, <B>%option c++),</B> which is automatically specified if the 
name of the flex executable ends in a '+', such as <I>flex++.</I> When using this 
option, flex defaults to generating the scanner to the file <B>lex.yy.cc</B> instead 
of <B>lex.yy.c.</B> The generated scanner includes the header file <I>FlexLexer.h,</I> which 
defines the interface to two C++ classes. <P>
The first class, <B>FlexLexer,</B> provides 
an abstract base class defining the general scanner class interface.  It 
provides the following member functions: 
<DL>

<DT><B>const char* YYText()</B>  </DT>
<DD>returns 
the text of the most recently matched token, the equivalent of <B>yytext.</B> 
</DD>

<DT><B>int YYLeng()</B>  </DT>
<DD>returns the length of the most recently matched token, the 
equivalent of <B>yyleng.</B> </DD>

<DT><B>int lineno() const</B>  </DT>
<DD>returns the current input line 
number (see <B>%option yylineno),</B> or <B>1</B> if <B>%option yylineno</B> was not used. </DD>

<DT><B>void 
set_debug( int flag )</B>  </DT>
<DD>sets the debugging flag for the scanner, equivalent 
to assigning to <B>yy_flex_debug</B> (see the Options section above).  Note that 
you must build the scanner using <B>%option debug</B> to include debugging information 
in it. </DD>

<DT><B>int debug() const</B>  </DT>
<DD>returns the current setting of the debugging 
flag. </DD>
</DL>
<P>
Also provided are member functions equivalent to <B>yy_switch_to_buffer(),</B> 
<B>yy_create_buffer()</B> (though the first argument is an <B>istream*</B> object pointer 
and not a <B>FILE*),</B> <B>yy_flush_buffer(),</B> <B>yy_delete_buffer(),</B> and <B>yyrestart()</B> 
(again, the first argument is a <B>istream*</B> object pointer). <P>
The second class 
defined in <I>FlexLexer.h</I> is <B>yyFlexLexer,</B> which is derived from <B>FlexLexer.</B> 
It defines the following additional member functions: 
<DL>

<DT><B></B> yyFlexLexer( istream* 
arg_yyin = 0, ostream* arg_yyout = 0 )  </DT>
<DD>constructs a <B>yyFlexLexer</B> object 
using the given streams for input and output.  If not specified, the streams 
default to <B>cin</B> and <B>cout,</B> respectively. </DD>

<DT><B>virtual int yylex()</B>  </DT>
<DD>performs the 
same role is <B>yylex()</B> does for ordinary flex scanners: it scans the input 
stream, consuming tokens, until a rule's action returns a value.  If you 
derive a subclass <B>S</B> from <B>yyFlexLexer</B> and want to access the member functions 
and variables of <B>S</B> inside <B>yylex(),</B> then you need to use <B>%option yyclass="S"</B> 
to inform <I>flex</I> that you will be using that subclass instead of <B>yyFlexLexer.</B> 
In this case, rather than generating <B>yyFlexLexer::yylex(),</B> <I>flex</I> generates 
<B>S::yylex()</B> (and also generates a dummy <B>yyFlexLexer::yylex()</B> that calls 
<B>yyFlexLexer::LexerError()</B> if called). </DD>

<DT><B></B> virtual void switch_streams(istream* 
new_in = 0,  </DT>
<DD><B></B> ostream* new_out = 0) reassigns <B>yyin</B> to <B>new_in</B> (if non-nil) 
and <B>yyout</B> to <B>new_out</B> (ditto), deleting the previous input buffer if <B>yyin</B> 
is reassigned. </DD>

<DT><B></B> int yylex( istream* new_in, ostream* new_out = 0 )  </DT>
<DD>first 
switches the input streams via <B>switch_streams( new_in, new_out )</B> and then 
returns the value of <B>yylex().</B> </DD>
</DL>
<P>
In addition, <B>yyFlexLexer</B> defines the following 
protected virtual functions which you can redefine in derived classes 
to tailor the scanner: 
<DL>

<DT><B></B> virtual int LexerInput( char* buf, int max_size 
)  </DT>
<DD>reads up to <B>max_size</B> characters into <B>buf</B> and returns the number of 
characters read.  To indicate end-of-input, return 0 characters.  Note that 
"interactive" scanners (see the <B>-B</B> and <B>-I</B> flags) define the macro <B>YY_INTERACTIVE.</B> 
If you redefine <B>LexerInput()</B> and need to take different actions depending 
on whether or not the scanner might be scanning an interactive input source, 
you can test for the presence of this name via <B>#ifdef.</B> </DD>

<DT><B></B> virtual void LexerOutput( 
const char* buf, int size )  </DT>
<DD>writes out <B>size</B> characters from the buffer 
<B>buf,</B> which, while NUL-terminated, may also contain "internal" NUL's if the 
scanner's rules can match text with NUL's in them. </DD>

<DT><B></B> virtual void LexerError( 
const char* msg )  </DT>
<DD>reports a fatal error message.  The default version 
of this function writes the message to the stream <B>cerr</B> and exits. </DD>
</DL>
<P>
Note 
that a <B>yyFlexLexer</B> object contains its <I>entire</I> scanning state.  Thus you 
can use such objects to create reentrant scanners.  You can instantiate 
multiple instances of the same <B>yyFlexLexer</B> class, and you can also combine 
multiple C++ scanner classes together in the same program using the <B>-P</B> 
option discussed above. <P>
Finally, note that the <B>%array</B> feature is not available 
to C++ scanner classes; you must use <B>%pointer</B> (the default). <P>
Here is an 
example of a simple C++ scanner:  <BR>
 <PRE>  
          // An example of using the flex C++ scanner class. 
   
      %{ 
     int mylineno = 0; 
     %} 
   
      string  \"[^\n"]+\" 
   
      ws      [ \t]+ 
   
      alpha   [A-Za-z] 
     dig     [0-9] 
     name    ({alpha}|{dig}|\$)({alpha}|{dig}|[_.\-/$])* 
     num1    [-+]?{dig}+\.?([eE][-+]?{dig}+)? 
     num2    [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)? 
     number  {num1}|{num2} 
   
      %% 
   
      {ws}    /* skip blanks and tabs */ 
   
      "/*"    { 
             int c; 
   
              while((c = yyinput()) != 0) 
                 { 
                 if(c == '\n') 
                     ++mylineno; 
   
                  else if(c == '*') 
                     { 
                     if((c = yyinput()) == '/') 
                         break; 
                     else 
                         unput(c); 
                     } 
                 } 
             } 
   
      {number}  cout &lt;&lt; "number " &lt;&lt; YYText() &lt;&lt; '\n'; 
   
      \n        mylineno++; 
   
      {name}    cout &lt;&lt; "name " &lt;&lt; YYText() &lt;&lt; '\n'; 
   
      {string}  cout &lt;&lt; "string " &lt;&lt; YYText() &lt;&lt; '\n'; 
   
      %% 
   
      int main( int /* argc */, char** /* argv */ ) 
         { 
         FlexLexer* lexer = new yyFlexLexer; 
         while(lexer-&gt;yylex() != 0) 
             ; 
         return 0; 
         } 
  </PRE>If you want to create multiple (different) lexer classes, you use the 
<B>-P</B> flag (or the <B>prefix=</B> option) to rename each <B>yyFlexLexer</B> to some other 
<B>xxFlexLexer.</B> You then can include <B>&lt;FlexLexer.h&gt;</B> in your other sources once 
per lexer class, first renaming <B>yyFlexLexer</B> as follows:  <BR>
 <PRE>  
      #undef yyFlexLexer 
     #define yyFlexLexer xxFlexLexer 
     #include &lt;FlexLexer.h&gt; 
   
      #undef yyFlexLexer 
     #define yyFlexLexer zzFlexLexer 
     #include &lt;FlexLexer.h&gt; 
   
   </PRE>if, for example, you used <B>%option prefix="xx"</B> for one of your scanners 
and <B>%option prefix="zz"</B> for the other. <P>
IMPORTANT: the present form of the 
scanning class is <I>experimental</I> and may change considerably between major 
releases.   
<H2><A NAME="sect19" HREF="#toc19">Incompatibilities with Lex and Posix </A></H2>
<I>flex</I> is a rewrite of the 
AT&amp;T Unix <I>lex</I> tool (the two implementations do not share any code, though), 
with some extensions and incompatibilities, both of which are of concern 
to those who wish to write scanners acceptable to either implementation. 
 Flex is fully compliant with the POSIX <I>lex</I> specification, except that 
when using <B>%pointer</B> (the default), a call to <B>unput()</B> destroys the contents 
of <B>yytext,</B> which is counter to the POSIX specification. <P>
In this section 
we discuss all of the known areas of incompatibility between flex, AT&amp;T 
lex, and the POSIX specification. <P>
<I>flex's</I> <B>-l</B> option turns on maximum compatibility 
with the original AT&amp;T <I>lex</I> implementation, at the cost of a major loss 
in the generated scanner's performance.  We note below which incompatibilities 
can be overcome using the <B>-l</B> option. <P>
<I>flex</I> is fully compatible with <I>lex</I> with 
the following exceptions: 
<DL>

<DT>- </DT>
<DD>The undocumented <I>lex</I> scanner internal variable 
<B>yylineno</B> is not supported unless <B>-l</B> or <B>%option yylineno</B> is used. </DD>

<DT><B>yylineno</B> 
 </DT>
<DD>should be maintained on a per-buffer basis, rather than a per-scanner (single 
global variable) basis. </DD>

<DT><B>yylineno</B>  </DT>
<DD>is not part of the POSIX specification. 
</DD>

<DT>- </DT>
<DD>The <B>input()</B> routine is not redefinable, though it may be called to read 
characters following whatever has been matched by a rule.  If <B>input()</B> encounters 
an end-of-file the normal <B>yywrap()</B> processing is done.  A ``real'' end-of-file 
is returned by <B>input()</B> as <I>EOF.</I> </DD>

<DT>Input is instead controlled by defining 
the  </DT>
<DD><B>YY_INPUT</B> macro. </DD>

<DT>The  </DT>
<DD><I>flex</I> restriction that <B>input()</B> cannot be redefined 
is in accordance with the POSIX specification, which simply does not specify 
any way of controlling the scanner's input other than by making an initial 
assignment to <I>yyin.</I> </DD>

<DT>- </DT>
<DD>The <B>unput()</B> routine is not redefinable.  This restriction 
is in accordance with POSIX. </DD>

<DT>- </DT>
<DD><I>flex</I> scanners are not as reentrant as <I>lex</I> 
scanners.  In particular, if you have an interactive scanner and an interrupt 
handler which long-jumps out of the scanner, and the scanner is subsequently 
called again, you may get the following message:  <BR>
 <PRE>  
      fatal flex scanner internal error--end of buffer missed 
   
   </PRE>To reenter the scanner, first use  <BR>
 <PRE>  
      yyrestart( yyin ); 
   
   </PRE>Note that this call will throw away any buffered input; usually 
this isn't a problem with an interactive scanner. </DD>

<DT>Also note that flex C++ 
scanner classes  </DT>
<DD><I>are</I> reentrant, so if using C++ is an option for you, 
you should use them instead.  See "Generating C++ Scanners" above for details. 
</DD>

<DT>- </DT>
<DD><B>output()</B> is not supported. Output from the <B>ECHO</B> macro is done to the file-pointer 
<I>yyout</I> (default <I>stdout).</I> </DD>

<DT><B>output()</B>  </DT>
<DD>is not part of the POSIX specification. 
</DD>

<DT>- </DT>
<DD><I>lex</I> does not support exclusive start conditions (%x), though they are 
in the POSIX specification. </DD>

<DT>- </DT>
<DD>When definitions are expanded, <I>flex</I> encloses 
them in parentheses. With lex, the following:  <BR>
 <PRE>  
      NAME    [A-Z][A-Z0-9]* 
     %% 
     foo{NAME}?      printf( "Found it\n" ); 
     %% 
   
   </PRE>will not match the string "foo" because when the macro is expanded 
the rule is equivalent to "foo[A-Z][A-Z0-9]*?" and the precedence is such 
that the '?' is associated with "[A-Z0-9]*".  With <I>flex,</I> the rule will be expanded 
to "foo([A-Z][A-Z0-9]*)?" and so the string "foo" will match. </DD>

<DT>Note that if 
the definition begins with  </DT>
<DD><B>^</B> or ends with <B>$</B> then it is <I>not</I> expanded with 
parentheses, to allow these operators to appear in definitions without 
losing their special meanings.  But the <B>&lt;s&gt;, /,</B> and <B>&lt;&lt;EOF&gt;&gt;</B> operators cannot 
be used in a <I>flex</I> definition. </DD>

<DT>Using  </DT>
<DD><B>-l</B> results in the <I>lex</I> behavior of no 
parentheses around the definition. </DD>

<DT>The POSIX specification is that the 
definition be enclosed in parentheses.  </DT>
<DD></DD>

<DT>- </DT>
<DD>Some implementations of <I>lex</I> allow 
a rule's action to begin on a separate line, if the rule's pattern has trailing 
whitespace:  <BR>
 <PRE>  
      %% 
     foo|bar&lt;space here&gt; 
       { foobar_action(); } 
   
   </PRE><I>flex</I> does not support this feature. </DD>

<DT>- </DT>
<DD>The <I>lex</I> <B>%r</B> (generate a Ratfor 
scanner) option is not supported.  It is not part of the POSIX specification. 
</DD>

<DT>- </DT>
<DD>After a call to <B>unput(),</B> <I>yytext</I> is undefined until the next token is 
matched, unless the scanner was built using <B>%array.</B> This is not the case 
with <I>lex</I> or the POSIX specification.  The <B>-l</B> option does away with this 
incompatibility. </DD>

<DT>- </DT>
<DD>The precedence of the <B>{}</B> (numeric range) operator is 
different. <I>lex</I> interprets "abc{1,3}" as "match one, two, or three occurrences 
of 'abc'", whereas <I>flex</I> interprets it as "match 'ab' followed by one, two, 
or three occurrences of 'c'".  The latter is in agreement with the POSIX 
specification. </DD>

<DT>- </DT>
<DD>The precedence of the <B>^</B> operator is different. <I>lex</I> interprets 
"^foo|bar" as "match either 'foo' at the beginning of a line, or 'bar' anywhere", 
whereas <I>flex</I> interprets it as "match either 'foo' or 'bar' if they come at 
the beginning of a line".  The latter is in agreement with the POSIX specification. 
</DD>

<DT>- </DT>
<DD>The special table-size declarations such as <B>%a</B> supported by <I>lex</I> are not 
required by <I>flex</I> scanners; <I>flex</I> ignores them. </DD>

<DT>- </DT>
<DD>The name  FLEX_SCANNER is 
#define'd so scanners may be written for use with either <I>flex</I> or <I>lex.</I> Scanners 
also include <B>YY_FLEX_MAJOR_VERSION</B> and <B>YY_FLEX_MINOR_VERSION</B> indicating 
which version of <I>flex</I> generated the scanner (for example, for the 2.5 release, 
these defines would be 2 and 5 respectively). </DD>
</DL>
<P>
The following <I>flex</I> features 
are not included in <I>lex</I> or the POSIX specification:  <BR>
 <PRE>  
      C++ scanners 
     %option 
     start condition scopes 
     start condition stacks 
     interactive/non-interactive scanners 
     yy_scan_string() and friends 
     yyterminate() 
     yy_set_interactive() 
     yy_set_bol() 
     YY_AT_BOL() 
     &lt;&lt;EOF&gt;&gt; 
     &lt;*&gt; 
     YY_DECL 
     YY_START 
     YY_USER_ACTION 
     YY_USER_INIT 
     #line directives 
     %{}'s around actions 
     multiple actions on a line 
   
   </PRE>plus almost all of the flex flags. The last feature in the list refers 
to the fact that with <I>flex</I> you can put multiple actions on the same line, 
separated with semi-colons, while with <I>lex,</I> the following  <BR>
 <PRE>  
      foo    handle_foo(); ++num_foos_seen; 
   
   </PRE>is (rather surprisingly) truncated to  <BR>
 <PRE>  
      foo    handle_foo(); 
   
   </PRE><I>flex</I> does not truncate the action.  Actions that are not enclosed 
in braces are simply terminated at the end of the line.  
<H2><A NAME="sect20" HREF="#toc20">Diagnostics </A></H2>
<P>
<I>warning,</I> 
rule cannot be matched indicates that the given rule cannot be matched 
because it follows other rules that will always match the same text as 
it.  For example, in the following "foo" cannot be matched because it comes 
after an identifier "catch-all" rule:  <BR>
 <PRE>  
      [a-z]+    got_identifier(); 
     foo       got_foo(); 
   
   </PRE>Using <B>REJECT</B> in a scanner suppresses this warning. <P>
<I>warning,</I> <B>-s</B> <I></I> option 
given but default rule can be matched means that it is possible (perhaps 
only in a particular start condition) that the default rule (match any 
single character) is the only one that will match a particular input.  
Since <B>-s</B> was given, presumably this is not intended. <P>
<I>reject_used_but_not_detected</I> 
undefined or <I>yymore_used_but_not_detected</I> undefined - These errors can 
occur at compile time.  They indicate that the scanner uses <B>REJECT</B> or <B>yymore()</B> 
but that <I>flex</I> failed to notice the fact, meaning that <I>flex</I> scanned the 
first two sections looking for occurrences of these actions and failed 
to find any, but somehow you snuck some in (via a #include file, for example). 
 Use <B>%option reject</B> or <B>%option yymore</B> to indicate to flex that you really 
do use these features. <P>
<I>flex</I> scanner jammed - a scanner compiled with <B>-s</B> has 
encountered an input string which wasn't matched by any of its rules.  This 
error can also occur due to internal problems. <P>
<I>token</I> too large, exceeds 
YYLMAX - your scanner uses <B>%array</B> and one of its rules matched a string 
longer than the <B>YYLMAX</B> constant (8K bytes by default).  You can increase 
the value by #define'ing <B>YYLMAX</B> in the definitions section of your <I>flex</I> 
input. <P>
<I>scanner</I> requires -8 flag to <I>use</I> the character 'x' - Your scanner specification 
includes recognizing the 8-bit character <I>'x'</I> and you did not specify the 
-8 flag, and your scanner defaulted to 7-bit because you used the <B>-Cf</B> or 
<B>-CF</B> table compression options.  See the discussion of the <B>-7</B> flag for details. 
<P>
<I>flex</I> scanner push-back overflow - you used <B>unput()</B> to push back so much 
text that the scanner's buffer could not hold both the pushed-back text 
and the current token in <B>yytext.</B> Ideally the scanner should dynamically 
resize the buffer in this case, but at present it does not. <P>
<I></I> input buffer 
overflow, can't enlarge buffer because scanner uses REJECT - the scanner 
was working on matching an extremely large token and needed to expand 
the input buffer.  This doesn't work with scanners that use <B></B> REJECT. <P>
<I></I> fatal 
flex scanner internal error--end of buffer missed - This can occur in an 
scanner which is reentered after a long-jump has jumped out (or over) the 
scanner's activation frame.  Before reentering the scanner, use:  <BR>
 <PRE>  
      yyrestart( yyin ); 
   
   </PRE>or, as noted above, switch to using the C++ scanner class. <P>
<I>too</I> many 
start conditions in &lt;&gt; construct! - you listed more start conditions in a 
&lt;&gt; construct than exist (so you must have listed at least one of them twice). 
 
<H2><A NAME="sect21" HREF="#toc21">Files </A></H2>

<DL>

<DT><B>-lfl</B>  </DT>
<DD>library with which scanners must be linked. </DD>

<DT><I>lex.yy.c</I>  </DT>
<DD>generated 
scanner (called <I>lexyy.c</I> on some systems). </DD>

<DT><I>lex.yy.cc</I>  </DT>
<DD>generated C++ scanner 
class, when using <B>-+.</B> </DD>

<DT><I>&lt;FlexLexer.h&gt;</I>  </DT>
<DD>header file defining the C++ scanner base 
class, <B>FlexLexer,</B> and its derived class, <B>yyFlexLexer.</B> </DD>

<DT><I>flex.skl</I>  </DT>
<DD>skeleton 
scanner.  This file is only used when building flex, not when flex executes. 
</DD>

<DT><I>lex.backup</I>  </DT>
<DD>backing-up information for <B>-b</B> flag (called <I>lex.bck</I> on some systems). 
</DD>
</DL>
 
<H2><A NAME="sect22" HREF="#toc22">Deficiencies / Bugs </A></H2>
<P>
Some trailing context patterns cannot be properly 
matched and generate warning messages ("dangerous trailing context").  
These are patterns where the ending of the first part of the rule matches 
the beginning of the second part, such as "zx*/xy*", where the 'x*' matches 
the 'x' at the beginning of the trailing context.  (Note that the POSIX draft 
states that the text matched by such patterns is undefined.) <P>
For some trailing 
context rules, parts which are actually fixed-length are not recognized 
as such, leading to the abovementioned performance loss. In particular, 
parts using '|' or {n} (such as "foo{3}") are always considered variable-length. 
<P>
Combining trailing context with the special '|' action can result in <I>fixed</I> 
trailing context being turned into the more expensive <I>variable</I> trailing 
context.  For example, in the following:  <BR>
 <PRE>  
      %% 
     abc      | 
     xyz/def 
   
   </PRE><P>
Use of <B>unput()</B> invalidates yytext and yyleng, unless the <B>%array</B> 
directive or the <B>-l</B> option has been used. <P>
Pattern-matching of NUL's is substantially 
slower than matching other characters. <P>
Dynamic resizing of the input buffer 
is slow, as it entails rescanning all the text matched so far by the current 
(generally huge) token. <P>
Due to both buffering of input and read-ahead, you 
cannot intermix calls to &lt;stdio.h&gt; routines, such as, for example, <B>getchar(),</B> 
with <I>flex</I> rules and expect it to work.  Call <B>input()</B> instead. <P>
The total 
table entries listed by the <B>-v</B> flag excludes the number of table entries 
needed to determine what rule has been matched.  The number of entries 
is equal to the number of DFA states if the scanner does not use <B>REJECT,</B> 
and somewhat greater than the number of states if it does. <P>
<B>REJECT</B> cannot 
be used with the <B>-f</B> or <B>-F</B> options. <P>
The <I>flex</I> internal algorithms need documentation. 
 
<H2><A NAME="sect23" HREF="#toc23">See Also </A></H2>
<P>
<A HREF="s">lex(1)</A>
, <A HREF="s">yacc(1)</A>
, <A HREF="s">sed(1)</A>
, <A HREF="s">awk(1)</A>
. <P>
John Levine, Tony Mason, and 
Doug Brown, <I>Lex</I> &amp; Yacc, O'Reilly and Associates.  Be sure to get the 2nd 
edition. <P>
M. E. Lesk and E. Schmidt, <I>LEX</I> - Lexical Analyzer Generator <P>
Alfred 
Aho, Ravi Sethi and Jeffrey Ullman, <I>Compilers:</I> Principles, Techniques 
and Tools, Addison-Wesley (1986).  Describes the pattern-matching techniques 
used by <I>flex</I> (deterministic finite automata).  
<H2><A NAME="sect24" HREF="#toc24">Author </A></H2>
Vern Paxson, with 
the help of many ideas and much inspiration from Van Jacobson.  Original 
version by Jef Poskanzer.  The fast table representation is a partial implementation 
of a design done by Van Jacobson.  The implementation was done by Kevin 
Gong and Vern Paxson. <P>
Thanks to the many <I>flex</I> beta-testers, feedbackers, 
and contributors, especially Francois Pinard, Casey Leedom, Robert Abramovitz, 
Stan Adermann, Terry Allen, David Barker-Plummer, John Basrai, Neal Becker, 
Nelson H.F. Beebe, benson@odi.com, Karl Berry, Peter A. Bigot, Simon Blanchard, 
Keith Bostic, Frederic Brehm, Ian Brockbank, Kin Cho, Nick Christopher, 
Brian Clapper, J.T. Conklin, Jason Coughlin, Bill Cox, Nick Cropper, Dave 
Curtis, Scott David Daniels, Chris G. Demetriou, Theo Deraadt, Mike Donahue, 
Chuck Doucette, Tom Epperly, Leo Eskin, Chris Faylor, Chris Flatters, 
Jon Forrest, Jeffrey Friedl, Joe Gayda, Kaveh R. Ghazi, Wolfgang Glunz, 
Eric Goldman, Christopher M. Gould, Ulrich Grepel, Peer Griebel, Jan Hajic, 
Charles Hemphill, NORO Hideo, Jarkko Hietaniemi, Scott Hofmann, Jeff Honig, 
Dana Hudes, Eric Hughes, John Interrante, Ceriel Jacobs, Michal Jaegermann, 
Sakari Jalovaara, Jeffrey R. Jones, Henry Juengst, Klaus Kaempf, Jonathan 
I. Kamens, Terrence O Kane, Amir Katz, ken@ken.hilco.com, Kevin B. Kenny, 
Steve Kirsch, Winfried Koenig, Marq Kole, Ronald Lamprecht, Greg Lee, 
Rohan Lenard, Craig Leres, John Levine, Steve Liddle, David Loffredo, 
Mike Long, Mohamed el Lozy, Brian Madsen, Malte, Joe Marshall, Bengt Martensson, 
Chris Metcalf, Luke Mewburn, Jim Meyering, R. Alexander Milowski, Erik 
Naggum, G.T. Nicol, Landon Noll, James Nordby, Marc Nozell, Richard Ohnemus, 
Karsten Pahnke, Sven Panne, Roland Pesch, Walter Pelissero, Gaumond Pierre, 
Esmond Pitt, Jef Poskanzer, Joe Rahmeh, Jarmo Raiha, Frederic Raimbault, 
Pat Rankin, Rick Richardson, Kevin Rodgers, Kai Uwe Rommel, Jim Roskind, 
Alberto Santini, Andreas Scherer, Darrell Schiebel, Raf Schietekat, Doug 
Schmidt, Philippe Schnoebelen, Andreas Schwab, Larry Schwimmer, Alex Siegel, 
Eckehard Stolz, Jan-Erik Strvmquist, Mike Stump, Paul Stuart, Dave Tallman, 
Ian Lance Taylor, Chris Thewalt, Richard M. Timoney, Jodi Tsai, Paul Tuinenga, 
Gary Weik, Frank Whaley, Gerhard Wilhelms, Kent Williams, Ken Yap, Ron 
Zellar, Nathan Zelle, David Zuhn, and those whose names have slipped my 
marginal mail-archiving skills but whose contributions are appreciated 
all the same. <P>
Thanks to Keith Bostic, Jon Forrest, Noah Friedman, John 
Gilmore, Craig Leres, John Levine, Bob Mulcahy, G.T. Nicol, Francois Pinard, 
Rich Salz, and Richard Stallman for help with various distribution headaches. 
<P>
Thanks to Esmond Pitt and Earle Horton for 8-bit character support; to 
Benson Margulies and Fred Burke for C++ support; to Kent Williams and 
Tom Epperly for C++ class support; to Ove Ewerlid for support of NUL's; 
and to Eric Hughes for support of multiple buffers. <P>
This work was primarily 
done when I was with the Real Time Systems Group at the Lawrence Berkeley 
Laboratory in Berkeley, CA.  Many thanks to all there for the support I 
received. <P>
Send comments to vern@ee.lbl.gov. <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Synopsis</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Overview</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Description</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Some Simple Examples</A></LI>
<LI><A NAME="toc5" HREF="#sect5">Format of the Input File</A></LI>
<LI><A NAME="toc6" HREF="#sect6">Patterns</A></LI>
<LI><A NAME="toc7" HREF="#sect7">How the Input is Matched</A></LI>
<LI><A NAME="toc8" HREF="#sect8">Actions</A></LI>
<LI><A NAME="toc9" HREF="#sect9">the Generated Scanner</A></LI>
<LI><A NAME="toc10" HREF="#sect10">Start Conditions</A></LI>
<LI><A NAME="toc11" HREF="#sect11">Multiple Input Buffers</A></LI>
<LI><A NAME="toc12" HREF="#sect12">End-of-file Rules</A></LI>
<LI><A NAME="toc13" HREF="#sect13">Miscellaneous Macros</A></LI>
<LI><A NAME="toc14" HREF="#sect14">Values Available to the User</A></LI>
<LI><A NAME="toc15" HREF="#sect15">Interfacing with Yacc</A></LI>
<LI><A NAME="toc16" HREF="#sect16">Options</A></LI>
<LI><A NAME="toc17" HREF="#sect17">Performance Considerations</A></LI>
<LI><A NAME="toc18" HREF="#sect18">Generating C++ Scanners</A></LI>
<LI><A NAME="toc19" HREF="#sect19">Incompatibilities with Lex and Posix</A></LI>
<LI><A NAME="toc20" HREF="#sect20">Diagnostics</A></LI>
<LI><A NAME="toc21" HREF="#sect21">Files</A></LI>
<LI><A NAME="toc22" HREF="#sect22">Deficiencies / Bugs</A></LI>
<LI><A NAME="toc23" HREF="#sect23">See Also</A></LI>
<LI><A NAME="toc24" HREF="#sect24">Author</A></LI>
</UL>
</BODY></HTML>
