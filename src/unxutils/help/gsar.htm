<!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>gsar(1) manual page</TITLE>
</HEAD>
<BODY bgcolor=white>
<A HREF="#toc">Table of Contents</A><P>
 
<H1>gsar(1) manual page</H1>

<H2><A NAME="sect0" HREF="#toc0">Name </A></H2>
<B>gsar </B> - General Search And Replace utility <P>
 
<H2><A NAME="sect1" HREF="#toc1">Synopsis </A></H2>
<B>gsar </B> [<I>options 
</I>] [<I>infile(s) </I>] [<I>outfile </I>] <P>
 
<H2><A NAME="sect2" HREF="#toc2">Description </A></H2>
<B>gsar </B> (General Search And Replace) 
is a utility for searching for and --- optionally --- replacing strings in both 
text and binary files. The search and replace strings can contain all kinds 
of characters (0--255), i.e. Ctrl characters and extended ASCII as well. <P>
The 
algorithm used is a variation of the Boyer-Moore search algorithm, modified 
to search binary files. As a result of this, <B>gsar </B> is blindingly fast. <P>
Opposed 
to line oriented search programs (like <B><A HREF="s">grep(1)</A>
 </B>), gsar will find all matches 
on a line. Actually, <B>gsar </B> doesn't know anything about lines at all, all 
files and strings are treated as binary. <P>
<B>Gsar </B> can search one or several 
files for a string and report the occurrences. <B>Gsar </B> can read one file, 
search for a string, replace it with some other string, and create a new 
file containing the changes. <B>Gsar </B> can perform a search and replace in 
multiple files, overwriting the originals. Finally, gsar can work as a 
filter, reading from standard input and writing to standard output. <P>
 
<H2><A NAME="sect3" HREF="#toc3">Options 
</A></H2>
All options can be concatenated into one single option i.e the command: 
<B>gsar  -i -b -l </B> is the same as <B>gsar -ibl </B>  <P>
An option which takes an argument 
must be the last one in the  concatenated option, since the rest of the 
option is taken as  a possible argument.  <P>
Fields enclosed in [] are optional, 
but mandatory when enclosed in &lt;&gt;.  Options are case sensitive i.e <B>-b </B> is not 
the same as <B>-B </B>.  <P>
If no options are given, <B>gsar </B> just gives a brief help 
message.  
<H3><A NAME="sect4" HREF="#toc4">[<B>infile(s) </B>] </A></H3>
Name(s) of input file(s) (wildcards allowed on most 
Unix shells and  most DOS compilers). If the <B>-F </B> option is used input is 
taken from  <I>stdin </I>.  
<H3><A NAME="sect5" HREF="#toc5">[<B>outfile </B>] </A></H3>
Name of output file that is to contain 
the replacements. If the <B>-F </B> option is used, transformed output is sent 
to <I>stdout </I>.  
<H3><A NAME="sect6" HREF="#toc6">-<B>s </B>&lt;<I>string </I>&gt; </A></H3>
String to search for in file. Ctrl characters can 
be entered by using a `:' in the string followed by the ASCII value of the 
character. The value is entered using a `:' followed by three decimal digits 
or `:x' followed by two hex numbers. To enter a colon (<I>: </I>) in the search 
pattern use `::'.  The <I>string </I> must follow directly after <B>s </B>. <P>
Example: To 
search for the string <I>:foo </I> (`o' is 111 decimal, 6F in hex) use the search 
options:   <BR>
  <B>-s::foo </B> or <B>-s::fo:111 </B> or <B>-s::fo:x6F </B> <P>
If you want to search for a string 
with spaces in it, under MSDOS surround the expression with quotes. Under 
Unix, use the mechanisms your shell provides (commonly quotes)  to include 
space or other special characters. <P>
Example: search for <I>gsar is fast </I> use: 
 <BR>
  <B>gsar "-sgsar is fast" foobar.txt </B> <P>
The precompiled <I>MSDOS </I> executable in 
the archive supports response  files. Just put you <B>gsar </B> commands into 
a file and put a `@' in front of the filename on the gsar command line. <P>
Example: 
file <I>foobar.txt </I> contains  <I>-ssupercalifragilisticexpialidocus </I>:  <BR>
  <B>gsar @foobar.txt poppins.txt </B> <P>
If response files are needed, most Unix 
shells will allow  <BR>
  <B>gsar `cat foobar.txt` poppins.txt </B>   
<H3><A NAME="sect7" HREF="#toc7">-<B>r </B>[<I>string </I>] </A></H3>
String which is to replace 
search string in file. Use <B>-r </B> to delete the search string from the file 
i.e. replace with nothing. Ctrl characters can be entered in the same way 
as in the search string. If this option is left out, <B>gsar </B> only  performs 
a search. The <I>string </I> must follow directly after <B>r </B>.  
<H3><A NAME="sect8" HREF="#toc8">-<B>i </B></A></H3>
Ignore case difference 
when comparing strings. I.e. <I>foobar </I> matches <I>fooBAR </I>.  
<H3><A NAME="sect9" HREF="#toc9">-<B>B </B></A></H3>
Just display the 
search &amp; replace buffers, for test purposes.  
<H3><A NAME="sect10" HREF="#toc10">-<B>f </B></A></H3>
If the output file already 
exists this switch can be used to force an overwrite of the existing output 
file.  
<H3><A NAME="sect11" HREF="#toc11">-<B>o </B></A></H3>
Search and replace of multiple files, overwrite the input  file(s). 
For each input file, gsar creates a tempfile which contains the replacements 
and copies the tempfile to the original input file name. If no matches 
were found, the input file stays the same. The tempfile is removed. <P>
Example: 
   <B>gsar -s__ZTC__ -r__TURBOC__ -o foo.c bar.c bat.c </B>  <BR>
The files <I>foo.c </I>, <I>bar.c </I> &amp; <I>bat.c </I> are all changed.  
<H3><A NAME="sect12" HREF="#toc12">-<B>c </B>[<I>n </I>] </A></H3>
Display the context 
around a match in a textual manner. Undisplayable characters are displayed 
as a dot (`.'). <I>n </I> is  optional number of bytes in context. <I>n </I> must follow 
directly after <B>c </B>.  
<H3><A NAME="sect13" HREF="#toc13">-<B>x </B>[<I>n </I>] </A></H3>
Display the context around a match as a hexadecimal 
dump. Undisplayable characters are displayed as a dot (`.'). <I>n </I> is  optional 
number of bytes in context. <I>n </I> must follow directly after <B>x </B>.  
<H3><A NAME="sect14" HREF="#toc14">-<B>b </B></A></H3>
Display 
the byte offset of the match in hex.  
<H3><A NAME="sect15" HREF="#toc15">-<B>l </B></A></H3>
Only list filename and number of 
matches if any (default).  
<H3><A NAME="sect16" HREF="#toc16">-<B>h </B></A></H3>
Suppress display of filename when displaying 
context or byte offsets.  
<H3><A NAME="sect17" HREF="#toc17">-<B>du </B></A></H3>
Convert a DOS ASCII file to UNIX (strips carriage 
return).  
<H3><A NAME="sect18" HREF="#toc18">-<B>ud </B></A></H3>
Convert a UNIX ASCII file to DOS (adds carriage return).  
<H3><A NAME="sect19" HREF="#toc19">-<B>F 
</B></A></H3>
<I>Filter </I> mode, gsar takes it's input from <I>stdin </I> and redirects eventual 
output to <I>stdout </I>. All error messages are sent <I>stderr </I>.  
<H3><A NAME="sect20" HREF="#toc20">-<B>G </B></A></H3>
Display the GNU 
General Public Licence. <P>
 
<H2><A NAME="sect21" HREF="#toc21"><B>Examples </B></A></H2>
Search for two spaces at the end of a 
line (DOS text) and replace with just a carriage return overwriting the 
original files: <P>
  <B>gsar  -s:x20:x20:x0d  -r:x0d  -o  foobar.txt  *.c </B> <P>
Convert 
a UNIX text file to DOS format overwriting the original file: <P>
  <B>gsar  
-ud  -o  unix.txt </B> <P>
Search for the string <I>WATCOM </I> and replace with <I>__ZTC__ 
</I> using gsar as a filter. Output is redirected to a new file: <P>
  <B>gsar  -sWATCOM 
 -r__ZTC__  -F  &lt;  foo_w.c  &gt;  foo_z.c </B> <P>
Display textual context of the string 
<I>error </I> in the file <I>gsar.exe </I> disregarding case. With 40 bytes in the context: 
<P>
  <B>gsar  -serror  -i  -c40  gsar.exe </B> <P>
Search for the string <I>gnu </I> in the file 
<I>fsf </I> and replace it with <I>wildebeest </I>, creating a new output file <I>africa 
</I>: <P>
  <B>gsar  -sgnu  -rwildebeest  fsf  africa </B> <P>
(if the file <I>africa </I> exists, 
you have to use the <B>-f </B>  option to overwrite it.) <P>
Search for the string 
<I>error </I> in the file <I>command.com </I>  and display the byte offset of each match: 
<P>
  <B>gsar  -serror  -b  command.com </B> <P>
 
<H2><A NAME="sect22" HREF="#toc22"><B>Limitations </B></A></H2>
No wildcards or regular expressions 
allowed in search string. <P>
On MSDOS platforms <I>stdin </I> from a tty is not allowed 
because <I>stdin </I> has been turned into binary. MSDOS will not catch the Ctrl-Z 
signifying EOF.  
<H2><A NAME="sect23" HREF="#toc23"><B>Authors </B></A></H2>
Tormod Tjaberg (coding, design (all bugs are his)) 
 <BR>
Hans Peter Verne (ideas, demands, testing, UNIX platforms) <P>
If you have 
any comments, bug reports or whatever, we can be reached through email 
at: <P>
<I>tormod@sn.no </I>  <BR>
<I>hpv@kjemi.uio.no </I>  <BR>
<P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Synopsis</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Description</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Options</A></LI>
<UL>
<LI><A NAME="toc4" HREF="#sect4">[infile(s) ]</A></LI>
<LI><A NAME="toc5" HREF="#sect5">[outfile ]</A></LI>
<LI><A NAME="toc6" HREF="#sect6">-s <string ></A></LI>
<LI><A NAME="toc7" HREF="#sect7">-r [string ]</A></LI>
<LI><A NAME="toc8" HREF="#sect8">-i</A></LI>
<LI><A NAME="toc9" HREF="#sect9">-B</A></LI>
<LI><A NAME="toc10" HREF="#sect10">-f</A></LI>
<LI><A NAME="toc11" HREF="#sect11">-o</A></LI>
<LI><A NAME="toc12" HREF="#sect12">-c [n ]</A></LI>
<LI><A NAME="toc13" HREF="#sect13">-x [n ]</A></LI>
<LI><A NAME="toc14" HREF="#sect14">-b</A></LI>
<LI><A NAME="toc15" HREF="#sect15">-l</A></LI>
<LI><A NAME="toc16" HREF="#sect16">-h</A></LI>
<LI><A NAME="toc17" HREF="#sect17">-du</A></LI>
<LI><A NAME="toc18" HREF="#sect18">-ud</A></LI>
<LI><A NAME="toc19" HREF="#sect19">-F</A></LI>
<LI><A NAME="toc20" HREF="#sect20">-G</A></LI>
</UL>
<LI><A NAME="toc21" HREF="#sect21">Examples</A></LI>
<LI><A NAME="toc22" HREF="#sect22">Limitations</A></LI>
<LI><A NAME="toc23" HREF="#sect23">Authors</A></LI>
</UL>
</BODY></HTML>
