  <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>PATCH(1) manual page</TITLE>
</HEAD>
<BODY bgcolor=white>
<A HREF="#toc">Table of Contents</A><P>
<P>

 <H1>PATCH(1) manual page</H1>

<H2><A NAME="sect0" HREF="#toc0">Name </A></H2>
patch - apply a diff file to an original  
<H2><A NAME="sect1" HREF="#toc1">Synopsis </A></H2>
<B>patch</B> [<I>options</I>]<I></I> 
[<I>originalfile</I> [<I>patchfile</I>]]<I></I>  <P>
  but usually just  <P>
  <B>patch -p</B><I>num</I> <B>&lt;</B><I>patchfile</I> 
 
<H2><A NAME="sect2" HREF="#toc2">Description </A></H2>
<B>patch</B> takes a patch file <I>patchfile</I> containing a difference 
listing produced by the <B>diff</B> program and applies those differences to 
one or more original files, producing patched versions. Normally the patched 
versions are put in place of the originals. Backups can be made; see the 
<B>-b</B> or <B>backup</B> option. The names of the files to be patched are usually taken 
from the patch file, but if there's just one file to be patched it can 
specified on the command line as <I>originalfile</I>. <P>
Upon startup, patch attempts 
to determine the type of the diff listing, unless overruled by a <B>-c </B> (<B>context 
</B>), <B>-e </B> (<B>ed </B>), <B>-n </B> (<B>normal </B>), or <B>-u </B> (<B>unified </B>) option. Context diffs (old-style, 
new-style, and unified) and normal diffs are applied by the <B>patch</B> program 
itself, while <B>ed</B> diffs are simply fed to the <B><A HREF="s">ed</B>(1)</A>
 editor via a pipe. <P>
<B>patch</B> 
tries to skip any leading garbage, apply the diff, and then skip any trailing 
garbage. Thus you could feed an article or message containing a diff listing 
to <B>patch</B>, and it should work. If the entire diff is indented by a consistent 
amount, or if a context diff is encapsulated one or more times by prepending 
"<B>-  </B>" to lines starting with "<B>- </B>" as specified by Internet RFC 934, this 
is taken into account. <P>
With context diffs, and to a lesser extent with 
normal diffs, <B>patch</B> can detect when the line numbers mentioned in the 
patch are incorrect, and attempts to find the correct place to apply each 
hunk of the patch. As a first guess, it takes the line number mentioned 
for the hunk, plus or minus any offset used in applying the previous hunk. 
If that is not the correct place, <B>patch</B> scans both forwards and backwards 
for a set of lines matching the context given in the hunk. First <B>patch</B> 
looks for a place where all lines of the context match. If no such place 
is found, and it's a context diff, and the maximum fuzz factor is set to 
1 or more, then another scan takes place ignoring the first and last line 
of context. If that fails, and the maximum fuzz factor is set to 2 or more, 
the first two and last two lines of context are ignored, and another scan 
is made. (The default maximum fuzz factor is 2.) If <B>patch</B> cannot find a 
place to install that hunk of the patch, it puts the hunk out to a reject 
file, which normally is the name of the output file plus a <B>.rej</B> suffix, 
or <B>#</B> if <B>.rej</B> would generate a file name that is too long (if even appending 
the single character <B>#</B> makes the file name too long, then <B>#</B> replaces the 
file name's last character). (The rejected hunk comes out in ordinary context 
diff form regardless of the input patch's form. If the input was a normal 
diff, many of the contexts are simply null.) The line numbers on the hunks 
in the reject file may be different than in the patch file: they reflect 
the approximate location patch thinks the failed hunks belong in the new 
file rather than the old one. <P>
As each hunk is completed, you are told if 
the hunk failed, and if so which line (in the new file) <B>patch</B> thought 
the hunk should go on. If the hunk is installed at a different line from 
the line number specified in the diff you are told the offset. A single 
large offset <I>may</I> indicate that a hunk was installed in the wrong place. 
You are also told if a fuzz factor was used to make the match, in which 
case you should also be slightly suspicious. If the <B>verbose</B> option is given, 
you are also told about hunks that match exactly. <P>
If no original file <I>origfile</I> 
is specified on the command line, <B>patch</B> tries to figure out from the leading 
garbage what the name of the file to edit is, using the following rules. 

<DL>

<DT><B> &#183;</B> If the header is that of a context diff,  </DT>
<DD><B>patch</B> takes the old and new 
file names in the header. Any <B>/dev/null</B> names are ignored. </DD>

<DT><B> &#183;</B> If there is 
an  </DT>
<DD><B>Index:</B> line in the leading garbage and if either the old and new names 
are both absent or the <B>POSIXLY_CORRECT</B> environment variable is set, <B>patch</B> 
takes the name in the <B>Index:</B> line. </DD>

<DT><B> &#183;</B> For the purpose of the following rules, 
 </DT>
<DD>the names are considered to be in the order (old, new, index), regardless 
of the order that they appear in the header. </DD>

<DT><B> &#183;</B> If some of the named files 
exist,  </DT>
<DD><B>patch</B> uses the first name if the <B>POSIXLY_CORRECT</B> environment variable 
is set, and the best name otherwise. </DD>

<DT><B> &#183;</B> If  </DT>
<DD><B>patch</B> is not ignoring <FONT SIZE=-1>RCS</FONT>
 and 
<FONT SIZE=-1>SCCS</FONT>
 (see the <B>-g&nbsp;</B><I>num</I> or <B>get=</B><I>num</I> option), and no named files exist but an 
<FONT SIZE=-1>RCS</FONT>
 or <FONT SIZE=-1>SCCS</FONT>
 master is found, <B>patch</B> uses the first named file with an <FONT SIZE=-1>RCS</FONT>
 
or <FONT SIZE=-1>SCCS</FONT>
 master. <FONT SIZE=-1></FONT>
<FONT SIZE=-1></FONT>
</DD>

<DT><B> &#183;</B> If no named files exist, no RCS or SCCS master was found, 
 </DT>
<DD>some names are given, <B>POSIXLY_CORRECT</B> is not set, and the patch appears 
to create a file, <B>patch</B> uses the best name requiring the creation of the 
fewest directories. </DD>

<DT><B> &#183;</B> If no file name results from the above heuristics, 
you are asked  </DT>
<DD>for the name of the file to patch. </DD>
</DL>
<P>
To determine the <I>best</I> 
of a nonempty list of file names, <B>patch</B> first takes all the names with 
the fewest path name components; of those, it then takes all the names 
with the shortest basename; of those, it then takes all the shortest names; 
finally, it takes the first remaining name. <P>
Additionally, if the leading 
garbage contains a <B>Prereq:</B> line, <B>patch</B> takes the first word from the prerequisites 
line (normally a version number) and checks the original file to see if 
that word can be found. If not, <B>patch</B> asks for confirmation before proceeding. 
<P>
The upshot of all this is that you should be able to say, while in a news 
interface, something like the following:  <P>
  <tt> </tt>&nbsp;<tt> </tt>&nbsp;<B>| patch -d /usr/src/local/blurfl 
</B>  <P>
  and patch a file in the <B>blurfl</B> directory directly from the article 
containing the patch. <P>
If the patch file contains more than one patch, <B>patch</B> 
tries to apply each of them as if they came from separate patch files. 
This means, among other things, that it is assumed that the name of the 
file to patch must be determined for each diff listing, and that the garbage 
before each diff listing contains interesting things such as file names 
and revision level, as mentioned previously.  
<H2><A NAME="sect3" HREF="#toc3">Options </A></H2>

<DL>

<DT><B>-b </B>  or  <B>backup </B>  
</DT>
<DD>Make backup files. That is, when patching a file, rename or copy the original 
instead of removing it. When backing up a file that does not exist, an 
empty, unreadable backup file is created as a placeholder to represent 
the nonexistent file. See the <B>-V</B> or <B>version-control</B> option for details about 
how backup file names are determined. </DD>

<DT><B>backup-if-mismatch</B>  </DT>
<DD>Back up a file 
if the patch does not match the file exactly and if backups are not otherwise 
requested. This is the default unless the <B>POSIXLY_CORRECT</B> environment variable 
is set. </DD>

<DT><B>no-backup-if-mismatch</B>  </DT>
<DD>Do not back up a file if the patch does not 
match the file exactly and if backups are not otherwise requested. This 
is the default if the <B>POSIXLY_CORRECT</B> environment variable is set. </DD>

<DT><B>-B </B> <I>pref 
</I>  or  <B>prefix= </B><I>pref </I>  </DT>
<DD>Prefix <I>pref</I> to a file name when generating its simple 
backup file name. For example, with <B>-B&nbsp;/junk/</B> the simple backup file name 
for <B>src/patch/util.c</B> is <B>/junk/src/patch/util.c</B>. </DD>

<DT><B>binary </B>  </DT>
<DD>Read and write all 
files in binary mode, except for standard output and <B>/dev/tty</B>. This option 
has no effect on <FONT SIZE=-1>POSIX</FONT>
-compliant systems. On systems like <FONT SIZE=-1>DOS</FONT>
 where this 
option makes a difference, the patch should be generated by <B>diff&nbsp;-a&nbsp;binary</B>. 
</DD>

<DT><B>-c </B>  or  <B>context </B>  </DT>
<DD>Interpret the patch file as a ordinary context diff. 
</DD>

<DT><B>-d </B> <I>dir </I>  or  <B>directory= </B><I>dir </I>  </DT>
<DD>Change to the directory <I>dir</I> immediately, 
before doing anything else. </DD>

<DT><B>-D </B> <I>define </I>  or  <B>ifdef= </B><I>define </I>  </DT>
<DD>Use the <B>#ifdef</B> 
... <B>#endif</B> construct to mark changes, with <I>define</I> as the differentiating 
symbol. </DD>

<DT><B>dry-run</B>  </DT>
<DD>Print the results of applying the patches without actually 
changing any files. </DD>

<DT><B>-e </B>  or  <B>ed </B>  </DT>
<DD>Interpret the patch file as an <B>ed</B> script. 
</DD>

<DT><B>-E </B>  or  <B>remove-empty-files </B>  </DT>
<DD>Remove output files that are empty after the 
patches have been applied. Normally this option is unnecessary, since <B>patch</B> 
can examine the time stamps on the header to determine whether a file 
should exist after patching. However, if the input is not a context diff 
or if the <B>POSIXLY_CORRECT</B> environment variable is set, <B>patch</B> does not 
remove empty patched files unless this option is given. When <B>patch</B> removes 
a file, it also attempts to remove any empty ancestor directories. </DD>

<DT><B>-f </B>  
or  <B>force </B>  </DT>
<DD>Assume that the user knows exactly what he or she is doing, 
and do not ask any questions.  Skip patches whose headers do not say which 
file is to be patched; patch files even though they have the wrong version 
for the <B>Prereq:</B> line in the patch; and assume that patches are not reversed 
even if they look like they are. This option does not suppress commentary; 
use <B>-s</B> for that. </DD>

<DT><B>-F </B> <I>num </I>  or  <B>fuzz= </B><I>num </I>  </DT>
<DD>Set the maximum fuzz factor. This 
option only applies to diffs that have context, and causes <B>patch</B> to ignore 
up to that many lines in looking for places to install a hunk. Note that 
a larger fuzz factor increases the odds of a faulty patch. The default 
fuzz factor is 2, and it may not be set to more than the number of lines 
of context in the context diff, ordinarily 3. </DD>

<DT><B>-g </B> <I>num </I>  or  <B>get= </B><I>num </I>  </DT>
<DD>This 
option controls <B>patch</B>'s actions when a file is under <FONT SIZE=-1>RCS</FONT>
 or <FONT SIZE=-1>SCCS</FONT>
 control, 
and does not exist or is read-only and matches the default version. If <I>num</I> 
is positive, <B>patch</B> gets (or checks out) the file from the revision control 
system; if zero, <B>patch</B> ignores <FONT SIZE=-1>RCS</FONT>
 and <FONT SIZE=-1>SCCS</FONT>
 and does not get the file; 
and if negative, <B>patch</B> asks the user whether to get the file. The default 
value of this option is given by the value of the <B>PATCH_GET</B> environment 
variable if it is set; if not, the default value is zero if  <B>POSIXLY_CORRECT</B> 
is set, negative otherwise. </DD>

<DT><B>help</B>  </DT>
<DD>Print a summary of options and exit. </DD>

<DT><B>-i 
</B> <I>patchfile </I>  or  <B>input= </B><I>patchfile </I>  </DT>
<DD>Read the patch from <I>patchfile</I>. If <I>patchfile</I> 
is <B>-</B>, read from standard input, the default. </DD>

<DT><B>-l </B>  or  <B>ignore-whitespace </B>  
</DT>
<DD>Match patterns loosely, in case tabs or spaces have been munged in your 
files. Any sequence of one or more blanks in the patch file matches any 
sequence in the original file, and sequences of blanks at the ends of 
lines are ignored. Normal characters must still match exactly. Each line 
of the context must still match a line in the original file. </DD>

<DT><B>-n </B>  or  <B>normal 
</B>  </DT>
<DD>Interpret the patch file as a normal diff. </DD>

<DT><B>-N </B>  or  <B>forward </B>  </DT>
<DD>Ignore patches 
that seem to be reversed or already applied. See also <B>-R</B>. </DD>

<DT><B>-o </B> <I>outfile </I>  or 
 <B>output= </B><I>outfile </I>  </DT>
<DD>Send output to <I>outfile</I> instead of patching files in 
place. </DD>

<DT><B>-p </B><I>num </I>  or  <B>strip </B><B>= </B><I>num </I>  </DT>
<DD>Strip the smallest prefix containing <I>num</I> 
leading slashes from each file name found in the patch file. A sequence 
of one or more adjacent slashes is counted as a single slash. This controls 
how file names found in the patch file are treated, in case you keep your 
files in a different directory than the person who sent out the patch. 
For example, supposing the file name in the patch file was  <P>
  <tt> </tt>&nbsp;<tt> </tt>&nbsp;<B>/u/howard/src/blurfl/blurfl.c 
</B>  <P>
  setting <B>-p0</B> gives the entire file name unmodified, <B>-p1</B> gives  <P>
  <tt> </tt>&nbsp;<tt> </tt>&nbsp;<B>u/howard/src/blurfl/blurfl.c 
</B>  <P>
  without the leading slash, <B>-p4</B> gives  <P>
  <tt> </tt>&nbsp;<tt> </tt>&nbsp;<B>blurfl/blurfl.c </B>  <P>
  and not 
specifying <B>-p</B> at all just gives you <B>blurfl.c </B>. Whatever you end up with is 
looked for either in the current directory, or the directory specified 
by the <B>-d</B> option. </DD>

<DT><B>-r </B> <I>rejectfile </I>  or  <B>reject-file= </B><I>rejectfile </I>  </DT>
<DD>Put rejects 
into <I>rejectfile</I> instead of the default <B>.rej</B> file. </DD>

<DT><B>-R </B>  or  <B>reverse </B>  </DT>
<DD>Assume 
that this patch was created with the old and new files swapped. (Yes, I'm 
afraid that does happen occasionally, human nature being what it is.) <B>patch</B> 
attempts to swap each hunk around before applying it. Rejects come out 
in the swapped format. The <B>-R</B> option does not work with <B>ed</B> diff scripts 
because there is too little information to reconstruct the reverse operation. 
 <P>
  If the first hunk of a patch fails, <B>patch</B> reverses the hunk to see 
if it can be applied that way. If it can, you are asked if you want to 
have the <B>-R</B> option set. If it can't, the patch continues to be applied normally. 
(Note: this method cannot detect a reversed patch if it is a normal diff 
and if the first command is an append (i.e. it should have been a delete) 
since appends always succeed, due to the fact that a null context matches 
anywhere. Luckily, most patches add or change lines rather than delete 
them, so most reversed normal diffs begin with a delete, which fails, 
triggering the heuristic.) </DD>

<DT><B>-s </B>  or  <B>silent </B>  or  <B>quiet </B>  </DT>
<DD>Work silently, 
unless an error occurs. </DD>

<DT><B>-t </B>  or  <B>batch </B>  </DT>
<DD>Suppress questions like <B>-f</B>, but 
make some different assumptions: skip patches whose headers do not contain 
file names (the same as <B>-f </B>); skip patches for which the file has the wrong 
version for the <B>Prereq:</B> line in the patch; and assume that patches are 
reversed if they look like they are. </DD>

<DT><B>-T </B>  or  <B>set-time </B>  </DT>
<DD>Set the modification 
and access times of patched files from time stamps given in context diff 
headers, assuming that the context diff headers use local time.  This option 
is not recommended, because patches using local time cannot easily be 
used by people in other time zones, and because local time stamps are 
ambiguous when local clocks move backwards during daylight-saving time 
adjustments.  Instead of using this option, generate patches with <FONT SIZE=-1>UTC</FONT>
 and 
use the <B>-Z</B> or <B>set-utc</B> option instead. </DD>

<DT><B>-u </B>  or  <B>unified </B>  </DT>
<DD>Interpret the patch 
file as a unified context diff. </DD>

<DT><B>-v </B>  or  <B>version </B>  </DT>
<DD>Print out <B>patch</B>'s revision 
header and patch level, and exit. </DD>

<DT><B>-V </B> <I>method </I>  or  <B>version-control= </B><I>method 
</I>  </DT>
<DD>Use <I>method</I> to determine backup file names.  The method can also be given 
by the <B>PATCH_VERSION_CONTROL</B> (or, if that's not set, the <B>VERSION_CONTROL</B>) 
environment variable, which is overridden by this option. The method does 
not affect whether backup files are made; it affects only the names of 
any backup files that are made.  <P>
  The value of <I>method</I> is like the <FONT SIZE=-1>GNU</FONT>
 
Emacs `version-control' variable; <B>patch</B> also recognizes synonyms that are 
more descriptive.  The valid values for <I>method</I> are (unique abbreviations 
are accepted):  <blockquote></DD>

<DT><B>existing </B>  or  <B>nil </B>  </DT>
<DD>Make numbered backups of files that 
already have them, otherwise simple backups. This is the default. </DD>

<DT><B>numbered 
</B>  or  <B>t </B>  </DT>
<DD>Make numbered backups.  The numbered backup file name for <I>F</I> is 
<I>F</I><B>.~</B><I>N</I><B>~</B> where <I>N</I> is the version number. </DD>

<DT><B>simple </B>  or  <B>never </B>  </DT>
<DD>Make simple backups. 
The <B>-B</B> or <B>prefix</B>, <B>-Y</B> or <B>basename-prefix</B>, and <B>-z</B> or <B>suffix</B> options specify 
the simple backup file name. If none of these options are given, then a 
simple backup suffix is used; it is the value of the <B>SIMPLE_BACKUP_SUFFIX</B> 
environment variable if set, and is <B>.orig</B> otherwise. </DD>
</DL>
<P>
With numbered or simple 
backups, if the backup file name is too long, the backup suffix <B>~</B> is used 
instead; if even appending <B>~</B> would make the name too long, then <B>~</B> replaces 
the last character of the file name.  </blockquote>

<DL>

<DT><B>verbose </B>  </DT>
<DD>Output extra information 
about the work being done. </DD>

<DT><B>-x </B> <I>num </I>  or  <B>debug= </B><I>num </I>  </DT>
<DD>Set internal debugging 
flags of interest only to <B>patch</B> patchers. </DD>

<DT><B>-Y </B> <I>pref </I>  or  <B>basename-prefix= 
</B><I>pref </I>  </DT>
<DD>Prefix <I>pref</I> to the basename of a file name when generating its 
simple backup file name. For example, with <B>-Y&nbsp;.del/</B> the simple backup file 
name for <B>src/patch/util.c</B> is <B>src/patch/.del/util.c</B>. </DD>

<DT><B>-z </B> <I>suffix </I>  or  <B>suffix= 
</B><I>suffix </I>  </DT>
<DD>Use <I>suffix</I> as the simple backup suffix. For example, with <B>-z&nbsp;-</B> the 
simple backup file name for <B>src/patch/util.c</B> is <B>src/patch/util.c-</B>. The backup 
suffix may also be specified by the <B>SIMPLE_BACKUP_SUFFIX</B> environment variable, 
which is overridden by this option. </DD>

<DT><B>-Z </B>  or  <B>set-utc </B>  </DT>
<DD>Set the modification 
and access times of patched files from time stamps given in context diff 
headers, assuming that the context diff headers use Coordinated Universal 
Time (<FONT SIZE=-1>UTC</FONT>
, often known as <FONT SIZE=-1>GMT</FONT>
). Also see the <B>-T</B> or <B>set-time</B> option.  <P>
  The 
<B>-Z</B> or <B>set-utc</B> and <B>-T</B> or <B>set-time</B> options normally refrain from setting a file's 
time if the file's original time does not match the time given in the patch 
header, or if its contents do not match the patch exactly.  However, if 
the <B>-f</B> or <B>force</B> option is given, the file time is set regardless.  <P>
  Due 
to the limitations of <B>diff</B> output format, these options cannot update 
the times of files whose contents have not changed.  Also, if you use these 
options, you should remove (e.g. with <B>make&nbsp;clean</B>) all files that depend on 
the patched files, so that later invocations of <B>make</B> do not get confused 
by the patched files' times. </DD>
</DL>
 
<H2><A NAME="sect4" HREF="#toc4">Environment </A></H2>

<DL>

<DT><B>PATCH_GET </B>  </DT>
<DD>This specifies whether 
<B>patch</B> gets missing or read-only files from <FONT SIZE=-1>RCS</FONT>
 or <FONT SIZE=-1>SCCS</FONT>
 by default; see 
the <B>-g</B> or <B>get</B> option. </DD>

<DT><B>POSIXLY_CORRECT</B>  </DT>
<DD>If set, <B>patch</B> conforms more strictly 
to the <FONT SIZE=-1>POSIX</FONT>
 standard: it takes the first existing file from the list 
(old, new, index) when intuiting file names from diff headers, it does 
not remove files that are empty after patching, it does not ask whether 
to get files from <FONT SIZE=-1>RCS</FONT>
 or <FONT SIZE=-1>SCCS</FONT>
, it requires that all options precede the 
files in the command line, and it does not backup files when there is 
a mismatch. </DD>

<DT><B>SIMPLE_BACKUP_SUFFIX</B>  </DT>
<DD>Extension to use for simple backup file 
names instead of <B>.orig</B>. </DD>

<DT><B>TMPDIR </B>, <B>TMP </B>, <B>TEMP </B>  </DT>
<DD>Directory to put temporary 
files in; <B>patch</B> uses the first environment variable in this list that 
is set. If none are set, the default is system-dependent; it is normally 
<B>/tmp</B> on Unix hosts. </DD>

<DT><B>VERSION_CONTROL </B> or <B>PATCH_VERSION_CONTROL </B>  </DT>
<DD>Selects 
version control style; see the <B>-v</B> or <B>version-control</B> option. </DD>
</DL>
 
<H2><A NAME="sect5" HREF="#toc5">Files </A></H2>

<DL>

<DT><I>$TMPDIR</I><B>/p*</B> 
 </DT>
<DD>temporary files </DD>

<DT><B>/dev/tty</B>  </DT>
<DD>controlling terminal; used to get answers to 
questions asked of the user </DD>
</DL>
 
<H2><A NAME="sect6" HREF="#toc6">See Also </A></H2>
<B><A HREF="s">diff</B>(1)</A>
, <B><A HREF="s">ed</B>(1)</A>
  <P>
  Marshall T. Rose 
and Einar A. Stefferud, Proposed Standard for Message Encapsulation, Internet 
RFC 934 &lt;URL:ftp://ftp.isi.edu/in-notes/rfc934.txt&gt; (1985-01).  
<H2><A NAME="sect7" HREF="#toc7">Notes for Patch 
Senders </A></H2>
There are several things you should bear in mind if you are going 
to be sending out patches. <P>
Create your patch systematically. A good method 
is the command <B>diff&nbsp;-Naur&nbsp;</B><I>old&nbsp;new</I> where <I>old</I> and <I>new</I> identify the old and new 
directories. The names <I>old</I> and <I>new</I> should not contain any slashes. The <B>diff</B> 
command's headers should have dates and times in Universal Time using traditional 
Unix format, so that patch recipients can use the <B>-Z</B> or <B>set-utc</B> option. Here 
is an example command, using Bourne shell syntax:  <P>
  <tt> </tt>&nbsp;<tt> </tt>&nbsp;<B>LC_ALL=C TZ=UTC0 
diff -Naur gcc-2.7 gcc-2.8 </B> <P>
Tell your recipients how to apply the patch by 
telling them which directory to <B>cd</B> to, and which <B>patch</B> options to use. 
 The option string <B>-Np1</B> is recommended. Test your procedure by pretending 
to be a recipient and applying your patch to a copy of the original files. 
<P>
You can save people a lot of grief by keeping a <B>patchlevel.h</B> file which 
is patched to increment the patch level as the first diff in the patch 
file you send out. If you put a <B>Prereq:</B> line in with the patch, it won't 
let them apply patches out of order without some warning. <P>
You can create 
a file by sending out a diff that compares <B>/dev/null</B> or an empty file 
dated the Epoch (1970-01-01 00:00:00 <FONT SIZE=-1>UTC</FONT>
) to the file you want to create. 
This only works if the file you want to create doesn't exist already in 
the target directory. Conversely, you can remove a file by sending out 
a context diff that compares the file to be deleted with an empty file 
dated the Epoch. The file will be removed unless the <B>POSIXLY_CORRECT</B> environment 
variable is set and the <B>-E</B> or <B>remove-empty-files</B> option is not given. An easy 
way to generate patches that create and remove files is to use <FONT SIZE=-1>GNU</FONT>
 <B>diff</B>'s 
<B>-N</B> or <B>new-file</B> option. <P>
If the recipient is supposed to use the <B>-p</B><I>N</I> option, 
do not send output that looks like this:  <P>
  <B> <tt> </tt>&nbsp;<tt> </tt>&nbsp;diff -Naur v2.0.29/prog/README 
prog/README  <BR>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;--- v2.0.29/prog/README   Mon Mar 10 15:13:12 1997  <BR>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;+++ prog/README   Mon Mar 17 14:58:22 1997 </B> <P>
  because the two file names 
have different numbers of slashes, and different versions of <B>patch</B> interpret 
the file names differently. To avoid confusion, send output that looks 
like this instead:  <P>
  <B> <tt> </tt>&nbsp;<tt> </tt>&nbsp;diff -Naur v2.0.29/prog/README v2.0.30/prog/README  
<BR>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;--- v2.0.29/prog/README   Mon Mar 10 15:13:12 1997  <BR>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;+++ v2.0.30/prog/README   Mon Mar 17 14:58:22 1997 </B> <P>
  <P>
Avoid sending patches 
that compare backup file names like <B>README.orig</B>, since this might confuse 
<B>patch</B> into patching a backup file instead of the real file. Instead, send 
patches that compare the same base file names in different directories, 
e.g. <B>old/README</B> and <B>new/README</B>. <P>
Take care not to send out reversed patches, 
since it makes people wonder whether they already applied the patch. <P>
Try 
not to have your patch modify derived files (e.g. the file <B>configure</B> where 
there is a line <B>configure: configure.in</B> in your makefile), since the recipient 
should be able to regenerate the derived files anyway. If you must send 
diffs of derived files, generate the diffs using <FONT SIZE=-1>UTC</FONT>
, have the recipients 
apply the patch with the <B>-Z</B> or <B>set-utc</B> option, and have them remove any 
unpatched files that depend on patched files (e.g. with <B>make&nbsp;clean</B>). <P>
While 
you may be able to get away with putting 582 diff listings into one file, 
it may be wiser to group related patches into separate files in case something 
goes haywire.  
<H2><A NAME="sect8" HREF="#toc8">Diagnostics </A></H2>
Diagnostics generally indicate that <B>patch</B> couldn't 
parse your patch file. <P>
If the <B>verbose</B> option is given, the message <B>Hmm...</B> 
indicates that there is unprocessed text in the patch file and that <B>patch</B> 
is attempting to intuit whether there is a patch in that text and, if 
so, what kind of patch it is. <P>
<B>patch</B>'s exit status is 0 if all hunks are 
applied successfully, 1 if some hunks cannot be applied, and 2 if there 
is more serious trouble. When applying a set of patches in a loop it behooves 
you to check this exit status so you don't apply a later patch to a partially 
patched file.  
<H2><A NAME="sect9" HREF="#toc9">Caveats </A></H2>
Context diffs cannot reliably represent the creation 
or deletion of empty files, empty directories, or special files such as 
symbolic links. Nor can they represent changes to file metadata like ownership, 
permissions, or whether one file is a hard link to another. If changes 
like these are also required, separate instructions (e.g. a shell script) 
to accomplish them should accompany the patch. <P>
<B>patch</B> cannot tell if the 
line numbers are off in an <B>ed</B> script, and can detect bad line numbers 
in a normal diff only when it finds a change or deletion. A context diff 
using fuzz factor 3 may have the same problem. Until a suitable interactive 
interface is added, you should probably do a context diff in these cases 
to see if the changes made sense. Of course, compiling without errors is 
a pretty good indication that the patch worked, but not always. <P>
<B>patch</B> usually 
produces the correct results, even when it has to do a lot of guessing. 
However, the results are guaranteed to be correct only when the patch 
is applied to exactly the same version of the file that the patch was 
generated from.  
<H2><A NAME="sect10" HREF="#toc10">Compatibility Issues </A></H2>
The <FONT SIZE=-1>POSIX</FONT>
 standard specifies behavior 
that differs from <B>patch</B>'s traditional behavior. You should be aware of these 
differences if you must interoperate with <B>patch</B> versions 2.1 and earlier, 
which are not <FONT SIZE=-1>POSIX</FONT>
-compliant. 
<DL>

<DT><B> &#183;</B> In traditional  </DT>
<DD><B>patch</B>, the <B>-p</B> option's operand 
was optional, and a bare <B>-p</B> was equivalent to <B>-p0.</B> The <B>-p</B> option now requires 
an operand, and <B>-p&nbsp;0</B> is now equivalent to <B>-p0</B>. For maximum compatibility, 
use options like <B>-p0</B> and <B>-p1</B>.  <P>
  Also, traditional <B>patch</B> simply counted slashes 
when stripping path prefixes; <B>patch</B> now counts pathname components. That 
is, a sequence of one or more adjacent slashes now counts as a single 
slash. For maximum portability, avoid sending patches containing <B>//</B> in 
file names. </DD>

<DT><B> &#183;</B> In traditional  </DT>
<DD><B>patch</B>, backups were enabled by default. This 
behavior is now enabled with the <B>-b</B> or <B>backup</B> option.  <P>
  Conversely, in 
<FONT SIZE=-1>POSIX</FONT>
 <B>patch</B>, backups are never made, even when there is a mismatch. In 
<FONT SIZE=-1>GNU</FONT>
 <B>patch</B>, this behavior is enabled with the <B>no-backup-if-mismatch</B> option 
or by setting the <B>POSIXLY_CORRECT</B> environment variable.  <P>
  The <B>-b</B><I>&nbsp;suffix</I> 
option of traditional <B>patch</B> is equivalent to the <B>-b&nbsp;-z</B><I>&nbsp;suffix</I> options of <FONT SIZE=-1>GNU</FONT>
 
<B>patch</B>. </DD>

<DT><B> &#183;</B> Traditional  </DT>
<DD><B>patch</B> used a complicated (and incompletely documented) 
method to intuit the name of the file to be patched from the patch header. 
This method was not <FONT SIZE=-1>POSIX</FONT>
-compliant, and had a few gotchas. Now <B>patch</B> uses 
a different, equally complicated (but better documented) method that is 
optionally <FONT SIZE=-1>POSIX</FONT>
-compliant; we hope it has fewer gotchas.  The two methods 
are compatible if the file names in the context diff header and the <B>Index:</B> 
line are all identical after prefix-stripping. Your patch is normally compatible 
if each header's file names all contain the same number of slashes. </DD>

<DT><B> &#183;</B> When 
traditional  </DT>
<DD><B>patch</B> asked the user a question, it sent the question to 
standard error and looked for an answer from the first file in the following 
list that was a terminal: standard error, standard output, <B>/dev/tty</B>, and 
standard input. Now <B>patch</B> sends questions to standard output and gets answers 
from <B>/dev/tty</B>. Defaults for some answers have been changed so that <B>patch</B> 
never goes into an infinite loop when using default answers. </DD>

<DT><B> &#183;</B> Traditional 
 </DT>
<DD><B>patch</B> exited with a status value that counted the number of bad hunks, 
or with status 1 if there was real trouble. Now <B>patch</B> exits with status 
1 if some hunks failed, or with 2 if there was real trouble. </DD>

<DT><B> &#183;</B> Limit yourself 
to the following options when sending instructions  </DT>
<DD>meant to be executed 
by anyone running <FONT SIZE=-1>GNU</FONT>
 <B>patch</B>, traditional <B>patch</B>, or a <FONT SIZE=-1>POSIX</FONT>
-compliant <B>patch</B>. 
Spaces are significant in the following list, and operands are required. 
 <P>
   <BR>
 <PRE>  -c -d dir -D define -e -l -n -N -o outfile -pnum -R -r rejectfile   </PRE></DD>
</DL>
 
<H2><A NAME="sect11" HREF="#toc11">Bugs </A></H2>
<B>patch</B> 
could be smarter about partial matches, excessively deviant offsets and 
swapped code, but that would take an extra pass. <P>
If code has been duplicated 
(for instance with <B>#ifdef OLDCODE </B> ... <B>#else ... #endif </B>), <B>patch</B> is incapable 
of patching both versions, and, if it works at all, will likely patch 
the wrong one, and tell you that it succeeded to boot. <P>
If you apply a patch 
you've already applied, <B>patch</B> thinks it is a reversed patch, and offers 
to un-apply the patch. This could be construed as a feature.  
<H2><A NAME="sect12" HREF="#toc12">Copying </A></H2>
Copyright 
1984, 1985, 1986, 1988 Larry Wall.  <BR>
Copyright 1997 Free Software Foundation, Inc. <P>
Permission is granted to 
make and distribute verbatim copies of this manual provided the copyright 
notice and this permission notice are preserved on all copies. <P>
Permission 
is granted to copy and distribute modified versions of this manual under 
the conditions for verbatim copying, provided that the entire resulting 
derived work is distributed under the terms of a permission notice identical 
to this one. <P>
Permission is granted to copy and distribute translations 
of this manual into another language, under the above conditions for modified 
versions, except that this permission notice may be included in translations 
approved by the copyright holders instead of in the original English.  

<H2><A NAME="sect13" HREF="#toc13">Authors </A></H2>
Larry Wall wrote the original version of <B>patch</B>. Paul Eggert removed 
<B>patch</B>'s arbitrary limits; added support for binary files, setting file 
times, and deleting files; and made it conform better to <FONT SIZE=-1>POSIX</FONT>
. Other contributors 
include Wayne Davison, who added unidiff support, and David MacKenzie, 
who added configuration and backup support. <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Synopsis</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Description</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Options</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Environment</A></LI>
<LI><A NAME="toc5" HREF="#sect5">Files</A></LI>
<LI><A NAME="toc6" HREF="#sect6">See Also</A></LI>
<LI><A NAME="toc7" HREF="#sect7">Notes for Patch Senders</A></LI>
<LI><A NAME="toc8" HREF="#sect8">Diagnostics</A></LI>
<LI><A NAME="toc9" HREF="#sect9">Caveats</A></LI>
<LI><A NAME="toc10" HREF="#sect10">Compatibility Issues</A></LI>
<LI><A NAME="toc11" HREF="#sect11">Bugs</A></LI>
<LI><A NAME="toc12" HREF="#sect12">Copying</A></LI>
<LI><A NAME="toc13" HREF="#sect13">Authors</A></LI>
</UL>
</BODY></HTML>
