{\rtf1\windows \deff0{\fonttbl
{\f0\fswiss MS Sans Serif;}{\f1\fmodern Courier New;}{\f2\ftech Symbol;}}\fs20
\page #{\footnote hcAbout}${\footnote \pard{}About this help file}\pard{\fs24\b About this help file}\par\par\pard{}This file was made with the help of {\ul Makertf 3.12b-1}{\v hcMakertf} from the input file gawk.texi.\par\par{INFO-DIR-SECTION Programming Languages
{START-INFO-DIR-ENTRY
\pard{}* Gawk: (gawk.info).           A Text Scanning and Processing Language.\line
END-INFO-DIR-ENTRY\par
\pard{}}}\par
{}{}{}{\pard{}This file documents {\f1{}awk}, a program that you can use to select particular records in a file and perform operations upon them.\par
\par
\pard{}This is Edition 1.0.4 of {\i Effective AWK Programming}, for the 3.0.4 version of the GNU implementation of AWK.\par
\par
\pard{}Copyright (C) 1989, 1991, 92, 93, 96, 97, 98, 99 Free Software Foundation, Inc.\par
\par
\pard{}Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.\par
\par
\pard{}Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.\par
\par
\pard{}Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions, except that this permission notice may be stated in a translation approved by the Foundation.  }\par
\par
{\page\pard Node: {\b Top}, \keepn Next: {\uldb Preface}{\v Preface}, Prev: {\uldb (dir)}{\v Top @dir.hlp}, Up: {\uldb (dir)}{\v Top @dir.hlp}\tab\tab{\uldb About this help file}{\v hcAbout}\line
K{\footnote K Top}
#{\footnote Top}
${\footnote \pard{}General Introduction}\par
\pard\pard{\fs24\b General Introduction}\par
\par
\pard{}This file documents {\f1{}awk}, a program that you can use to select particular records in a file and perform operations upon them.\par
\par
\pard{}This is Edition 1.0.4 of {\i Effective AWK Programming},\par
\pard{}for the 3.0.4 version of the GNU implementation\par
\pard{}of AWK.\par
\par
}{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Preface}{\v Preface}\tab What this Info file is about; brief history and acknowledgements.\par
{\uldb What Is Awk}{\v What_Is_Awk}\tab What is the {\f1{}awk} language; using this Info file.\par
{\uldb Getting Started}{\v Getting_Started}\tab A basic introduction to using {\f1{}awk}. How to run an {\f1{}awk} program. Command line syntax.\par
{\uldb One-liners}{\v One_liners}\tab Short, sample {\f1{}awk} programs.\par
{\uldb Regexp}{\v Regexp}\tab All about matching things using regular expressions.\par
{\uldb Reading Files}{\v Reading_Files}\tab How to read files and manipulate fields.\par
{\uldb Printing}{\v Printing}\tab How to print using {\f1{}awk}.  Describes the {\f1{}print} and {\f1{}printf} statements. Also describes redirection of output.\par
{\uldb Expressions}{\v Expressions}\tab Expressions are the basic building blocks of statements.\par
{\uldb Patterns and Actions}{\v Patterns_and_Actions}\tab Overviews of patterns and actions.\par
{\uldb Statements}{\v Statements}\tab The various control statements are described in detail.\par
{\uldb Built-in Variables}{\v Built_in_Variables}\tab Built-in Variables\par
{\uldb Arrays}{\v Arrays}\tab The description and use of arrays. Also includes array-oriented control statements.\par
{\uldb Built-in}{\v Built_in}\tab The built-in functions are summarized here.\par
{\uldb User-defined}{\v User_defined}\tab User-defined functions are described in detail.\par
{\uldb Invoking Gawk}{\v Invoking_Gawk}\tab How to run {\f1{}gawk}.\par
{\uldb Library Functions}{\v Library_Functions}\tab A Library of {\f1{}awk} Functions.\par
{\uldb Sample Programs}{\v Sample_Programs}\tab Many {\f1{}awk} programs with complete explanations.\par
{\uldb Language History}{\v Language_History}\tab The evolution of the {\f1{}awk} language.\par
{\uldb Gawk Summary}{\v Gawk_Summary}\tab {\f1{}gawk} Options and Language Summary.\par
{\uldb Installation}{\v Installation}\tab Installing {\f1{}gawk} under various operating systems.\par
{\uldb Notes}{\v Notes}\tab Something about the implementation of {\f1{}gawk}.\par
{\uldb Glossary}{\v Glossary}\tab An explanation of some unfamiliar terms.\par
{\uldb Copying}{\v Copying}\tab Your right to copy and distribute {\f1{}gawk}.\par
{\uldb Index}{\v Index}\tab Concept and Variable Index.\par
\par
 \par
{\uldb History}{\v History}\tab The history of {\f1{}gawk} and {\f1{}awk}.\par
{\uldb Manual History}{\v Manual_History}\tab Brief history of the GNU project and this Info file.\par
{\uldb Acknowledgements}{\v Acknowledgements}\tab Acknowledgements.\par
{\uldb This Manual}{\v This_Manual}\tab Using this Info file. Includes sample input files that you can use.\par
{\uldb Conventions}{\v Conventions}\tab Typographical Conventions.\par
{\uldb Sample Data Files}{\v Sample_Data_Files}\tab Sample data files for use in the {\f1{}awk} programs illustrated in this Info file.\par
{\uldb Names}{\v Names}\tab What name to use to find {\f1{}awk}.\par
{\uldb Running gawk}{\v Running_gawk}\tab How to run {\f1{}gawk} programs; includes command line syntax.\par
{\uldb One-shot}{\v One_shot}\tab Running a short throw-away {\f1{}awk} program.\par
{\uldb Read Terminal}{\v Read_Terminal}\tab Using no input files (input from terminal instead).\par
{\uldb Long}{\v Long}\tab Putting permanent {\f1{}awk} programs in files.\par
{\uldb Executable Scripts}{\v Executable_Scripts}\tab Making self-contained {\f1{}awk} programs.\par
{\uldb Comments}{\v Comments}\tab Adding documentation to {\f1{}gawk} programs.\par
{\uldb Very Simple}{\v Very_Simple}\tab A very simple example.\par
{\uldb Two Rules}{\v Two_Rules}\tab A less simple one-line example with two rules.\par
{\uldb More Complex}{\v More_Complex}\tab A more complex example.\par
{\uldb Statements/Lines}{\v Statements_Lines}\tab Subdividing or combining statements into lines.\par
{\uldb Other Features}{\v Other_Features}\tab Other Features of {\f1{}awk}.\par
{\uldb When}{\v When}\tab When to use {\f1{}gawk} and when to use other things.\par
{\uldb Regexp Usage}{\v Regexp_Usage}\tab How to Use Regular Expressions.\par
{\uldb Escape Sequences}{\v Escape_Sequences}\tab How to write non-printing characters.\par
{\uldb Regexp Operators}{\v Regexp_Operators}\tab Regular Expression Operators.\par
{\uldb GNU Regexp Operators}{\v GNU_Regexp_Operators}\tab Operators specific to GNU software.\par
{\uldb Case-sensitivity}{\v Case_sensitivity}\tab How to do case-insensitive matching.\par
{\uldb Leftmost Longest}{\v Leftmost_Longest}\tab How much text matches.\par
{\uldb Computed Regexps}{\v Computed_Regexps}\tab Using Dynamic Regexps.\par
{\uldb Records}{\v Records}\tab Controlling how data is split into records.\par
{\uldb Fields}{\v Fields}\tab An introduction to fields.\par
{\uldb Non-Constant Fields}{\v Non_Constant_Fields}\tab Non-constant Field Numbers.\par
{\uldb Changing Fields}{\v Changing_Fields}\tab Changing the Contents of a Field.\par
{\uldb Field Separators}{\v Field_Separators}\tab The field separator and how to change it.\par
{\uldb Basic Field Splitting}{\v Basic_Field_Splitting}\tab How fields are split with single characters or simple strings.\par
{\uldb Regexp Field Splitting}{\v Regexp_Field_Splitting}\tab Using regexps as the field separator.\par
{\uldb Single Character Fields}{\v Single_Character_Fields}\tab Making each character a separate field.\par
{\uldb Command Line Field Separator}{\v Command_Line_Field_Separator}\tab Setting {\f1{}FS} from the command line.\par
{\uldb Field Splitting Summary}{\v Field_Splitting_Summary}\tab Some final points and a summary table.\par
{\uldb Constant Size}{\v Constant_Size}\tab Reading constant width data.\par
{\uldb Multiple Line}{\v Multiple_Line}\tab Reading multi-line records.\par
{\uldb Getline}{\v Getline}\tab Reading files under explicit program control using the {\f1{}getline} function.\par
{\uldb Getline Intro}{\v Getline_Intro}\tab Introduction to the {\f1{}getline} function.\par
{\uldb Plain Getline}{\v Plain_Getline}\tab Using {\f1{}getline} with no arguments.\par
{\uldb Getline/Variable}{\v Getline_Variable}\tab Using {\f1{}getline} into a variable.\par
{\uldb Getline/File}{\v Getline_File}\tab Using {\f1{}getline} from a file.\par
{\uldb Getline/Variable/File}{\v Getline_Variable_File}\tab Using {\f1{}getline} into a variable from a file.\par
{\uldb Getline/Pipe}{\v Getline_Pipe}\tab Using {\f1{}getline} from a pipe.\par
{\uldb Getline/Variable/Pipe}{\v Getline_Variable_Pipe}\tab Using {\f1{}getline} into a variable from a pipe.\par
{\uldb Getline Summary}{\v Getline_Summary}\tab Summary Of {\f1{}getline} Variants.\par
{\uldb Print}{\v Print}\tab The {\f1{}print} statement.\par
{\uldb Print Examples}{\v Print_Examples}\tab Simple examples of {\f1{}print} statements.\par
{\uldb Output Separators}{\v Output_Separators}\tab The output separators and how to change them.\par
{\uldb OFMT}{\v OFMT}\tab Controlling Numeric Output With {\f1{}print}.\par
{\uldb Printf}{\v Printf}\tab The {\f1{}printf} statement.\par
{\uldb Basic Printf}{\v Basic_Printf}\tab Syntax of the {\f1{}printf} statement.\par
{\uldb Control Letters}{\v Control_Letters}\tab Format-control letters.\par
{\uldb Format Modifiers}{\v Format_Modifiers}\tab Format-specification modifiers.\par
{\uldb Printf Examples}{\v Printf_Examples}\tab Several examples.\par
{\uldb Redirection}{\v Redirection}\tab How to redirect output to multiple files and pipes.\par
{\uldb Special Files}{\v Special_Files}\tab File name interpretation in {\f1{}gawk}. {\f1{}gawk} allows access to inherited file descriptors.\par
{\uldb Close Files And Pipes}{\v Close_Files_And_Pipes}\tab Closing Input and Output Files and Pipes.\par
{\uldb Constants}{\v Constants}\tab String, numeric, and regexp constants.\par
{\uldb Scalar Constants}{\v Scalar_Constants}\tab Numeric and string constants.\par
{\uldb Regexp Constants}{\v Regexp_Constants}\tab Regular Expression constants.\par
{\uldb Using Constant Regexps}{\v Using_Constant_Regexps}\tab When and how to use a regexp constant.\par
{\uldb Variables}{\v Variables}\tab Variables give names to values for later use.\par
{\uldb Using Variables}{\v Using_Variables}\tab Using variables in your programs.\par
{\uldb Assignment Options}{\v Assignment_Options}\tab Setting variables on the command line and a summary of command line syntax. This is an advanced method of input.\par
{\uldb Conversion}{\v Conversion}\tab The conversion of strings to numbers and vice versa.\par
{\uldb Arithmetic Ops}{\v Arithmetic_Ops}\tab Arithmetic operations ({\f1{}+}, {\f1{}-}, etc.)\par
{\uldb Concatenation}{\v Concatenation}\tab Concatenating strings.\par
{\uldb Assignment Ops}{\v Assignment_Ops}\tab Changing the value of a variable or a field.\par
{\uldb Increment Ops}{\v Increment_Ops}\tab Incrementing the numeric value of a variable.\par
{\uldb Truth Values}{\v Truth_Values}\tab What is ``true'' and what is ``false''.\par
{\uldb Typing and Comparison}{\v Typing_and_Comparison}\tab How variables acquire types, and how this affects comparison of numbers and strings with {\f1{}<}, etc.\par
{\uldb Boolean Ops}{\v Boolean_Ops}\tab Combining comparison expressions using boolean operators {\f1{}||} (``or''), {\f1{}&&} (``and'') and {\f1{}!} (``not'').\par
{\uldb Conditional Exp}{\v Conditional_Exp}\tab Conditional expressions select between two subexpressions under control of a third subexpression.\par
{\uldb Function Calls}{\v Function_Calls}\tab A function call is an expression.\par
{\uldb Precedence}{\v Precedence}\tab How various operators nest.\par
{\uldb Pattern Overview}{\v Pattern_Overview}\tab What goes into a pattern.\par
{\uldb Kinds of Patterns}{\v Kinds_of_Patterns}\tab A list of all kinds of patterns.\par
{\uldb Regexp Patterns}{\v Regexp_Patterns}\tab Using regexps as patterns.\par
{\uldb Expression Patterns}{\v Expression_Patterns}\tab Any expression can be used as a pattern.\par
{\uldb Ranges}{\v Ranges}\tab Pairs of patterns specify record ranges.\par
{\uldb BEGIN/END}{\v BEGIN_END}\tab Specifying initialization and cleanup rules.\par
{\uldb Using BEGIN/END}{\v Using_BEGIN_END}\tab How and why to use BEGIN/END rules.\par
{\uldb I/O And BEGIN/END}{\v I_O_And_BEGIN_END}\tab I/O issues in BEGIN/END rules.\par
{\uldb Empty}{\v Empty}\tab The empty pattern, which matches every record.\par
{\uldb Action Overview}{\v Action_Overview}\tab What goes into an action.\par
{\uldb If Statement}{\v If_Statement}\tab Conditionally execute some {\f1{}awk} statements.\par
{\uldb While Statement}{\v While_Statement}\tab Loop until some condition is satisfied.\par
{\uldb Do Statement}{\v Do_Statement}\tab Do specified action while looping until some condition is satisfied.\par
{\uldb For Statement}{\v For_Statement}\tab Another looping statement, that provides initialization and increment clauses.\par
{\uldb Break Statement}{\v Break_Statement}\tab Immediately exit the innermost enclosing loop.\par
{\uldb Continue Statement}{\v Continue_Statement}\tab Skip to the end of the innermost enclosing loop.\par
{\uldb Next Statement}{\v Next_Statement}\tab Stop processing the current input record.\par
{\uldb Nextfile Statement}{\v Nextfile_Statement}\tab Stop processing the current file.\par
{\uldb Exit Statement}{\v Exit_Statement}\tab Stop execution of {\f1{}awk}.\par
{\uldb User-modified}{\v User_modified}\tab Built-in variables that you change to control {\f1{}awk}.\par
{\uldb Auto-set}{\v Auto_set}\tab Built-in variables where {\f1{}awk} gives you information.\par
{\uldb ARGC and ARGV}{\v ARGC_and_ARGV}\tab Ways to use {\f1{}ARGC} and {\f1{}ARGV}.\par
{\uldb Array Intro}{\v Array_Intro}\tab Introduction to Arrays\par
{\uldb Reference to Elements}{\v Reference_to_Elements}\tab How to examine one element of an array.\par
{\uldb Assigning Elements}{\v Assigning_Elements}\tab How to change an element of an array.\par
{\uldb Array Example}{\v Array_Example}\tab Basic Example of an Array\par
{\uldb Scanning an Array}{\v Scanning_an_Array}\tab A variation of the {\f1{}for} statement. It loops through the indices of an array's existing elements.\par
{\uldb Delete}{\v Delete}\tab The {\f1{}delete} statement removes an element from an array.\par
{\uldb Numeric Array Subscripts}{\v Numeric_Array_Subscripts}\tab How to use numbers as subscripts in {\f1{}awk}.\par
{\uldb Uninitialized Subscripts}{\v Uninitialized_Subscripts}\tab Using Uninitialized variables as subscripts.\par
{\uldb Multi-dimensional}{\v Multi_dimensional}\tab Emulating multi-dimensional arrays in {\f1{}awk}.\par
{\uldb Multi-scanning}{\v Multi_scanning}\tab Scanning multi-dimensional arrays.\par
{\uldb Calling Built-in}{\v Calling_Built_in}\tab How to call built-in functions.\par
{\uldb Numeric Functions}{\v Numeric_Functions}\tab Functions that work with numbers, including {\f1{}int}, {\f1{}sin} and {\f1{}rand}.\par
{\uldb String Functions}{\v String_Functions}\tab Functions for string manipulation, such as {\f1{}split}, {\f1{}match}, and {\f1{}sprintf}.\par
{\uldb I/O Functions}{\v I_O_Functions}\tab Functions for files and shell commands.\par
{\uldb Time Functions}{\v Time_Functions}\tab Functions for dealing with time stamps.\par
{\uldb Definition Syntax}{\v Definition_Syntax}\tab How to write definitions and what they mean.\par
{\uldb Function Example}{\v Function_Example}\tab An example function definition and what it does.\par
{\uldb Function Caveats}{\v Function_Caveats}\tab Things to watch out for.\par
{\uldb Return Statement}{\v Return_Statement}\tab Specifying the value a function returns.\par
{\uldb Options}{\v Options}\tab Command line options and their meanings.\par
{\uldb Other Arguments}{\v Other_Arguments}\tab Input file names and variable assignments.\par
{\uldb AWKPATH Variable}{\v AWKPATH_Variable}\tab Searching directories for {\f1{}awk} programs.\par
{\uldb Obsolete}{\v Obsolete}\tab Obsolete Options and/or features.\par
{\uldb Undocumented}{\v Undocumented}\tab Undocumented Options and Features.\par
{\uldb Known Bugs}{\v Known_Bugs}\tab Known Bugs in {\f1{}gawk}.\par
{\uldb Portability Notes}{\v Portability_Notes}\tab What to do if you don't have {\f1{}gawk}.\par
{\uldb Nextfile Function}{\v Nextfile_Function}\tab Two implementations of a {\f1{}nextfile} function.\par
{\uldb Assert Function}{\v Assert_Function}\tab A function for assertions in {\f1{}awk} programs.\par
{\uldb Round Function}{\v Round_Function}\tab A function for rounding if {\f1{}sprintf} does not do it correctly.\par
{\uldb Ordinal Functions}{\v Ordinal_Functions}\tab Functions for using characters as numbers and vice versa.\par
{\uldb Join Function}{\v Join_Function}\tab A function to join an array into a string.\par
{\uldb Mktime Function}{\v Mktime_Function}\tab A function to turn a date into a timestamp.\par
{\uldb Gettimeofday Function}{\v Gettimeofday_Function}\tab A function to get formatted times.\par
{\uldb Filetrans Function}{\v Filetrans_Function}\tab A function for handling data file transitions.\par
{\uldb Getopt Function}{\v Getopt_Function}\tab A function for processing command line arguments.\par
{\uldb Passwd Functions}{\v Passwd_Functions}\tab Functions for getting user information.\par
{\uldb Group Functions}{\v Group_Functions}\tab Functions for getting group information.\par
{\uldb Library Names}{\v Library_Names}\tab How to best name private global variables in library functions.\par
{\uldb Clones}{\v Clones}\tab Clones of common utilities.\par
{\uldb Cut Program}{\v Cut_Program}\tab The {\f1{}cut} utility.\par
{\uldb Egrep Program}{\v Egrep_Program}\tab The {\f1{}egrep} utility.\par
{\uldb Id Program}{\v Id_Program}\tab The {\f1{}id} utility.\par
{\uldb Split Program}{\v Split_Program}\tab The {\f1{}split} utility.\par
{\uldb Tee Program}{\v Tee_Program}\tab The {\f1{}tee} utility.\par
{\uldb Uniq Program}{\v Uniq_Program}\tab The {\f1{}uniq} utility.\par
{\uldb Wc Program}{\v Wc_Program}\tab The {\f1{}wc} utility.\par
{\uldb Miscellaneous Programs}{\v Miscellaneous_Programs}\tab Some interesting {\f1{}awk} programs.\par
{\uldb Dupword Program}{\v Dupword_Program}\tab Finding duplicated words in a document.\par
{\uldb Alarm Program}{\v Alarm_Program}\tab An alarm clock.\par
{\uldb Translate Program}{\v Translate_Program}\tab A program similar to the {\f1{}tr} utility.\par
{\uldb Labels Program}{\v Labels_Program}\tab Printing mailing labels.\par
{\uldb Word Sorting}{\v Word_Sorting}\tab A program to produce a word usage count.\par
{\uldb History Sorting}{\v History_Sorting}\tab Eliminating duplicate entries from a history file.\par
{\uldb Extract Program}{\v Extract_Program}\tab Pulling out programs from Texinfo source files.\par
{\uldb Simple Sed}{\v Simple_Sed}\tab A Simple Stream Editor.\par
{\uldb Igawk Program}{\v Igawk_Program}\tab A wrapper for {\f1{}awk} that includes files.\par
{\uldb V7/SVR3.1}{\v V7_SVR3_1}\tab The major changes between V7 and System V Release 3.1.\par
{\uldb SVR4}{\v SVR4}\tab Minor changes between System V Releases 3.1 and 4.\par
{\uldb POSIX}{\v POSIX}\tab New features from the POSIX standard.\par
{\uldb BTL}{\v BTL}\tab New features from the Bell Laboratories version of {\f1{}awk}.\par
{\uldb POSIX/GNU}{\v POSIX_GNU}\tab The extensions in {\f1{}gawk} not in POSIX {\f1{}awk}.\par
{\uldb Command Line Summary}{\v Command_Line_Summary}\tab Recapitulation of the command line.\par
{\uldb Language Summary}{\v Language_Summary}\tab A terse review of the language.\par
{\uldb Variables/Fields}{\v Variables_Fields}\tab Variables, fields, and arrays.\par
{\uldb Fields Summary}{\v Fields_Summary}\tab Input field splitting.\par
{\uldb Built-in Summary}{\v Built_in_Summary}\tab {\f1{}awk}'s built-in variables.\par
{\uldb Arrays Summary}{\v Arrays_Summary}\tab Using arrays.\par
{\uldb Data Type Summary}{\v Data_Type_Summary}\tab Values in {\f1{}awk} are numbers or strings.\par
{\uldb Rules Summary}{\v Rules_Summary}\tab Patterns and Actions, and their component parts.\par
{\uldb Pattern Summary}{\v Pattern_Summary}\tab Quick overview of patterns.\par
{\uldb Regexp Summary}{\v Regexp_Summary}\tab Quick overview of regular expressions.\par
{\uldb Actions Summary}{\v Actions_Summary}\tab Quick overview of actions.\par
{\uldb Operator Summary}{\v Operator_Summary}\tab {\f1{}awk} operators.\par
{\uldb Control Flow Summary}{\v Control_Flow_Summary}\tab The control statements.\par
{\uldb I/O Summary}{\v I_O_Summary}\tab The I/O statements.\par
{\uldb Printf Summary}{\v Printf_Summary}\tab A summary of {\f1{}printf}.\par
{\uldb Special File Summary}{\v Special_File_Summary}\tab Special file names interpreted internally.\par
{\uldb Built-in Functions Summary}{\v Built_in_Functions_Summary}\tab Built-in numeric and string functions.\par
{\uldb Time Functions Summary}{\v Time_Functions_Summary}\tab Built-in time functions.\par
{\uldb String Constants Summary}{\v String_Constants_Summary}\tab Escape sequences in strings.\par
{\uldb Functions Summary}{\v Functions_Summary}\tab Defining and calling functions.\par
{\uldb Historical Features}{\v Historical_Features}\tab Some undocumented but supported ``features''.\par
{\uldb Gawk Distribution}{\v Gawk_Distribution}\tab What is in the {\f1{}gawk} distribution.\par
{\uldb Getting}{\v Getting}\tab How to get the distribution.\par
{\uldb Extracting}{\v Extracting}\tab How to extract the distribution.\par
{\uldb Distribution contents}{\v Distribution_contents}\tab What is in the distribution.\par
{\uldb Unix Installation}{\v Unix_Installation}\tab Installing {\f1{}gawk} under various versions of Unix.\par
{\uldb Quick Installation}{\v Quick_Installation}\tab Compiling {\f1{}gawk} under Unix.\par
{\uldb Configuration Philosophy}{\v Configuration_Philosophy}\tab How it's all supposed to work.\par
{\uldb VMS Installation}{\v VMS_Installation}\tab Installing {\f1{}gawk} on VMS.\par
{\uldb VMS Compilation}{\v VMS_Compilation}\tab How to compile {\f1{}gawk} under VMS.\par
{\uldb VMS Installation Details}{\v VMS_Installation_Details}\tab How to install {\f1{}gawk} under VMS.\par
{\uldb VMS Running}{\v VMS_Running}\tab How to run {\f1{}gawk} under VMS.\par
{\uldb VMS POSIX}{\v VMS_POSIX}\tab Alternate instructions for VMS POSIX.\par
{\uldb PC Installation}{\v PC_Installation}\tab Installing and Compiling {\f1{}gawk} on MS-DOS and OS/2\par
{\uldb Atari Installation}{\v Atari_Installation}\tab Installing {\f1{}gawk} on the Atari ST.\par
{\uldb Atari Compiling}{\v Atari_Compiling}\tab Compiling {\f1{}gawk} on Atari\par
{\uldb Atari Using}{\v Atari_Using}\tab Running {\f1{}gawk} on Atari\par
{\uldb Amiga Installation}{\v Amiga_Installation}\tab Installing {\f1{}gawk} on an Amiga.\par
{\uldb Bugs}{\v Bugs}\tab Reporting Problems and Bugs.\par
{\uldb Other Versions}{\v Other_Versions}\tab Other freely available {\f1{}awk} implementations.\par
{\uldb Compatibility Mode}{\v Compatibility_Mode}\tab How to disable certain {\f1{}gawk} extensions.\par
{\uldb Additions}{\v Additions}\tab Making Additions To {\f1{}gawk}.\par
{\uldb Adding Code}{\v Adding_Code}\tab Adding code to the main body of {\f1{}gawk}.\par
{\uldb New Ports}{\v New_Ports}\tab Porting {\f1{}gawk} to a new operating system.\par
{\uldb Future Extensions}{\v Future_Extensions}\tab New features that may be implemented one day.\par
{\uldb Improvements}{\v Improvements}\tab Suggestions for improvements by volunteers.\par
\par\par
\pard{}}\par
{\pard{}To Miriam, for making me complete.\qc{}\par
\par
\pard{}To Chana, for the joy you bring us.\qc{}\par
\par
\pard{}To Rivka, for the exponential increase.\qc{}\par
\par
\pard{}To Nachum, for the added dimension.\qc{}\par
\par
}\page\pard Node: {\b Preface}, \keepn Next: {\uldb What Is Awk}{\v What_Is_Awk}, Prev: {\uldb Top}{\v Top}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Preface}
#{\footnote Preface}
${\footnote \pard{}Preface}\par
\pard{\fs24\b Preface}\par
\par
\pard{}This Info file teaches you about the {\f1{}awk} language and how you can use it effectively.  You should already be familiar with basic system commands, such as {\f1{}cat} and {\f1{}ls},({\ul 1}{\v Preface_1}) and basic shell facilities, such as Input/Output (I/O) redirection and pipes.\par
\par
\pard{}Implementations of the {\f1{}awk} language are available for many different computing environments.  This Info file, while describing the {\f1{}awk} language in general, also describes a particular implementation of {\f1{}awk} called {\f1{}gawk} (which stands for "GNU Awk").  {\f1{}gawk} runs on a broad range of Unix systems, ranging from 80386 PC-based computers, up through large scale systems, such as Crays. {\f1{}gawk} has also been ported to MS-DOS and OS/2 PC's, Atari and Amiga micro-computers, and VMS.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb History}{\v History}\tab The history of {\f1{}gawk} and {\f1{}awk}.\par
{\uldb Manual History}{\v Manual_History}\tab Brief history of the GNU project and this Info file.\par
{\uldb Acknowledgements}{\v Acknowledgements}\tab Acknowledgements.\par
\pard{}}\par
\page\pard#{\footnote Preface_1}
\pard{}(1) These commands are available on POSIX compliant systems, as well as on traditional Unix based systems. If you are using some other operating system, you still need to be familiar with the ideas of I/O redirection and pipes.\par
\par
\page\pard Node: {\b History}, \keepn Next: {\uldb Manual History}{\v Manual_History}, Prev: {\uldb Preface}{\v Preface}, Up: {\uldb Preface}{\v Preface}\line
K{\footnote K History}
#{\footnote History}
${\footnote \pard{}History of {\f1{}awk} and {\f1{}gawk}}\par
\pard{\fs24\b History of {\f1{}awk} and {\f1{}gawk}}\par
\par
\pard{}{K{\footnote K acronym}}{K{\footnote K history of {\f1{}awk}}}{K{\footnote K Aho, Alfred}}{K{\footnote K Weinberger, Peter}}{K{\footnote K Kernighan, Brian}}{K{\footnote K old {\f1{}awk}}}{K{\footnote K new {\f1{}awk}}}The name {\f1{}awk} comes from the initials of its designers: Alfred V.  Aho, Peter J. Weinberger, and Brian W. Kernighan.  The original version of {\f1{}awk} was written in 1977 at AT&T Bell Laboratories.  In 1985 a new version made the programming language more powerful, introducing user-defined functions, multiple input streams, and computed regular expressions.  This new version became generally available with Unix System V Release 3.1.  The version in System V Release 4 added some new features and also cleaned up the behavior in some of the "dark corners" of the language.  The specification for {\f1{}awk} in the POSIX Command Language and Utilities standard further clarified the language based on feedback from both the {\f1{}gawk} designers, and the original Bell Labs {\f1{}awk} designers.\par
\par
\pard{}The GNU implementation, {\f1{}gawk}, was written in 1986 by Paul Rubin and Jay Fenlason, with advice from Richard Stallman.  John Woods contributed parts of the code as well.  In 1988 and 1989, David Trueman, with help from Arnold Robbins, thoroughly reworked {\f1{}gawk} for compatibility with the newer {\f1{}awk}.  Current development focuses on bug fixes, performance improvements, standards compliance, and occasionally, new features.\par
\par
\page\pard Node: {\b Manual History}, \keepn Next: {\uldb Acknowledgements}{\v Acknowledgements}, Prev: {\uldb History}{\v History}, Up: {\uldb Preface}{\v Preface}\line
K{\footnote K Manual History}
#{\footnote Manual_History}
${\footnote \pard{}The GNU Project and This Book}\par
\pard{\fs24\b The GNU Project and This Book}\par
\par
\pard{}{K{\footnote K Free Software Foundation}}{K{\footnote K Stallman, Richard}}The Free Software Foundation (FSF) is a non-profit organization dedicated to the production and distribution of freely distributable software.  It was founded by Richard M. Stallman, the author of the original Emacs editor.  GNU Emacs is the most widely used version of Emacs today.\par
\par
\pard{}{K{\footnote K GNU Project}}The GNU project is an on-going effort on the part of the Free Software Foundation to create a complete, freely distributable, POSIX compliant computing environment.  (GNU stands for "GNU's not Unix".)  The FSF uses the "GNU General Public License" (or GPL) to ensure that source code for their software is always available to the end user. A copy of the GPL is included for your reference (see {\uldb GNU GENERAL PUBLIC LICENSE}{\v Copying}).  The GPL applies to the C language source code for {\f1{}gawk}.\par
\par
\pard{}A shell, an editor (Emacs), highly portable optimizing C, C++, and Objective-C compilers, a symbolic debugger, and dozens of large and small utilities (such as {\f1{}gawk}), have all been completed and are freely available.  As of this writing (early 1997), the GNU operating system kernel (the HURD), has been released, but is still in an early stage of development.\par
\par
\pard{}{K{\footnote K Linux}}{K{\footnote K NetBSD}}{K{\footnote K FreeBSD}}Until the GNU operating system is more fully developed, you should consider using Linux, a freely distributable, Unix-like operating system for 80386, DEC Alpha, Sun SPARC and other systems.  There are many books on Linux. One freely available one is {\i Linux Installation and Getting Started}, by Matt Welsh.  Many Linux distributions are available, often in computer stores or bundled on CD-ROM with books about Linux.  (There are three other freely available, Unix-like operating systems for 80386 and other systems, NetBSD, FreeBSD,and OpenBSD. All are based on the 4.4-Lite Berkeley Software Distribution, and they use recent versions of {\f1{}gawk} for their versions of {\f1{}awk}.)\par
\par
\pard{}This Info file itself has gone through several previous, preliminary editions.  I started working on a preliminary draft of {\i The GAWK Manual}, by Diane Close, Paul Rubin, and Richard Stallman in the fall of 1988.  It was around 90 pages long, and barely described the original, "old" version of {\f1{}awk}. After substantial revision, the first version of the {\i The GAWK Manual} to be released was Edition 0.11 Beta in October of 1989.  The manual then underwent more substantial revision for Edition 0.13 of December 1991.  David Trueman, Pat Rankin, and Michal Jaegermann contributed sections of the manual for Edition 0.13.  That edition was published by the FSF as a bound book early in 1992.  Since then there have been several minor revisions, notably Edition 0.14 of November 1992 that was published by the FSF in January of 1993, and Edition 0.16 of August 1993.\par
\par
\pard{}Edition 1.0 of {\i Effective AWK Programming} represents a significant re-working of {\i The GAWK Manual}, with much additional material.  The FSF and I agree that I am now the primary author.  I also felt that it needed a more descriptive title.\par
\par
{\i \pa\'7BNo Value For "rd\'7B\'7DTITLE"\'7D} will undoubtedly continue to evolve.  An electronic version comes with the {\f1{}gawk} distribution from the FSF.  If you find an error in this Info file, please report it!  See {\uldb Reporting Problems and Bugs}{\v Bugs}, for information on submitting problem reports electronically, or write to me in care of the FSF.\par
\par
\page\pard Node: {\b Acknowledgements}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Manual History}{\v Manual_History}, Up: {\uldb Preface}{\v Preface}\line
K{\footnote K Acknowledgements}
#{\footnote Acknowledgements}
${\footnote \pard{}Acknowledgements}\par
\pard{\fs24\b Acknowledgements}\par
\par
\pard{}{K{\footnote K Stallman, Richard}}I would like to acknowledge Richard M. Stallman, for his vision of a better world, and for his courage in founding the FSF and starting the GNU project.\par
\par
\pard{}The initial draft of {\i The GAWK Manual} had the following acknowledgements:\par
\par
{\pard\li720{}Many people need to be thanked for their assistance in producing this manual.  Jay Fenlason contributed many ideas and sample programs.  Richard Mlynarik and Robert Chassell gave helpful comments on drafts of this manual.  The paper {\i A Supplemental Document for {\f1{}awk}} by John W.  Pierce of the Chemistry Department at UC San Diego, pinpointed several issues relevant both to {\f1{}awk} implementation and to this manual, that would otherwise have escaped us.\par
\pard{}}\par
\pard{}The following people provided many helpful comments on Edition 0.13 of {\i The GAWK Manual}: Rick Adams, Michael Brennan, Rich Burridge, Diane Close, Christopher ("Topher") Eliot, Michael Lijewski, Pat Rankin, Miriam Robbins, and Michal Jaegermann.\par
\par
\pard{}The following people provided many helpful comments for Edition 1.0 of {\i Effective AWK Programming}: Karl Berry, Michael Brennan, Darrel Hankerson, Michal Jaegermann, Michael Lijewski, and Miriam Robbins.  Pat Rankin, Michal Jaegermann, Darrel Hankerson and Scott Deifik updated their respective sections for Edition 1.0.\par
\par
\pard{}Robert J. Chassell provided much valuable advice on the use of Texinfo.  He also deserves special thanks for convincing me {\i not} to title this Info file {\i How To Gawk Politely}.  Karl Berry helped significantly with the TeX part of Texinfo.\par
\par
\pard{}{K{\footnote K Trueman, David}}David Trueman deserves special credit; he has done a yeoman job of evolving {\f1{}gawk} so that it performs well, and without bugs.  Although he is no longer involved with {\f1{}gawk}, working with him on this project was a significant pleasure.\par
\par
\pard{}{K{\footnote K Deifik, Scott}}{K{\footnote K Hankerson, Darrel}}{K{\footnote K Rommel, Kai Uwe}}{K{\footnote K Rankin, Pat}}{K{\footnote K Jaegermann, Michal}}Scott Deifik, Darrel Hankerson, Kai Uwe Rommel, Pat Rankin, and Michal Jaegermann (in no particular order) are long time members of the {\f1{}gawk} "crack portability team."  Without their hard work and help, {\f1{}gawk} would not be nearly the fine program it is today.  It has been and continues to be a pleasure working with this team of fine people.\par
\par
\pard{}{K{\footnote K Friedl, Jeffrey}}Jeffrey Friedl provided invaluable help in tracking down a number of last minute problems with regular expressions in {\f1{}gawk} 3.0.\par
\par
\pard{}{K{\footnote K Kernighan, Brian}}David and I would like to thank Brian Kernighan of Bell Labs for invaluable assistance during the testing and debugging of {\f1{}gawk}, and for help in clarifying numerous points about the language.  We could not have done nearly as good a job on either {\f1{}gawk} or its documentation without his help.\par
\par
\pard{}{K{\footnote K Hughes, Phil}}I would like to thank Marshall and Elaine Hartholz of Seattle, and Dr.  Bert and Rita Schreiber of Detroit for large amounts of quiet vacation time in their homes, which allowed me to make significant progress on this Info file and on {\f1{}gawk} itself.  Phil Hughes of SSC contributed in a very important way by loaning me his laptop Linux system, not once, but twice, allowing me to do a lot of work while away from home.\par
\par
\pard{}{K{\footnote K Robbins, Miriam}}Finally, I must thank my wonderful wife, Miriam, for her patience through the many versions of this project, for her proof-reading, and for sharing me with the computer.  I would like to thank my parents for their love, and for the grace with which they raised and educated me.  I also must acknowledge my gratitude to G-d, for the many opportunities He has sent my way, as well as for the gifts He has given me with which to take advantage of those opportunities.\par
\par
\pard{}Arnold Robbins\par
\pard{}Atlanta, Georgia\par
\pard{}February, 1997\par
\par
\page\pard Node: {\b What Is Awk}, \keepn Next: {\uldb Getting Started}{\v Getting_Started}, Prev: {\uldb Preface}{\v Preface}, Up: {\uldb Top}{\v Top}\line
K{\footnote K What Is Awk}
#{\footnote What_Is_Awk}
${\footnote \pard{}Introduction}\par
\pard{\fs24\b Introduction}\par
\par
\pard{}If you are like many computer users, you would frequently like to make changes in various text files wherever certain patterns appear, or extract data from parts of certain lines while discarding the rest.  To write a program to do this in a language such as C or Pascal is a time-consuming inconvenience that may take many lines of code.  The job may be easier with {\f1{}awk}.\par
\par
\pard{}The {\f1{}awk} utility interprets a special-purpose programming language that makes it possible to handle simple data-reformatting jobs with just a few lines of code.\par
\par
\pard{}The GNU implementation of {\f1{}awk} is called {\f1{}gawk}; it is fully upward compatible with the System V Release 4 version of {\f1{}awk}.  {\f1{}gawk} is also upward compatible with the POSIX specification of the {\f1{}awk} language.  This means that all properly written {\f1{}awk} programs should work with {\f1{}gawk}.  Thus, we usually don't distinguish between {\f1{}gawk} and other {\f1{}awk} implementations.\par
\par
\pard{}{K{\footnote K uses of {\f1{}awk}}}Using {\f1{}awk} you can:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}manage small, personal databases\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}generate reports\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}validate data\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}produce indexes, and perform other document preparation tasks\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}even experiment with algorithms that can be adapted later to other computer languages\par
\pard{}}\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb This Manual}{\v This_Manual}\tab Using this Info file. Includes sample input files that you can use.\par
{\uldb Conventions}{\v Conventions}\tab Typographical Conventions.\par
{\uldb Sample Data Files}{\v Sample_Data_Files}\tab Sample data files for use in the {\f1{}awk} programs illustrated in this Info file.\par
\pard{}}\par
\page\pard Node: {\b This Manual}, \keepn Next: {\uldb Conventions}{\v Conventions}, Prev: {\uldb What Is Awk}{\v What_Is_Awk}, Up: {\uldb What Is Awk}{\v What_Is_Awk}\line
K{\footnote K This Manual}
#{\footnote This_Manual}
${\footnote \pard{}Using This Book}\par
\pard{\fs24\b Using This Book}\par
\par
\pard{}{K{\footnote K book, using this}}{K{\footnote K using this book}}{K{\footnote K language, {\f1{}awk}}}{K{\footnote K program, {\f1{}awk}}} The term {\f1{}awk} refers to a particular program, and to the language you use to tell this program what to do.  When we need to be careful, we call the program "the {\f1{}awk} utility" and the language "the {\f1{}awk} language."  The term {\f1{}gawk} refers to a version of {\f1{}awk} developed as part the GNU project.  The purpose of this Info file is to explain both the {\f1{}awk} language and how to run the {\f1{}awk} utility.\par
\par
\pard{}The main purpose of the Info file is to explain the features of {\f1{}awk}, as defined in the POSIX standard.  It does so in the context of one particular implementation, {\f1{}gawk}. While doing so, it will also attempt to describe important differences between {\f1{}gawk} and other {\f1{}awk} implementations.  Finally, any {\f1{}gawk} features that are not in the POSIX standard for {\f1{}awk} will be noted.\par
\par
\pard{}The term \'A2{\f1{}awk} program\'A2 refers to a program written by you in the {\f1{}awk} programming language.\par
\par
\pard{}See {\uldb Getting Started with {\f1{}awk}}{\v Getting_Started}, for the bare essentials you need to know to start using {\f1{}awk}.\par
\par
\pard{}Some useful "one-liners" are included to give you a feel for the {\f1{}awk} language (see {\uldb Useful One Line Programs}{\v One_liners}).\par
\par
\pard{}Many sample {\f1{}awk} programs have been provided for you (see {\uldb A Library of {\f1{}awk} Functions}{\v Library_Functions}; also see {\uldb Practical {\f1{}awk} Programs}{\v Sample_Programs}).\par
\par
\pard{}The entire {\f1{}awk} language is summarized for quick reference in {\uldb {\f1{}gawk} Summary}{\v Gawk_Summary}.  Look there if you just need to refresh your memory about a particular feature.\par
\par
\pard{}If you find terms that you aren't familiar with, try looking them up in the glossary (see {\uldb Glossary}{\v Glossary}).\par
\par
\pard{}Most of the time complete {\f1{}awk} programs are used as examples, but in some of the more advanced sections, only the part of the {\f1{}awk} program that illustrates the concept being described is shown.\par
\par
\pard{}While this Info file is aimed principally at people who have not been exposed to {\f1{}awk}, there is a lot of information here that even the {\f1{}awk} expert should find useful.  In particular, the description of POSIX {\f1{}awk}, and the example programs in {\uldb A Library of {\f1{}awk} Functions}{\v Library_Functions}, and {\uldb Practical {\f1{}awk} Programs}{\v Sample_Programs}, should be of interest.\par
\par
\pard{\b Dark Corners}\par
\par
{\pard\li720\f1{}Who opened that window shade?!?\line
Count Dracula\par
\pard\f0{}}\par
\pard{}{K{\footnote K d.c., see "dark corner"}}{K{\footnote K dark corner}}Until the POSIX standard (and {\i The Gawk Manual}), many features of {\f1{}awk} were either poorly documented, or not documented at all.  Descriptions of such features (often called "dark corners") are noted in this Info file with "(d.c.)".  They also appear in the index under the heading "dark corner."\par
\par
\page\pard Node: {\b Conventions}, \keepn Next: {\uldb Sample Data Files}{\v Sample_Data_Files}, Prev: {\uldb This Manual}{\v This_Manual}, Up: {\uldb What Is Awk}{\v What_Is_Awk}\line
K{\footnote K Conventions}
#{\footnote Conventions}
${\footnote \pard{}Typographical Conventions}\par
\pard{\fs24\b Typographical Conventions}\par
\par
\pard{}This Info file is written using Texinfo, the GNU documentation formatting language.  A single Texinfo source file is used to produce both the printed and on-line versions of the documentation.  {This section briefly documents the typographical conventions used in Texinfo.  }\par
\par
\pard{}Examples you would type at the command line are preceded by the common shell primary and secondary prompts, {\f1{}$} and {\f1{}>}.  Output from the command is preceded by the glyph "-|".  This typically represents the command's standard output.  Error messages, and other output on the command's standard error, are preceded by the glyph "error-->".  For example:\par
\par
{{\pard\keep\li720\f1{}$ echo hi on stdout\line
-| hi on stdout\line
$ echo hello on stderr 1>&2\line
error--> hello on stderr\par
\pard\keep\li720{}}}\par
\pard\f0{}Characters that you type at the keyboard look {\f1{}like this}.  In particular, there are special characters called "control characters."  These are characters that you type by holding down both the {\f1{}CONTROL} key and another key, at the same time.  For example, a {\f1{}Control-d} is typed by first pressing and holding the {\f1{}CONTROL} key, next pressing the {\f1{}d} key, and finally releasing both keys.\par
\par
\page\pard Node: {\b Sample Data Files}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Conventions}{\v Conventions}, Up: {\uldb What Is Awk}{\v What_Is_Awk}\line
K{\footnote K Sample Data Files}
#{\footnote Sample_Data_Files}
${\footnote \pard{}Data Files for the Examples}\par
\pard{\fs24\b Data Files for the Examples}\par
\par
\pard{}{K{\footnote K input file, sample}}{K{\footnote K sample input file}}{K{\footnote K {\f1{}BBS-list} file}}Many of the examples in this Info file take their input from two sample data files.  The first, called {\f1{}BBS-list}, represents a list of computer bulletin board systems together with information about those systems.  The second data file, called {\f1{}inventory-shipped}, contains information about shipments on a monthly basis.  In both files, each line is considered to be one \'A2record\'A2.\par
\par
\pard{}In the file {\f1{}BBS-list}, each record contains the name of a computer bulletin board, its phone number, the board's baud rate(s), and a code for the number of hours it is operational.  An {\f1{}A} in the last column means the board operates 24 hours a day.  A {\f1{}B} in the last column means the board operates evening and weekend hours, only.  A {\f1{}C} means the board operates only on weekends.\par
\par
{\pard\keep\li720\f1{}aardvark     555-5553     1200/300          B\line
alpo-net     555-3412     2400/1200/300     A\line
barfly       555-7685     1200/300          A\line
bites        555-1675     2400/1200/300     A\line
camelot      555-0542     300               C\line
core         555-2912     1200/300          C\line
fooey        555-1234     2400/1200/300     B\line
foot         555-6699     1200/300          B\line
macfoo       555-6480     1200/300          A\line
sdace        555-3430     2400/1200/300     A\line
sabafoo      555-2127     1200/300          C\par
\pard\f0{}}\par
\pard{}{K{\footnote K {\f1{}inventory-shipped} file}}The second data file, called {\f1{}inventory-shipped}, represents information about shipments during the year.  Each record contains the month of the year, the number of green crates shipped, the number of red boxes shipped, the number of orange bags shipped, and the number of blue packages shipped, respectively.  There are 16 entries, covering the 12 months of one year and four months of the next year.\par
\par
{\pard\keep\li720\f1{}Jan  13  25  15 115\line
Feb  15  32  24 226\line
Mar  15  24  34 228\line
Apr  31  52  63 420\line
May  16  34  29 208\line
Jun  31  42  75 492\line
Jul  24  34  67 436\line
Aug  15  34  47 316\line
Sep  13  55  37 277\line
Oct  29  54  68 525\line
Nov  20  87  82 577\line
Dec  17  35  61 401\line
\line
Jan  21  36  64 620\line
Feb  26  58  80 652\line
Mar  24  75  70 495\line
Apr  21  70  74 514\par
\pard\f0{}}\par
{\pard{}If you are reading this in GNU Emacs using Info, you can copy the regions of text showing these sample files into your own test files.  This way you can try out the examples shown in the remainder of this document.  You do this by using the command {\f1{}M-x write-region} to copy text from the Info file into a file for use with {\f1{}awk} (See {\uldb Miscellaneous File Operations}{\v Misc_File_Ops @emacs.hlp}, for more information).  Using this information, create your own {\f1{}BBS-list} and {\f1{}inventory-shipped} files, and practice what you learn in this Info file.\par
\par
\pard{}If you are using the stand-alone version of Info, see {\uldb Extracting Programs from Texinfo Source Files}{\v Extract_Program}, for an {\f1{}awk} program that will extract these data files from {\f1{}gawk.texi}, the Texinfo source file for this Info file.  }\par
\par
\page\pard Node: {\b Getting Started}, \keepn Next: {\uldb One-liners}{\v One_liners}, Prev: {\uldb What Is Awk}{\v What_Is_Awk}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Getting Started}
#{\footnote Getting_Started}
${\footnote \pard{}Getting Started with {\f1{}awk}}\par
\pard{\fs24\b Getting Started with {\f1{}awk}}\par
\par
\pard{}{K{\footnote K script, definition of}}{K{\footnote K rule, definition of}}{K{\footnote K program, definition of}}{K{\footnote K basic function of {\f1{}awk}}} The basic function of {\f1{}awk} is to search files for lines (or other units of text) that contain certain patterns.  When a line matches one of the patterns, {\f1{}awk} performs specified actions on that line.  {\f1{}awk} keeps processing input lines in this way until the end of the input files are reached.\par
\par
\pard{}{K{\footnote K data-driven languages}}{K{\footnote K procedural languages}}{K{\footnote K language, data-driven}}{K{\footnote K language, procedural}}Programs in {\f1{}awk} are different from programs in most other languages, because {\f1{}awk} programs are \'A2data-driven\'A2; that is, you describe the data you wish to work with, and then what to do when you find it.  Most other languages are \'A2procedural\'A2; you have to describe, in great detail, every step the program is to take.  When working with procedural languages, it is usually much harder to clearly describe the data your program will process.  For this reason, {\f1{}awk} programs are often refreshingly easy to both write and read.\par
\par
\pard{}{K{\footnote K program, definition of}}{K{\footnote K rule, definition of}}When you run {\f1{}awk}, you specify an {\f1{}awk} \'A2program\'A2 that tells {\f1{}awk} what to do.  The program consists of a series of \'A2rules\'A2.  (It may also contain \'A2function definitions\'A2, an advanced feature which we will ignore for now.  See {\uldb User-defined Functions}{\v User_defined}.)  Each rule specifies one pattern to search for, and one action to perform when that pattern is found.\par
\par
\pard{}Syntactically, a rule consists of a pattern followed by an action.  The action is enclosed in curly braces to separate it from the pattern.  Rules are usually separated by newlines.  Therefore, an {\f1{}awk} program looks like this:\par
\par
{{\i \pard\li720\f1{}pattern} \'7B {\i action} \'7D\line
{\i pattern} \'7B {\i action} \'7D\line
...\par
\pard\f0{}}\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Names}{\v Names}\tab What name to use to find {\f1{}awk}.\par
{\uldb Running gawk}{\v Running_gawk}\tab How to run {\f1{}gawk} programs; includes command line syntax.\par
{\uldb Very Simple}{\v Very_Simple}\tab A very simple example.\par
{\uldb Two Rules}{\v Two_Rules}\tab A less simple one-line example with two rules.\par
{\uldb More Complex}{\v More_Complex}\tab A more complex example.\par
{\uldb Statements/Lines}{\v Statements_Lines}\tab Subdividing or combining statements into lines.\par
{\uldb Other Features}{\v Other_Features}\tab Other Features of {\f1{}awk}.\par
{\uldb When}{\v When}\tab When to use {\f1{}gawk} and when to use other things.\par
\pard{}}\par
\page\pard Node: {\b Names}, \keepn Next: {\uldb Running gawk}{\v Running_gawk}, Prev: {\uldb Getting Started}{\v Getting_Started}, Up: {\uldb Getting Started}{\v Getting_Started}\line
K{\footnote K Names}
#{\footnote Names}
${\footnote \pard{}A Rose By Any Other Name}\par
\pard{\fs24\b A Rose By Any Other Name}\par
\par
\pard{}{K{\footnote K old {\f1{}awk} vs. new {\f1{}awk}}}{K{\footnote K new {\f1{}awk} vs. old {\f1{}awk}}}The {\f1{}awk} language has evolved over the years. Full details are provided in {\uldb The Evolution of the {\f1{}awk} Language}{\v Language_History}.  The language described in this Info file is often referred to as "new {\f1{}awk}."\par
\par
\pard{}Because of this, many systems have multiple versions of {\f1{}awk}.  Some systems have an {\f1{}awk} utility that implements the original version of the {\f1{}awk} language, and a {\f1{}nawk} utility for the new version.  Others have an {\f1{}oawk} for the "old {\f1{}awk}" language, and plain {\f1{}awk} for the new one.  Still others only have one version, usually the new one.({\ul 1}{\v Names_1})\par
\par
\pard{}All in all, this makes it difficult for you to know which version of {\f1{}awk} you should run when writing your programs.  The best advice we can give here is to check your local documentation. Look for {\f1{}awk}, {\f1{}oawk}, and {\f1{}nawk}, as well as for {\f1{}gawk}. Chances are, you will have some version of new {\f1{}awk} on your system, and that is what you should use when running your programs.  (Of course, if you're reading this Info file, chances are good that you have {\f1{}gawk}!)\par
\par
\pard{}Throughout this Info file, whenever we refer to a language feature that should be available in any complete implementation of POSIX {\f1{}awk}, we simply use the term {\f1{}awk}.  When referring to a feature that is specific to the GNU implementation, we use the term {\f1{}gawk}.\par
\par
\page\pard#{\footnote Names_1}
\pard{}(1) Often, these systems use {\f1{}gawk} for their {\f1{}awk} implementation!\par
\par
\page\pard Node: {\b Running gawk}, \keepn Next: {\uldb Very Simple}{\v Very_Simple}, Prev: {\uldb Names}{\v Names}, Up: {\uldb Getting Started}{\v Getting_Started}\line
K{\footnote K Running gawk}
#{\footnote Running_gawk}
${\footnote \pard{}How to Run {\f1{}awk} Programs}\par
\pard{\fs24\b How to Run {\f1{}awk} Programs}\par
\par
\pard{}{K{\footnote K command line formats}}{K{\footnote K running {\f1{}awk} programs}}There are several ways to run an {\f1{}awk} program.  If the program is short, it is easiest to include it in the command that runs {\f1{}awk}, like this:\par
\par
{\pard\keep\li720\f1{}awk '{\i program}' {\i input-file1} {\i input-file2} ...\par
\pard\f0{}}\par
\pard{}where {\i program} consists of a series of patterns and actions, as described earlier.  (The reason for the single quotes is described below, in {\uldb One-shot Throw-away {\f1{}awk} Programs}{\v One_shot}.)\par
\par
\pard{}When the program is long, it is usually more convenient to put it in a file and run it with a command like this:\par
\par
{\pard\keep\li720\f1{}awk -f {\i program-file} {\i input-file1} {\i input-file2} ...\par
\pard\f0{}}\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb One-shot}{\v One_shot}\tab Running a short throw-away {\f1{}awk} program.\par
{\uldb Read Terminal}{\v Read_Terminal}\tab Using no input files (input from terminal instead).\par
{\uldb Long}{\v Long}\tab Putting permanent {\f1{}awk} programs in files.\par
{\uldb Executable Scripts}{\v Executable_Scripts}\tab Making self-contained {\f1{}awk} programs.\par
{\uldb Comments}{\v Comments}\tab Adding documentation to {\f1{}gawk} programs.\par
\pard{}}\par
\page\pard Node: {\b One-shot}, \keepn Next: {\uldb Read Terminal}{\v Read_Terminal}, Prev: {\uldb Running gawk}{\v Running_gawk}, Up: {\uldb Running gawk}{\v Running_gawk}\line
K{\footnote K One-shot}
#{\footnote One_shot}
${\footnote \pard{}One-shot Throw-away {\f1{}awk} Programs}\par
\pard{\fs24\b One-shot Throw-away {\f1{}awk} Programs}\par
\par
\pard{}Once you are familiar with {\f1{}awk}, you will often type in simple programs the moment you want to use them.  Then you can write the program as the first argument of the {\f1{}awk} command, like this:\par
\par
{\pard\keep\li720\f1{}awk '{\i program}' {\i input-file1} {\i input-file2} ...\par
\pard\f0{}}\par
\pard{}where {\i program} consists of a series of {\i patterns} and {\i actions}, as described earlier.\par
\par
\pard{}{K{\footnote K single quotes, why needed}}This command format instructs the \'A2shell\'A2, or command interpreter, to start {\f1{}awk} and use the {\i program} to process records in the input file(s).  There are single quotes around {\i program} so that the shell doesn't interpret any {\f1{}awk} characters as special shell characters.  They also cause the shell to treat all of {\i program} as a single argument for {\f1{}awk} and allow {\i program} to be more than one line long.\par
\par
\pard{}This format is also useful for running short or medium-sized {\f1{}awk} programs from shell scripts, because it avoids the need for a separate file for the {\f1{}awk} program.  A self-contained shell script is more reliable since there are no other files to misplace.\par
\par
{\uldb \pard{}Useful One Line Programs}{\v One_liners}, presents several short, self-contained programs.\par
\par
\pard{}As an interesting side point, the command\par
\par
{\pard\keep\li720\f1{}awk '/foo/' {\i files} ...\par
\pard\f0{}}\par
\pard{}is essentially the same as\par
\par
\pard{}{K{\footnote K {\f1{}egrep}}}{\par
\pard\keep\li720\f1{}egrep foo {\i files} ...\par
\pard\f0{}}\par
\page\pard Node: {\b Read Terminal}, \keepn Next: {\uldb Long}{\v Long}, Prev: {\uldb One-shot}{\v One_shot}, Up: {\uldb Running gawk}{\v Running_gawk}\line
K{\footnote K Read Terminal}
#{\footnote Read_Terminal}
${\footnote \pard{}Running {\f1{}awk} without Input Files}\par
\pard{\fs24\b Running {\f1{}awk} without Input Files}\par
\par
\pard{}{K{\footnote K standard input}}{K{\footnote K input, standard}}You can also run {\f1{}awk} without any input files.  If you type the command line:\par
\par
{\pard\keep\li720\f1{}awk '{\i program}'\par
\pard\f0{}}\par
\pard{}then {\f1{}awk} applies the {\i program} to the \'A2standard input\'A2, which usually means whatever you type on the terminal.  This continues until you indicate end-of-file by typing {\f1{}Control-d}.  (On other operating systems, the end-of-file character may be different.  For example, on OS/2 and MS-DOS, it is {\f1{}Control-z}.)\par
\par
\pard{}For example, the following program prints a friendly piece of advice (from Douglas Adams' {\i The Hitchhiker's Guide to the Galaxy}), to keep you from worrying about the complexities of computer programming ({\f1{}BEGIN} is a feature we haven't discussed yet).\par
\par
{\pard\keep\li720\f1{}$ awk "BEGIN \'7B print \'5C"Don't Panic!\'5C" \'7D"\line
-| Don't Panic!\par
\pard\f0{}}\par
\pard{}{K{\footnote K quoting, shell}}{K{\footnote K shell quoting}}This program does not read any input.  The {\f1{}\'5C} before each of the inner double quotes is necessary because of the shell's quoting rules, in particular because it mixes both single quotes and double quotes.\par
\par
\pard{}This next simple {\f1{}awk} program emulates the {\f1{}cat} utility; it copies whatever you type at the keyboard to its standard output. (Why this works is explained shortly.)\par
\par
{\pard\keep\li720\f1{}$ awk '\'7B print \'7D'\line
Now is the time for all good men\line
-| Now is the time for all good men\line
to come to the aid of their country.\line
-| to come to the aid of their country.\line
Four score and seven years ago, ...\line
-| Four score and seven years ago, ...\line
What, me worry?\line
-| What, me worry?\line
Control-d\par
\pard\f0{}}\par
\page\pard Node: {\b Long}, \keepn Next: {\uldb Executable Scripts}{\v Executable_Scripts}, Prev: {\uldb Read Terminal}{\v Read_Terminal}, Up: {\uldb Running gawk}{\v Running_gawk}\line
K{\footnote K Long}
#{\footnote Long}
${\footnote \pard{}Running Long Programs}\par
\pard{\fs24\b Running Long Programs}\par
\par
\pard{}{K{\footnote K running long programs}}{K{\footnote K {\f1{}-f} option}}{K{\footnote K program file}}{K{\footnote K file, {\f1{}awk} program}}Sometimes your {\f1{}awk} programs can be very long.  In this case it is more convenient to put the program into a separate file.  To tell {\f1{}awk} to use that file for its program, you type:\par
\par
{\pard\keep\li720\f1{}awk -f {\i source-file} {\i input-file1} {\i input-file2} ...\par
\pard\f0{}}\par
\pard{}The {\f1{}-f} instructs the {\f1{}awk} utility to get the {\f1{}awk} program from the file {\i source-file}.  Any file name can be used for {\i source-file}.  For example, you could put the program:\par
\par
{\pard\keep\li720\f1{}BEGIN \'7B print "Don't Panic!" \'7D\par
\pard\f0{}}\par
\pard{}into the file {\f1{}advice}.  Then this command:\par
\par
{\pard\keep\li720\f1{}awk -f advice\par
\pard\f0{}}\par
\pard{}does the same thing as this one:\par
\par
{\pard\keep\li720\f1{}awk "BEGIN \'7B print \'5C"Don't Panic!\'5C" \'7D"\par
\pard\f0{}}\par
\pard{}{K{\footnote K quoting, shell}}{K{\footnote K shell quoting}} which was explained earlier (see {\uldb Running {\f1{}awk} without Input Files}{\v Read_Terminal}).  Note that you don't usually need single quotes around the file name that you specify with {\f1{}-f}, because most file names don't contain any of the shell's special characters.  Notice that in {\f1{}advice}, the {\f1{}awk} program did not have single quotes around it.  The quotes are only needed for programs that are provided on the {\f1{}awk} command line.\par
\par
\pard{}If you want to identify your {\f1{}awk} program files clearly as such, you can add the extension {\f1{}.awk} to the file name.  This doesn't affect the execution of the {\f1{}awk} program, but it does make "housekeeping" easier.\par
\par
\page\pard Node: {\b Executable Scripts}, \keepn Next: {\uldb Comments}{\v Comments}, Prev: {\uldb Long}{\v Long}, Up: {\uldb Running gawk}{\v Running_gawk}\line
K{\footnote K Executable Scripts}
#{\footnote Executable_Scripts}
${\footnote \pard{}Executable {\f1{}awk} Programs}\par
\pard{\fs24\b Executable {\f1{}awk} Programs}\par
\par
\pard{}{K{\footnote K executable scripts}}{K{\footnote K scripts, executable}}{K{\footnote K self contained programs}}{K{\footnote K program, self contained}}{K{\footnote K {\f1{}#!} (executable scripts)}} Once you have learned {\f1{}awk}, you may want to write self-contained {\f1{}awk} scripts, using the {\f1{}#!} script mechanism.  You can do this on many Unix systems({\ul 1}{\v Executable_Scripts_1}) (and someday on the GNU system).\par
\par
\pard{}For example, you could update the file {\f1{}advice} to look like this:\par
\par
{\pard\keep\li720\f1{}#! /bin/awk -f\line
\line
BEGIN    \'7B print "Don't Panic!" \'7D\par
\pard\f0{}}\par
\pard{}After making this file executable (with the {\f1{}chmod} utility), you can simply type {\f1{}advice} at the shell, and the system will arrange to run {\f1{}awk}({\ul 2}{\v Executable_Scripts_2}) as if you had typed {\f1{}awk -f advice}.\par
\par
{{\pard\keep\li720\f1{}$ advice\line
-| Don't Panic!\par
\pard\keep\li720{}}}\par
\pard\f0{}Self-contained {\f1{}awk} scripts are useful when you want to write a program which users can invoke without their having to know that the program is written in {\f1{}awk}.\par
\par
{\b \pard{}Caution:} You should not put more than one argument on the {\f1{}#!} line after the path to {\f1{}awk}. This will not work. The operating system treats the rest of the line as a single agument, and passes it to {\f1{}awk}.  Doing this will lead to confusing behavior: most likely a usage diagnostic of some sort from {\f1{}awk}.\par
\par
\pard{}{K{\footnote K shell scripts}}{K{\footnote K scripts, shell}}Some older systems do not support the {\f1{}#!} mechanism. You can get a similar effect using a regular shell script.  It would look something like this:\par
\par
{\pard\keep\li720\f1{}: The colon ensures execution by the standard shell.\line
awk '{\i program}' "$@"\par
\pard\f0{}}\par
\pard{}Using this technique, it is {\i vital} to enclose the {\i program} in single quotes to protect it from interpretation by the shell.  If you omit the quotes, only a shell wizard can predict the results.\par
\par
\pard{}The {\f1{}"$@"} causes the shell to forward all the command line arguments to the {\f1{}awk} program, without interpretation.  The first line, which starts with a colon, is used so that this shell script will work even if invoked by a user who uses the C shell.  (Not all older systems obey this convention, but many do.)\par
\par
\page\pard#{\footnote Executable_Scripts_1}
\pard{}(1) The {\f1{}#!} mechanism works on Linux systems, Unix systems derived from Berkeley Unix, System V Release 4, and some System V Release 3 systems.\par
\par
\page\pard#{\footnote Executable_Scripts_2}
\pard{}(2) The line beginning with {\f1{}#!} lists the full file name of an interpreter to be run, and an optional initial command line argument to pass to that interpreter.  The operating system then runs the interpreter with the given argument and the full argument list of the executed program.  The first argument in the list is the full file name of the {\f1{}awk} program.  The rest of the argument list will either be options to {\f1{}awk}, or data files, or both.\par
\par
\page\pard Node: {\b Comments}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Executable Scripts}{\v Executable_Scripts}, Up: {\uldb Running gawk}{\v Running_gawk}\line
K{\footnote K Comments}
#{\footnote Comments}
${\footnote \pard{}Comments in {\f1{}awk} Programs}\par
\pard{\fs24\b Comments in {\f1{}awk} Programs}\par
\par
\pard{}{K{\footnote K {\f1{}#} (comment)}}{K{\footnote K comments}}{K{\footnote K use of comments}}{K{\footnote K documenting {\f1{}awk} programs}}{K{\footnote K programs, documenting}} A \'A2comment\'A2 is some text that is included in a program for the sake of human readers; it is not really part of the program.  Comments can explain what the program does, and how it works.  Nearly all programming languages have provisions for comments, because programs are typically hard to understand without their extra help.\par
\par
\pard{}In the {\f1{}awk} language, a comment starts with the sharp sign character, {\f1{}#}, and continues to the end of the line.  The {\f1{}#} does not have to be the first character on the line. The {\f1{}awk} language ignores the rest of a line following a sharp sign.  For example, we could have put the following into {\f1{}advice}:\par
\par
{\pard\keep\li720\f1{}# This program prints a nice friendly message.  It helps\line
# keep novice users from being afraid of the computer.\line
BEGIN    \'7B print "Don't Panic!" \'7D\par
\pard\f0{}}\par
\pard{}You can put comment lines into keyboard-composed throw-away {\f1{}awk} programs also, but this usually isn't very useful; the purpose of a comment is to help you or another person understand the program at a later time.\par
\par
{\b \pard{}Caution:} As mentioned in {\uldb One-shot Throw-away {\f1{}awk} Programs}{\v One_shot}, you can enclose small to medium programs in single quotes, in order to keep your shell scripts self-contained.  When doing so, {\i don't} put an apostrophe (i.e., a single quote) into a comment (or anywhere else in your program). The shell will interpret the quote as the closing quote for the entire program. As a result, usually the shell will print a message about mismatched quotes, and if {\f1{}awk} actually runs, it will probably print strange messages about syntax errors.  For example:\par
\par
{\pard\keep\li720\f1{}awk 'BEGIN \'7B print "hello" \'7D # let's be cute'\par
\pard\f0{}}\par
\page\pard Node: {\b Very Simple}, \keepn Next: {\uldb Two Rules}{\v Two_Rules}, Prev: {\uldb Running gawk}{\v Running_gawk}, Up: {\uldb Getting Started}{\v Getting_Started}\line
K{\footnote K Very Simple}
#{\footnote Very_Simple}
${\footnote \pard{}A Very Simple Example}\par
\pard{\fs24\b A Very Simple Example}\par
\par
\pard{}The following command runs a simple {\f1{}awk} program that searches the input file {\f1{}BBS-list} for the string of characters: {\f1{}foo}.  (A string of characters is usually called a \'A2string\'A2.  The term \'A2string\'A2 is perhaps based on similar usage in English, such as "a string of pearls," or, "a string of cars in a train.")\par
\par
{\pard\keep\li720\f1{}awk '/foo/ \'7B print $0 \'7D' BBS-list\par
\pard\f0{}}\par
\pard{}When lines containing {\f1{}foo} are found, they are printed, because {\f1{}print $0} means print the current line.  (Just {\f1{}print} by itself means the same thing, so we could have written that instead.)\par
\par
\pard{}You will notice that slashes, {\f1{}/}, surround the string {\f1{}foo} in the {\f1{}awk} program.  The slashes indicate that {\f1{}foo} is a pattern to search for.  This type of pattern is called a \'A2regular expression\'A2, and is covered in more detail later (see {\uldb Regular Expressions}{\v Regexp}).  The pattern is allowed to match parts of words.  There are single-quotes around the {\f1{}awk} program so that the shell won't interpret any of it as special shell characters.\par
\par
\pard{}Here is what this program prints:\par
\par
{{\pard\keep\li720\f1{}$ awk '/foo/ \'7B print $0 \'7D' BBS-list\line
-| fooey        555-1234     2400/1200/300     B\line
-| foot         555-6699     1200/300          B\line
-| macfoo       555-6480     1200/300          A\line
-| sabafoo      555-2127     1200/300          C\par
\pard\keep\li720{}}}\par
\pard\f0{}{K{\footnote K action, default}}{K{\footnote K pattern, default}}{K{\footnote K default action}}{K{\footnote K default pattern}}In an {\f1{}awk} rule, either the pattern or the action can be omitted, but not both.  If the pattern is omitted, then the action is performed for {\i every} input line.  If the action is omitted, the default action is to print all lines that match the pattern.\par
\par
\pard{}{K{\footnote K empty action}}{K{\footnote K action, empty}}Thus, we could leave out the action (the {\f1{}print} statement and the curly braces) in the above example, and the result would be the same: all lines matching the pattern {\f1{}foo} would be printed.  By comparison, omitting the {\f1{}print} statement but retaining the curly braces makes an empty action that does nothing; then no lines would be printed.\par
\par
\page\pard Node: {\b Two Rules}, \keepn Next: {\uldb More Complex}{\v More_Complex}, Prev: {\uldb Very Simple}{\v Very_Simple}, Up: {\uldb Getting Started}{\v Getting_Started}\line
K{\footnote K Two Rules}
#{\footnote Two_Rules}
${\footnote \pard{}An Example with Two Rules}\par
\pard{\fs24\b An Example with Two Rules}\par
\par
\pard{}{K{\footnote K how {\f1{}awk} works}} The {\f1{}awk} utility reads the input files one line at a time.  For each line, {\f1{}awk} tries the patterns of each of the rules.  If several patterns match then several actions are run, in the order in which they appear in the {\f1{}awk} program.  If no patterns match, then no actions are run.\par
\par
\pard{}After processing all the rules (perhaps none) that match the line, {\f1{}awk} reads the next line (however, see {\uldb The {\f1{}next} Statement}{\v Next_Statement}, and also see {\uldb The {\f1{}nextfile} Statement}{\v Nextfile_Statement}).  This continues until the end of the file is reached.\par
\par
\pard{}For example, the {\f1{}awk} program:\par
\par
{\pard\keep\li720\f1{}/12/  \'7B print $0 \'7D\line
/21/  \'7B print $0 \'7D\par
\pard\f0{}}\par
\pard{}contains two rules.  The first rule has the string {\f1{}12} as the pattern and {\f1{}print $0} as the action.  The second rule has the string {\f1{}21} as the pattern and also has {\f1{}print $0} as the action.  Each rule's action is enclosed in its own pair of braces.\par
\par
\pard{}This {\f1{}awk} program prints every line that contains the string {\f1{}12} {\i or} the string {\f1{}21}.  If a line contains both strings, it is printed twice, once by each rule.\par
\par
\pard{}This is what happens if we run this program on our two sample data files, {\f1{}BBS-list} and {\f1{}inventory-shipped}, as shown here:\par
\par
{\pard\keep\li720\f1{}$ awk '/12/ \'7B print $0 \'7D\line
>      /21/ \'7B print $0 \'7D' BBS-list inventory-shipped\line
-| aardvark     555-5553     1200/300          B\line
-| alpo-net     555-3412     2400/1200/300     A\line
-| barfly       555-7685     1200/300          A\line
-| bites        555-1675     2400/1200/300     A\line
-| core         555-2912     1200/300          C\line
-| fooey        555-1234     2400/1200/300     B\line
-| foot         555-6699     1200/300          B\line
-| macfoo       555-6480     1200/300          A\line
-| sdace        555-3430     2400/1200/300     A\line
-| sabafoo      555-2127     1200/300          C\line
-| sabafoo      555-2127     1200/300          C\line
-| Jan  21  36  64 620\line
-| Apr  21  70  74 514\par
\pard\f0{}}\par
\pard{}Note how the line in {\f1{}BBS-list} beginning with {\f1{}sabafoo} was printed twice, once for each rule.\par
\par
\page\pard Node: {\b More Complex}, \keepn Next: {\uldb Statements/Lines}{\v Statements_Lines}, Prev: {\uldb Two Rules}{\v Two_Rules}, Up: {\uldb Getting Started}{\v Getting_Started}\line
K{\footnote K More Complex}
#{\footnote More_Complex}
${\footnote \pard{}A More Complex Example}\par
\pard{\fs24\b A More Complex Example}\par
\par
\pard{}Here is an example to give you an idea of what typical {\f1{}awk} programs do.  This example shows how {\f1{}awk} can be used to summarize, select, and rearrange the output of another utility.  It uses features that haven't been covered yet, so don't worry if you don't understand all the details.\par
\par
{\pard\keep\li720\f1{}ls -lg | awk '$6 == "Nov" \'7B sum += $5 \'7D\line
             END \'7B print sum \'7D'\par
\pard\f0{}}\par
\pard{}{K{\footnote K {\f1{}csh}, backslash continuation}}{K{\footnote K backslash continuation in {\f1{}csh}}}This command prints the total number of bytes in all the files in the current directory that were last modified in November (of any year).  (In the C shell you would need to type a semicolon and then a backslash at the end of the first line; in a POSIX-compliant shell, such as the Bourne shell or Bash, the GNU Bourne-Again shell, you can type the example as shown.)\par
\par
\pard{}The {\f1{}ls -lg} part of this example is a system command that gives you a listing of the files in a directory, including file size and the date the file was last modified. Its output looks like this:\par
\par
{\pard\keep\li720\f1{}-rw-r--r--  1 arnold   user   1933 Nov  7 13:05 Makefile\line
-rw-r--r--  1 arnold   user  10809 Nov  7 13:03 gawk.h\line
-rw-r--r--  1 arnold   user    983 Apr 13 12:14 gawk.tab.h\line
-rw-r--r--  1 arnold   user  31869 Jun 15 12:20 gawk.y\line
-rw-r--r--  1 arnold   user  22414 Nov  7 13:03 gawk1.c\line
-rw-r--r--  1 arnold   user  37455 Nov  7 13:03 gawk2.c\line
-rw-r--r--  1 arnold   user  27511 Dec  9 13:07 gawk3.c\line
-rw-r--r--  1 arnold   user   7989 Nov  7 13:03 gawk4.c\par
\pard\f0{}}\par
\pard{}The first field contains read-write permissions, the second field contains the number of links to the file, and the third field identifies the owner of the file. The fourth field identifies the group of the file.  The fifth field contains the size of the file in bytes.  The sixth, seventh and eighth fields contain the month, day, and time, respectively, that the file was last modified.  Finally, the ninth field contains the name of the file.\par
\par
\pard{}{K{\footnote K automatic initialization}}{K{\footnote K initialization, automatic}}The {\f1{}$6 == "Nov"} in our {\f1{}awk} program is an expression that tests whether the sixth field of the output from {\f1{}ls -lg} matches the string {\f1{}Nov}.  Each time a line has the string {\f1{}Nov} for its sixth field, the action {\f1{}sum += $5} is performed.  This adds the fifth field (the file size) to the variable {\f1{}sum}.  As a result, when {\f1{}awk} has finished reading all the input lines, {\f1{}sum} is the sum of the sizes of files whose lines matched the pattern.  (This works because {\f1{}awk} variables are automatically initialized to zero.)\par
\par
\pard{}After the last line of output from {\f1{}ls} has been processed, the {\f1{}END} rule is executed, and the value of {\f1{}sum} is printed.  In this example, the value of {\f1{}sum} would be 80600.\par
\par
\pard{}These more advanced {\f1{}awk} techniques are covered in later sections (see {\uldb Overview of Actions}{\v Action_Overview}).  Before you can move on to more advanced {\f1{}awk} programming, you have to know how {\f1{}awk} interprets your input and displays your output.  By manipulating fields and using {\f1{}print} statements, you can produce some very useful and impressive looking reports.\par
\par
\page\pard Node: {\b Statements/Lines}, \keepn Next: {\uldb Other Features}{\v Other_Features}, Prev: {\uldb More Complex}{\v More_Complex}, Up: {\uldb Getting Started}{\v Getting_Started}\line
K{\footnote K Statements/Lines}
#{\footnote Statements_Lines}
${\footnote {\f1{}\pard{}awk} Statements Versus Lines}\par
\pard{\fs24\b {\f1{}awk} Statements Versus Lines}\par
\par
\pard{}{K{\footnote K line break}}{K{\footnote K newline}} Most often, each line in an {\f1{}awk} program is a separate statement or separate rule, like this:\par
\par
{\pard\keep\li720\f1{}awk '/12/  \'7B print $0 \'7D\line
     /21/  \'7B print $0 \'7D' BBS-list inventory-shipped\par
\pard\f0{}}\par
\pard{}However, {\f1{}gawk} will ignore newlines after any of the following:\par
\par
{\pard\keep\li720\f1{},    \'7B    ?    :    ||    &&    do    else\par
\pard\f0{}}\par
\pard{}A newline at any other point is considered the end of the statement.  (Splitting lines after {\f1{}?} and {\f1{}:} is a minor {\f1{}gawk} extension.  The {\f1{}?} and {\f1{}:} referred to here is the three operand conditional expression described in {\uldb Conditional Expressions}{\v Conditional_Exp}.)\par
\par
\pard{}{K{\footnote K backslash continuation}}{K{\footnote K continuation of lines}}{K{\footnote K line continuation}}If you would like to split a single statement into two lines at a point where a newline would terminate it, you can \'A2continue\'A2 it by ending the first line with a backslash character, {\f1{}\'5C}.  The backslash must be the final character on the line to be recognized as a continuation character.  This is allowed absolutely anywhere in the statement, even in the middle of a string or regular expression.  For example:\par
\par
{\pard\keep\li720\f1{}awk '/This regular expression is too long, so continue it\'5C\line
 on the next line/ \'7B print $1 \'7D'\par
\pard\f0{}}\par
\pard{}{K{\footnote K portability issues}}We have generally not used backslash continuation in the sample programs in this Info file.  Since in {\f1{}gawk} there is no limit on the length of a line, it is never strictly necessary; it just makes programs more readable.  For this same reason, as well as for clarity, we have kept most statements short in the sample programs presented throughout the Info file.  Backslash continuation is most useful when your {\f1{}awk} program is in a separate source file, instead of typed in on the command line.  You should also note that many {\f1{}awk} implementations are more particular about where you may use backslash continuation. For example, they may not allow you to split a string constant using backslash continuation.  Thus, for maximal portability of your {\f1{}awk} programs, it is best not to split your lines in the middle of a regular expression or a string.\par
\par
\pard{}{K{\footnote K {\f1{}csh}, backslash continuation}}{K{\footnote K backslash continuation in {\f1{}csh}}}{\b Caution: backslash continuation does not work as described above with the C shell.}  Continuation with backslash works for {\f1{}awk} programs in files, and also for one-shot programs {\i provided} you are using a POSIX-compliant shell, such as the Bourne shell or Bash, the GNU Bourne-Again shell.  But the C shell ({\f1{}csh}) behaves differently!  There, you must use two backslashes in a row, followed by a newline.  Note also that when using the C shell, {\i every} newline in your awk program must be escaped with a backslash. To illustrate:\par
\par
{\pard\keep\li720\f1{}% awk 'BEGIN \'7B \'5C\line
?   print \'5C\'5C\line
?       "hello, world" \'5C\line
? \'7D'\line
-| hello, world\par
\pard\f0{}}\par
\pard{}Here, the {\f1{}%} and {\f1{}?} are the C shell's primary and secondary prompts, analogous to the standard shell's {\f1{}$} and {\f1{}>}.\par
\par
{\f1{}\pard{}awk} is a line-oriented language.  Each rule's action has to begin on the same line as the pattern.  To have the pattern and action on separate lines, you {\i must} use backslash continuation--there is no other way.\par
\par
\pard{}{K{\footnote K backslash continuation and comments}}{K{\footnote K comments and backslash continuation}}Note that backslash continuation and comments do not mix. As soon as {\f1{}awk} sees the {\f1{}#} that starts a comment, it ignores {\i everything} on the rest of the line. For example:\par
\par
{{\pard\keep\li720\f1{}$ gawk 'BEGIN \'7B print "dont panic" # a friendly \'5C\line
>                                    BEGIN rule\line
> \'7D'\line
error--> gawk: cmd. line:2:                BEGIN rule\line
error--> gawk: cmd. line:2:                ^ parse error\par
\pard\keep\li720{}}}\par
\pard\f0{}Here, it looks like the backslash would continue the comment onto the next line. However, the backslash-newline combination is never even noticed, since it is "hidden" inside the comment. Thus, the {\f1{}BEGIN} is noted as a syntax error.\par
\par
\pard{}{K{\footnote K multiple statements on one line}}When {\f1{}awk} statements within one rule are short, you might want to put more than one of them on a line.  You do this by separating the statements with a semicolon, {\f1{};}.\par
\par
\pard{}This also applies to the rules themselves.  Thus, the previous program could have been written:\par
\par
{\pard\keep\li720\f1{}/12/ \'7B print $0 \'7D ; /21/ \'7B print $0 \'7D\par
\pard\f0{}}\par
{\b \pard{}Note:} the requirement that rules on the same line must be separated with a semicolon was not in the original {\f1{}awk} language; it was added for consistency with the treatment of statements within an action.\par
\par
\page\pard Node: {\b Other Features}, \keepn Next: {\uldb When}{\v When}, Prev: {\uldb Statements/Lines}{\v Statements_Lines}, Up: {\uldb Getting Started}{\v Getting_Started}\line
K{\footnote K Other Features}
#{\footnote Other_Features}
${\footnote \pard{}Other Features of {\f1{}awk}}\par
\pard{\fs24\b Other Features of {\f1{}awk}}\par
\par
\pard{}The {\f1{}awk} language provides a number of predefined, or built-in variables, which your programs can use to get information from {\f1{}awk}.  There are other variables your program can set to control how {\f1{}awk} processes your data.\par
\par
\pard{}In addition, {\f1{}awk} provides a number of built-in functions for doing common computational and string related operations.\par
\par
\pard{}As we develop our presentation of the {\f1{}awk} language, we introduce most of the variables and many of the functions. They are defined systematically in {\uldb Built-in Variables}{\v Built_in_Variables}, and {\uldb Built-in Functions}{\v Built_in}.\par
\par
\page\pard Node: {\b When}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Other Features}{\v Other_Features}, Up: {\uldb Getting Started}{\v Getting_Started}\line
K{\footnote K When}
#{\footnote When}
${\footnote \pard{}When to Use {\f1{}awk}}\par
\pard{\fs24\b When to Use {\f1{}awk}}\par
\par
\pard{}{K{\footnote K when to use {\f1{}awk}}}{K{\footnote K applications of {\f1{}awk}}}You might wonder how {\f1{}awk} might be useful for you.  Using utility programs, advanced patterns, field separators, arithmetic statements, and other selection criteria, you can produce much more complex output.  The {\f1{}awk} language is very useful for producing reports from large amounts of raw data, such as summarizing information from the output of other utility programs like {\f1{}ls}.  (See {\uldb A More Complex Example}{\v More_Complex}.)\par
\par
\pard{}Programs written with {\f1{}awk} are usually much smaller than they would be in other languages.  This makes {\f1{}awk} programs easy to compose and use.  Often, {\f1{}awk} programs can be quickly composed at your terminal, used once, and thrown away.  Since {\f1{}awk} programs are interpreted, you can avoid the (usually lengthy) compilation part of the typical edit-compile-test-debug cycle of software development.\par
\par
\pard{}Complex programs have been written in {\f1{}awk}, including a complete retargetable assembler for eight-bit microprocessors (see {\uldb Glossary}{\v Glossary}, for more information) and a microcode assembler for a special purpose Prolog computer.  However, {\f1{}awk}'s capabilities are strained by tasks of such complexity.\par
\par
\pard{}If you find yourself writing {\f1{}awk} scripts of more than, say, a few hundred lines, you might consider using a different programming language.  Emacs Lisp is a good choice if you need sophisticated string or pattern matching capabilities.  The shell is also good at string and pattern matching; in addition, it allows powerful use of the system utilities.  More conventional languages, such as C, C++, and Lisp, offer better facilities for system programming and for managing the complexity of large programs.  Programs in these languages may require more lines of source code than the equivalent {\f1{}awk} programs, but they are easier to maintain and usually run more efficiently.\par
\par
\page\pard Node: {\b One-liners}, \keepn Next: {\uldb Regexp}{\v Regexp}, Prev: {\uldb Getting Started}{\v Getting_Started}, Up: {\uldb Top}{\v Top}\line
K{\footnote K One-liners}
#{\footnote One_liners}
${\footnote \pard{}Useful One Line Programs}\par
\pard{\fs24\b Useful One Line Programs}\par
\par
\pard{}{K{\footnote K one-liners}}Many useful {\f1{}awk} programs are short, just a line or two.  Here is a collection of useful, short programs to get you started.  Some of these programs contain constructs that haven't been covered yet.  The description of the program will give you a good idea of what is going on, but please read the rest of the Info file to become an {\f1{}awk} expert!\par
\par
\pard{}Most of the examples use a data file named {\f1{}data}.  This is just a placeholder; if you were to use these programs yourself, you would substitute your own file names for {\f1{}data}.\par
\par
{\pard{}Since you are reading this in Info, each line of the example code is enclosed in quotes, to represent text that you would type literally.  The examples themselves represent shell commands that use single quotes to keep the shell from interpreting the contents of the program.  When reading the examples, focus on the text between the open and close quotes.  }\par
\par
{\pard{}{\f1{}awk '\'7B if (length($0) > max) max = length($0) \'7D}\par
\pard{}{\f1{}     END \'7B print max \'7D' data}\par
\pard\li720{}This program prints the length of the longest input line.\par
\par
\pard{}{\f1{}awk 'length($0) > 80' data}\par
\pard\li720{}This program prints every line that is longer than 80 characters.  The sole rule has a relational expression as its pattern, and has no action (so the default action, printing the record, is used).\par
\par
\pard{}{\f1{}expand data | awk '\'7B if (x < length()) x = length() \'7D}\par
\pard{}{\f1{}                   END \'7B print "maximum line length is " x \'7D'}\par
\pard\li720{}This program prints the length of the longest line in {\f1{}data}.  The input is processed by the {\f1{}expand} program to change tabs into spaces, so the widths compared are actually the right-margin columns.\par
\par
\pard{}{\f1{}awk 'NF > 0' data}\par
\pard\li720{}This program prints every line that has at least one field.  This is an easy way to delete blank lines from a file (or rather, to create a new file similar to the old file but from which the blank lines have been deleted).\par
\par
\pard{}{\f1{}awk 'BEGIN \'7B for (i = 1; i <= 7; i++)}\par
\pard{}{\f1{}               print int(101 * rand()) \'7D'}\par
\pard\li720{}This program prints seven random numbers from zero to 100, inclusive.\par
\par
\pard{}{\f1{}ls -lg {\i files} | awk '\'7B x += $5 \'7D ; END \'7B print "total bytes: " x \'7D'}\par
\pard\li720{}This program prints the total number of bytes used by {\i files}.\par
\par
\pard{}{\f1{}ls -lg {\i files} | awk '\'7B x += $5 \'7D}\par
\pard{}{\f1{}                 END \'7B print "total K-bytes: " (x + 1023)/1024 \'7D'}\par
\pard\li720{}This program prints the total number of kilobytes used by {\i files}.\par
\par
\pard{}{\f1{}awk -F: '\'7B print $1 \'7D' /etc/passwd | sort}\par
\pard\li720{}This program prints a sorted list of the login names of all users.\par
\par
\pard{}{\f1{}awk 'END \'7B print NR \'7D' data}\par
\pard\li720{}This program counts lines in a file.\par
\par
\pard{}{\f1{}awk 'NR % 2 == 0' data}\par
\pard\li720{}This program prints the even numbered lines in the data file.  If you were to use the expression {\f1{}NR % 2 == 1} instead, it would print the odd numbered lines.\par
\pard{}}\par
\page\pard Node: {\b Regexp}, \keepn Next: {\uldb Reading Files}{\v Reading_Files}, Prev: {\uldb One-liners}{\v One_liners}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Regexp}
#{\footnote Regexp}
${\footnote \pard{}Regular Expressions}\par
\pard{\fs24\b Regular Expressions}\par
\par
\pard{}{K{\footnote K pattern, regular expressions}}{K{\footnote K regexp}}{K{\footnote K regular expression}}{K{\footnote K regular expressions as patterns}} A \'A2regular expression\'A2, or \'A2regexp\'A2, is a way of describing a set of strings.  Because regular expressions are such a fundamental part of {\f1{}awk} programming, their format and use deserve a separate chapter.\par
\par
\pard{}A regular expression enclosed in slashes ({\f1{}/}) is an {\f1{}awk} pattern that matches every input record whose text belongs to that set.\par
\par
\pard{}The simplest regular expression is a sequence of letters, numbers, or both.  Such a regexp matches any string that contains that sequence.  Thus, the regexp {\f1{}foo} matches any string containing {\f1{}foo}.  Therefore, the pattern {\f1{}/foo/} matches any input record containing the three characters {\f1{}foo}, {\i anywhere} in the record.  Other kinds of regexps let you specify more complicated classes of strings.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Regexp Usage}{\v Regexp_Usage}\tab How to Use Regular Expressions.\par
{\uldb Escape Sequences}{\v Escape_Sequences}\tab How to write non-printing characters.\par
{\uldb Regexp Operators}{\v Regexp_Operators}\tab Regular Expression Operators.\par
{\uldb GNU Regexp Operators}{\v GNU_Regexp_Operators}\tab Operators specific to GNU software.\par
{\uldb Case-sensitivity}{\v Case_sensitivity}\tab How to do case-insensitive matching.\par
{\uldb Leftmost Longest}{\v Leftmost_Longest}\tab How much text matches.\par
{\uldb Computed Regexps}{\v Computed_Regexps}\tab Using Dynamic Regexps.\par
\pard{}}\par
\page\pard Node: {\b Regexp Usage}, \keepn Next: {\uldb Escape Sequences}{\v Escape_Sequences}, Prev: {\uldb Regexp}{\v Regexp}, Up: {\uldb Regexp}{\v Regexp}\line
K{\footnote K Regexp Usage}
#{\footnote Regexp_Usage}
${\footnote \pard{}How to Use Regular Expressions}\par
\pard{\fs24\b How to Use Regular Expressions}\par
\par
\pard{}A regular expression can be used as a pattern by enclosing it in slashes.  Then the regular expression is tested against the entire text of each record.  (Normally, it only needs to match some part of the text in order to succeed.)  For example, this prints the second field of each record that contains the three characters {\f1{}foo} anywhere in it:\par
\par
{{\pard\keep\li720\f1{}$ awk '/foo/ \'7B print $2 \'7D' BBS-list\line
-| 555-1234\line
-| 555-6699\line
-| 555-6480\line
-| 555-2127\par
\pard\keep\li720{}}}\par
\pard\f0{}{K{\footnote K regexp matching operators}}{K{\footnote K string-matching operators}}{K{\footnote K operators, string-matching}}{K{\footnote K operators, regexp matching}}{K{\footnote K regexp match/non-match operators}}{K{\footnote K {\f1{}~} operator}}{K{\footnote K {\f1{}!~} operator}}Regular expressions can also be used in matching expressions.  These expressions allow you to specify the string to match against; it need not be the entire current input record.  The two operators, {\f1{}~} and {\f1{}!~}, perform regular expression comparisons.  Expressions using these operators can be used as patterns or in {\f1{}if}, {\f1{}while}, {\f1{}for}, and {\f1{}do} statements.  {(See {\uldb Control Statements in Actions}{\v Statements}.)  }\par
\par
{\pard{}{\f1{}{\i exp} ~ /{\i regexp}/}\par
\pard\li720{}This is true if the expression {\i exp} (taken as a string) is matched by {\i regexp}.  The following example matches, or selects, all input records with the upper-case letter {\f1{}J} somewhere in the first field:\par
\par
{{\pard\keep\li1440\f1{}$ awk '$1 ~ /J/' inventory-shipped\line
-| Jan  13  25  15 115\line
-| Jun  31  42  75 492\line
-| Jul  24  34  67 436\line
-| Jan  21  36  64 620\par
\pard\keep\li1440{}}}\par
\pard\li720\f0{}So does this:\par
\par
{\pard\keep\li1440\f1{}awk '\'7B if ($1 ~ /J/) print \'7D' inventory-shipped\par
\pard\li720\f0{}}\par
\pard{}{\f1{}{\i exp} !~ /{\i regexp}/}\par
\pard\li720{}This is true if the expression {\i exp} (taken as a character string) is {\i not} matched by {\i regexp}.  The following example matches, or selects, all input records whose first field {\i does not} contain the upper-case letter {\f1{}J}:\par
\par
{{\pard\keep\li1440\f1{}$ awk '$1 !~ /J/' inventory-shipped\line
-| Feb  15  32  24 226\line
-| Mar  15  24  34 228\line
-| Apr  31  52  63 420\line
-| May  16  34  29 208\line
...\par
\pard\keep\li1440{}}}}\par
\pard\f0{}{K{\footnote K regexp constant}}When a regexp is written enclosed in slashes, like {\f1{}/foo/}, we call it a \'A2regexp constant\'A2, much like {\f1{}5.27} is a numeric constant, and {\f1{}"foo"} is a string constant.\par
\par
\page\pard Node: {\b Escape Sequences}, \keepn Next: {\uldb Regexp Operators}{\v Regexp_Operators}, Prev: {\uldb Regexp Usage}{\v Regexp_Usage}, Up: {\uldb Regexp}{\v Regexp}\line
K{\footnote K Escape Sequences}
#{\footnote Escape_Sequences}
${\footnote \pard{}Escape Sequences}\par
\pard{\fs24\b Escape Sequences}\par
\par
\pard{}{K{\footnote K escape sequence notation}}Some characters cannot be included literally in string constants ({\f1{}"foo"}) or regexp constants ({\f1{}/foo/}).  You represent them instead with \'A2escape sequences\'A2, which are character sequences beginning with a backslash ({\f1{}\'5C}).\par
\par
\pard{}One use of an escape sequence is to include a double-quote character in a string constant.  Since a plain double-quote would end the string, you must use {\f1{}\'5C"} to represent an actual double-quote character as a part of the string.  For example:\par
\par
{\pard\keep\li720\f1{}$ awk 'BEGIN \'7B print "He said \'5C"hi!\'5C" to her." \'7D'\line
-| He said "hi!" to her.\par
\pard\f0{}}\par
\pard{}The  backslash character itself is another character that cannot be included normally; you write {\f1{}\'5C\'5C} to put one backslash in the string or regexp.  Thus, the string whose contents are the two characters {\f1{}"} and {\f1{}\'5C} must be written {\f1{}"\'5C"\'5C\'5C"}.\par
\par
\pard{}Another use of backslash is to represent unprintable characters such as tab or newline.  While there is nothing to stop you from entering most unprintable characters directly in a string constant or regexp constant, they may look ugly.\par
\par
\pard{}Here is a table of all the escape sequences used in {\f1{}awk}, and what they represent. Unless noted otherwise, all of these escape sequences apply to both string constants and regexp constants.\par
\par
{\pard{}{\f1{}\'5C\'5C}\par
\pard\li720{}A literal backslash, {\f1{}\'5C}.\par
\par
\pard\li720{}{K{\footnote K {\f1{}awk} language, V.4 version}}\par
\par
\pard{}{\f1{}\'5Ca}\par
\pard\li720{}The "alert" character, {\f1{}Control-g}, ASCII code 7 (BEL).\par
\par
\pard{}{\f1{}\'5Cb}\par
\pard\li720{}Backspace, {\f1{}Control-h}, ASCII code 8 (BS).\par
\par
\pard{}{\f1{}\'5Cf}\par
\pard\li720{}Formfeed, {\f1{}Control-l}, ASCII code 12 (FF).\par
\par
\pard{}{\f1{}\'5Cn}\par
\pard\li720{}Newline, {\f1{}Control-j}, ASCII code 10 (LF).\par
\par
\pard{}{\f1{}\'5Cr}\par
\pard\li720{}Carriage return, {\f1{}Control-m}, ASCII code 13 (CR).\par
\par
\pard{}{\f1{}\'5Ct}\par
\pard\li720{}Horizontal tab, {\f1{}Control-i}, ASCII code 9 (HT).\par
\par
\pard\li720{}{K{\footnote K {\f1{}awk} language, V.4 version}}\par
\par
\pard{}{\f1{}\'5Cv}\par
\pard\li720{}Vertical tab, {\f1{}Control-k}, ASCII code 11 (VT).\par
\par
\pard{}{\f1{}\'5C{\i nnn}}\par
\pard\li720{}The octal value {\i nnn}, where {\i nnn} are one to three digits between {\f1{}0} and {\f1{}7}.  For example, the code for the ASCII ESC (escape) character is {\f1{}\'5C033}.\par
\par
\pard\li720{}{K{\footnote K {\f1{}awk} language, V.4 version}}{K{\footnote K {\f1{}awk} language, POSIX version}}{K{\footnote K POSIX {\f1{}awk}}}\par
\par
\pard{}{\f1{}\'5Cx{\i hh}...}\par
\pard\li720{}The hexadecimal value {\i hh}, where {\i hh} are hexadecimal digits ({\f1{}0} through {\f1{}9} and either {\f1{}A} through {\f1{}F} or {\f1{}a} through {\f1{}f}).  Like the same construct in ANSI C, the escape sequence continues until the first non-hexadecimal digit is seen.  However, using more than two hexadecimal digits produces undefined results. (The {\f1{}\'5Cx} escape sequence is not allowed in POSIX {\f1{}awk}.)\par
\par
\pard{}{\f1{}\'5C/}\par
\pard\li720{}A literal slash (necessary for regexp constants only).  You use this when you wish to write a regexp constant that contains a slash. Since the regexp is delimited by slashes, you need to escape the slash that is part of the pattern, in order to tell {\f1{}awk} to keep processing the rest of the regexp.\par
\par
\pard{}{\f1{}\'5C"}\par
\pard\li720{}A literal double-quote (necessary for string constants only).  You use this when you wish to write a string constant that contains a double-quote. Since the string is delimited by double-quotes, you need to escape the quote that is part of the string, in order to tell {\f1{}awk} to keep processing the rest of the string.\par
\pard{}}\par
\pard{}In {\f1{}gawk}, there are additional two character sequences that begin with backslash that have special meaning in regexps.  See {\uldb Additional Regexp Operators Only in {\f1{}gawk}}{\v GNU_Regexp_Operators}.\par
\par
\pard{}In a string constant, what happens if you place a backslash before something that is not one of the characters listed above?  POSIX {\f1{}awk} purposely leaves this case undefined.  There are two choices.\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Strip the backslash out.  This is what Unix {\f1{}awk} and {\f1{}gawk} both do.  For example, {\f1{}"a\'5Cqc"} is the same as {\f1{}"aqc"}.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Leave the backslash alone.  Some other {\f1{}awk} implementations do this.  In such implementations, {\f1{}"a\'5Cqc"} is the same as if you had typed {\f1{}"a\'5C\'5Cqc"}.\par
\pard{}}\par
\pard{}In a regexp, a backslash before any character that is not in the above table, and not listed in {\uldb Additional Regexp Operators Only in {\f1{}gawk}}{\v GNU_Regexp_Operators}, means that the next character should be taken literally, even if it would normally be a regexp operator. E.g., {\f1{}/a\'5C+b/} matches the three characters {\f1{}a+b}.\par
\par
\pard{}{K{\footnote K portability issues}}For complete portability, do not use a backslash before any character not listed in the table above.\par
\par
\pard{}Another interesting question arises. Suppose you use an octal or hexadecimal escape to represent a regexp metacharacter (see {\uldb Regular Expression Operators}{\v Regexp_Operators}).  Does {\f1{}awk} treat the character as a literal character, or as a regexp operator?\par
\par
\pard{}{K{\footnote K dark corner}}It turns out that historically, such characters were taken literally (d.c.).  However, the POSIX standard indicates that they should be treated as real metacharacters, and this is what {\f1{}gawk} does.  However, in compatibility mode (see {\uldb Command Line Options}{\v Options}), {\f1{}gawk} treats the characters represented by octal and hexadecimal escape sequences literally when used in regexp constants. Thus, {\f1{}/a\'5C52b/} is equivalent to {\f1{}/a\'5C*b/}.\par
\par
\pard{}To summarize:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}1. \tab{}The escape sequences in the table above are always processed first, for both string constants and regexp constants. This happens very early, as soon as {\f1{}awk} reads your program.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}2. \tab{}{\f1{}gawk} processes both regexp constants and dynamic regexps (see {\uldb Using Dynamic Regexps}{\v Computed_Regexps}), for the special operators listed in {\uldb Additional Regexp Operators Only in {\f1{}gawk}}{\v GNU_Regexp_Operators}.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}3. \tab{}A backslash before any other character means to treat that character literally.\par
\pard{}}\par
\page\pard Node: {\b Regexp Operators}, \keepn Next: {\uldb GNU Regexp Operators}{\v GNU_Regexp_Operators}, Prev: {\uldb Escape Sequences}{\v Escape_Sequences}, Up: {\uldb Regexp}{\v Regexp}\line
K{\footnote K Regexp Operators}
#{\footnote Regexp_Operators}
${\footnote \pard{}Regular Expression Operators}\par
\pard{\fs24\b Regular Expression Operators}\par
\par
\pard{}{K{\footnote K metacharacters}}{K{\footnote K regular expression metacharacters}}{K{\footnote K regexp operators}} You can combine regular expressions with the following characters, called \'A2regular expression operators\'A2, or \'A2metacharacters\'A2, to increase the power and versatility of regular expressions.\par
\par
\pard{}The escape sequences described in {\uldb Escape Sequences}{\v Escape_Sequences}, are valid inside a regexp.  They are introduced by a {\f1{}\'5C}.  They are recognized and converted into the corresponding real characters as the very first step in processing regexps.\par
\par
\pard{}Here is a table of metacharacters.  All characters that are not escape sequences and that are not listed in the table stand for themselves.\par
\par
{\pard{}{\f1{}\'5C}\par
\pard\li720{}This is used to suppress the special meaning of a character when matching.  For example:\par
\par
{\pard\keep\li1440\f1{}\'5C$\par
\pard\li720\f0{}}\par
\pard\li720{}matches the character {\f1{}$}.\par
\par
\pard\li720{}{K{\footnote K anchors in regexps}}{K{\footnote K regexp, anchors}}\par
\par
\pard{}{\f1{}^}\par
\pard\li720{}This matches the beginning of a string.  For example:\par
\par
{\pard\keep\li1440\f1{}^@chapter\par
\pard\li720\f0{}}\par
\pard\li720{}matches the {\f1{}@chapter} at the beginning of a string, and can be used to identify chapter beginnings in Texinfo source files.  The {\f1{}^} is known as an \'A2anchor\'A2, since it anchors the pattern to matching only at the beginning of the string.\par
\par
\pard\li720{}It is important to realize that {\f1{}^} does not match the beginning of a line embedded in a string.  In this example the condition is not true:\par
\par
{\pard\keep\li1440\f1{}if ("line1\'5CnLINE 2" ~ /^L/) ...\par
\pard\li720\f0{}}\par
\pard{}{\f1{}$}\par
\pard\li720{}This is similar to {\f1{}^}, but it matches only at the end of a string.  For example:\par
\par
{\pard\keep\li1440\f1{}p$\par
\pard\li720\f0{}}\par
\pard\li720{}matches a record that ends with a {\f1{}p}.  The {\f1{}$} is also an anchor, and also does not match the end of a line embedded in a string.  In this example the condition is not true:\par
\par
{\pard\keep\li1440\f1{}if ("line1\'5CnLINE 2" ~ /1$/) ...\par
\pard\li720\f0{}}\par
\pard{}{\f1{}.}\par
\pard\li720{}The period, or dot, matches any single character, {\i including} the newline character.  For example:\par
\par
{\pard\keep\li1440\f1{}.P\par
\pard\li720\f0{}}\par
\pard\li720{}matches any single character followed by a {\f1{}P} in a string.  Using concatenation we can make a regular expression like {\f1{}U.A}, which matches any three-character sequence that begins with {\f1{}U} and ends with {\f1{}A}.\par
\par
\pard\li720{}{K{\footnote K {\f1{}awk} language, POSIX version}}{K{\footnote K POSIX {\f1{}awk}}}In strict POSIX mode (see {\uldb Command Line Options}{\v Options}), {\f1{}.} does not match the {\scaps\fs16{}nul} character, which is a character with all bits equal to zero.  Otherwise, {\scaps\fs16{}nul} is just another character. Other versions of {\f1{}awk} may not be able to match the {\scaps\fs16{}nul} character.\par
\par
\pard\li720{}{K{\footnote K character list}}\par
\par
\pard{}{\f1{}[...]}\par
\pard\li720{}This is called a \'A2character list\'A2.  It matches any {\i one} of the characters that are enclosed in the square brackets.  For example:\par
\par
{\pard\keep\li1440\f1{}[MVX]\par
\pard\li720\f0{}}\par
\pard\li720{}matches any one of the characters {\f1{}M}, {\f1{}V}, or {\f1{}X} in a string.\par
\par
\pard\li720{}Ranges of characters are indicated by using a hyphen between the beginning and ending characters, and enclosing the whole thing in brackets.  For example:\par
\par
{\pard\keep\li1440\f1{}[0-9]\par
\pard\li720\f0{}}\par
\pard\li720{}matches any digit.  Multiple ranges are allowed. E.g., the list {\f1{}[A-Za-z0-9]} is a common way to express the idea of "all alphanumeric characters."\par
\par
\pard\li720{}To include one of the characters {\f1{}\'5C}, {\f1{}]}, {\f1{}-} or {\f1{}^} in a character list, put a {\f1{}\'5C} in front of it.  For example:\par
\par
{\pard\keep\li1440\f1{}[d\'5C]]\par
\pard\li720\f0{}}\par
\pard\li720{}matches either {\f1{}d}, or {\f1{}]}.\par
\par
\pard\li720{}{K{\footnote K {\f1{}egrep}}}This treatment of {\f1{}\'5C} in character lists is compatible with other {\f1{}awk} implementations, and is also mandated by POSIX.  The regular expressions in {\f1{}awk} are a superset of the POSIX specification for Extended Regular Expressions (EREs).  POSIX EREs are based on the regular expressions accepted by the traditional {\f1{}egrep} utility.\par
\par
\pard\li720{}{K{\footnote K character classes}}{K{\footnote K {\f1{}awk} language, POSIX version}}{K{\footnote K POSIX {\f1{}awk}}}\'A2Character classes\'A2 are a new feature introduced in the POSIX standard.  A character class is a special notation for describing lists of characters that have a specific attribute, but where the actual characters themselves can vary from country to country and/or from character set to character set.  For example, the notion of what is an alphabetic character differs in the USA and in France.\par
\par
\pard\li720{}A character class is only valid in a regexp {\i inside} the brackets of a character list.  Character classes consist of {\f1{}[:}, a keyword denoting the class, and {\f1{}:]}.  Here are the character classes defined by the POSIX standard.\par
\par
{\pard\li720{}{\f1{}[:alnum:]}\par
\pard\li1440{}Alphanumeric characters.\par
\par
\pard\li720{}{\f1{}[:alpha:]}\par
\pard\li1440{}Alphabetic characters.\par
\par
\pard\li720{}{\f1{}[:blank:]}\par
\pard\li1440{}Space and tab characters.\par
\par
\pard\li720{}{\f1{}[:cntrl:]}\par
\pard\li1440{}Control characters.\par
\par
\pard\li720{}{\f1{}[:digit:]}\par
\pard\li1440{}Numeric characters.\par
\par
\pard\li720{}{\f1{}[:graph:]}\par
\pard\li1440{}Characters that are printable and are also visible.  (A space is printable, but not visible, while an {\f1{}a} is both.)\par
\par
\pard\li720{}{\f1{}[:lower:]}\par
\pard\li1440{}Lower-case alphabetic characters.\par
\par
\pard\li720{}{\f1{}[:print:]}\par
\pard\li1440{}Printable characters (characters that are not control characters.)\par
\par
\pard\li720{}{\f1{}[:punct:]}\par
\pard\li1440{}Punctuation characters (characters that are not letter, digits, control characters, or space characters).\par
\par
\pard\li720{}{\f1{}[:space:]}\par
\pard\li1440{}Space characters (such as space, tab, and formfeed, to name a few).\par
\par
\pard\li720{}{\f1{}[:upper:]}\par
\pard\li1440{}Upper-case alphabetic characters.\par
\par
\pard\li720{}{\f1{}[:xdigit:]}\par
\pard\li1440{}Characters that are hexadecimal digits.\par
\pard\li720{}}\par
\pard\li720{}For example, before the POSIX standard, to match alphanumeric characters, you had to write {\f1{}/[A-Za-z0-9]/}.  If your character set had other alphabetic characters in it, this would not match them.  With the POSIX character classes, you can write {\f1{}/[[:alnum:]]/}, and this will match {\i all} the alphabetic and numeric characters in your character set.\par
\par
\pard\li720{}{K{\footnote K collating elements}}Two additional special sequences can appear in character lists.  These apply to non-ASCII character sets, which can have single symbols (called \'A2collating elements\'A2) that are represented with more than one character, as well as several characters that are equivalent for \'A2collating\'A2, or sorting, purposes.  (E.g., in French, a plain "e" and a grave-accented "e`" are equivalent.)\par
\par
{\pard\li1440{}{K{\footnote K collating symbols}}\par
\par
\pard\li720{}Collating Symbols\par
\pard\li1440{}A \'A2collating symbol\'A2 is a multi-character collating element enclosed in {\f1{}[.} and {\f1{}.]}.  For example, if {\f1{}ch} is a collating element, then {\f1{}[[.ch.]]} is a regexp that matches this collating element, while {\f1{}[ch]} is a regexp that matches either {\f1{}c} or {\f1{}h}.\par
\par
\pard\li1440{}{K{\footnote K equivalence classes}}\par
\par
\pard\li720{}Equivalence Classes\par
\pard\li1440{}An \'A2equivalence class\'A2 is a locale-specific name for a list of characters that are equivalent. The name is enclosed in {\f1{}[=} and {\f1{}=]}.  For example, the name {\f1{}e} might be used to represent all of "e," "e`," and "e'." In this case, {\f1{}[[=e]]} is a regexp that matches any of {\f1{}e}, {\f1{}e'},  or {\f1{}e`}.\par
\pard\li720{}}\par
\pard\li720{}These features are very valuable in non-English speaking locales.\par
\par
{\b \pard\li720{}Caution:} The library functions that {\f1{}gawk} uses for regular expression matching currently only recognize POSIX character classes; they do not recognize collating symbols or equivalence classes.\par
\par
\pard\li720{}{K{\footnote K complemented character list}}{K{\footnote K character list, complemented}}\par
\par
\pard{}{\f1{}[^ ...]}\par
\pard\li720{}This is a \'A2complemented character list\'A2.  The first character after the {\f1{}[} {\i must} be a {\f1{}^}.  It matches any characters {\i except} those in the square brackets.  For example:\par
\par
{\pard\keep\li1440\f1{}[^0-9]\par
\pard\li720\f0{}}\par
\pard\li720{}matches any character that is not a digit.\par
\par
\pard{}{\f1{}|}\par
\pard\li720{}This is the \'A2alternation operator\'A2, and it is used to specify alternatives.  For example:\par
\par
{\pard\keep\li1440\f1{}^P|[0-9]\par
\pard\li720\f0{}}\par
\pard\li720{}matches any string that matches either {\f1{}^P} or {\f1{}[0-9]}.  This means it matches any string that starts with {\f1{}P} or contains a digit.\par
\par
\pard\li720{}The alternation applies to the largest possible regexps on either side.  In other words, {\f1{}|} has the lowest precedence of all the regular expression operators.\par
\par
\pard{}{\f1{}(...)}\par
\pard\li720{}Parentheses are used for grouping in regular expressions as in arithmetic.  They can be used to concatenate regular expressions containing the alternation operator, {\f1{}|}.  For example, {\f1{}@(samp|code)\'5C\'7B[^\'7D]+\'5C\'7D} matches both {\f1{}@code\'7Bfoo\'7D} and {\f1{}@samp\'7Bbar\'7D}. (These are Texinfo formatting control sequences.)\par
\par
\pard{}{\f1{}*}\par
\pard\li720{}This symbol means that the preceding regular expression is to be repeated as many times as necessary to find a match.  For example:\par
\par
{\pard\keep\li1440\f1{}ph*\par
\pard\li720\f0{}}\par
\pard\li720{}applies the {\f1{}*} symbol to the preceding {\f1{}h} and looks for matches of one {\f1{}p} followed by any number of {\f1{}h}s.  This will also match just {\f1{}p} if no {\f1{}h}s are present.\par
\par
\pard\li720{}The {\f1{}*} repeats the {\i smallest} possible preceding expression.  (Use parentheses if you wish to repeat a larger expression.)  It finds as many repetitions as possible.  For example:\par
\par
{\pard\keep\li1440\f1{}awk '/\'5C(c[ad][ad]*r x\'5C)/ \'7B print \'7D' sample\par
\pard\li720\f0{}}\par
\pard\li720{}prints every record in {\f1{}sample} containing a string of the form {\f1{}(car x)}, {\f1{}(cdr x)}, {\f1{}(cadr x)}, and so on.  Notice the escaping of the parentheses by preceding them with backslashes.\par
\par
\pard{}{\f1{}+}\par
\pard\li720{}This symbol is similar to {\f1{}*}, but the preceding expression must be matched at least once.  This means that:\par
\par
{\pard\keep\li1440\f1{}wh+y\par
\pard\li720\f0{}}\par
\pard\li720{}would match {\f1{}why} and {\f1{}whhy} but not {\f1{}wy}, whereas {\f1{}wh*y} would match all three of these strings.  This is a simpler way of writing the last {\f1{}*} example:\par
\par
{\pard\keep\li1440\f1{}awk '/\'5C(c[ad]+r x\'5C)/ \'7B print \'7D' sample\par
\pard\li720\f0{}}\par
\pard{}{\f1{}?}\par
\pard\li720{}This symbol is similar to {\f1{}*}, but the preceding expression can be matched either once or not at all.  For example:\par
\par
{\pard\keep\li1440\f1{}fe?d\par
\pard\li720\f0{}}\par
\pard\li720{}will match {\f1{}fed} and {\f1{}fd}, but nothing else.\par
\par
\pard\li720{}{K{\footnote K {\f1{}awk} language, POSIX version}}{K{\footnote K POSIX {\f1{}awk}}}{K{\footnote K interval expressions}}\par
\par
\pard{}{\f1{}\'7B{\i n}\'7D}\par
\pard{}{\f1{}\'7B{\i n},\'7D}\par
\pard{}{\f1{}\'7B{\i n},{\i m}\'7D}\par
\pard\li720{}One or two numbers inside braces denote an \'A2interval expression\'A2.  If there is one number in the braces, the preceding regexp is repeated {\i n} times.  If there are two numbers separated by a comma, the preceding regexp is repeated {\i n} to {\i m} times.  If there is one number followed by a comma, then the preceding regexp is repeated at least {\i n} times.\par
\par
{\pard\li720{}{\f1{}wh\'7B3\'7Dy}\par
\pard\li1440{}matches {\f1{}whhhy} but not {\f1{}why} or {\f1{}whhhhy}.\par
\par
\pard\li720{}{\f1{}wh\'7B3,5\'7Dy}\par
\pard\li1440{}matches {\f1{}whhhy} or {\f1{}whhhhy} or {\f1{}whhhhhy}, only.\par
\par
\pard\li720{}{\f1{}wh\'7B2,\'7Dy}\par
\pard\li1440{}matches {\f1{}whhy} or {\f1{}whhhy}, and so on.\par
\pard\li720{}}\par
\pard\li720{}Interval expressions were not traditionally available in {\f1{}awk}.  As part of the POSIX standard they were added, to make {\f1{}awk} and {\f1{}egrep} consistent with each other.\par
\par
\pard\li720{}However, since old programs may use {\f1{}\'7B} and {\f1{}\'7D} in regexp constants, by default {\f1{}gawk} does {\i not} match interval expressions in regexps.  If either {\f1{}--posix} or {\f1{}--re-interval} are specified (see {\uldb Command Line Options}{\v Options}), then interval expressions are allowed in regexps.\par
\pard{}}\par
\pard{}{K{\footnote K precedence, regexp operators}}{K{\footnote K regexp operators, precedence of}}In regular expressions, the {\f1{}*}, {\f1{}+}, and {\f1{}?} operators, as well as the braces {\f1{}\'7B} and {\f1{}\'7D}, have the highest precedence, followed by concatenation, and finally by {\f1{}|}.  As in arithmetic, parentheses can change how operators are grouped.\par
\par
\pard{}If {\f1{}gawk} is in compatibility mode (see {\uldb Command Line Options}{\v Options}), character classes and interval expressions are not available in regular expressions.\par
\par
\pard{}The next {node }discusses the GNU-specific regexp operators, and provides more detail concerning how command line options affect the way {\f1{}gawk} interprets the characters in regular expressions.\par
\par
\page\pard Node: {\b GNU Regexp Operators}, \keepn Next: {\uldb Case-sensitivity}{\v Case_sensitivity}, Prev: {\uldb Regexp Operators}{\v Regexp_Operators}, Up: {\uldb Regexp}{\v Regexp}\line
K{\footnote K GNU Regexp Operators}
#{\footnote GNU_Regexp_Operators}
${\footnote \pard{}Additional Regexp Operators Only in {\f1{}gawk}}\par
\pard{\fs24\b Additional Regexp Operators Only in {\f1{}gawk}}\par
\par
\pard{}{K{\footnote K regexp operators, GNU specific}}GNU software that deals with regular expressions provides a number of additional regexp operators.  These operators are described in this section, and are specific to {\f1{}gawk}; they are not available in other {\f1{}awk} implementations.\par
\par
\pard{}{K{\footnote K word, regexp definition of}}Most of the additional operators are for dealing with word matching.  For our purposes, a \'A2word\'A2 is a sequence of one or more letters, digits, or underscores ({\f1{}_}).\par
\par
{\pard\li720{}{K{\footnote K {\f1{}\'5Cw} regexp operator}}\par
\par
\pard{}{\f1{}\'5Cw}\par
\pard\li720{}This operator matches any word-constituent character, i.e. any letter, digit, or underscore. Think of it as a short-hand for {\f1{}[[:alnum:]_]}.\par
\par
\pard\li720{}{K{\footnote K {\f1{}\'5CW} regexp operator}}\par
\par
\pard{}{\f1{}\'5CW}\par
\pard\li720{}This operator matches any character that is not word-constituent.  Think of it as a short-hand for {\f1{}[^[:alnum:]_]}.\par
\par
\pard\li720{}{K{\footnote K {\f1{}\'5C<} regexp operator}}\par
\par
\pard{}{\f1{}\'5C<}\par
\pard\li720{}This operator matches the empty string at the beginning of a word.  For example, {\f1{}/\'5C<away/} matches {\f1{}away}, but not {\f1{}stowaway}.\par
\par
\pard\li720{}{K{\footnote K {\f1{}\'5C>} regexp operator}}\par
\par
\pard{}{\f1{}\'5C>}\par
\pard\li720{}This operator matches the empty string at the end of a word.  For example, {\f1{}/stow\'5C>/} matches {\f1{}stow}, but not {\f1{}stowaway}.\par
\par
\pard\li720{}{K{\footnote K {\f1{}\'5Cy} regexp operator}}{K{\footnote K word boundaries, matching}}\par
\par
\pard{}{\f1{}\'5Cy}\par
\pard\li720{}This operator matches the empty string at either the beginning or the end of a word (the word boundar{\b y}).  For example, {\f1{}\'5Cyballs?\'5Cy} matches either {\f1{}ball} or {\f1{}balls} as a separate word.\par
\par
\pard\li720{}{K{\footnote K {\f1{}\'5CB} regexp operator}}\par
\par
\pard{}{\f1{}\'5CB}\par
\pard\li720{}This operator matches the empty string within a word. In other words, {\f1{}\'5CB} matches the empty string that occurs between two word-constituent characters. For example, {\f1{}/\'5CBrat\'5CB/} matches {\f1{}crate}, but it does not match {\f1{}dirty rat}.  {\f1{}\'5CB} is essentially the opposite of {\f1{}\'5Cy}.\par
\pard{}}\par
\pard{}There are two other operators that work on buffers.  In Emacs, a \'A2buffer\'A2 is, naturally, an Emacs buffer.  For other programs, the regexp library routines that {\f1{}gawk} uses consider the entire string to be matched as the buffer.\par
\par
\pard{}For {\f1{}awk}, since {\f1{}^} and {\f1{}$} always work in terms of the beginning and end of strings, these operators don't add any new capabilities.  They are provided for compatibility with other GNU software.\par
\par
\pard{}{K{\footnote K buffer matching operators}}{\par
\pard\li720{}{K{\footnote K {\f1{}\'5C`} regexp operator}}\par
\par
\pard{}{\f1{}\'5C`}\par
\pard\li720{}This operator matches the empty string at the beginning of the buffer.\par
\par
\pard\li720{}{K{\footnote K {\f1{}\'5C'} regexp operator}}\par
\par
\pard{}{\f1{}\'5C'}\par
\pard\li720{}This operator matches the empty string at the end of the buffer.\par
\pard{}}\par
\pard{}In other GNU software, the word boundary operator is {\f1{}\'5Cb}. However, that conflicts with the {\f1{}awk} language's definition of {\f1{}\'5Cb} as backspace, so {\f1{}gawk} uses a different letter.\par
\par
\pard{}An alternative method would have been to require two backslashes in the GNU operators, but this was deemed to be too confusing, and the current method of using {\f1{}\'5Cy} for the GNU {\f1{}\'5Cb} appears to be the lesser of two evils.\par
\par
\pard{}{K{\footnote K regexp, effect of command line options}}The various command line options (see {\uldb Command Line Options}{\v Options}) control how {\f1{}gawk} interprets characters in regexps.\par
\par
{\pard{}No options\par
\pard\li720{}In the default case, {\f1{}gawk} provide all the facilities of POSIX regexps and the GNU regexp operators described {in {\uldb Regular Expression Operators}{\v Regexp_Operators}.  }However, interval expressions are not supported.\par
\par
\pard{}{\f1{}--posix}\par
\pard\li720{}Only POSIX regexps are supported, the GNU operators are not special (e.g., {\f1{}\'5Cw} matches a literal {\f1{}w}).  Interval expressions are allowed.\par
\par
\pard{}{\f1{}--traditional}\par
\pard\li720{}Traditional Unix {\f1{}awk} regexps are matched. The GNU operators are not special, interval expressions are not available, and neither are the POSIX character classes ({\f1{}[[:alnum:]]} and so on).  Characters described by octal and hexadecimal escape sequences are treated literally, even if they represent regexp metacharacters.\par
\par
\pard{}{\f1{}--re-interval}\par
\pard\li720{}Allow interval expressions in regexps, even if {\f1{}--traditional} has been provided.\par
\pard{}}\par
\page\pard Node: {\b Case-sensitivity}, \keepn Next: {\uldb Leftmost Longest}{\v Leftmost_Longest}, Prev: {\uldb GNU Regexp Operators}{\v GNU_Regexp_Operators}, Up: {\uldb Regexp}{\v Regexp}\line
K{\footnote K Case-sensitivity}
#{\footnote Case_sensitivity}
${\footnote \pard{}Case-sensitivity in Matching}\par
\pard{\fs24\b Case-sensitivity in Matching}\par
\par
\pard{}{K{\footnote K case sensitivity}}{K{\footnote K ignoring case}}Case is normally significant in regular expressions, both when matching ordinary characters (i.e. not metacharacters), and inside character sets.  Thus a {\f1{}w} in a regular expression matches only a lower-case {\f1{}w} and not an upper-case {\f1{}W}.\par
\par
\pard{}The simplest way to do a case-independent match is to use a character list: {\f1{}[Ww]}.  However, this can be cumbersome if you need to use it often; and it can make the regular expressions harder to read.  There are two alternatives that you might prefer.\par
\par
\pard{}One way to do a case-insensitive match at a particular point in the program is to convert the data to a single case, using the {\f1{}tolower} or {\f1{}toupper} built-in string functions (which we haven't discussed yet; see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}).  For example:\par
\par
{\pard\keep\li720\f1{}tolower($1) ~ /foo/  \'7B ... \'7D\par
\pard\f0{}}\par
\pard{}converts the first field to lower-case before matching against it.  This will work in any POSIX-compliant implementation of {\f1{}awk}.\par
\par
\pard{}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}{K{\footnote K {\f1{}~} operator}}{K{\footnote K {\f1{}!~} operator}}{K{\footnote K IGNORECASE}}Another method, specific to {\f1{}gawk}, is to set the variable {\f1{}IGNORECASE} to a non-zero value (see {\uldb Built-in Variables}{\v Built_in_Variables}).  When {\f1{}IGNORECASE} is not zero, {\i all} regexp and string operations ignore case.  Changing the value of {\f1{}IGNORECASE} dynamically controls the case sensitivity of your program as it runs.  Case is significant by default because {\f1{}IGNORECASE} (like most variables) is initialized to zero.\par
\par
{{\pard\keep\li720\f1{}x = "aB"\line
if (x ~ /ab/) ...   # this test will fail\par
\pard\keep\li720{}}\line
{IGNORECASE = 1\line
if (x ~ /ab/) ...   # now it will succeed\par
\pard\keep\li720{}}}\par
\pard\f0{}In general, you cannot use {\f1{}IGNORECASE} to make certain rules case-insensitive and other rules case-sensitive, because there is no way to set {\f1{}IGNORECASE} just for the pattern of a particular rule.  To do this, you must use character lists or {\f1{}tolower}.  However, one thing you can do only with {\f1{}IGNORECASE} is turn case-sensitivity on or off dynamically for all the rules at once.\par
\par
{\f1{}\pard{}IGNORECASE} can be set on the command line, or in a {\f1{}BEGIN} rule (see {\uldb Other Command Line Arguments}{\v Other_Arguments}; also see {\uldb Startup and Cleanup Actions}{\v Using_BEGIN_END}).  Setting {\f1{}IGNORECASE} from the command line is a way to make a program case-insensitive without having to edit it.\par
\par
\pard{}Prior to version 3.0 of {\f1{}gawk}, the value of {\f1{}IGNORECASE} only affected regexp operations. It did not affect string comparison with {\f1{}==}, {\f1{}!=}, and so on.  Beginning with version 3.0, both regexp and string comparison operations are affected by {\f1{}IGNORECASE}.\par
\par
\pard{}{K{\footnote K ISO 8859-1}}{K{\footnote K ISO Latin-1}}Beginning with version 3.0 of {\f1{}gawk}, the equivalences between upper-case and lower-case characters are based on the ISO-8859-1 (ISO Latin-1) character set. This character set is a superset of the traditional 128 ASCII characters, that also provides a number of characters suitable for use with European languages.\par
\par
\pard{}The value of {\f1{}IGNORECASE} has no effect if {\f1{}gawk} is in compatibility mode (see {\uldb Command Line Options}{\v Options}).  Case is always significant in compatibility mode.\par
\par
\page\pard Node: {\b Leftmost Longest}, \keepn Next: {\uldb Computed Regexps}{\v Computed_Regexps}, Prev: {\uldb Case-sensitivity}{\v Case_sensitivity}, Up: {\uldb Regexp}{\v Regexp}\line
K{\footnote K Leftmost Longest}
#{\footnote Leftmost_Longest}
${\footnote \pard{}How Much Text Matches?}\par
\pard{\fs24\b How Much Text Matches?}\par
\par
\pard{}{K{\footnote K leftmost longest match}}{K{\footnote K matching, leftmost longest}}Consider the following example:\par
\par
{\pard\keep\li720\f1{}echo aaaabcd | awk '\'7B sub(/a+/, "<A>"); print \'7D'\par
\pard\f0{}}\par
\pard{}This example uses the {\f1{}sub} function (which we haven't discussed yet, see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}) to make a change to the input record. Here, the regexp {\f1{}/a+/} indicates "one or more {\f1{}a} characters," and the replacement text is {\f1{}<A>}.\par
\par
\pard{}The input contains four {\f1{}a} characters.  What will the output be?  In other words, how many is "one or more"--will {\f1{}awk} match two, three, or all four {\f1{}a} characters?\par
\par
\pard{}The answer is, {\f1{}awk} (and POSIX) regular expressions always match the leftmost, {\i longest} sequence of input characters that can match.  Thus, in this example, all four {\f1{}a} characters are replaced with {\f1{}<A>}.\par
\par
{\pard\keep\li720\f1{}$ echo aaaabcd | awk '\'7B sub(/a+/, "<A>"); print \'7D'\line
-| <A>bcd\par
\pard\f0{}}\par
\pard{}For simple match/no-match tests, this is not so important. But when doing regexp-based field and record splitting, and text matching and substitutions with the {\f1{}match}, {\f1{}sub}, {\f1{}gsub}, and {\f1{}gensub} functions, it is very important.  {See {\uldb Built-in Functions for String Manipulation}{\v String_Functions}, for more information on these functions.  }Understanding this principle is also important for regexp-based record and field splitting (see {\uldb How Input is Split into Records}{\v Records}, and also see {\uldb Specifying How Fields are Separated}{\v Field_Separators}).\par
\par
\page\pard Node: {\b Computed Regexps}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Leftmost Longest}{\v Leftmost_Longest}, Up: {\uldb Regexp}{\v Regexp}\line
K{\footnote K Computed Regexps}
#{\footnote Computed_Regexps}
${\footnote \pard{}Using Dynamic Regexps}\par
\pard{\fs24\b Using Dynamic Regexps}\par
\par
\pard{}{K{\footnote K computed regular expressions}}{K{\footnote K regular expressions, computed}}{K{\footnote K dynamic regular expressions}}{K{\footnote K regexp, dynamic}}{K{\footnote K {\f1{}~} operator}}{K{\footnote K {\f1{}!~} operator}}The right hand side of a {\f1{}~} or {\f1{}!~} operator need not be a regexp constant (i.e. a string of characters between slashes).  It may be any expression.  The expression is evaluated, and converted if necessary to a string; the contents of the string are used as the regexp.  A regexp that is computed in this way is called a \'A2dynamic regexp\'A2.  For example:\par
\par
{\pard\keep\li720\f1{}BEGIN \'7B identifier_regexp = "[A-Za-z_][A-Za-z_0-9]+" \'7D\line
$0 ~ identifier_regexp    \'7B print \'7D\par
\pard\f0{}}\par
\pard{}sets {\f1{}identifier_regexp} to a regexp that describes {\f1{}awk} variable names, and tests if the input record matches this regexp.\par
\par
{\b \pard{}Caution:} When using the {\f1{}~} and {\f1{}!~} operators, there is a difference between a regexp constant enclosed in slashes, and a string constant enclosed in double quotes.  If you are going to use a string constant, you have to understand that the string is in essence scanned {\i twice}; the first time when {\f1{}awk} reads your program, and the second time when it goes to match the string on the left-hand side of the operator with the pattern on the right.  This is true of any string valued expression (such as {\f1{}identifier_regexp} above), not just string constants.\par
\par
\pard{}{K{\footnote K regexp constants, difference between slashes and quotes}}What difference does it make if the string is scanned twice? The answer has to do with escape sequences, and particularly with backslashes.  To get a backslash into a regular expression inside a string, you have to type two backslashes.\par
\par
\pard{}For example, {\f1{}/\'5C*/} is a regexp constant for a literal {\f1{}*}.  Only one backslash is needed.  To do the same thing with a string, you would have to type {\f1{}"\'5C\'5C*"}.  The first backslash escapes the second one, so that the string actually contains the two characters {\f1{}\'5C} and {\f1{}*}.\par
\par
\pard{}{K{\footnote K common mistakes}}{K{\footnote K mistakes, common}}{K{\footnote K errors, common}}Given that you can use both regexp and string constants to describe regular expressions, which should you use?  The answer is "regexp constants," for several reasons.\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}1. \tab{}String constants are more complicated to write, and more difficult to read. Using regexp constants makes your programs less error-prone.  Not understanding the difference between the two kinds of constants is a common source of errors.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}2. \tab{}It is also more efficient to use regexp constants: {\f1{}awk} can note that you have supplied a regexp and store it internally in a form that makes pattern matching more efficient.  When using a string constant, {\f1{}awk} must first convert the string into this internal form, and then perform the pattern matching.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}3. \tab{}Using regexp constants is better style; it shows clearly that you intend a regexp match.\par
\pard{}}\par
\page\pard Node: {\b Reading Files}, \keepn Next: {\uldb Printing}{\v Printing}, Prev: {\uldb Regexp}{\v Regexp}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Reading Files}
#{\footnote Reading_Files}
${\footnote \pard{}Reading Input Files}\par
\pard{\fs24\b Reading Input Files}\par
\par
\pard{}{K{\footnote K reading files}}{K{\footnote K input}}{K{\footnote K standard input}}{K{\footnote K FILENAME}}In the typical {\f1{}awk} program, all input is read either from the standard input (by default the keyboard, but often a pipe from another command) or from files whose names you specify on the {\f1{}awk} command line.  If you specify input files, {\f1{}awk} reads them in order, reading all the data from one before going on to the next.  The name of the current input file can be found in the built-in variable {\f1{}FILENAME} (see {\uldb Built-in Variables}{\v Built_in_Variables}).\par
\par
\pard{}The input is read in units called \'A2records\'A2, and processed by the rules of your program one record at a time.  By default, each record is one line.  Each record is automatically split into chunks called \'A2fields\'A2.  This makes it more convenient for programs to work on the parts of a record.\par
\par
\pard{}On rare occasions you will need to use the {\f1{}getline} command.  The  {\f1{}getline} command is valuable, both because it can do explicit input from any number of files, and because the files used with it do not have to be named on the {\f1{}awk} command line (see {\uldb Explicit Input with {\f1{}getline}}{\v Getline}).\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Records}{\v Records}\tab Controlling how data is split into records.\par
{\uldb Fields}{\v Fields}\tab An introduction to fields.\par
{\uldb Non-Constant Fields}{\v Non_Constant_Fields}\tab Non-constant Field Numbers.\par
{\uldb Changing Fields}{\v Changing_Fields}\tab Changing the Contents of a Field.\par
{\uldb Field Separators}{\v Field_Separators}\tab The field separator and how to change it.\par
{\uldb Constant Size}{\v Constant_Size}\tab Reading constant width data.\par
{\uldb Multiple Line}{\v Multiple_Line}\tab Reading multi-line records.\par
{\uldb Getline}{\v Getline}\tab Reading files under explicit program control using the {\f1{}getline} function.\par
\pard{}}\par
\page\pard Node: {\b Records}, \keepn Next: {\uldb Fields}{\v Fields}, Prev: {\uldb Reading Files}{\v Reading_Files}, Up: {\uldb Reading Files}{\v Reading_Files}\line
K{\footnote K Records}
#{\footnote Records}
${\footnote \pard{}How Input is Split into Records}\par
\pard{\fs24\b How Input is Split into Records}\par
\par
\pard{}{K{\footnote K record separator, {\f1{}RS}}}{K{\footnote K changing the record separator}}{K{\footnote K record, definition of}}{K{\footnote K RS}}The {\f1{}awk} utility divides the input for your {\f1{}awk} program into records and fields.  Records are separated by a character called the \'A2record separator\'A2.  By default, the record separator is the newline character.  This is why records are, by default, single lines.  You can use a different character for the record separator by assigning the character to the built-in variable {\f1{}RS}.\par
\par
\pard{}You can change the value of {\f1{}RS} in the {\f1{}awk} program, like any other variable, with the assignment operator, {\f1{}=} (see {\uldb Assignment Expressions}{\v Assignment_Ops}).  The new record-separator character should be enclosed in quotation marks, which indicate a string constant.  Often the right time to do this is at the beginning of execution, before any input has been processed, so that the very first record will be read with the proper separator.  To do this, use the special {\f1{}BEGIN} pattern (see {\uldb The {\f1{}BEGIN} and {\f1{}END} Special Patterns}{\v BEGIN_END}).  For example:\par
\par
{\pard\keep\li720\f1{}awk 'BEGIN \'7B RS = "/" \'7D ; \'7B print $0 \'7D' BBS-list\par
\pard\f0{}}\par
\pard{}changes the value of {\f1{}RS} to {\f1{}"/"}, before reading any input.  This is a string whose first character is a slash; as a result, records are separated by slashes.  Then the input file is read, and the second rule in the {\f1{}awk} program (the action with no pattern) prints each record.  Since each {\f1{}print} statement adds a newline at the end of its output, the effect of this {\f1{}awk} program is to copy the input with each slash changed to a newline.  Here are the results of running the program on {\f1{}BBS-list}:\par
\par
{{\pard\keep\li720\f1{}$ awk 'BEGIN \'7B RS = "/" \'7D ; \'7B print $0 \'7D' BBS-list\line
-| aardvark     555-5553     1200\line
-| 300          B\line
-| alpo-net     555-3412     2400\line
-| 1200\line
-| 300     A\line
-| barfly       555-7685     1200\line
-| 300          A\line
-| bites        555-1675     2400\line
-| 1200\line
-| 300     A\line
-| camelot      555-0542     300               C\line
-| core         555-2912     1200\line
-| 300          C\line
-| fooey        555-1234     2400\line
-| 1200\line
-| 300     B\line
-| foot         555-6699     1200\line
-| 300          B\line
-| macfoo       555-6480     1200\line
-| 300          A\line
-| sdace        555-3430     2400\line
-| 1200\line
-| 300     A\line
-| sabafoo      555-2127     1200\line
-| 300          C\line
-|\par
\pard\keep\li720{}}}\par
\pard\f0{}Note that the entry for the {\f1{}camelot} BBS is not split.  In the original data file (see {\uldb Data Files for the Examples}{\v Sample_Data_Files}), the line looks like this:\par
\par
{\pard\keep\li720\f1{}camelot      555-0542     300               C\par
\pard\f0{}}\par
\pard{}It only has one baud rate; there are no slashes in the record.\par
\par
\pard{}Another way to change the record separator is on the command line, using the variable-assignment feature (see {\uldb Other Command Line Arguments}{\v Other_Arguments}).\par
\par
{\pard\keep\li720\f1{}awk '\'7B print $0 \'7D' RS="/" BBS-list\par
\pard\f0{}}\par
\pard{}This sets {\f1{}RS} to {\f1{}/} before processing {\f1{}BBS-list}.\par
\par
\pard{}Using an unusual character such as {\f1{}/} for the record separator produces correct behavior in the vast majority of cases.  However, the following (extreme) pipeline prints a surprising {\f1{}1}.  There is one field, consisting of a newline.  The value of the built-in variable {\f1{}NF} is the number of fields in the current record.\par
\par
{\pard\keep\li720\f1{}$ echo | awk 'BEGIN \'7B RS = "a" \'7D ; \'7B print NF \'7D'\line
-| 1\par
\pard\f0{}}\par
\pard{}{K{\footnote K dark corner}} Reaching the end of an input file terminates the current input record, even if the last character in the file is not the character in {\f1{}RS} (d.c.).\par
\par
\pard{}{K{\footnote K empty string}}The empty string, {\f1{}""} (a string of no characters), has a special meaning as the value of {\f1{}RS}: it means that records are separated by one or more blank lines, and nothing else.  See {\uldb Multiple-Line Records}{\v Multiple_Line}, for more details.\par
\par
\pard{}If you change the value of {\f1{}RS} in the middle of an {\f1{}awk} run, the new value is used to delimit subsequent records, but the record currently being processed (and records already processed) are not affected.\par
\par
\pard{}{K{\footnote K RT}}{K{\footnote K record terminator, {\f1{}RT}}}{K{\footnote K terminator, record}}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}After the end of the record has been determined, {\f1{}gawk} sets the variable {\f1{}RT} to the text in the input that matched {\f1{}RS}.\par
\par
\pard{}{K{\footnote K regular expressions as record separators}}The value of {\f1{}RS} is in fact not limited to a one-character string.  It can be any regular expression (see {\uldb Regular Expressions}{\v Regexp}).  In general, each record ends at the next string that matches the regular expression; the next record starts at the end of the matching string.  This general rule is actually at work in the usual case, where {\f1{}RS} contains just a newline: a record ends at the beginning of the next matching string (the next newline in the input) and the following record starts just after the end of this string (at the first character of the following line).  The newline, since it matches {\f1{}RS}, is not part of either record.\par
\par
\pard{}When {\f1{}RS} is a single character, {\f1{}RT} will contain the same single character. However, when {\f1{}RS} is a regular expression, then {\f1{}RT} becomes more useful; it contains the actual input text that matched the regular expression.\par
\par
\pard{}The following example illustrates both of these features.  It sets {\f1{}RS} equal to a regular expression that matches either a newline, or a series of one or more upper-case letters with optional leading and/or trailing white space (see {\uldb Regular Expressions}{\v Regexp}).\par
\par
{\pard\keep\li720\f1{}$ echo record 1 AAAA record 2 BBBB record 3 |\line
> gawk 'BEGIN \'7B RS = "\'5Cn|( *[[:upper:]]+ *)" \'7D\line
>             \'7B print "Record =", $0, "and RT =", RT \'7D'\line
-| Record = record 1 and RT =  AAAA\line
-| Record = record 2 and RT =  BBBB\line
-| Record = record 3 and RT =\line
-|\par
\pard\f0{}}\par
\pard{}The final line of output has an extra blank line. This is because the value of {\f1{}RT} is a newline, and then the {\f1{}print} statement supplies its own terminating newline.\par
\par
\pard{}See {\uldb A Simple Stream Editor}{\v Simple_Sed}, for a more useful example of {\f1{}RS} as a regexp and {\f1{}RT}.\par
\par
\pard{}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}The use of {\f1{}RS} as a regular expression and the {\f1{}RT} variable are {\f1{}gawk} extensions; they are not available in compatibility mode (see {\uldb Command Line Options}{\v Options}).  In compatibility mode, only the first character of the value of {\f1{}RS} is used to determine the end of the record.\par
\par
\pard{}{K{\footnote K number of records, {\f1{}NR}, {\f1{}FNR}}}{K{\footnote K NR}}{K{\footnote K FNR}}The {\f1{}awk} utility keeps track of the number of records that have been read so far from the current input file.  This value is stored in a built-in variable called {\f1{}FNR}.  It is reset to zero when a new file is started.  Another built-in variable, {\f1{}NR}, is the total number of input records read so far from all data files.  It starts at zero but is never automatically reset to zero.\par
\par
\page\pard Node: {\b Fields}, \keepn Next: {\uldb Non-Constant Fields}{\v Non_Constant_Fields}, Prev: {\uldb Records}{\v Records}, Up: {\uldb Reading Files}{\v Reading_Files}\line
K{\footnote K Fields}
#{\footnote Fields}
${\footnote \pard{}Examining Fields}\par
\pard{\fs24\b Examining Fields}\par
\par
\pard{}{K{\footnote K examining fields}}{K{\footnote K fields}}{K{\footnote K accessing fields}}When {\f1{}awk} reads an input record, the record is automatically separated or \'A2parsed\'A2 by the interpreter into chunks called \'A2fields\'A2.  By default, fields are separated by whitespace, like words in a line.  Whitespace in {\f1{}awk} means any string of one or more spaces, tabs or newlines;({\ul 1}{\v Fields_1}) other characters such as formfeed, and so on, that are considered whitespace by other languages are {\i not} considered whitespace by {\f1{}awk}.\par
\par
\pard{}The purpose of fields is to make it more convenient for you to refer to these pieces of the record.  You don't have to use them--you can operate on the whole record if you wish--but fields are what make simple {\f1{}awk} programs so powerful.\par
\par
\pard{}{K{\footnote K {\f1{}$} (field operator)}}{K{\footnote K field operator {\f1{}$}}}To refer to a field in an {\f1{}awk} program, you use a dollar-sign, {\f1{}$}, followed by the number of the field you want.  Thus, {\f1{}$1} refers to the first field, {\f1{}$2} to the second, and so on.  For example, suppose the following is a line of input:\par
\par
{\pard\keep\li720\f1{}This seems like a pretty nice example.\par
\pard\f0{}}\par
\pard{}Here the first field, or {\f1{}$1}, is {\f1{}This}; the second field, or {\f1{}$2}, is {\f1{}seems}; and so on.  Note that the last field, {\f1{}$7}, is {\f1{}example.}.  Because there is no space between the {\f1{}e} and the {\f1{}.}, the period is considered part of the seventh field.\par
\par
\pard{}{K{\footnote K NF}}{K{\footnote K number of fields, {\f1{}NF}}}{\f1{}NF} is a built-in variable whose value is the number of fields in the current record.  {\f1{}awk} updates the value of {\f1{}NF} automatically, each time a record is read.\par
\par
\pard{}No matter how many fields there are, the last field in a record can be represented by {\f1{}$NF}.  So, in the example above, {\f1{}$NF} would be the same as {\f1{}$7}, which is {\f1{}example.}.  Why this works is explained below (see {\uldb Non-constant Field Numbers}{\v Non_Constant_Fields}).  If you try to reference a field beyond the last one, such as {\f1{}$8} when the record has only seven fields, you get the empty string.\par
\par
{\f1{}\pard{}$0}, which looks like a reference to the "zeroth" field, is a special case: it represents the whole input record.  {\f1{}$0} is used when you are not interested in fields.\par
\par
\pard{}Here are some more examples:\par
\par
{{\pard\keep\li720\f1{}$ awk '$1 ~ /foo/ \'7B print $0 \'7D' BBS-list\line
-| fooey        555-1234     2400/1200/300     B\line
-| foot         555-6699     1200/300          B\line
-| macfoo       555-6480     1200/300          A\line
-| sabafoo      555-2127     1200/300          C\par
\pard\keep\li720{}}}\par
\pard\f0{}This example prints each record in the file {\f1{}BBS-list} whose first field contains the string {\f1{}foo}.  The operator {\f1{}~} is called a \'A2matching operator\'A2 (see {\uldb How to Use Regular Expressions}{\v Regexp_Usage}); it tests whether a string (here, the field {\f1{}$1}) matches a given regular expression.\par
\par
\pard{}By contrast, the following example looks for {\f1{}foo} in {\i the entire record} and prints the first field and the last field for each input record containing a match.\par
\par
{{\pard\keep\li720\f1{}$ awk '/foo/ \'7B print $1, $NF \'7D' BBS-list\line
-| fooey B\line
-| foot B\line
-| macfoo A\line
-| sabafoo C\par
\pard\keep\li720{}}}\par
\page\pard#{\footnote Fields_1}
\pard\f0{}(1) In POSIX {\f1{}awk}, newlines are not considered whitespace for separating fields.\par
\par
\page\pard Node: {\b Non-Constant Fields}, \keepn Next: {\uldb Changing Fields}{\v Changing_Fields}, Prev: {\uldb Fields}{\v Fields}, Up: {\uldb Reading Files}{\v Reading_Files}\line
K{\footnote K Non-Constant Fields}
#{\footnote Non_Constant_Fields}
${\footnote \pard{}Non-constant Field Numbers}\par
\pard{\fs24\b Non-constant Field Numbers}\par
\par
\pard{}The number of a field does not need to be a constant.  Any expression in the {\f1{}awk} language can be used after a {\f1{}$} to refer to a field.  The value of the expression specifies the field number.  If the value is a string, rather than a number, it is converted to a number.  Consider this example:\par
\par
{\pard\keep\li720\f1{}awk '\'7B print $NR \'7D'\par
\pard\f0{}}\par
\pard{}Recall that {\f1{}NR} is the number of records read so far: one in the first record, two in the second, etc.  So this example prints the first field of the first record, the second field of the second record, and so on.  For the twentieth record, field number 20 is printed; most likely, the record has fewer than 20 fields, so this prints a blank line.\par
\par
\pard{}Here is another example of using expressions as field numbers:\par
\par
{\pard\keep\li720\f1{}awk '\'7B print $(2*2) \'7D' BBS-list\par
\pard\f0{}}\par
{\f1{}\pard{}awk} must evaluate the expression {\f1{}(2*2)} and use its value as the number of the field to print.  The {\f1{}*} sign represents multiplication, so the expression {\f1{}2*2} evaluates to four.  The parentheses are used so that the multiplication is done before the {\f1{}$} operation; they are necessary whenever there is a binary operator in the field-number expression.  This example, then, prints the hours of operation (the fourth field) for every line of the file {\f1{}BBS-list}.  (All of the {\f1{}awk} operators are listed, in order of decreasing precedence, in {\uldb Operator Precedence (How Operators Nest)}{\v Precedence}.)\par
\par
\pard{}If the field number you compute is zero, you get the entire record.  Thus, {\f1{}$(2-2)} has the same value as {\f1{}$0}.  Negative field numbers are not allowed; trying to reference one will usually terminate your running {\f1{}awk} program.  (The POSIX standard does not define what happens when you reference a negative field number.  {\f1{}gawk} will notice this and terminate your program.  Other {\f1{}awk} implementations may behave differently.)\par
\par
\pard{}As mentioned in {\uldb Examining Fields}{\v Fields}, the number of fields in the current record is stored in the built-in variable {\f1{}NF} (also see {\uldb Built-in Variables}{\v Built_in_Variables}).  The expression {\f1{}$NF} is not a special feature: it is the direct consequence of evaluating {\f1{}NF} and using its value as a field number.\par
\par
\page\pard Node: {\b Changing Fields}, \keepn Next: {\uldb Field Separators}{\v Field_Separators}, Prev: {\uldb Non-Constant Fields}{\v Non_Constant_Fields}, Up: {\uldb Reading Files}{\v Reading_Files}\line
K{\footnote K Changing Fields}
#{\footnote Changing_Fields}
${\footnote \pard{}Changing the Contents of a Field}\par
\pard{\fs24\b Changing the Contents of a Field}\par
\par
\pard{}{K{\footnote K field, changing contents of}}{K{\footnote K changing contents of a field}}{K{\footnote K assignment to fields}}You can change the contents of a field as seen by {\f1{}awk} within an {\f1{}awk} program; this changes what {\f1{}awk} perceives as the current input record.  (The actual input is untouched; {\f1{}awk} {\i never} modifies the input file.)\par
\par
\pard{}Consider this example and its output:\par
\par
{{\pard\keep\li720\f1{}$ awk '\'7B $3 = $2 - 10; print $2, $3 \'7D' inventory-shipped\line
-| 13 3\line
-| 15 5\line
-| 15 5\line
...\par
\pard\keep\li720{}}}\par
\pard\f0{}The {\f1{}-} sign represents subtraction, so this program reassigns field three, {\f1{}$3}, to be the value of field two minus ten, {\f1{}$2 - 10}.  (See {\uldb Arithmetic Operators}{\v Arithmetic_Ops}.)  Then field two, and the new value for field three, are printed.\par
\par
\pard{}In order for this to work, the text in field {\f1{}$2} must make sense as a number; the string of characters must be converted to a number in order for the computer to do arithmetic on it.  The number resulting from the subtraction is converted back to a string of characters which then becomes field three.  See {\uldb Conversion of Strings and Numbers}{\v Conversion}.\par
\par
\pard{}When you change the value of a field (as perceived by {\f1{}awk}), the text of the input record is recalculated to contain the new field where the old one was.  Therefore, {\f1{}$0} changes to reflect the altered field.  Thus, this program prints a copy of the input file, with 10 subtracted from the second field of each line.\par
\par
{{\pard\keep\li720\f1{}$ awk '\'7B $2 = $2 - 10; print $0 \'7D' inventory-shipped\line
-| Jan 3 25 15 115\line
-| Feb 5 32 24 226\line
-| Mar 5 24 34 228\line
...\par
\pard\keep\li720{}}}\par
\pard\f0{}You can also assign contents to fields that are out of range.  For example:\par
\par
{\pard\keep\li720\f1{}$ awk '\'7B $6 = ($5 + $4 + $3 + $2)\line
>        print $6 \'7D' inventory-shipped\line
-| 168\line
-| 297\line
-| 301\line
...\par
\pard\f0{}}\par
\pard{}We've just created {\f1{}$6}, whose value is the sum of fields {\f1{}$2}, {\f1{}$3}, {\f1{}$4}, and {\f1{}$5}.  The {\f1{}+} sign represents addition.  For the file {\f1{}inventory-shipped}, {\f1{}$6} represents the total number of parcels shipped for a particular month.\par
\par
\pard{}Creating a new field changes {\f1{}awk}'s internal copy of the current input record--the value of {\f1{}$0}.  Thus, if you do {\f1{}print $0} after adding a field, the record printed includes the new field, with the appropriate number of field separators between it and the previously existing fields.\par
\par
\pard{}This recomputation affects and is affected by {\f1{}NF} (the number of fields; see {\uldb Examining Fields}{\v Fields}), and by a feature that has not been discussed yet, the \'A2output field separator\'A2, {\f1{}OFS}, which is used to separate the fields (see {\uldb Output Separators}{\v Output_Separators}).  For example, the value of {\f1{}NF} is set to the number of the highest field you create.\par
\par
\pard{}Note, however, that merely {\i referencing} an out-of-range field does {\i not} change the value of either {\f1{}$0} or {\f1{}NF}.  Referencing an out-of-range field only produces an empty string.  For example:\par
\par
{\pard\keep\li720\f1{}if ($(NF+1) != "")\line
    print "can't happen"\line
else\line
    print "everything is normal"\par
\pard\f0{}}\par
\pard{}should print {\f1{}everything is normal}, because {\f1{}NF+1} is certain to be out of range.  (See {\uldb The {\f1{}if}-{\f1{}else} Statement}{\v If_Statement}, for more information about {\f1{}awk}'s {\f1{}if-else} statements.  See {\uldb Variable Typing and Comparison Expressions}{\v Typing_and_Comparison}, for more information about the {\f1{}!=} operator.)\par
\par
\pard{}It is important to note that making an assignment to an existing field will change the value of {\f1{}$0}, but will not change the value of {\f1{}NF}, even when you assign the empty string to a field.  For example:\par
\par
{{\pard\keep\li720\f1{}$ echo a b c d | awk '\'7B OFS = ":"; $2 = ""\line
>                       print $0; print NF \'7D'\line
-| a::c:d\line
-| 4\par
\pard\keep\li720{}}}\par
\pard\f0{}The field is still there; it just has an empty value.  You can tell because there are two colons in a row.\par
\par
\pard{}This example shows what happens if you create a new field.\par
\par
{\pard\keep\li720\f1{}$ echo a b c d | awk '\'7B OFS = ":"; $2 = ""; $6 = "new"\line
>                       print $0; print NF \'7D'\line
-| a::c:d::new\line
-| 6\par
\pard\f0{}}\par
\pard{}The intervening field, {\f1{}$5} is created with an empty value (indicated by the second pair of adjacent colons), and {\f1{}NF} is updated with the value six.\par
\par
\pard{}Finally, decrementing {\f1{}NF} will lose the values of the fields after the new value of {\f1{}NF}, and {\f1{}$0} will be recomputed.  Here is an example:\par
\par
{\pard\keep\li720\f1{}$ echo a b c d e f | ../gawk '\'7B print "NF =", NF;\line
>                               NF = 3; print $0 \'7D'\line
-| NF = 6\line
-| a b c\par
\pard\f0{}}\par
\page\pard Node: {\b Field Separators}, \keepn Next: {\uldb Constant Size}{\v Constant_Size}, Prev: {\uldb Changing Fields}{\v Changing_Fields}, Up: {\uldb Reading Files}{\v Reading_Files}\line
K{\footnote K Field Separators}
#{\footnote Field_Separators}
${\footnote \pard{}Specifying How Fields are Separated}\par
\pard{\fs24\b Specifying How Fields are Separated}\par
\par
\pard{}This section is rather long; it describes one of the most fundamental operations in {\f1{}awk}.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Basic Field Splitting}{\v Basic_Field_Splitting}\tab How fields are split with single characters or simple strings.\par
{\uldb Regexp Field Splitting}{\v Regexp_Field_Splitting}\tab Using regexps as the field separator.\par
{\uldb Single Character Fields}{\v Single_Character_Fields}\tab Making each character a separate field.\par
{\uldb Command Line Field Separator}{\v Command_Line_Field_Separator}\tab Setting {\f1{}FS} from the command line.\par
{\uldb Field Splitting Summary}{\v Field_Splitting_Summary}\tab Some final points and a summary table.\par
\pard{}}\par
\page\pard Node: {\b Basic Field Splitting}, \keepn Next: {\uldb Regexp Field Splitting}{\v Regexp_Field_Splitting}, Prev: {\uldb Field Separators}{\v Field_Separators}, Up: {\uldb Field Separators}{\v Field_Separators}\line
K{\footnote K Basic Field Splitting}
#{\footnote Basic_Field_Splitting}
${\footnote \pard{}The Basics of Field Separating}\par
\pard{\fs24\b The Basics of Field Separating}\par
\par
\pard{}{K{\footnote K FS}}{K{\footnote K fields, separating}}{K{\footnote K field separator, {\f1{}FS}}} The \'A2field separator\'A2, which is either a single character or a regular expression, controls the way {\f1{}awk} splits an input record into fields.  {\f1{}awk} scans the input record for character sequences that match the separator; the fields themselves are the text between the matches.\par
\par
\pard{}In the examples below, we use the bullet symbol "{\f2\'B7}" to represent spaces in the output.\par
\par
\pard{}If the field separator is {\f1{}oo}, then the following line:\par
\par
{\pard\keep\li720\f1{}moo goo gai pan\par
\pard\f0{}}\par
\pard{}would be split into three fields: {\f1{}m}, {\f1{}{\f2\'B7}g} and {\f1{}{\f2\'B7}gai{\f2\'B7}pan}.  Note the leading spaces in the values of the second and third fields.\par
\par
\pard{}{K{\footnote K common mistakes}}{K{\footnote K mistakes, common}}{K{\footnote K errors, common}}The field separator is represented by the built-in variable {\f1{}FS}.  Shell programmers take note!  {\f1{}awk} does {\i not} use the name {\f1{}IFS} which is used by the POSIX compatible shells (such as the Bourne shell, {\f1{}sh}, or the GNU Bourne-Again Shell, Bash).\par
\par
\pard{}You can change the value of {\f1{}FS} in the {\f1{}awk} program with the assignment operator, {\f1{}=} (see {\uldb Assignment Expressions}{\v Assignment_Ops}).  Often the right time to do this is at the beginning of execution, before any input has been processed, so that the very first record will be read with the proper separator.  To do this, use the special {\f1{}BEGIN} pattern (see {\uldb The {\f1{}BEGIN} and {\f1{}END} Special Patterns}{\v BEGIN_END}).  For example, here we set the value of {\f1{}FS} to the string {\f1{}","}:\par
\par
{\pard\keep\li720\f1{}awk 'BEGIN \'7B FS = "," \'7D ; \'7B print $2 \'7D'\par
\pard\f0{}}\par
\pard{}Given the input line,\par
\par
{\pard\keep\li720\f1{}John Q. Smith, 29 Oak St., Walamazoo, MI 42139\par
\pard\f0{}}\par
\pard{}this {\f1{}awk} program extracts and prints the string {\f1{}{\f2\'B7}29{\f2\'B7}Oak{\f2\'B7}St.}.\par
\par
\pard{}{K{\footnote K field separator, choice of}}{K{\footnote K regular expressions as field separators}}Sometimes your input data will contain separator characters that don't separate fields the way you thought they would.  For instance, the person's name in the example we just used might have a title or suffix attached, such as {\f1{}John Q. Smith, LXIX}.  From input containing such a name:\par
\par
{\pard\keep\li720\f1{}John Q. Smith, LXIX, 29 Oak St., Walamazoo, MI 42139\par
\pard\f0{}}\par
\pard{}the above program would extract {\f1{}{\f2\'B7}LXIX}, instead of {\f1{}{\f2\'B7}29{\f2\'B7}Oak{\f2\'B7}St.}.  If you were expecting the program to print the address, you would be surprised.  The moral is: choose your data layout and separator characters carefully to prevent such problems.\par
\par
{\pard{}Normally, }fields are separated by whitespace sequences (spaces, tabs and newlines), not by single spaces: two spaces in a row do not delimit an empty field.  The default value of the field separator {\f1{}FS} is a string containing a single space, {\f1{}" "}.  If this value were interpreted in the usual way, each space character would separate fields, so two spaces in a row would make an empty field between them.  The reason this does not happen is that a single space as the value of {\f1{}FS} is a special case: it is taken to specify the default manner of delimiting fields.\par
\par
\pard{}If {\f1{}FS} is any other single character, such as {\f1{}","}, then each occurrence of that character separates two fields.  Two consecutive occurrences delimit an empty field.  If the character occurs at the beginning or the end of the line, that too delimits an empty field.  The space character is the only single character which does not follow these rules.\par
\par
\page\pard Node: {\b Regexp Field Splitting}, \keepn Next: {\uldb Single Character Fields}{\v Single_Character_Fields}, Prev: {\uldb Basic Field Splitting}{\v Basic_Field_Splitting}, Up: {\uldb Field Separators}{\v Field_Separators}\line
K{\footnote K Regexp Field Splitting}
#{\footnote Regexp_Field_Splitting}
${\footnote \pard{}Using Regular Expressions to Separate Fields}\par
\pard{\fs24\b Using Regular Expressions to Separate Fields}\par
\par
\pard{}The previous {node }discussed the use of single characters or simple strings as the value of {\f1{}FS}.  More generally, the value of {\f1{}FS} may be a string containing any regular expression.  In this case, each match in the record for the regular expression separates fields.  For example, the assignment:\par
\par
{\pard\keep\li720\f1{}FS = ", \'5Ct"\par
\pard\f0{}}\par
\pard{}makes every area of an input line that consists of a comma followed by a space and a tab, into a field separator.  ({\f1{}\'5Ct} is an \'A2escape sequence\'A2 that stands for a tab; see {\uldb Escape Sequences}{\v Escape_Sequences}, for the complete list of similar escape sequences.)\par
\par
\pard{}For a less trivial example of a regular expression, suppose you want single spaces to separate fields the way single commas were used above.  You can set {\f1{}FS} to {\f1{}"[ ]"} (left bracket, space, right bracket).  This regular expression matches a single space and nothing else (see {\uldb Regular Expressions}{\v Regexp}).\par
\par
\pard{}There is an important difference between the two cases of {\f1{}FS = " "} (a single space) and {\f1{}FS = "[ \'5Ct\'5Cn]+"} (left bracket, space, backslash, "t", backslash, "n", right bracket, which is a regular expression matching one or more spaces, tabs, or newlines).  For both values of {\f1{}FS}, fields are separated by runs of spaces, tabs and/or newlines.  However, when the value of {\f1{}FS} is {\f1{}" "}, {\f1{}awk} will first strip leading and trailing whitespace from the record, and then decide where the fields are.\par
\par
\pard{}For example, the following pipeline prints {\f1{}b}:\par
\par
{\pard\keep\li720\f1{}$ echo ' a b c d ' | awk '\'7B print $2 \'7D'\line
-| b\par
\pard\f0{}}\par
\pard{}However, this pipeline prints {\f1{}a} (note the extra spaces around each letter):\par
\par
{\pard\keep\li720\f1{}$ echo ' a  b  c  d ' | awk 'BEGIN \'7B FS = "[ \'5Ct]+" \'7D\line
>                                  \'7B print $2 \'7D'\line
-| a\par
\pard\f0{}}\par
\pard{}{K{\footnote K null string}}{K{\footnote K empty string}}In this case, the first field is \'A2null\'A2, or empty.\par
\par
\pard{}The stripping of leading and trailing whitespace also comes into play whenever {\f1{}$0} is recomputed.  For instance, study this pipeline:\par
\par
{\pard\keep\li720\f1{}$ echo '   a b c d' | awk '\'7B print; $2 = $2; print \'7D'\line
-|    a b c d\line
-| a b c d\par
\pard\f0{}}\par
\pard{}The first {\f1{}print} statement prints the record as it was read, with leading whitespace intact.  The assignment to {\f1{}$2} rebuilds {\f1{}$0} by concatenating {\f1{}$1} through {\f1{}$NF} together, separated by the value of {\f1{}OFS}.  Since the leading whitespace was ignored when finding {\f1{}$1}, it is not part of the new {\f1{}$0}.  Finally, the last {\f1{}print} statement prints the new {\f1{}$0}.\par
\par
\page\pard Node: {\b Single Character Fields}, \keepn Next: {\uldb Command Line Field Separator}{\v Command_Line_Field_Separator}, Prev: {\uldb Regexp Field Splitting}{\v Regexp_Field_Splitting}, Up: {\uldb Field Separators}{\v Field_Separators}\line
K{\footnote K Single Character Fields}
#{\footnote Single_Character_Fields}
${\footnote \pard{}Making Each Character a Separate Field}\par
\pard{\fs24\b Making Each Character a Separate Field}\par
\par
\pard{}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}{K{\footnote K single character fields}}There are times when you may want to examine each character of a record separately.  In {\f1{}gawk}, this is easy to do, you simply assign the null string ({\f1{}""}) to {\f1{}FS}. In this case, each individual character in the record will become a separate field.  Here is an example:\par
\par
{{\pard\keep\li720\f1{}$ echo a b | gawk 'BEGIN \'7B FS = "" \'7D\line
>                  \'7B\line
>                      for (i = 1; i <= NF; i = i + 1)\line
>                          print "Field", i, "is", $i\line
>                  \'7D'\line
-| Field 1 is a\line
-| Field 2 is\line
-| Field 3 is b\par
\pard\keep\li720{}}}\par
\pard\f0{}{K{\footnote K dark corner}}Traditionally, the behavior for {\f1{}FS} equal to {\f1{}""} was not defined.  In this case, Unix {\f1{}awk} would simply treat the entire record as only having one field (d.c.).  In compatibility mode (see {\uldb Command Line Options}{\v Options}), if {\f1{}FS} is the null string, then {\f1{}gawk} will also behave this way.\par
\par
\page\pard Node: {\b Command Line Field Separator}, \keepn Next: {\uldb Field Splitting Summary}{\v Field_Splitting_Summary}, Prev: {\uldb Single Character Fields}{\v Single_Character_Fields}, Up: {\uldb Field Separators}{\v Field_Separators}\line
K{\footnote K Command Line Field Separator}
#{\footnote Command_Line_Field_Separator}
${\footnote \pard{}Setting {\f1{}FS} from the Command Line}\par
\pard{\fs24\b Setting {\f1{}FS} from the Command Line}\par
\par
\pard{}{K{\footnote K {\f1{}-F} option}}{K{\footnote K field separator, on command line}}{K{\footnote K command line, setting {\f1{}FS} on}} {\f1{}FS} can be set on the command line.  You use the {\f1{}-F} option to do so.  For example:\par
\par
{\pard\keep\li720\f1{}awk -F, '{\i program}' {\i input-files}\par
\pard\f0{}}\par
\pard{}sets {\f1{}FS} to be the {\f1{},} character.  Notice that the option uses a capital {\f1{}F}.  Contrast this with {\f1{}-f}, which specifies a file containing an {\f1{}awk} program.  Case is significant in command line options: the {\f1{}-F} and {\f1{}-f} options have nothing to do with each other.  You can use both options at the same time to set the {\f1{}FS} variable {\i and} get an {\f1{}awk} program from a file.\par
\par
\pard{}The value used for the argument to {\f1{}-F} is processed in exactly the same way as assignments to the built-in variable {\f1{}FS}.  This means that if the field separator contains special characters, they must be escaped appropriately.  For example, to use a {\f1{}\'5C} as the field separator, you would have to type:\par
\par
{\pard\keep\li720\f1{}# same as FS = "\'5C\'5C"\line
awk -F\'5C\'5C\'5C\'5C '...' files ...\par
\pard\f0{}}\par
\pard{}Since {\f1{}\'5C} is used for quoting in the shell, {\f1{}awk} will see {\f1{}-F\'5C\'5C}.  Then {\f1{}awk} processes the {\f1{}\'5C\'5C} for escape characters (see {\uldb Escape Sequences}{\v Escape_Sequences}), finally yielding a single {\f1{}\'5C} to be used for the field separator.\par
\par
\pard{}{K{\footnote K historical features}}As a special case, in compatibility mode (see {\uldb Command Line Options}{\v Options}), if the argument to {\f1{}-F} is {\f1{}t}, then {\f1{}FS} is set to the tab character.  This is because if you type {\f1{}-F\'5Ct} at the shell, without any quotes, the {\f1{}\'5C} gets deleted, so {\f1{}awk} figures that you really want your fields to be separated with tabs, and not {\f1{}t}s.  Use {\f1{}-v FS="t"} on the command line if you really do want to separate your fields with {\f1{}t}s (see {\uldb Command Line Options}{\v Options}).\par
\par
\pard{}For example, let's use an {\f1{}awk} program file called {\f1{}baud.awk} that contains the pattern {\f1{}/300/}, and the action {\f1{}print $1}.  Here is the program:\par
\par
{\pard\keep\li720\f1{}/300/   \'7B print $1 \'7D\par
\pard\f0{}}\par
\pard{}Let's also set {\f1{}FS} to be the {\f1{}-} character, and run the program on the file {\f1{}BBS-list}.  The following command prints a list of the names of the bulletin boards that operate at 300 baud and the first three digits of their phone numbers:\par
\par
{{\pard\keep\li720\f1{}$ awk -F- -f baud.awk BBS-list\line
-| aardvark     555\line
-| alpo\line
-| barfly       555\line
...\par
\pard\keep\li720{}}}\par
\pard\f0{}Note the second line of output.  In the original file (see {\uldb Data Files for the Examples}{\v Sample_Data_Files}), the second line looked like this:\par
\par
{\pard\keep\li720\f1{}alpo-net     555-3412     2400/1200/300     A\par
\pard\f0{}}\par
\pard{}The {\f1{}-} as part of the system's name was used as the field separator, instead of the {\f1{}-} in the phone number that was originally intended.  This demonstrates why you have to be careful in choosing your field and record separators.\par
\par
\pard{}On many Unix systems, each user has a separate entry in the system password file, one line per user.  The information in these lines is separated by colons.  The first field is the user's logon name, and the second is the user's encrypted password.  A password file entry might look like this:\par
\par
{\pard\keep\li720\f1{}arnold:xyzzy:2076:10:Arnold Robbins:/home/arnold:/bin/sh\par
\pard\f0{}}\par
\pard{}The following program searches the system password file, and prints the entries for users who have no password:\par
\par
{\pard\keep\li720\f1{}awk -F: '$2 == ""' /etc/passwd\par
\pard\f0{}}\par
\page\pard Node: {\b Field Splitting Summary}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Command Line Field Separator}{\v Command_Line_Field_Separator}, Up: {\uldb Field Separators}{\v Field_Separators}\line
K{\footnote K Field Splitting Summary}
#{\footnote Field_Splitting_Summary}
${\footnote \pard{}Field Splitting Summary}\par
\pard{\fs24\b Field Splitting Summary}\par
\par
\pard{}{K{\footnote K {\f1{}awk} language, POSIX version}}{K{\footnote K POSIX {\f1{}awk}}}According to the POSIX standard, {\f1{}awk} is supposed to behave as if each record is split into fields at the time that it is read.  In particular, this means that you can change the value of {\f1{}FS} after a record is read, and the value of the fields (i.e. how they were split) should reflect the old value of {\f1{}FS}, not the new one.\par
\par
\pard{}{K{\footnote K dark corner}}{K{\footnote K {\f1{}sed} utility}}{K{\footnote K stream editor}}However, many implementations of {\f1{}awk} do not work this way.  Instead, they defer splitting the fields until a field is actually referenced.  The fields will be split using the {\i current} value of {\f1{}FS}! (d.c.)  This behavior can be difficult to diagnose. The following example illustrates the difference between the two methods.  (The {\f1{}sed}({\ul 1}{\v Field_Splitting_Summary_1}) command prints just the first line of {\f1{}/etc/passwd}.)\par
\par
{\pard\keep\li720\f1{}sed 1q /etc/passwd | awk '\'7B FS = ":" ; print $1 \'7D'\par
\pard\f0{}}\par
\pard{}will usually print\par
\par
{\pard\keep\li720\f1{}root\par
\pard\f0{}}\par
\pard{}on an incorrect implementation of {\f1{}awk}, while {\f1{}gawk} will print something like\par
\par
{\pard\keep\li720\f1{}root:nSijPlPhZZwgE:0:0:Root:/:\par
\pard\f0{}}\par
\pard{}The following table summarizes how fields are split, based on the value of {\f1{}FS}. ({\f1{}==} means "is equal to.")\par
\par
{\pard{}{\f1{}FS == " "}\par
\pard\li720{}Fields are separated by runs of whitespace.  Leading and trailing whitespace are ignored.  This is the default.\par
\par
\pard{}{\f1{}FS == {\i any other single character}}\par
\pard\li720{}Fields are separated by each occurrence of the character.  Multiple successive occurrences delimit empty fields, as do leading and trailing occurrences.  The character can even be a regexp metacharacter; it does not need to be escaped.\par
\par
\pard{}{\f1{}FS == {\i regexp}}\par
\pard\li720{}Fields are separated by occurrences of characters that match {\i regexp}.  Leading and trailing matches of {\i regexp} delimit empty fields.\par
\par
\pard{}{\f1{}FS == ""}\par
\pard\li720{}Each individual character in the record becomes a separate field.\par
\pard{}}\par
\page\pard#{\footnote Field_Splitting_Summary_1}
\pard{}(1) The {\f1{}sed} utility is a "stream editor."  Its behavior is also defined by the POSIX standard.\par
\par
\page\pard Node: {\b Constant Size}, \keepn Next: {\uldb Multiple Line}{\v Multiple_Line}, Prev: {\uldb Field Separators}{\v Field_Separators}, Up: {\uldb Reading Files}{\v Reading_Files}\line
K{\footnote K Constant Size}
#{\footnote Constant_Size}
${\footnote \pard{}Reading Fixed-width Data}\par
\pard{\fs24\b Reading Fixed-width Data}\par
\par
\pard{}(This section discusses an advanced, experimental feature.  If you are a novice {\f1{}awk} user, you may wish to skip it on the first reading.)\par
\par
{\f1{}\pard{}gawk} version 2.13 introduced a new facility for dealing with fixed-width fields with no distinctive field separator.  Data of this nature arises, for example, in  the input for old FORTRAN programs where numbers are run together; or in the output of programs that did not anticipate the use of their output as input for other programs.\par
\par
\pard{}An example of the latter is a table where all the columns are lined up by the use of a variable number of spaces and {\i empty fields are just spaces}.  Clearly, {\f1{}awk}'s normal field splitting based on {\f1{}FS} will not work well in this case.  Although a portable {\f1{}awk} program can use a series of {\f1{}substr} calls on {\f1{}$0} (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}), this is awkward and inefficient for a large number of fields.\par
\par
\pard{}The splitting of an input record into fixed-width fields is specified by assigning a string containing space-separated numbers to the built-in variable {\f1{}FIELDWIDTHS}.  Each number specifies the width of the field {\i including} columns between fields.  If you want to ignore the columns between fields, you can specify the width as a separate field that is subsequently ignored.\par
\par
\pard{}The following data is the output of the Unix {\f1{}w} utility.  It is useful to illustrate the use of {\f1{}FIELDWIDTHS}.\par
\par
{{\pard\keep\li720\f1{} 10:06pm  up 21 days, 14:04,  23 users\line
User     tty       login  idle   JCPU   PCPU  what\line
hzuo     ttyV0     8:58pm            9      5  vi p24.tex\line
hzang    ttyV3     6:37pm    50                -csh\line
eklye    ttyV5     9:53pm            7      1  em thes.tex\line
dportein ttyV6     8:17pm  1:47                -csh\line
gierd    ttyD3    10:00pm     1                elm\line
dave     ttyD4     9:47pm            4      4  w\line
brent    ttyp0    26Jun91  4:46  26:46   4:41  bash\line
dave     ttyq4    26Jun9115days     46     46  wnewmail\par
\pard\keep\li720{}}}\par
\pard\f0{}The following program takes the above input, converts the idle time to number of seconds and prints out the first two fields and the calculated idle time.  (This program uses a number of {\f1{}awk} features that haven't been introduced yet.)\par
\par
{{\pard\keep\li720\f1{}BEGIN  \'7B FIELDWIDTHS = "9 6 10 6 7 7 35" \'7D\line
NR > 2 \'7B\line
    idle = $4\line
    sub(/^  */, "", idle)   # strip leading spaces\line
    if (idle == "")\line
        idle = 0\line
    if (idle ~ /:/) \'7B\line
        split(idle, t, ":")\line
        idle = t[1] * 60 + t[2]\line
    \'7D\line
    if (idle ~ /days/)\line
        idle *= 24 * 60 * 60\line
\line
    print $1, $2, idle\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}Here is the result of running the program on the data:\par
\par
{\pard\keep\li720\f1{}hzuo      ttyV0  0\line
hzang     ttyV3  50\line
eklye     ttyV5  0\line
dportein  ttyV6  107\line
gierd     ttyD3  1\line
dave      ttyD4  0\line
brent     ttyp0  286\line
dave      ttyq4  1296000\par
\pard\f0{}}\par
\pard{}Another (possibly more practical) example of fixed-width input data would be the input from a deck of balloting cards.  In some parts of the United States, voters mark their choices by punching holes in computer cards.  These cards are then processed to count the votes for any particular candidate or on any particular issue.  Since a voter may choose not to vote on some issue, any column on the card may be empty.  An {\f1{}awk} program for processing such data could use the {\f1{}FIELDWIDTHS} feature to simplify reading the data.  (Of course, getting {\f1{}gawk} to run on a system with card readers is another story!)\par
\par
\pard{}Assigning a value to {\f1{}FS} causes {\f1{}gawk} to return to using {\f1{}FS} for field splitting.  Use {\f1{}FS = FS} to make this happen, without having to know the current value of {\f1{}FS}.\par
\par
\pard{}This feature is still experimental, and may evolve over time.  Note that in particular, {\f1{}gawk} does not attempt to verify the sanity of the values used in the value of {\f1{}FIELDWIDTHS}.\par
\par
\page\pard Node: {\b Multiple Line}, \keepn Next: {\uldb Getline}{\v Getline}, Prev: {\uldb Constant Size}{\v Constant_Size}, Up: {\uldb Reading Files}{\v Reading_Files}\line
K{\footnote K Multiple Line}
#{\footnote Multiple_Line}
${\footnote \pard{}Multiple-Line Records}\par
\pard{\fs24\b Multiple-Line Records}\par
\par
\pard{}{K{\footnote K multiple line records}}{K{\footnote K input, multiple line records}}{K{\footnote K reading files, multiple line records}}{K{\footnote K records, multiple line}}In some data bases, a single line cannot conveniently hold all the information in one entry.  In such cases, you can use multi-line records.\par
\par
\pard{}The first step in doing this is to choose your data format: when records are not defined as single lines, how do you want to define them?  What should separate records?\par
\par
\pard{}One technique is to use an unusual character or string to separate records.  For example, you could use the formfeed character (written {\f1{}\'5Cf} in {\f1{}awk}, as in C) to separate them, making each record a page of the file.  To do this, just set the variable {\f1{}RS} to {\f1{}"\'5Cf"} (a string containing the formfeed character).  Any other character could equally well be used, as long as it won't be part of the data in a record.\par
\par
\pard{}Another technique is to have blank lines separate records.  By a special dispensation, an empty string as the value of {\f1{}RS} indicates that records are separated by one or more blank lines.  If you set {\f1{}RS} to the empty string, a record always ends at the first blank line encountered.  And the next record doesn't start until the first non-blank line that follows--no matter how many blank lines appear in a row, they are considered one record-separator.\par
\par
\pard{}{K{\footnote K leftmost longest match}}{K{\footnote K matching, leftmost longest}}You can achieve the same effect as {\f1{}RS = ""} by assigning the string {\f1{}"\'5Cn\'5Cn+"} to {\f1{}RS}. This regexp matches the newline at the end of the record, and one or more blank lines after the record.  In addition, a regular expression always matches the longest possible sequence when there is a choice (see {\uldb How Much Text Matches?}{\v Leftmost_Longest}).  So the next record doesn't start until the first non-blank line that follows--no matter how many blank lines appear in a row, they are considered one record-separator.\par
\par
\pard{}{K{\footnote K dark corner}}There is an important difference between {\f1{}RS = ""} and {\f1{}RS = "\'5Cn\'5Cn+"}. In the first case, leading newlines in the input data file are ignored, and if a file ends without extra blank lines after the last record, the final newline is removed from the record.  In the second case, this special processing is not done (d.c.).\par
\par
\pard{}Now that the input is separated into records, the second step is to separate the fields in the record.  One way to do this is to divide each of the lines into fields in the normal manner.  This happens by default as the result of a special feature: when {\f1{}RS} is set to the empty string, the newline character {\i always} acts as a field separator.  This is in addition to whatever field separations result from {\f1{}FS}.\par
\par
\pard{}The original motivation for this special exception was probably to provide useful behavior in the default case (i.e. {\f1{}FS} is equal to {\f1{}" "}).  This feature can be a problem if you really don't want the newline character to separate fields, since there is no way to prevent it.  However, you can work around this by using the {\f1{}split} function to break up the record manually (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}).\par
\par
\pard{}Another way to separate fields is to put each field on a separate line: to do this, just set the variable {\f1{}FS} to the string {\f1{}"\'5Cn"}.  (This simple regular expression matches a single newline.)\par
\par
\pard{}A practical example of a data file organized this way might be a mailing list, where each entry is separated by blank lines.  If we have a mailing list in a file named {\f1{}addresses}, that looks like this:\par
\par
{\pard\keep\li720\f1{}Jane Doe\line
123 Main Street\line
Anywhere, SE 12345-6789\line
\line
John Smith\line
456 Tree-lined Avenue\line
Smallville, MW 98765-4321\line
\line
...\par
\pard\f0{}}\par
\pard{}A simple program to process this file would look like this:\par
\par
{{\pard\keep\li720\f1{}# addrs.awk --- simple mailing list program\line
\line
# Records are separated by blank lines.\line
# Each line is one field.\line
BEGIN \'7B RS = "" ; FS = "\'5Cn" \'7D\line
\line
\'7B\line
      print "Name is:", $1\line
      print "Address is:", $2\line
      print "City and State are:", $3\line
      print ""\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}Running the program produces the following output:\par
\par
{{\pard\keep\li720\f1{}$ awk -f addrs.awk addresses\line
-| Name is: Jane Doe\line
-| Address is: 123 Main Street\line
-| City and State are: Anywhere, SE 12345-6789\line
-|\par
\pard\keep\li720{}}{-| Name is: John Smith\line
-| Address is: 456 Tree-lined Avenue\line
-| City and State are: Smallville, MW 98765-4321\line
-|\line
...\par
\pard\keep\li720{}}}\par
\pard\f0{}See {\uldb Printing Mailing Labels}{\v Labels_Program}, for a more realistic program that deals with address lists.\par
\par
\pard{}The following table summarizes how records are split, based on the value of {\f1{}RS}. ({\f1{}==} means "is equal to.")\par
\par
{\pard{}{\f1{}RS == "\'5Cn"}\par
\pard\li720{}Records are separated by the newline character ({\f1{}\'5Cn}).  In effect, every line in the data file is a separate record, including blank lines.  This is the default.\par
\par
\pard{}{\f1{}RS == {\i any single character}}\par
\pard\li720{}Records are separated by each occurrence of the character.  Multiple successive occurrences delimit empty records.\par
\par
\pard{}{\f1{}RS == ""}\par
\pard\li720{}Records are separated by runs of blank lines.  The newline character always serves as a field separator, in addition to whatever value {\f1{}FS} may have. Leading and trailing newlines in a file are ignored.\par
\par
\pard{}{\f1{}RS == {\i regexp}}\par
\pard\li720{}Records are separated by occurrences of characters that match {\i regexp}.  Leading and trailing matches of {\i regexp} delimit empty records.\par
\pard{}}\par
\pard{}{K{\footnote K RT}}In all cases, {\f1{}gawk} sets {\f1{}RT} to the input text that matched the value specified by {\f1{}RS}.\par
\par
\page\pard Node: {\b Getline}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Multiple Line}{\v Multiple_Line}, Up: {\uldb Reading Files}{\v Reading_Files}\line
K{\footnote K Getline}
#{\footnote Getline}
${\footnote \pard{}Explicit Input with {\f1{}getline}}\par
\pard{\fs24\b Explicit Input with {\f1{}getline}}\par
\par
\pard{}{K{\footnote K getline}}{K{\footnote K input, explicit}}{K{\footnote K explicit input}}{K{\footnote K input, {\f1{}getline} command}}{K{\footnote K reading files, {\f1{}getline} command}}So far we have been getting our input data from {\f1{}awk}'s main input stream--either the standard input (usually your terminal, sometimes the output from another program) or from the files specified on the command line.  The {\f1{}awk} language has a special built-in command called {\f1{}getline} that can be used to read input under your explicit control.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Getline Intro}{\v Getline_Intro}\tab Introduction to the {\f1{}getline} function.\par
{\uldb Plain Getline}{\v Plain_Getline}\tab Using {\f1{}getline} with no arguments.\par
{\uldb Getline/Variable}{\v Getline_Variable}\tab Using {\f1{}getline} into a variable.\par
{\uldb Getline/File}{\v Getline_File}\tab Using {\f1{}getline} from a file.\par
{\uldb Getline/Variable/File}{\v Getline_Variable_File}\tab Using {\f1{}getline} into a variable from a file.\par
{\uldb Getline/Pipe}{\v Getline_Pipe}\tab Using {\f1{}getline} from a pipe.\par
{\uldb Getline/Variable/Pipe}{\v Getline_Variable_Pipe}\tab Using {\f1{}getline} into a variable from a pipe.\par
{\uldb Getline Summary}{\v Getline_Summary}\tab Summary Of {\f1{}getline} Variants.\par
\pard{}}\par
\page\pard Node: {\b Getline Intro}, \keepn Next: {\uldb Plain Getline}{\v Plain_Getline}, Prev: {\uldb Getline}{\v Getline}, Up: {\uldb Getline}{\v Getline}\line
K{\footnote K Getline Intro}
#{\footnote Getline_Intro}
${\footnote \pard{}Introduction to {\f1{}getline}}\par
\pard{\fs24\b Introduction to {\f1{}getline}}\par
\par
\pard{}This command is used in several different ways, and should {\i not} be used by beginners.  It is covered here because this is the chapter on input.  The examples that follow the explanation of the {\f1{}getline} command include material that has not been covered yet.  Therefore, come back and study the {\f1{}getline} command {\i after} you have reviewed the rest of this Info file and have a good knowledge of how {\f1{}awk} works.\par
\par
\pard{}{K{\footnote K ERRNO}}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}{K{\footnote K {\f1{}getline}, return values}}{\f1{}getline} returns one if it finds a record, and zero if the end of the file is encountered.  If there is some error in getting a record, such as a file that cannot be opened, then {\f1{}getline} returns -1.  In this case, {\f1{}gawk} sets the variable {\f1{}ERRNO} to a string describing the error that occurred.\par
\par
\pard{}In the following examples, {\i command} stands for a string value that represents a shell command.\par
\par
\page\pard Node: {\b Plain Getline}, \keepn Next: {\uldb Getline/Variable}{\v Getline_Variable}, Prev: {\uldb Getline Intro}{\v Getline_Intro}, Up: {\uldb Getline}{\v Getline}\line
K{\footnote K Plain Getline}
#{\footnote Plain_Getline}
${\footnote \pard{}Using {\f1{}getline} with No Arguments}\par
\pard{\fs24\b Using {\f1{}getline} with No Arguments}\par
\par
\pard{}The {\f1{}getline} command can be used without arguments to read input from the current input file.  All it does in this case is read the next input record and split it up into fields.  This is useful if you've finished processing the current record, but you want to do some special processing {\i right now} on the next record.  Here's an example:\par
\par
{{\pard\keep\li720\f1{}awk '\'7B\line
     if ((t = index($0, "/*")) != 0) \'7B\line
          # value will be "" if t is 1\line
          tmp = substr($0, 1, t - 1)\line
          u = index(substr($0, t + 2), "*/")\line
          while (u == 0) \'7B\line
               if (getline <= 0) \'7B\line
                    m = "unexpected EOF or error"\line
                    m = (m ": " ERRNO)\line
                    print m > "/dev/stderr"\line
                    exit\line
               \'7D\line
               t = -1\line
               u = index($0, "*/")\line
          \'7D\par
\pard\keep\li720{}}{          # substr expression will be "" if */\line
          # occurred at end of line\line
          $0 = tmp substr($0, t + u + 3)\line
     \'7D\line
     print $0\line
\'7D'\par
\pard\keep\li720{}}}\par
\pard\f0{}This {\f1{}awk} program deletes all C-style comments, {\f1{}/* ...  */}, from the input.  By replacing the {\f1{}print $0} with other statements, you could perform more complicated processing on the decommented input, like searching for matches of a regular expression.  This program has a subtle problem--it does not work if one comment ends and another begins on the same line.\par
\par
\pard{}This form of the {\f1{}getline} command sets {\f1{}NF} (the number of fields; see {\uldb Examining Fields}{\v Fields}), {\f1{}NR} (the number of records read so far; see {\uldb How Input is Split into Records}{\v Records}), {\f1{}FNR} (the number of records read from this input file), and the value of {\f1{}$0}.\par
\par
\pard{}{K{\footnote K dark corner}}{\b Note:} the new value of {\f1{}$0} is used in testing the patterns of any subsequent rules.  The original value of {\f1{}$0} that triggered the rule which executed {\f1{}getline} is lost (d.c.).  By contrast, the {\f1{}next} statement reads a new record but immediately begins processing it normally, starting with the first rule in the program.  See {\uldb The {\f1{}next} Statement}{\v Next_Statement}.\par
\par
\page\pard Node: {\b Getline/Variable}, \keepn Next: {\uldb Getline/File}{\v Getline_File}, Prev: {\uldb Plain Getline}{\v Plain_Getline}, Up: {\uldb Getline}{\v Getline}\line
K{\footnote K Getline/Variable}
#{\footnote Getline_Variable}
${\footnote \pard{}Using {\f1{}getline} Into a Variable}\par
\pard{\fs24\b Using {\f1{}getline} Into a Variable}\par
\par
\pard{}You can use {\f1{}getline {\i var}} to read the next record from {\f1{}awk}'s input into the variable {\i var}.  No other processing is done.\par
\par
\pard{}For example, suppose the next line is a comment, or a special string, and you want to read it, without triggering any rules.  This form of {\f1{}getline} allows you to read that line and store it in a variable so that the main read-a-line-and-check-each-rule loop of {\f1{}awk} never sees it.\par
\par
\pard{}The following example swaps every two lines of input.  For example, given:\par
\par
{\pard\keep\li720\f1{}wan\line
tew\line
free\line
phore\par
\pard\f0{}}\par
\pard{}it outputs:\par
\par
{\pard\keep\li720\f1{}tew\line
wan\line
phore\line
free\par
\pard\f0{}}\par
\pard{}Here's the program:\par
\par
{{\pard\keep\li720\f1{}awk '\'7B\line
     if ((getline tmp) > 0) \'7B\line
          print tmp\line
          print $0\line
     \'7D else\line
          print $0\line
\'7D'\par
\pard\keep\li720{}}}\par
\pard\f0{}The {\f1{}getline} command used in this way sets only the variables {\f1{}NR} and {\f1{}FNR} (and of course, {\i var}).  The record is not split into fields, so the values of the fields (including {\f1{}$0}) and the value of {\f1{}NF} do not change.\par
\par
\page\pard Node: {\b Getline/File}, \keepn Next: {\uldb Getline/Variable/File}{\v Getline_Variable_File}, Prev: {\uldb Getline/Variable}{\v Getline_Variable}, Up: {\uldb Getline}{\v Getline}\line
K{\footnote K Getline/File}
#{\footnote Getline_File}
${\footnote \pard{}Using {\f1{}getline} from a File}\par
\pard{\fs24\b Using {\f1{}getline} from a File}\par
\par
\pard{}{K{\footnote K input redirection}}{K{\footnote K redirection of input}}Use {\f1{}getline < {\i file}} to read the next record from the file {\i file}.  Here {\i file} is a string-valued expression that specifies the file name.  {\f1{}< {\i file}} is called a \'A2redirection\'A2 since it directs input to come from a different place.\par
\par
\pard{}For example, the following program reads its input record from the file {\f1{}secondary.input} when it encounters a first field with a value equal to 10 in the current input file.\par
\par
{{\pard\keep\li720\f1{}awk '\'7B\line
    if ($1 == 10) \'7B\line
         getline < "secondary.input"\line
         print\line
    \'7D else\line
         print\line
\'7D'\par
\pard\keep\li720{}}}\par
\pard\f0{}Since the main input stream is not used, the values of {\f1{}NR} and {\f1{}FNR} are not changed.  But the record read is split into fields in the normal manner, so the values of {\f1{}$0} and other fields are changed.  So is the value of {\f1{}NF}.\par
\par
\pard{}According to POSIX, {\f1{}getline < {\i expression}} is ambiguous if {\i expression} contains unparenthesized operators other than {\f1{}$}; for example, {\f1{}getline < dir "/" file} is ambiguous because the concatenation operator is not parenthesized, and you should write it as {\f1{}getline < (dir "/" file)} if you want your program to be portable to other {\f1{}awk} implementations.\par
\par
\page\pard Node: {\b Getline/Variable/File}, \keepn Next: {\uldb Getline/Pipe}{\v Getline_Pipe}, Prev: {\uldb Getline/File}{\v Getline_File}, Up: {\uldb Getline}{\v Getline}\line
K{\footnote K Getline/Variable/File}
#{\footnote Getline_Variable_File}
${\footnote \pard{}Using {\f1{}getline} Into a Variable from a File}\par
\pard{\fs24\b Using {\f1{}getline} Into a Variable from a File}\par
\par
\pard{}Use {\f1{}getline {\i var} < {\i file}} to read input the file {\i file} and put it in the variable {\i var}.  As above, {\i file} is a string-valued expression that specifies the file from which to read.\par
\par
\pard{}In this version of {\f1{}getline}, none of the built-in variables are changed, and the record is not split into fields.  The only variable changed is {\i var}.\par
\par
{\pard{}According to POSIX, {\f1{}getline {\i var} < {\i expression}} is ambiguous if {\i expression} contains unparenthesized operators other than {\f1{}$}; for example, {\f1{}getline < dir "/" file} is ambiguous because the concatenation operator is not parenthesized, and you should write it as {\f1{}getline < (dir "/" file)} if you want your program to be portable to other {\f1{}awk} implementations.  }\par
\par
\pard{}For example, the following program copies all the input files to the output, except for records that say {\f1{}@include {\i filename}}.  Such a record is replaced by the contents of the file {\i filename}.\par
\par
{{\pard\keep\li720\f1{}awk '\'7B\line
     if (NF == 2 && $1 == "@include") \'7B\line
          while ((getline line < $2) > 0)\line
               print line\line
          close($2)\line
     \'7D else\line
          print\line
\'7D'\par
\pard\keep\li720{}}}\par
\pard\f0{}Note here how the name of the extra input file is not built into the program; it is taken directly from the data, from the second field on the {\f1{}@include} line.\par
\par
\pard{}The {\f1{}close} function is called to ensure that if two identical {\f1{}@include} lines appear in the input, the entire specified file is included twice.  See {\uldb Closing Input and Output Files and Pipes}{\v Close_Files_And_Pipes}.\par
\par
\pard{}One deficiency of this program is that it does not process nested {\f1{}@include} statements ({\f1{}@include} statements in included files) the way a true macro preprocessor would.  See {\uldb An Easy Way to Use Library Functions}{\v Igawk_Program}, for a program that does handle nested {\f1{}@include} statements.\par
\par
\page\pard Node: {\b Getline/Pipe}, \keepn Next: {\uldb Getline/Variable/Pipe}{\v Getline_Variable_Pipe}, Prev: {\uldb Getline/Variable/File}{\v Getline_Variable_File}, Up: {\uldb Getline}{\v Getline}\line
K{\footnote K Getline/Pipe}
#{\footnote Getline_Pipe}
${\footnote \pard{}Using {\f1{}getline} from a Pipe}\par
\pard{\fs24\b Using {\f1{}getline} from a Pipe}\par
\par
\pard{}{K{\footnote K input pipeline}}{K{\footnote K pipeline, input}}You can pipe the output of a command into {\f1{}getline}, using {\f1{}{\i command} | getline}.  In this case, the string {\i command} is run as a shell command and its output is piped into {\f1{}awk} to be used as input.  This form of {\f1{}getline} reads one record at a time from the pipe.\par
\par
\pard{}For example, the following program copies its input to its output, except for lines that begin with {\f1{}@execute}, which are replaced by the output produced by running the rest of the line as a shell command:\par
\par
{{\pard\keep\li720\f1{}awk '\'7B\line
     if ($1 == "@execute") \'7B\line
          tmp = substr($0, 10)\line
          while ((tmp | getline) > 0)\line
               print\line
          close(tmp)\line
     \'7D else\line
          print\line
\'7D'\par
\pard\keep\li720{}}}\par
\pard\f0{}The {\f1{}close} function is called to ensure that if two identical {\f1{}@execute} lines appear in the input, the command is run for each one.  See {\uldb Closing Input and Output Files and Pipes}{\v Close_Files_And_Pipes}.\par
\par
\pard{}Given the input:\par
\par
{{\pard\keep\li720\f1{}foo\line
bar\line
baz\line
@execute who\line
bletch\par
\pard\keep\li720{}}}\par
\pard\f0{}the program might produce:\par
\par
{{\pard\keep\li720\f1{}foo\line
bar\line
baz\line
arnold     ttyv0   Jul 13 14:22\line
miriam     ttyp0   Jul 13 14:23     (murphy:0)\line
bill       ttyp1   Jul 13 14:23     (murphy:0)\line
bletch\par
\pard\keep\li720{}}}\par
\pard\f0{}Notice that this program ran the command {\f1{}who} and printed the result.  (If you try this program yourself, you will of course get different results, showing you who is logged in on your system.)\par
\par
\pard{}This variation of {\f1{}getline} splits the record into fields, sets the value of {\f1{}NF} and recomputes the value of {\f1{}$0}.  The values of {\f1{}NR} and {\f1{}FNR} are not changed.\par
\par
\pard{}According to POSIX, {\f1{}{\i expression} | getline} is ambiguous if {\i expression} contains unparenthesized operators other than {\f1{}$}; for example, {\f1{}"echo " "date" | getline} is ambiguous because the concatenation operator is not parenthesized, and you should write it as {\f1{}("echo " "date") | getline} if you want your program to be portable to other {\f1{}awk} implementations.  (It happens that {\f1{}gawk} gets it right, but you should not rely on this. Parentheses make it easier to read, anyway.)\par
\par
\page\pard Node: {\b Getline/Variable/Pipe}, \keepn Next: {\uldb Getline Summary}{\v Getline_Summary}, Prev: {\uldb Getline/Pipe}{\v Getline_Pipe}, Up: {\uldb Getline}{\v Getline}\line
K{\footnote K Getline/Variable/Pipe}
#{\footnote Getline_Variable_Pipe}
${\footnote \pard{}Using {\f1{}getline} Into a Variable from a Pipe}\par
\pard{\fs24\b Using {\f1{}getline} Into a Variable from a Pipe}\par
\par
\pard{}When you use {\f1{}{\i command} | getline {\i var}}, the output of the command {\i command} is sent through a pipe to {\f1{}getline} and into the variable {\i var}.  For example, the following program reads the current date and time into the variable {\f1{}current_time}, using the {\f1{}date} utility, and then prints it.\par
\par
{{\pard\keep\li720\f1{}awk 'BEGIN \'7B\line
     "date" | getline current_time\line
     close("date")\line
     print "Report printed on " current_time\line
\'7D'\par
\pard\keep\li720{}}}\par
\pard\f0{}In this version of {\f1{}getline}, none of the built-in variables are changed, and the record is not split into fields.\par
\par
{\pard{}According to POSIX, {\f1{}{\i expression} | getline {\i var}} is ambiguous if {\i expression} contains unparenthesized operators other than {\f1{}$}; for example, {\f1{}"echo " "date" | getline {\i var}} is ambiguous because the concatenation operator is not parenthesized, and you should write it as {\f1{}("echo " "date") | getline {\i var}} if you want your program to be portable to other {\f1{}awk} implementations.  (It happens that {\f1{}gawk} gets it right, but you should not rely on this. Parentheses make it easier to read, anyway.)  }\par
\par
\page\pard Node: {\b Getline Summary}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Getline/Variable/Pipe}{\v Getline_Variable_Pipe}, Up: {\uldb Getline}{\v Getline}\line
K{\footnote K Getline Summary}
#{\footnote Getline_Summary}
${\footnote \pard{}Summary of {\f1{}getline} Variants}\par
\pard{\fs24\b Summary of {\f1{}getline} Variants}\par
\par
\pard{}With all the forms of {\f1{}getline}, even though {\f1{}$0} and {\f1{}NF}, may be updated, the record will not be tested against all the patterns in the {\f1{}awk} program, in the way that would happen if the record were read normally by the main processing loop of {\f1{}awk}.  However the new record is tested against any subsequent rules.\par
\par
\pard{}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}{K{\footnote K limitations}}{K{\footnote K implementation limits}}Many {\f1{}awk} implementations limit the number of pipelines an {\f1{}awk} program may have open to just one!  In {\f1{}gawk}, there is no such limit.  You can open as many pipelines as the underlying operating system will permit.\par
\par
\pard{}{K{\footnote K FILENAME}}{K{\footnote K dark corner}}{K{\footnote K {\f1{}getline}, setting {\f1{}FILENAME}}}{K{\footnote K {\f1{}FILENAME}, being set by {\f1{}getline}}}An interesting side-effect occurs if you use {\f1{}getline} (without a redirection) inside a {\f1{}BEGIN} rule. Since an unredirected {\f1{}getline} reads from the command line data files, the first {\f1{}getline} command causes {\f1{}awk} to set the value of {\f1{}FILENAME}. Normally, {\f1{}FILENAME} does not have a value inside {\f1{}BEGIN} rules, since you have not yet started to process the command line data files (d.c.).  (See {\uldb The {\f1{}BEGIN} and {\f1{}END} Special Patterns}{\v BEGIN_END}, also see {\uldb Built-in Variables that Convey Information}{\v Auto_set}.)\par
\par
\pard{}The following table summarizes the six variants of {\f1{}getline}, listing which built-in variables are set by each one.\par
\par
{\pard{}{\f1{}getline}\par
\pard\li720{}sets {\f1{}$0}, {\f1{}NF}, {\f1{}FNR}, and {\f1{}NR}.\par
\par
\pard{}{\f1{}getline {\i var}}\par
\pard\li720{}sets {\i var}, {\f1{}FNR}, and {\f1{}NR}.\par
\par
\pard{}{\f1{}getline < {\i file}}\par
\pard\li720{}sets {\f1{}$0}, and {\f1{}NF}.\par
\par
\pard{}{\f1{}getline {\i var} < {\i file}}\par
\pard\li720{}sets {\i var}.\par
\par
\pard{}{\f1{}{\i command} | getline}\par
\pard\li720{}sets {\f1{}$0}, and {\f1{}NF}.\par
\par
\pard{}{\f1{}{\i command} | getline {\i var}}\par
\pard\li720{}sets {\i var}.\par
\pard{}}\par
\page\pard Node: {\b Printing}, \keepn Next: {\uldb Expressions}{\v Expressions}, Prev: {\uldb Reading Files}{\v Reading_Files}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Printing}
#{\footnote Printing}
${\footnote \pard{}Printing Output}\par
\pard{\fs24\b Printing Output}\par
\par
\pard{}{K{\footnote K printing}}{K{\footnote K output}}One of the most common actions is to \'A2print\'A2, or output, some or all of the input.  You use the {\f1{}print} statement for simple output.  You use the {\f1{}printf} statement for fancier formatting.  Both are described in this chapter.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Print}{\v Print}\tab The {\f1{}print} statement.\par
{\uldb Print Examples}{\v Print_Examples}\tab Simple examples of {\f1{}print} statements.\par
{\uldb Output Separators}{\v Output_Separators}\tab The output separators and how to change them.\par
{\uldb OFMT}{\v OFMT}\tab Controlling Numeric Output With {\f1{}print}.\par
{\uldb Printf}{\v Printf}\tab The {\f1{}printf} statement.\par
{\uldb Redirection}{\v Redirection}\tab How to redirect output to multiple files and pipes.\par
{\uldb Special Files}{\v Special_Files}\tab File name interpretation in {\f1{}gawk}. {\f1{}gawk} allows access to inherited file descriptors.\par
{\uldb Close Files And Pipes}{\v Close_Files_And_Pipes}\tab Closing Input and Output Files and Pipes.\par
\pard{}}\par
\page\pard Node: {\b Print}, \keepn Next: {\uldb Print Examples}{\v Print_Examples}, Prev: {\uldb Printing}{\v Printing}, Up: {\uldb Printing}{\v Printing}\line
K{\footnote K Print}
#{\footnote Print}
${\footnote \pard{}The {\f1{}print} Statement}\par
\pard{\fs24\b The {\f1{}print} Statement}\par
\par
\pard{}{K{\footnote K {\f1{}print} statement}} The {\f1{}print} statement does output with simple, standardized formatting.  You specify only the strings or numbers to be printed, in a list separated by commas.  They are output, separated by single spaces, followed by a newline.  The statement looks like this:\par
\par
{\pard\keep\li720\f1{}print {\i item1}, {\i item2}, ...\par
\pard\f0{}}\par
\pard{}The entire list of items may optionally be enclosed in parentheses.  The parentheses are necessary if any of the item expressions uses the {\f1{}>} relational operator; otherwise it could be confused with a redirection (see {\uldb Redirecting Output of {\f1{}print} and {\f1{}printf}}{\v Redirection}).\par
\par
\pard{}The items to be printed can be constant strings or numbers, fields of the current record (such as {\f1{}$1}), variables, or any {\f1{}awk} expressions.  Numeric values are converted to strings, and then printed.\par
\par
\pard{}The {\f1{}print} statement is completely general for computing {\i what} values to print. However, with two exceptions, you cannot specify {\i how} to print them--how many columns, whether to use exponential notation or not, and so on.  (For the exceptions, see {\uldb Output Separators}{\v Output_Separators}, and {\uldb Controlling Numeric Output with {\f1{}print}}{\v OFMT}.)  For that, you need the {\f1{}printf} statement (see {\uldb Using {\f1{}printf} Statements for Fancier Printing}{\v Printf}).\par
\par
\pard{}The simple statement {\f1{}print} with no items is equivalent to {\f1{}print $0}: it prints the entire current record.  To print a blank line, use {\f1{}print ""}, where {\f1{}""} is the empty string.\par
\par
\pard{}To print a fixed piece of text, use a string constant such as {\f1{}"Don't Panic"} as one item.  If you forget to use the double-quote characters, your text will be taken as an {\f1{}awk} expression, and you will probably get an error.  Keep in mind that a space is printed between any two items.\par
\par
\pard{}Each {\f1{}print} statement makes at least one line of output.  But it isn't limited to one line.  If an item value is a string that contains a newline, the newline is output along with the rest of the string.  A single {\f1{}print} can make any number of lines this way.\par
\par
\page\pard Node: {\b Print Examples}, \keepn Next: {\uldb Output Separators}{\v Output_Separators}, Prev: {\uldb Print}{\v Print}, Up: {\uldb Printing}{\v Printing}\line
K{\footnote K Print Examples}
#{\footnote Print_Examples}
${\footnote \pard{}Examples of {\f1{}print} Statements}\par
\pard{\fs24\b Examples of {\f1{}print} Statements}\par
\par
\pard{}Here is an example of printing a string that contains embedded newlines (the {\f1{}\'5Cn} is an escape sequence, used to represent the newline character; see {\uldb Escape Sequences}{\v Escape_Sequences}):\par
\par
{{\pard\keep\li720\f1{}$ awk 'BEGIN \'7B print "line one\'5Cnline two\'5Cnline three" \'7D'\line
-| line one\line
-| line two\line
-| line three\par
\pard\keep\li720{}}}\par
\pard\f0{}Here is an example that prints the first two fields of each input record, with a space between them:\par
\par
{{\pard\keep\li720\f1{}$ awk '\'7B print $1, $2 \'7D' inventory-shipped\line
-| Jan 13\line
-| Feb 15\line
-| Mar 15\line
...\par
\pard\keep\li720{}}}\par
\pard\f0{}{K{\footnote K common mistakes}}{K{\footnote K mistakes, common}}{K{\footnote K errors, common}}A common mistake in using the {\f1{}print} statement is to omit the comma between two items.  This often has the effect of making the items run together in the output, with no space.  The reason for this is that juxtaposing two string expressions in {\f1{}awk} means to concatenate them.  Here is the same program, without the comma:\par
\par
{{\pard\keep\li720\f1{}$ awk '\'7B print $1 $2 \'7D' inventory-shipped\line
-| Jan13\line
-| Feb15\line
-| Mar15\line
...\par
\pard\keep\li720{}}}\par
\pard\f0{}To someone unfamiliar with the file {\f1{}inventory-shipped}, neither example's output makes much sense.  A heading line at the beginning would make it clearer.  Let's add some headings to our table of months ({\f1{}$1}) and green crates shipped ({\f1{}$2}).  We do this using the {\f1{}BEGIN} pattern (see {\uldb The {\f1{}BEGIN} and {\f1{}END} Special Patterns}{\v BEGIN_END}) to force the headings to be printed only once:\par
\par
{\pard\keep\li720\f1{}awk 'BEGIN \'7B  print "Month Crates"\line
              print "----- ------" \'7D\line
           \'7B  print $1, $2 \'7D' inventory-shipped\par
\pard\f0{}}\par
\pard{}Did you already guess what happens? When run, the program prints the following:\par
\par
{{\pard\keep\li720\f1{}Month Crates\line
----- ------\line
Jan 13\line
Feb 15\line
Mar 15\line
...\par
\pard\keep\li720{}}}\par
\pard\f0{}The headings and the table data don't line up!  We can fix this by printing some spaces between the two fields:\par
\par
{\pard\keep\li720\f1{}awk 'BEGIN \'7B print "Month Crates"\line
             print "----- ------" \'7D\line
           \'7B print $1, "     ", $2 \'7D' inventory-shipped\par
\pard\f0{}}\par
\pard{}You can imagine that this way of lining up columns can get pretty complicated when you have many columns to fix.  Counting spaces for two or three columns can be simple, but more than this and you can get lost quite easily.  This is why the {\f1{}printf} statement was created (see {\uldb Using {\f1{}printf} Statements for Fancier Printing}{\v Printf}); one of its specialties is lining up columns of data.\par
\par
\pard{}{K{\footnote K line continuation}}As a side point, you can continue either a {\f1{}print} or {\f1{}printf} statement simply by putting a newline after any comma (see {\uldb {\f1{}awk} Statements Versus Lines}{\v Statements_Lines}).\par
\par
\page\pard Node: {\b Output Separators}, \keepn Next: {\uldb OFMT}{\v OFMT}, Prev: {\uldb Print Examples}{\v Print_Examples}, Up: {\uldb Printing}{\v Printing}\line
K{\footnote K Output Separators}
#{\footnote Output_Separators}
${\footnote \pard{}Output Separators}\par
\pard{\fs24\b Output Separators}\par
\par
\pard{}{K{\footnote K output field separator, {\f1{}OFS}}}{K{\footnote K output record separator, {\f1{}ORS}}}{K{\footnote K OFS}}{K{\footnote K ORS}}As mentioned previously, a {\f1{}print} statement contains a list of items, separated by commas.  In the output, the items are normally separated by single spaces.  This need not be the case; a single space is only the default.  You can specify any string of characters to use as the \'A2output field separator\'A2 by setting the built-in variable {\f1{}OFS}.  The initial value of this variable is the string {\f1{}" "}, that is, a single space.\par
\par
\pard{}The output from an entire {\f1{}print} statement is called an \'A2output record\'A2.  Each {\f1{}print} statement outputs one output record and then outputs a string called the \'A2output record separator\'A2.  The built-in variable {\f1{}ORS} specifies this string.  The initial value of {\f1{}ORS} is the string {\f1{}"\'5Cn"}, i.e. a newline character; thus, normally each {\f1{}print} statement makes a separate line.\par
\par
\pard{}You can change how output fields and records are separated by assigning new values to the variables {\f1{}OFS} and/or {\f1{}ORS}.  The usual place to do this is in the {\f1{}BEGIN} rule (see {\uldb The {\f1{}BEGIN} and {\f1{}END} Special Patterns}{\v BEGIN_END}), so that it happens before any input is processed.  You may also do this with assignments on the command line, before the names of your input files, or using the {\f1{}-v} command line option (see {\uldb Command Line Options}{\v Options}).\par
\par
\pard{}The following example prints the first and second fields of each input record separated by a semicolon, with a blank line added after each line:\par
\par
{{\pard\keep\li720\f1{}$ awk 'BEGIN \'7B OFS = ";"; ORS = "\'5Cn\'5Cn" \'7D\line
>            \'7B print $1, $2 \'7D' BBS-list\line
-| aardvark;555-5553\line
-|\line
-| alpo-net;555-3412\line
-|\line
-| barfly;555-7685\line
...\par
\pard\keep\li720{}}}\par
\pard\f0{}If the value of {\f1{}ORS} does not contain a newline, all your output will be run together on a single line, unless you output newlines some other way.\par
\par
\page\pard Node: {\b OFMT}, \keepn Next: {\uldb Printf}{\v Printf}, Prev: {\uldb Output Separators}{\v Output_Separators}, Up: {\uldb Printing}{\v Printing}\line
K{\footnote K OFMT}
#{\footnote OFMT}
${\footnote \pard{}Controlling Numeric Output with {\f1{}print}}\par
\pard{\fs24\b Controlling Numeric Output with {\f1{}print}}\par
\par
\pard{}{K{\footnote K OFMT}}{K{\footnote K numeric output format}}{K{\footnote K format, numeric output}}{K{\footnote K output format specifier, {\f1{}OFMT}}}When you use the {\f1{}print} statement to print numeric values, {\f1{}awk} internally converts the number to a string of characters, and prints that string.  {\f1{}awk} uses the {\f1{}sprintf} function to do this conversion (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}).  For now, it suffices to say that the {\f1{}sprintf} function accepts a \'A2format specification\'A2 that tells it how to format numbers (or strings), and that there are a number of different ways in which numbers can be formatted.  The different format specifications are discussed more fully in {\uldb Format-Control Letters}{\v Control_Letters}.\par
\par
\pard{}The built-in variable {\f1{}OFMT} contains the default format specification that {\f1{}print} uses with {\f1{}sprintf} when it wants to convert a number to a string for printing.  The default value of {\f1{}OFMT} is {\f1{}"%.6g"}.  By supplying different format specifications as the value of {\f1{}OFMT}, you can change how {\f1{}print} will print your numbers.  As a brief example:\par
\par
{{\pard\keep\li720\f1{}$ awk 'BEGIN \'7B\line
>   OFMT = "%.0f"  # print numbers as integers (rounds)\line
>   print 17.23 \'7D'\line
-| 17\par
\pard\keep\li720{}}}\par
\pard\f0{}{K{\footnote K dark corner}}{K{\footnote K {\f1{}awk} language, POSIX version}}{K{\footnote K POSIX {\f1{}awk}}}According to the POSIX standard, {\f1{}awk}'s behavior will be undefined if {\f1{}OFMT} contains anything but a floating point conversion specification (d.c.).\par
\par
\page\pard Node: {\b Printf}, \keepn Next: {\uldb Redirection}{\v Redirection}, Prev: {\uldb OFMT}{\v OFMT}, Up: {\uldb Printing}{\v Printing}\line
K{\footnote K Printf}
#{\footnote Printf}
${\footnote \pard{}Using {\f1{}printf} Statements for Fancier Printing}\par
\pard{\fs24\b Using {\f1{}printf} Statements for Fancier Printing}\par
\par
\pard{}{K{\footnote K formatted output}}{K{\footnote K output, formatted}} If you want more precise control over the output format than {\f1{}print} gives you, use {\f1{}printf}.  With {\f1{}printf} you can specify the width to use for each item, and you can specify various formatting choices for numbers (such as what radix to use, whether to print an exponent, whether to print a sign, and how many digits to print after the decimal point).  You do this by supplying a string, called the \'A2format string\'A2, which controls how and where to print the other arguments.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Basic Printf}{\v Basic_Printf}\tab Syntax of the {\f1{}printf} statement.\par
{\uldb Control Letters}{\v Control_Letters}\tab Format-control letters.\par
{\uldb Format Modifiers}{\v Format_Modifiers}\tab Format-specification modifiers.\par
{\uldb Printf Examples}{\v Printf_Examples}\tab Several examples.\par
\pard{}}\par
\page\pard Node: {\b Basic Printf}, \keepn Next: {\uldb Control Letters}{\v Control_Letters}, Prev: {\uldb Printf}{\v Printf}, Up: {\uldb Printf}{\v Printf}\line
K{\footnote K Basic Printf}
#{\footnote Basic_Printf}
${\footnote \pard{}Introduction to the {\f1{}printf} Statement}\par
\pard{\fs24\b Introduction to the {\f1{}printf} Statement}\par
\par
\pard{}{K{\footnote K {\f1{}printf} statement, syntax of}}The {\f1{}printf} statement looks like this:\par
\par
{\pard\keep\li720\f1{}printf {\i format}, {\i item1}, {\i item2}, ...\par
\pard\f0{}}\par
\pard{}The entire list of arguments may optionally be enclosed in parentheses.  The parentheses are necessary if any of the item expressions use the {\f1{}>} relational operator; otherwise it could be confused with a redirection (see {\uldb Redirecting Output of {\f1{}print} and {\f1{}printf}}{\v Redirection}).\par
\par
\pard{}{K{\footnote K format string}}The difference between {\f1{}printf} and {\f1{}print} is the {\i format} argument.  This is an expression whose value is taken as a string; it specifies how to output each of the other arguments.  It is called the \'A2format string\'A2.\par
\par
\pard{}The format string is very similar to that in the ANSI C library function {\f1{}printf}.  Most of {\i format} is text to be output verbatim.  Scattered among this text are \'A2format specifiers\'A2, one per item.  Each format specifier says to output the next item in the argument list at that place in the format.\par
\par
\pard{}The {\f1{}printf} statement does not automatically append a newline to its output.  It outputs only what the format string specifies.  So if you want a newline, you must include one in the format string.  The output separator variables {\f1{}OFS} and {\f1{}ORS} have no effect on {\f1{}printf} statements. For example:\par
\par
{{\pard\keep\li720\f1{}BEGIN \'7B\line
   ORS = "\'5CnOUCH!\'5Cn"; OFS = "!"\line
   msg = "Don't Panic!"; printf "%s\'5Cn", msg\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}This program still prints the familiar {\f1{}Don't Panic!} message.\par
\par
\page\pard Node: {\b Control Letters}, \keepn Next: {\uldb Format Modifiers}{\v Format_Modifiers}, Prev: {\uldb Basic Printf}{\v Basic_Printf}, Up: {\uldb Printf}{\v Printf}\line
K{\footnote K Control Letters}
#{\footnote Control_Letters}
${\footnote \pard{}Format-Control Letters}\par
\pard{\fs24\b Format-Control Letters}\par
\par
\pard{}{K{\footnote K {\f1{}printf}, format-control characters}}{K{\footnote K format specifier}} A format specifier starts with the character {\f1{}%} and ends with a \'A2format-control letter\'A2; it tells the {\f1{}printf} statement how to output one item.  (If you actually want to output a {\f1{}%}, write {\f1{}%%}.)  The format-control letter specifies what kind of value to print.  The rest of the format specifier is made up of optional \'A2modifiers\'A2 which are parameters to use, such as the field width.\par
\par
\pard{}Here is a list of the format-control letters:\par
\par
{\pard{}{\f1{}c}\par
\pard\li720{}This prints a number as an ASCII character.  Thus, {\f1{}printf "%c", 65} outputs the letter {\f1{}A}.  The output for a string value is the first character of the string.\par
\par
\pard{}{\f1{}d}\par
\pard{}{\f1{}i}\par
\pard\li720{}These are equivalent. They both print a decimal integer.  The {\f1{}%i} specification is for compatibility with ANSI C.\par
\par
\pard{}{\f1{}e}\par
\pard{}{\f1{}E}\par
\pard\li720{}This prints a number in scientific (exponential) notation.  For example,\par
\par
{\pard\keep\li1440\f1{}printf "%4.3e\'5Cn", 1950\par
\pard\li720\f0{}}\par
\pard\li720{}prints {\f1{}1.950e+03}, with a total of four significant figures of which three follow the decimal point.  The {\f1{}4.3} are modifiers, discussed below. {\f1{}%E} uses {\f1{}E} instead of {\f1{}e} in the output.\par
\par
\pard{}{\f1{}f}\par
\pard\li720{}This prints a number in floating point notation.  For example,\par
\par
{\pard\keep\li1440\f1{}printf "%4.3f", 1950\par
\pard\li720\f0{}}\par
\pard\li720{}prints {\f1{}1950.000}, with a total of four significant figures of which three follow the decimal point.  The {\f1{}4.3} are modifiers, discussed below.\par
\par
\pard{}{\f1{}g}\par
\pard{}{\f1{}G}\par
\pard\li720{}This prints a number in either scientific notation or floating point notation, whichever uses fewer characters. If the result is printed in scientific notation, {\f1{}%G} uses {\f1{}E} instead of {\f1{}e}.\par
\par
\pard{}{\f1{}o}\par
\pard\li720{}This prints an unsigned octal integer.  (In octal, or base-eight notation, the digits run from {\f1{}0} to {\f1{}7}; the decimal number eight is represented as {\f1{}10} in octal.)\par
\par
\pard{}{\f1{}s}\par
\pard\li720{}This prints a string.\par
\par
\pard{}{\f1{}x}\par
\pard{}{\f1{}X}\par
\pard\li720{}This prints an unsigned hexadecimal integer.  (In hexadecimal, or base-16 notation, the digits are {\f1{}0} through {\f1{}9} and {\f1{}a} through {\f1{}f}.  The hexadecimal digit {\f1{}f} represents the decimal number 15.) {\f1{}%X} uses the letters {\f1{}A} through {\f1{}F} instead of {\f1{}a} through {\f1{}f}.\par
\par
\pard{}{\f1{}%}\par
\pard\li720{}This isn't really a format-control letter, but it does have a meaning when used after a {\f1{}%}: the sequence {\f1{}%%} outputs one {\f1{}%}.  It does not consume an argument, and it ignores any modifiers.\par
\pard{}}\par
\pard{}{K{\footnote K dark corner}}When using the integer format-control letters for values that are outside the range of a C {\f1{}long} integer, {\f1{}gawk} will switch to the {\f1{}%g} format specifier. Other versions of {\f1{}awk} may print invalid values, or do something else entirely (d.c.).\par
\par
\page\pard Node: {\b Format Modifiers}, \keepn Next: {\uldb Printf Examples}{\v Printf_Examples}, Prev: {\uldb Control Letters}{\v Control_Letters}, Up: {\uldb Printf}{\v Printf}\line
K{\footnote K Format Modifiers}
#{\footnote Format_Modifiers}
${\footnote \pard{}Modifiers for {\f1{}printf} Formats}\par
\pard{\fs24\b Modifiers for {\f1{}printf} Formats}\par
\par
\pard{}{K{\footnote K {\f1{}printf}, modifiers}}{K{\footnote K modifiers (in format specifiers)}}A format specification can also include \'A2modifiers\'A2 that can control how much of the item's value is printed and how much space it gets.  The modifiers come between the {\f1{}%} and the format-control letter.  In the examples below, we use the bullet symbol "{\f2\'B7}" to represent spaces in the output. Here are the possible modifiers, in the order in which they may appear:\par
\par
{\pard{}{\f1{}-}\par
\pard\li720{}The minus sign, used before the width modifier (see below), says to left-justify the argument within its specified width.  Normally the argument is printed right-justified in the specified width.  Thus,\par
\par
{\pard\keep\li1440\f1{}printf "%-4s", "foo"\par
\pard\li720\f0{}}\par
\pard\li720{}prints {\f1{}foo{\f2\'B7}}.\par
\par
\pard{}{\f1{}{\i space}}\par
\pard\li720{}For numeric conversions, prefix positive values with a space, and negative values with a minus sign.\par
\par
\pard{}{\f1{}+}\par
\pard\li720{}The plus sign, used before the width modifier (see below), says to always supply a sign for numeric conversions, even if the data to be formatted is positive. The {\f1{}+} overrides the space modifier.\par
\par
\pard{}{\f1{}#}\par
\pard\li720{}Use an "alternate form" for certain control letters.  For {\f1{}%o}, supply a leading zero.  For {\f1{}%x}, and {\f1{}%X}, supply a leading {\f1{}0x} or {\f1{}0X} for a non-zero result.  For {\f1{}%e}, {\f1{}%E}, and {\f1{}%f}, the result will always contain a decimal point.  For {\f1{}%g}, and {\f1{}%G}, trailing zeros are not removed from the result.\par
\par
\pard\li720{}{K{\footnote K dark corner}}\par
\par
\pard{}{\f1{}0}\par
\pard\li720{}A leading {\f1{}0} (zero) acts as a flag, that indicates output should be padded with zeros instead of spaces.  This applies even to non-numeric output formats (d.c.).  This flag only has an effect when the field width is wider than the value to be printed.\par
\par
\pard{}{\f1{}{\i width}}\par
\pard\li720{}This is a number specifying the desired minimum width of a field.  Inserting any number between the {\f1{}%} sign and the format control character forces the field to be expanded to this width.  The default way to do this is to pad with spaces on the left.  For example,\par
\par
{\pard\keep\li1440\f1{}printf "%4s", "foo"\par
\pard\li720\f0{}}\par
\pard\li720{}prints {\f1{}{\f2\'B7}foo}.\par
\par
\pard\li720{}The value of {\i width} is a minimum width, not a maximum.  If the item value requires more than {\i width} characters, it can be as wide as necessary.  Thus,\par
\par
{\pard\keep\li1440\f1{}printf "%4s", "foobar"\par
\pard\li720\f0{}}\par
\pard\li720{}prints {\f1{}foobar}.\par
\par
\pard\li720{}Preceding the {\i width} with a minus sign causes the output to be padded with spaces on the right, instead of on the left.\par
\par
\pard{}{\f1{}.{\i prec}}\par
\pard\li720{}This is a number that specifies the precision to use when printing.  For the {\f1{}e}, {\f1{}E}, and {\f1{}f} formats, this specifies the number of digits you want printed to the right of the decimal point.  For the {\f1{}g}, and {\f1{}G} formats, it specifies the maximum number of significant digits.  For the {\f1{}d}, {\f1{}o}, {\f1{}i}, {\f1{}u}, {\f1{}x}, and {\f1{}X} formats, it specifies the minimum number of digits to print.  For a string, it specifies the maximum number of characters from the string that should be printed.  Thus,\par
\par
{\pard\keep\li1440\f1{}printf "%.4s", "foobar"\par
\pard\li720\f0{}}\par
\pard\li720{}prints {\f1{}foob}.\par
\pard{}}\par
\pard{}The C library {\f1{}printf}'s dynamic {\i width} and {\i prec} capability (for example, {\f1{}"%*.*s"}) is supported.  Instead of supplying explicit {\i width} and/or {\i prec} values in the format string, you pass them in the argument list.  For example:\par
\par
{\pard\keep\li720\f1{}w = 5\line
p = 3\line
s = "abcdefg"\line
printf "%*.*s\'5Cn", w, p, s\par
\pard\f0{}}\par
\pard{}is exactly equivalent to\par
\par
{\pard\keep\li720\f1{}s = "abcdefg"\line
printf "%5.3s\'5Cn", s\par
\pard\f0{}}\par
\pard{}Both programs output {\f1{}{\f2\'B7}{\f2\'B7}abc}.\par
\par
\pard{}Earlier versions of {\f1{}awk} did not support this capability.  If you must use such a version, you may simulate this feature by using concatenation to build up the format string, like so:\par
\par
{\pard\keep\li720\f1{}w = 5\line
p = 3\line
s = "abcdefg"\line
printf "%" w "." p "s\'5Cn", s\par
\pard\f0{}}\par
\pard{}This is not particularly easy to read, but it does work.\par
\par
\pard{}{K{\footnote K {\f1{}awk} language, POSIX version}}{K{\footnote K POSIX {\f1{}awk}}}C programmers may be used to supplying additional {\f1{}l} and {\f1{}h} flags in {\f1{}printf} format strings. These are not valid in {\f1{}awk}.  Most {\f1{}awk} implementations silently ignore these flags.  If {\f1{}--lint} is provided on the command line (see {\uldb Command Line Options}{\v Options}), {\f1{}gawk} will warn about their use. If {\f1{}--posix} is supplied, their use is a fatal error.\par
\par
\page\pard Node: {\b Printf Examples}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Format Modifiers}{\v Format_Modifiers}, Up: {\uldb Printf}{\v Printf}\line
K{\footnote K Printf Examples}
#{\footnote Printf_Examples}
${\footnote \pard{}Examples Using {\f1{}printf}}\par
\pard{\fs24\b Examples Using {\f1{}printf}}\par
\par
\pard{}Here is how to use {\f1{}printf} to make an aligned table:\par
\par
{\pard\keep\li720\f1{}awk '\'7B printf "%-10s %s\'5Cn", $1, $2 \'7D' BBS-list\par
\pard\f0{}}\par
\pard{}prints the names of bulletin boards ({\f1{}$1}) of the file {\f1{}BBS-list} as a string of 10 characters, left justified.  It also prints the phone numbers ({\f1{}$2}) afterward on the line.  This produces an aligned two-column table of names and phone numbers:\par
\par
{{\pard\keep\li720\f1{}$ awk '\'7B printf "%-10s %s\'5Cn", $1, $2 \'7D' BBS-list\line
-| aardvark   555-5553\line
-| alpo-net   555-3412\line
-| barfly     555-7685\line
-| bites      555-1675\line
-| camelot    555-0542\line
-| core       555-2912\line
-| fooey      555-1234\line
-| foot       555-6699\line
-| macfoo     555-6480\line
-| sdace      555-3430\line
-| sabafoo    555-2127\par
\pard\keep\li720{}}}\par
\pard\f0{}Did you notice that we did not specify that the phone numbers be printed as numbers?  They had to be printed as strings because the numbers are separated by a dash.  If we had tried to print the phone numbers as numbers, all we would have gotten would have been the first three digits, {\f1{}555}.  This would have been pretty confusing.\par
\par
\pard{}We did not specify a width for the phone numbers because they are the last things on their lines.  We don't need to put spaces after them.\par
\par
\pard{}We could make our table look even nicer by adding headings to the tops of the columns.  To do this, we use the {\f1{}BEGIN} pattern (see {\uldb The {\f1{}BEGIN} and {\f1{}END} Special Patterns}{\v BEGIN_END}) to force the header to be printed only once, at the beginning of the {\f1{}awk} program:\par
\par
{{\pard\keep\li720\f1{}awk 'BEGIN \'7B print "Name      Number"\line
             print "----      ------" \'7D\line
     \'7B printf "%-10s %s\'5Cn", $1, $2 \'7D' BBS-list\par
\pard\keep\li720{}}}\par
\pard\f0{}Did you notice that we mixed {\f1{}print} and {\f1{}printf} statements in the above example?  We could have used just {\f1{}printf} statements to get the same results:\par
\par
{{\pard\keep\li720\f1{}awk 'BEGIN \'7B printf "%-10s %s\'5Cn", "Name", "Number"\line
             printf "%-10s %s\'5Cn", "----", "------" \'7D\line
     \'7B printf "%-10s %s\'5Cn", $1, $2 \'7D' BBS-list\par
\pard\keep\li720{}}}\par
\pard\f0{}By printing each column heading with the same format specification used for the elements of the column, we have made sure that the headings are aligned just like the columns.\par
\par
\pard{}The fact that the same format specification is used three times can be emphasized by storing it in a variable, like this:\par
\par
{{\pard\keep\li720\f1{}awk 'BEGIN \'7B format = "%-10s %s\'5Cn"\line
             printf format, "Name", "Number"\line
             printf format, "----", "------" \'7D\line
     \'7B printf format, $1, $2 \'7D' BBS-list\par
\pard\keep\li720{}}}\par
\pard\f0{}See if you can use the {\f1{}printf} statement to line up the headings and table data for our {\f1{}inventory-shipped} example covered earlier in the section on the {\f1{}print} statement (see {\uldb The {\f1{}print} Statement}{\v Print}).\par
\par
\page\pard Node: {\b Redirection}, \keepn Next: {\uldb Special Files}{\v Special_Files}, Prev: {\uldb Printf}{\v Printf}, Up: {\uldb Printing}{\v Printing}\line
K{\footnote K Redirection}
#{\footnote Redirection}
${\footnote \pard{}Redirecting Output of {\f1{}print} and {\f1{}printf}}\par
\pard{\fs24\b Redirecting Output of {\f1{}print} and {\f1{}printf}}\par
\par
\pard{}{K{\footnote K output redirection}}{K{\footnote K redirection of output}}So far we have been dealing only with output that prints to the standard output, usually your terminal.  Both {\f1{}print} and {\f1{}printf} can also send their output to other places.  This is called \'A2redirection\'A2.\par
\par
\pard{}A redirection appears after the {\f1{}print} or {\f1{}printf} statement.  Redirections in {\f1{}awk} are written just like redirections in shell commands, except that they are written inside the {\f1{}awk} program.\par
\par
\pard{}There are three forms of output redirection: output to a file, output appended to a file, and output through a pipe to another command.  They are all shown for the {\f1{}print} statement, but they work identically for {\f1{}printf} also.\par
\par
{\pard{}{\f1{}print {\i items} > {\i output-file}}\par
\pard\li720{}This type of redirection prints the items into the output file {\i output-file}.  The file name {\i output-file} can be any expression.  Its value is changed to a string and then used as a file name (see {\uldb Expressions}{\v Expressions}).\par
\par
\pard\li720{}When this type of redirection is used, the {\i output-file} is erased before the first output is written to it.  Subsequent writes to the same {\i output-file} do not erase {\i output-file}, but append to it.  If {\i output-file} does not exist, then it is created.\par
\par
\pard\li720{}For example, here is how an {\f1{}awk} program can write a list of BBS names to a file {\f1{}name-list} and a list of phone numbers to a file {\f1{}phone-list}.  Each output file contains one name or number per line.\par
\par
{{\pard\keep\li1440\f1{}$ awk '\'7B print $2 > "phone-list"\line
>        print $1 > "name-list" \'7D' BBS-list\par
\pard\keep\li1440{}}{$ cat phone-list\line
-| 555-5553\line
-| 555-3412\line
...\par
\pard\keep\li1440{}}{$ cat name-list\line
-| aardvark\line
-| alpo-net\line
...\par
\pard\keep\li1440{}}}\par
\pard\f0{}{\f1{}print {\i items} >> {\i output-file}}\par
\pard\li720{}This type of redirection prints the items into the pre-existing output file {\i output-file}.  The difference between this and the single-{\f1{}>} redirection is that the old contents (if any) of {\i output-file} are not erased.  Instead, the {\f1{}awk} output is appended to the file.  If {\i output-file} does not exist, then it is created.\par
\par
\pard\li720{}{K{\footnote K pipes for output}}{K{\footnote K output, piping}}\par
\par
\pard{}{\f1{}print {\i items} | {\i command}}\par
\pard\li720{}It is also possible to send output to another program through a pipe instead of into a file.   This type of redirection opens a pipe to {\i command} and writes the values of {\i items} through this pipe, to another process created to execute {\i command}.\par
\par
\pard\li720{}The redirection argument {\i command} is actually an {\f1{}awk} expression.  Its value is converted to a string, whose contents give the shell command to be run.\par
\par
\pard\li720{}For example, this produces two files, one unsorted list of BBS names and one list sorted in reverse alphabetical order:\par
\par
{\pard\keep\li1440\f1{}awk '\'7B print $1 > "names.unsorted"\line
       command = "sort -r > names.sorted"\line
       print $1 | command \'7D' BBS-list\par
\pard\li720\f0{}}\par
\pard\li720{}Here the unsorted list is written with an ordinary redirection while the sorted list is written by piping through the {\f1{}sort} utility.\par
\par
\pard\li720{}This example uses redirection to mail a message to a mailing list {\f1{}bug-system}.  This might be useful when trouble is encountered in an {\f1{}awk} script run periodically for system maintenance.\par
\par
{\pard\keep\li1440\f1{}report = "mail bug-system"\line
print "Awk script failed:", $0 | report\line
m = ("at record number " FNR " of " FILENAME)\line
print m | report\line
close(report)\par
\pard\li720\f0{}}\par
\pard\li720{}The message is built using string concatenation and saved in the variable {\f1{}m}.  It is then sent down the pipeline to the {\f1{}mail} program.\par
\par
\pard\li720{}We call the {\f1{}close} function here because it's a good idea to close the pipe as soon as all the intended output has been sent to it.  See {\uldb Closing Input and Output Files and Pipes}{\v Close_Files_And_Pipes}, for more information on this.  This example also illustrates the use of a variable to represent a {\i file} or {\i command}: it is not necessary to always use a string constant.  Using a variable is generally a good idea, since {\f1{}awk} requires you to spell the string value identically every time.\par
\pard{}}\par
\pard{}Redirecting output using {\f1{}>}, {\f1{}>>}, or {\f1{}|} asks the system to open a file or pipe only if the particular {\i file} or {\i command} you've specified has not already been written to by your program, or if it has been closed since it was last written to.\par
\par
\pard{}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}{K{\footnote K limitations}}{K{\footnote K implementation limits}}{Many }{\f1{}awk} implementations limit the number of pipelines an {\f1{}awk} program may have open to just one!  In {\f1{}gawk}, there is no such limit.  You can open as many pipelines as the underlying operating system will permit.\par
\par
\page\pard Node: {\b Special Files}, \keepn Next: {\uldb Close Files And Pipes}{\v Close_Files_And_Pipes}, Prev: {\uldb Redirection}{\v Redirection}, Up: {\uldb Printing}{\v Printing}\line
K{\footnote K Special Files}
#{\footnote Special_Files}
${\footnote \pard{}Special File Names in {\f1{}gawk}}\par
\pard{\fs24\b Special File Names in {\f1{}gawk}}\par
\par
\pard{}{K{\footnote K standard input}}{K{\footnote K standard output}}{K{\footnote K standard error output}}{K{\footnote K file descriptors}} Running programs conventionally have three input and output streams already available to them for reading and writing.  These are known as the \'A2standard input\'A2, \'A2standard output\'A2, and \'A2standard error output\'A2.  These streams are, by default, connected to your terminal, but they are often redirected with the shell, via the {\f1{}<}, {\f1{}<<}, {\f1{}>}, {\f1{}>>}, {\f1{}>&} and {\f1{}|} operators.  Standard error is typically used for writing error messages; the reason we have two separate streams, standard output and standard error, is so that they can be redirected separately.\par
\par
\pard{}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}In other implementations of {\f1{}awk}, the only way to write an error message to standard error in an {\f1{}awk} program is as follows:\par
\par
{\pard\keep\li720\f1{}print "Serious error detected!" | "cat 1>&2"\par
\pard\f0{}}\par
\pard{}This works by opening a pipeline to a shell command which can access the standard error stream which it inherits from the {\f1{}awk} process.  This is far from elegant, and is also inefficient, since it requires a separate process.  So people writing {\f1{}awk} programs often neglect to do this.  Instead, they send the error messages to the terminal, like this:\par
\par
{{\pard\keep\li720\f1{}print "Serious error detected!" > "/dev/tty"\par
\pard\keep\li720{}}}\par
\pard\f0{}This usually has the same effect, but not always: although the standard error stream is usually the terminal, it can be redirected, and when that happens, writing to the terminal is not correct.  In fact, if {\f1{}awk} is run from a background job, it may not have a terminal at all.  Then opening {\f1{}/dev/tty} will fail.\par
\par
{\f1{}\pard{}gawk} provides special file names for accessing the three standard streams.  When you redirect input or output in {\f1{}gawk}, if the file name matches one of these special names, then {\f1{}gawk} directly uses the stream it stands for.\par
\par
\pard{}{K{\footnote K {\f1{}/dev/stdin}}}{K{\footnote K {\f1{}/dev/stdout}}}{K{\footnote K {\f1{}/dev/stderr}}}{K{\footnote K {\f1{}/dev/fd}}}{\par
\pard{}{\f1{}/dev/stdin}\par
\pard\li720{}The standard input (file descriptor 0).\par
\par
\pard{}{\f1{}/dev/stdout}\par
\pard\li720{}The standard output (file descriptor 1).\par
\par
\pard{}{\f1{}/dev/stderr}\par
\pard\li720{}The standard error output (file descriptor 2).\par
\par
\pard{}{\f1{}/dev/fd/{\i N}}\par
\pard\li720{}The file associated with file descriptor {\i N}.  Such a file must have been opened by the program initiating the {\f1{}awk} execution (typically the shell).  Unless you take special pains in the shell from which you invoke {\f1{}gawk}, only descriptors 0, 1 and 2 are available.\par
\pard{}}\par
\pard{}The file names {\f1{}/dev/stdin}, {\f1{}/dev/stdout}, and {\f1{}/dev/stderr} are aliases for {\f1{}/dev/fd/0}, {\f1{}/dev/fd/1}, and {\f1{}/dev/fd/2}, respectively, but they are more self-explanatory.\par
\par
\pard{}The proper way to write an error message in a {\f1{}gawk} program is to use {\f1{}/dev/stderr}, like this:\par
\par
{\pard\keep\li720\f1{}print "Serious error detected!" > "/dev/stderr"\par
\pard\f0{}}\par
{\f1{}\pard{}gawk} also provides special file names that give access to information about the running {\f1{}gawk} process.  Each of these "files" provides a single record of information.  To read them more than once, you must first close them with the {\f1{}close} function (see {\uldb Closing Input and Output Files and Pipes}{\v Close_Files_And_Pipes}).  The filenames are:\par
\par
\pard{}{K{\footnote K process information}}{K{\footnote K {\f1{}/dev/pid}}}{K{\footnote K {\f1{}/dev/pgrpid}}}{K{\footnote K {\f1{}/dev/ppid}}}{K{\footnote K {\f1{}/dev/user}}}{\par
\pard{}{\f1{}/dev/pid}\par
\pard\li720{}Reading this file returns the process ID of the current process, in decimal, terminated with a newline.\par
\par
\pard{}{\f1{}/dev/ppid}\par
\pard\li720{}Reading this file returns the parent process ID of the current process, in decimal, terminated with a newline.\par
\par
\pard{}{\f1{}/dev/pgrpid}\par
\pard\li720{}Reading this file returns the process group ID of the current process, in decimal, terminated with a newline.\par
\par
\pard{}{\f1{}/dev/user}\par
\pard\li720{}Reading this file returns a single record terminated with a newline.  The fields are separated with spaces.  The fields represent the following information:\par
\par
{\pard\li720{}{\f1{}$1}\par
\pard\li1440{}The return value of the {\f1{}getuid} system call (the real user ID number).\par
\par
\pard\li720{}{\f1{}$2}\par
\pard\li1440{}The return value of the {\f1{}geteuid} system call (the effective user ID number).\par
\par
\pard\li720{}{\f1{}$3}\par
\pard\li1440{}The return value of the {\f1{}getgid} system call (the real group ID number).\par
\par
\pard\li720{}{\f1{}$4}\par
\pard\li1440{}The return value of the {\f1{}getegid} system call (the effective group ID number).\par
\pard\li720{}}\par
\pard\li720{}If there are any additional fields, they are the group IDs returned by {\f1{}getgroups} system call.  (Multiple groups may not be supported on all systems.)\par
\pard{}}\par
\pard{}These special file names may be used on the command line as data files, as well as for I/O redirections within an {\f1{}awk} program.  They may not be used as source files with the {\f1{}-f} option.\par
\par
\pard{}Recognition of these special file names is disabled if {\f1{}gawk} is in compatibility mode (see {\uldb Command Line Options}{\v Options}).\par
\par
{\b \pard{}Caution}:  Unless your system actually has a {\f1{}/dev/fd} directory (or any of the other above listed special files), the interpretation of these file names is done by {\f1{}gawk} itself.  For example, using {\f1{}/dev/fd/4} for output will actually write on file descriptor 4, and not on a new file descriptor that was {\f1{}dup}'ed from file descriptor 4.  Most of the time this does not matter; however, it is important to {\i not} close any of the files related to file descriptors 0, 1, and 2.  If you do close one of these files, unpredictable behavior will result.\par
\par
\pard{}The special files that provide process-related information may disappear in a future version of {\f1{}gawk}.  See {\uldb Probable Future Extensions}{\v Future_Extensions}.\par
\par
\page\pard Node: {\b Close Files And Pipes}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Special Files}{\v Special_Files}, Up: {\uldb Printing}{\v Printing}\line
K{\footnote K Close Files And Pipes}
#{\footnote Close_Files_And_Pipes}
${\footnote \pard{}Closing Input and Output Files and Pipes}\par
\pard{\fs24\b Closing Input and Output Files and Pipes}\par
\par
\pard{}{K{\footnote K closing input files and pipes}}{K{\footnote K closing output files and pipes}}{K{\footnote K close}} If the same file name or the same shell command is used with {\f1{}getline} (see {\uldb Explicit Input with {\f1{}getline}}{\v Getline}) more than once during the execution of an {\f1{}awk} program, the file is opened (or the command is executed) only the first time.  At that time, the first record of input is read from that file or command.  The next time the same file or command is used in {\f1{}getline}, another record is read from it, and so on.\par
\par
\pard{}Similarly, when a file or pipe is opened for output, the file name or command associated with it is remembered by {\f1{}awk} and subsequent writes to the same file or command are appended to the previous writes.  The file or pipe stays open until {\f1{}awk} exits.\par
\par
\pard{}This implies that if you want to start reading the same file again from the beginning, or if you want to rerun a shell command (rather than reading more output from the command), you must take special steps.  What you must do is use the {\f1{}close} function, as follows:\par
\par
{\pard\keep\li720\f1{}close({\i filename})\par
\pard\f0{}}\par
\pard{}or\par
\par
{\pard\keep\li720\f1{}close({\i command})\par
\pard\f0{}}\par
\pard{}The argument {\i filename} or {\i command} can be any expression.  Its value must {\i exactly} match the string that was used to open the file or start the command (spaces and other "irrelevant" characters included). For example, if you open a pipe with this:\par
\par
{\pard\keep\li720\f1{}"sort -r names" | getline foo\par
\pard\f0{}}\par
\pard{}then you must close it with this:\par
\par
{\pard\keep\li720\f1{}close("sort -r names")\par
\pard\f0{}}\par
\pard{}Once this function call is executed, the next {\f1{}getline} from that file or command, or the next {\f1{}print} or {\f1{}printf} to that file or command, will reopen the file or rerun the command.\par
\par
\pard{}Because the expression that you use to close a file or pipeline must exactly match the expression used to open the file or run the command, it is good practice to use a variable to store the file name or command.  The previous example would become\par
\par
{\pard\keep\li720\f1{}sortcom = "sort -r names"\line
sortcom | getline foo\line
...\line
close(sortcom)\par
\pard\f0{}}\par
\pard{}This helps avoid hard-to-find typographical errors in your {\f1{}awk} programs.\par
\par
\pard{}Here are some reasons why you might need to close an output file:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}To write a file and read it back later on in the same {\f1{}awk} program.  Close the file when you are finished writing it; then you can start reading it with {\f1{}getline}.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}To write numerous files, successively, in the same {\f1{}awk} program.  If you don't close the files, eventually you may exceed a system limit on the number of open files in one process.  So close each one when you are finished writing it.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}To make a command finish.  When you redirect output through a pipe, the command reading the pipe normally continues to try to read input as long as the pipe is open.  Often this means the command cannot really do its work until the pipe is closed.  For example, if you redirect output to the {\f1{}mail} program, the message is not actually sent until the pipe is closed.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}To run the same program a second time, with the same arguments.  This is not the same thing as giving more input to the first run!\par
\par
\pard\li720{}For example, suppose you pipe output to the {\f1{}mail} program.  If you output several lines redirected to this pipe without closing it, they make a single message of several lines.  By contrast, if you close the pipe after each line of output, then each line makes a separate message.\par
\pard{}}\par
\pard{}{K{\footnote K ERRNO}}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}{\f1{}close} returns a value of zero if the close succeeded.  Otherwise, the value will be non-zero.  In this case, {\f1{}gawk} sets the variable {\f1{}ERRNO} to a string describing the error that occurred.\par
\par
\pard{}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}{K{\footnote K portability issues}}If you use more files than the system allows you to have open, {\f1{}gawk} will attempt to multiplex the available open files among your data files.  {\f1{}gawk}'s ability to do this depends upon the facilities of your operating system: it may not always work.  It is therefore both good practice and good portability advice to always use {\f1{}close} on your files when you are done with them.\par
\par
\page\pard Node: {\b Expressions}, \keepn Next: {\uldb Patterns and Actions}{\v Patterns_and_Actions}, Prev: {\uldb Printing}{\v Printing}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Expressions}
#{\footnote Expressions}
${\footnote \pard{}Expressions}\par
\pard{\fs24\b Expressions}\par
\par
\pard{}{K{\footnote K expression}} Expressions are the basic building blocks of {\f1{}awk} patterns and actions.  An expression evaluates to a value, which you can print, test, store in a variable or pass to a function.  Additionally, an expression can assign a new value to a variable or a field, with an assignment operator.\par
\par
\pard{}An expression can serve as a pattern or action statement on its own.  Most other kinds of statements contain one or more expressions which specify data on which to operate.  As in other languages, expressions in {\f1{}awk} include variables, array references, constants, and function calls, as well as combinations of these with various operators.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Constants}{\v Constants}\tab String, numeric, and regexp constants.\par
{\uldb Using Constant Regexps}{\v Using_Constant_Regexps}\tab When and how to use a regexp constant.\par
{\uldb Variables}{\v Variables}\tab Variables give names to values for later use.\par
{\uldb Conversion}{\v Conversion}\tab The conversion of strings to numbers and vice versa.\par
{\uldb Arithmetic Ops}{\v Arithmetic_Ops}\tab Arithmetic operations ({\f1{}+}, {\f1{}-}, etc.)\par
{\uldb Concatenation}{\v Concatenation}\tab Concatenating strings.\par
{\uldb Assignment Ops}{\v Assignment_Ops}\tab Changing the value of a variable or a field.\par
{\uldb Increment Ops}{\v Increment_Ops}\tab Incrementing the numeric value of a variable.\par
{\uldb Truth Values}{\v Truth_Values}\tab What is ``true'' and what is ``false''.\par
{\uldb Typing and Comparison}{\v Typing_and_Comparison}\tab How variables acquire types, and how this affects comparison of numbers and strings with {\f1{}<}, etc.\par
{\uldb Boolean Ops}{\v Boolean_Ops}\tab Combining comparison expressions using boolean operators {\f1{}||} (``or''), {\f1{}&&} (``and'') and {\f1{}!} (``not'').\par
{\uldb Conditional Exp}{\v Conditional_Exp}\tab Conditional expressions select between two subexpressions under control of a third subexpression.\par
{\uldb Function Calls}{\v Function_Calls}\tab A function call is an expression.\par
{\uldb Precedence}{\v Precedence}\tab How various operators nest.\par
\pard{}}\par
\page\pard Node: {\b Constants}, \keepn Next: {\uldb Using Constant Regexps}{\v Using_Constant_Regexps}, Prev: {\uldb Expressions}{\v Expressions}, Up: {\uldb Expressions}{\v Expressions}\line
K{\footnote K Constants}
#{\footnote Constants}
${\footnote \pard{}Constant Expressions}\par
\pard{\fs24\b Constant Expressions}\par
\par
\pard{}{K{\footnote K constants, types of}}{K{\footnote K string constants}} The simplest type of expression is the \'A2constant\'A2, which always has the same value.  There are three types of constants: numeric constants, string constants, and regular expression constants.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Scalar Constants}{\v Scalar_Constants}\tab Numeric and string constants.\par
{\uldb Regexp Constants}{\v Regexp_Constants}\tab Regular Expression constants.\par
\pard{}}\par
\page\pard Node: {\b Scalar Constants}, \keepn Next: {\uldb Regexp Constants}{\v Regexp_Constants}, Prev: {\uldb Constants}{\v Constants}, Up: {\uldb Constants}{\v Constants}\line
K{\footnote K Scalar Constants}
#{\footnote Scalar_Constants}
${\footnote \pard{}Numeric and String Constants}\par
\pard{\fs24\b Numeric and String Constants}\par
\par
\pard{}{K{\footnote K numeric constant}}{K{\footnote K numeric value}}A \'A2numeric constant\'A2 stands for a number.  This number can be an integer, a decimal fraction, or a number in scientific (exponential) notation.({\ul 1}{\v Scalar_Constants_1}) Here are some examples of numeric constants, which all have the same value:\par
\par
{\pard\keep\li720\f1{}105\line
1.05e+2\line
1050e-1\par
\pard\f0{}}\par
\pard{}A string constant consists of a sequence of characters enclosed in double-quote marks.  For example:\par
\par
{\pard\keep\li720\f1{}"parrot"\par
\pard\f0{}}\par
\pard{}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}represents the string whose contents are {\f1{}parrot}.  Strings in {\f1{}gawk} can be of any length and they can contain any of the possible eight-bit ASCII characters including ASCII NUL (character code zero).  Other {\f1{}awk} implementations may have difficulty with some character codes.\par
\par
\page\pard#{\footnote Scalar_Constants_1}
\pard{}(1) The internal representation uses double-precision floating point numbers. If you don't know what that means, then don't worry about it.\par
\par
\page\pard Node: {\b Regexp Constants}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Scalar Constants}{\v Scalar_Constants}, Up: {\uldb Constants}{\v Constants}\line
K{\footnote K Regexp Constants}
#{\footnote Regexp_Constants}
${\footnote \pard{}Regular Expression Constants}\par
\pard{\fs24\b Regular Expression Constants}\par
\par
\pard{}{K{\footnote K {\f1{}~} operator}}{K{\footnote K {\f1{}!~} operator}}A regexp constant is a regular expression description enclosed in slashes, such as {\f1{}/^beginning and end$/}.  Most regexps used in {\f1{}awk} programs are constant, but the {\f1{}~} and {\f1{}!~} matching operators can also match computed or "dynamic" regexps (which are just ordinary strings or variables that contain a regexp).\par
\par
\page\pard Node: {\b Using Constant Regexps}, \keepn Next: {\uldb Variables}{\v Variables}, Prev: {\uldb Constants}{\v Constants}, Up: {\uldb Expressions}{\v Expressions}\line
K{\footnote K Using Constant Regexps}
#{\footnote Using_Constant_Regexps}
${\footnote \pard{}Using Regular Expression Constants}\par
\pard{\fs24\b Using Regular Expression Constants}\par
\par
\pard{}When used on the right hand side of the {\f1{}~} or {\f1{}!~} operators, a regexp constant merely stands for the regexp that is to be matched.\par
\par
\pard{}{K{\footnote K dark corner}}Regexp constants (such as {\f1{}/foo/}) may be used like simple expressions.  When a regexp constant appears by itself, it has the same meaning as if it appeared in a pattern, i.e. {\f1{}($0 ~ /foo/)} (d.c.)  (see {\uldb Expressions as Patterns}{\v Expression_Patterns}).  This means that the two code segments,\par
\par
{\pard\keep\li720\f1{}if ($0 ~ /barfly/ || $0 ~ /camelot/)\line
    print "found"\par
\pard\f0{}}\par
\pard{}and\par
\par
{\pard\keep\li720\f1{}if (/barfly/ || /camelot/)\line
    print "found"\par
\pard\f0{}}\par
\pard{}are exactly equivalent.\par
\par
\pard{}One rather bizarre consequence of this rule is that the following boolean expression is valid, but does not do what the user probably intended:\par
\par
{\pard\keep\li720\f1{}# note that /foo/ is on the left of the ~\line
if (/foo/ ~ $1) print "found foo"\par
\pard\f0{}}\par
\pard{}This code is "obviously" testing {\f1{}$1} for a match against the regexp {\f1{}/foo/}.  But in fact, the expression {\f1{}/foo/ ~ $1} actually means {\f1{}($0 ~ /foo/) ~ $1}.  In other words, first match the input record against the regexp {\f1{}/foo/}.  The result will be either zero or one, depending upon the success or failure of the match.  Then match that result against the first field in the record.\par
\par
\pard{}Since it is unlikely that you would ever really wish to make this kind of test, {\f1{}gawk} will issue a warning when it sees this construct in a program.\par
\par
\pard{}Another consequence of this rule is that the assignment statement\par
\par
{\pard\keep\li720\f1{}matches = /foo/\par
\pard\f0{}}\par
\pard{}will assign either zero or one to the variable {\f1{}matches}, depending upon the contents of the current input record.\par
\par
\pard{}This feature of the language was never well documented until the POSIX specification.\par
\par
\pard{}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}{K{\footnote K dark corner}}Constant regular expressions are also used as the first argument for the {\f1{}gensub}, {\f1{}sub} and {\f1{}gsub} functions, and as the second argument of the {\f1{}match} function (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}).  Modern implementations of {\f1{}awk}, including {\f1{}gawk}, allow the third argument of {\f1{}split} to be a regexp constant, while some older implementations do not (d.c.).\par
\par
\pard{}This can lead to confusion when attempting to use regexp constants as arguments to user defined functions (see {\uldb User-defined Functions}{\v User_defined}).  For example:\par
\par
{{\pard\keep\li720\f1{}function mysub(pat, repl, str, global)\line
\'7B\line
    if (global)\line
        gsub(pat, repl, str)\line
    else\line
        sub(pat, repl, str)\line
    return str\line
\'7D\par
\pard\keep\li720{}}\line
{\'7B\line
    ...\line
    text = "hi! hi yourself!"\line
    mysub(/hi/, "howdy", text, 1)\line
    ...\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}In this example, the programmer wishes to pass a regexp constant to the user-defined function {\f1{}mysub}, which will in turn pass it on to either {\f1{}sub} or {\f1{}gsub}.  However, what really happens is that the {\f1{}pat} parameter will be either one or zero, depending upon whether or not {\f1{}$0} matches {\f1{}/hi/}.\par
\par
\pard{}As it is unlikely that you would ever really wish to pass a truth value in this way, {\f1{}gawk} will issue a warning when it sees a regexp constant used as a parameter to a user-defined function.\par
\par
\page\pard Node: {\b Variables}, \keepn Next: {\uldb Conversion}{\v Conversion}, Prev: {\uldb Using Constant Regexps}{\v Using_Constant_Regexps}, Up: {\uldb Expressions}{\v Expressions}\line
K{\footnote K Variables}
#{\footnote Variables}
${\footnote \pard{}Variables}\par
\pard{\fs24\b Variables}\par
\par
\pard{}Variables are ways of storing values at one point in your program for use later in another part of your program.  You can manipulate them entirely within your program text, and you can also assign values to them on the {\f1{}awk} command line.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Using Variables}{\v Using_Variables}\tab Using variables in your programs.\par
{\uldb Assignment Options}{\v Assignment_Options}\tab Setting variables on the command line and a summary of command line syntax. This is an advanced method of input.\par
\pard{}}\par
\page\pard Node: {\b Using Variables}, \keepn Next: {\uldb Assignment Options}{\v Assignment_Options}, Prev: {\uldb Variables}{\v Variables}, Up: {\uldb Variables}{\v Variables}\line
K{\footnote K Using Variables}
#{\footnote Using_Variables}
${\footnote \pard{}Using Variables in a Program}\par
\pard{\fs24\b Using Variables in a Program}\par
\par
\pard{}{K{\footnote K variables, user-defined}}{K{\footnote K user-defined variables}}Variables let you give names to values and refer to them later.  You have already seen variables in many of the examples.  The name of a variable must be a sequence of letters, digits and underscores, but it may not begin with a digit.  Case is significant in variable names; {\f1{}a} and {\f1{}A} are distinct variables.\par
\par
\pard{}A variable name is a valid expression by itself; it represents the variable's current value.  Variables are given new values with \'A2assignment operators\'A2, \'A2increment operators\'A2 and \'A2decrement operators\'A2.  See {\uldb Assignment Expressions}{\v Assignment_Ops}.\par
\par
\pard{}A few variables have special built-in meanings, such as {\f1{}FS}, the field separator, and {\f1{}NF}, the number of fields in the current input record.  See {\uldb Built-in Variables}{\v Built_in_Variables}, for a list of them.  These built-in variables can be used and assigned just like all other variables, but their values are also used or changed automatically by {\f1{}awk}.  All built-in variables names are entirely upper-case.\par
\par
\pard{}Variables in {\f1{}awk} can be assigned either numeric or string values.  By default, variables are initialized to the empty string, which is zero if converted to a number.  There is no need to "initialize" each variable explicitly in {\f1{}awk}, the way you would in C and in most other traditional languages.\par
\par
\page\pard Node: {\b Assignment Options}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Using Variables}{\v Using_Variables}, Up: {\uldb Variables}{\v Variables}\line
K{\footnote K Assignment Options}
#{\footnote Assignment_Options}
${\footnote \pard{}Assigning Variables on the Command Line}\par
\pard{\fs24\b Assigning Variables on the Command Line}\par
\par
\pard{}You can set any {\f1{}awk} variable by including a \'A2variable assignment\'A2 among the arguments on the command line when you invoke {\f1{}awk} (see {\uldb Other Command Line Arguments}{\v Other_Arguments}).  Such an assignment has this form:\par
\par
{{\i \pard\li720\f1{}variable}={\i text}\par
\pard\f0{}}\par
\pard{}With it, you can set a variable either at the beginning of the {\f1{}awk} run or in between input files.\par
\par
\pard{}If you precede the assignment with the {\f1{}-v} option, like this:\par
\par
{\pard\keep\li720\f1{}-v {\i variable}={\i text}\par
\pard\f0{}}\par
\pard{}then the variable is set at the very beginning, before even the {\f1{}BEGIN} rules are run.  The {\f1{}-v} option and its assignment must precede all the file name arguments, as well as the program text.  (See {\uldb Command Line Options}{\v Options}, for more information about the {\f1{}-v} option.)\par
\par
\pard{}Otherwise, the variable assignment is performed at a time determined by its position among the input file arguments: after the processing of the preceding input file argument.  For example:\par
\par
{\pard\keep\li720\f1{}awk '\'7B print $n \'7D' n=4 inventory-shipped n=2 BBS-list\par
\pard\f0{}}\par
\pard{}prints the value of field number {\f1{}n} for all input records.  Before the first file is read, the command line sets the variable {\f1{}n} equal to four.  This causes the fourth field to be printed in lines from the file {\f1{}inventory-shipped}.  After the first file has finished, but before the second file is started, {\f1{}n} is set to two, so that the second field is printed in lines from {\f1{}BBS-list}.\par
\par
{{\pard\keep\li720\f1{}$ awk '\'7B print $n \'7D' n=4 inventory-shipped n=2 BBS-list\line
-| 15\line
-| 24\line
...\line
-| 555-5553\line
-| 555-3412\line
...\par
\pard\keep\li720{}}}\par
\pard\f0{}Command line arguments are made available for explicit examination by the {\f1{}awk} program in an array named {\f1{}ARGV} (see {\uldb Using {\f1{}ARGC} and {\f1{}ARGV}}{\v ARGC_and_ARGV}).\par
\par
\pard{}{K{\footnote K dark corner}}{\f1{}awk} processes the values of command line assignments for escape sequences (d.c.) (see {\uldb Escape Sequences}{\v Escape_Sequences}).\par
\par
\page\pard Node: {\b Conversion}, \keepn Next: {\uldb Arithmetic Ops}{\v Arithmetic_Ops}, Prev: {\uldb Variables}{\v Variables}, Up: {\uldb Expressions}{\v Expressions}\line
K{\footnote K Conversion}
#{\footnote Conversion}
${\footnote \pard{}Conversion of Strings and Numbers}\par
\pard{\fs24\b Conversion of Strings and Numbers}\par
\par
\pard{}{K{\footnote K conversion of strings and numbers}}Strings are converted to numbers, and numbers to strings, if the context of the {\f1{}awk} program demands it.  For example, if the value of either {\f1{}foo} or {\f1{}bar} in the expression {\f1{}foo + bar} happens to be a string, it is converted to a number before the addition is performed.  If numeric values appear in string concatenation, they are converted to strings.  Consider this:\par
\par
{\pard\keep\li720\f1{}two = 2; three = 3\line
print (two three) + 4\par
\pard\f0{}}\par
\pard{}This prints the (numeric) value 27.  The numeric values of the variables {\f1{}two} and {\f1{}three} are converted to strings and concatenated together, and the resulting string is converted back to the number 23, to which four is then added.\par
\par
\pard{}{K{\footnote K null string}}{K{\footnote K empty string}}{K{\footnote K type conversion}}If, for some reason, you need to force a number to be converted to a string, concatenate the empty string, {\f1{}""}, with that number.  To force a string to be converted to a number, add zero to that string.\par
\par
\pard{}A string is converted to a number by interpreting any numeric prefix of the string as numerals: {\f1{}"2.5"} converts to 2.5, {\f1{}"1e3"} converts to 1000, and {\f1{}"25fix"} has a numeric value of 25.  Strings that can't be interpreted as valid numbers are converted to zero.\par
\par
\pard{}{K{\footnote K CONVFMT}}The exact manner in which numbers are converted into strings is controlled by the {\f1{}awk} built-in variable {\f1{}CONVFMT} (see {\uldb Built-in Variables}{\v Built_in_Variables}).  Numbers are converted using the {\f1{}sprintf} function (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}) with {\f1{}CONVFMT} as the format specifier.\par
\par
{\f1{}\pard{}CONVFMT}'s default value is {\f1{}"%.6g"}, which prints a value with at least six significant digits.  For some applications you will want to change it to specify more precision.  Double precision on most modern machines gives you 16 or 17 decimal digits of precision.\par
\par
\pard{}Strange results can happen if you set {\f1{}CONVFMT} to a string that doesn't tell {\f1{}sprintf} how to format floating point numbers in a useful way.  For example, if you forget the {\f1{}%} in the format, all numbers will be converted to the same constant string.\par
\par
\pard{}{K{\footnote K dark corner}}As a special case, if a number is an integer, then the result of converting it to a string is {\i always} an integer, no matter what the value of {\f1{}CONVFMT} may be.  Given the following code fragment:\par
\par
{\pard\keep\li720\f1{}CONVFMT = "%2.2f"\line
a = 12\line
b = a ""\par
\pard\f0{}}\par
{\f1{}\pard{}b} has the value {\f1{}"12"}, not {\f1{}"12.00"} (d.c.).\par
\par
\pard{}{K{\footnote K {\f1{}awk} language, POSIX version}}{K{\footnote K POSIX {\f1{}awk}}}{K{\footnote K OFMT}}Prior to the POSIX standard, {\f1{}awk} specified that the value of {\f1{}OFMT} was used for converting numbers to strings.  {\f1{}OFMT} specifies the output format to use when printing numbers with {\f1{}print}.  {\f1{}CONVFMT} was introduced in order to separate the semantics of conversion from the semantics of printing.  Both {\f1{}CONVFMT} and {\f1{}OFMT} have the same default value: {\f1{}"%.6g"}.  In the vast majority of cases, old {\f1{}awk} programs will not change their behavior.  However, this use of {\f1{}OFMT} is something to keep in mind if you must port your program to other implementations of {\f1{}awk}; we recommend that instead of changing your programs, you just port {\f1{}gawk} itself!  See {\uldb The {\f1{}print} Statement}{\v Print}, for more information on the {\f1{}print} statement.\par
\par
\page\pard Node: {\b Arithmetic Ops}, \keepn Next: {\uldb Concatenation}{\v Concatenation}, Prev: {\uldb Conversion}{\v Conversion}, Up: {\uldb Expressions}{\v Expressions}\line
K{\footnote K Arithmetic Ops}
#{\footnote Arithmetic_Ops}
${\footnote \pard{}Arithmetic Operators}\par
\pard{\fs24\b Arithmetic Operators}\par
\par
\pard{}{K{\footnote K arithmetic operators}}{K{\footnote K operators, arithmetic}}{K{\footnote K addition}}{K{\footnote K subtraction}}{K{\footnote K multiplication}}{K{\footnote K division}}{K{\footnote K remainder}}{K{\footnote K quotient}}{K{\footnote K exponentiation}} The {\f1{}awk} language uses the common arithmetic operators when evaluating expressions.  All of these arithmetic operators follow normal precedence rules, and work as you would expect them to.\par
\par
\pard{}Here is a file {\f1{}grades} containing a list of student names and three test scores per student (it's a small class):\par
\par
{\pard\keep\li720\f1{}Pat   100 97 58\line
Sandy  84 72 93\line
Chris  72 92 89\par
\pard\f0{}}\par
\pard{}This programs takes the file {\f1{}grades}, and prints the average of the scores.\par
\par
{\pard\keep\li720\f1{}$ awk '\'7B sum = $2 + $3 + $4 ; avg = sum / 3\line
>        print $1, avg \'7D' grades\line
-| Pat 85\line
-| Sandy 83\line
-| Chris 84.3333\par
\pard\f0{}}\par
\pard{}This table lists the arithmetic operators in {\f1{}awk}, in order from highest precedence to lowest:\par
\par
{\pard{}{\f1{}- {\i x}}\par
\pard\li720{}Negation.\par
\par
\pard{}{\f1{}+ {\i x}}\par
\pard\li720{}Unary plus.  The expression is converted to a number.\par
\par
\pard\li720{}{K{\footnote K {\f1{}awk} language, POSIX version}}{K{\footnote K POSIX {\f1{}awk}}}\par
\par
\pard{}{\f1{}{\i x} ^ {\i y}}\par
\pard{}{\f1{}{\i x} ** {\i y}}\par
\pard\li720{}Exponentiation: {\i x} raised to the {\i y} power.  {\f1{}2 ^ 3} has the value eight.  The character sequence {\f1{}**} is equivalent to {\f1{}^}.  (The POSIX standard only specifies the use of {\f1{}^} for exponentiation.)\par
\par
\pard{}{\f1{}{\i x} * {\i y}}\par
\pard\li720{}Multiplication.\par
\par
\pard{}{\f1{}{\i x} / {\i y}}\par
\pard\li720{}Division.  Since all numbers in {\f1{}awk} are real numbers, the result is not rounded to an integer: {\f1{}3 / 4} has the value 0.75.\par
\par
\pard{}{\f1{}{\i x} % {\i y}}\par
\pard\li720{}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}Remainder.  The quotient is rounded toward zero to an integer, multiplied by {\i y} and this result is subtracted from {\i x}.  This operation is sometimes known as "trunc-mod."  The following relation always holds:\par
\par
{\pard\keep\li1440\f1{}b * int(a / b) + (a % b) == a\par
\pard\li720\f0{}}\par
\pard\li720{}One possibly undesirable effect of this definition of remainder is that {\f1{}{\i x} % {\i y}} is negative if {\i x} is negative.  Thus,\par
\par
{\pard\keep\li1440\f1{}-17 % 8 = -1\par
\pard\li720\f0{}}\par
\pard\li720{}In other {\f1{}awk} implementations, the signedness of the remainder may be machine dependent.\par
\par
\pard{}{\f1{}{\i x} + {\i y}}\par
\pard\li720{}Addition.\par
\par
\pard{}{\f1{}{\i x} - {\i y}}\par
\pard\li720{}Subtraction.\par
\pard{}}\par
\pard{}For maximum portability, do not use the {\f1{}**} operator.\par
\par
\pard{}Unary plus and minus have the same precedence, the multiplication operators all have the same precedence, and addition and subtraction have the same precedence.\par
\par
\page\pard Node: {\b Concatenation}, \keepn Next: {\uldb Assignment Ops}{\v Assignment_Ops}, Prev: {\uldb Arithmetic Ops}{\v Arithmetic_Ops}, Up: {\uldb Expressions}{\v Expressions}\line
K{\footnote K Concatenation}
#{\footnote Concatenation}
${\footnote \pard{}String Concatenation}\par
\pard{\fs24\b String Concatenation}\par
\par
\pard{}{K{\footnote K Kernighan, Brian}}{\par
\pard\li720\f1{}It seemed like a good idea at the time.\line
Brian Kernighan\par
\pard\f0{}}\par
\pard{}{K{\footnote K string operators}}{K{\footnote K operators, string}}{K{\footnote K concatenation}}There is only one string operation: concatenation.  It does not have a specific operator to represent it.  Instead, concatenation is performed by writing expressions next to one another, with no operator.  For example:\par
\par
{{\pard\keep\li720\f1{}$ awk '\'7B print "Field number one: " $1 \'7D' BBS-list\line
-| Field number one: aardvark\line
-| Field number one: alpo-net\line
...\par
\pard\keep\li720{}}}\par
\pard\f0{}Without the space in the string constant after the {\f1{}:}, the line would run together.  For example:\par
\par
{{\pard\keep\li720\f1{}$ awk '\'7B print "Field number one:" $1 \'7D' BBS-list\line
-| Field number one:aardvark\line
-| Field number one:alpo-net\line
...\par
\pard\keep\li720{}}}\par
\pard\f0{}Since string concatenation does not have an explicit operator, it is often necessary to insure that it happens where you want it to by using parentheses to enclose the items to be concatenated.  For example, the following code fragment does not concatenate {\f1{}file} and {\f1{}name} as you might expect:\par
\par
{{\pard\keep\li720\f1{}file = "file"\line
name = "name"\line
print "something meaningful" > file name\par
\pard\keep\li720{}}}\par
\pard\f0{}It is necessary to use the following:\par
\par
{\pard\keep\li720\f1{}print "something meaningful" > (file name)\par
\pard\f0{}}\par
\pard{}We recommend that you use parentheses around concatenation in all but the most common contexts (such as on the right-hand side of {\f1{}=}).\par
\par
\page\pard Node: {\b Assignment Ops}, \keepn Next: {\uldb Increment Ops}{\v Increment_Ops}, Prev: {\uldb Concatenation}{\v Concatenation}, Up: {\uldb Expressions}{\v Expressions}\line
K{\footnote K Assignment Ops}
#{\footnote Assignment_Ops}
${\footnote \pard{}Assignment Expressions}\par
\pard{\fs24\b Assignment Expressions}\par
\par
\pard{}{K{\footnote K assignment operators}}{K{\footnote K operators, assignment}}{K{\footnote K expression, assignment}} An \'A2assignment\'A2 is an expression that stores a new value into a variable.  For example, let's assign the value one to the variable {\f1{}z}:\par
\par
{\pard\keep\li720\f1{}z = 1\par
\pard\f0{}}\par
\pard{}After this expression is executed, the variable {\f1{}z} has the value one.  Whatever old value {\f1{}z} had before the assignment is forgotten.\par
\par
\pard{}Assignments can store string values also.  For example, this would store the value {\f1{}"this food is good"} in the variable {\f1{}message}:\par
\par
{\pard\keep\li720\f1{}thing = "food"\line
predicate = "good"\line
message = "this " thing " is " predicate\par
\pard\f0{}}\par
\pard{}(This also illustrates string concatenation.)\par
\par
\pard{}The {\f1{}=} sign is called an \'A2assignment operator\'A2.  It is the simplest assignment operator because the value of the right-hand operand is stored unchanged.\par
\par
\pard{}{K{\footnote K side effect}}Most operators (addition, concatenation, and so on) have no effect except to compute a value.  If you ignore the value, you might as well not use the operator.  An assignment operator is different; it does produce a value, but even if you ignore the value, the assignment still makes itself felt through the alteration of the variable.  We call this a \'A2side effect\'A2.\par
\par
\pard{}{K{\footnote K lvalue}}{K{\footnote K rvalue}}The left-hand operand of an assignment need not be a variable (see {\uldb Variables}{\v Variables}); it can also be a field (see {\uldb Changing the Contents of a Field}{\v Changing_Fields}) or an array element (see {\uldb Arrays in {\f1{}awk}}{\v Arrays}).  These are all called \'A2lvalues\'A2, which means they can appear on the left-hand side of an assignment operator.  The right-hand operand may be any expression; it produces the new value which the assignment stores in the specified variable, field or array element. (Such values are called \'A2rvalues\'A2).\par
\par
\pard{}{K{\footnote K types of variables}}It is important to note that variables do {\i not} have permanent types.  The type of a variable is simply the type of whatever value it happens to hold at the moment.  In the following program fragment, the variable {\f1{}foo} has a numeric value at first, and a string value later on:\par
\par
{{\pard\keep\li720\f1{}foo = 1\line
print foo\line
foo = "bar"\line
print foo\par
\pard\keep\li720{}}}\par
\pard\f0{}When the second assignment gives {\f1{}foo} a string value, the fact that it previously had a numeric value is forgotten.\par
\par
\pard{}String values that do not begin with a digit have a numeric value of zero. After executing this code, the value of {\f1{}foo} is five:\par
\par
{\pard\keep\li720\f1{}foo = "a string"\line
foo = foo + 5\par
\pard\f0{}}\par
\pard{}(Note that using a variable as a number and then later as a string can be confusing and is poor programming style.  The above examples illustrate how {\f1{}awk} works, {\i not} how you should write your own programs!)\par
\par
\pard{}An assignment is an expression, so it has a value: the same value that is assigned.  Thus, {\f1{}z = 1} as an expression has the value one.  One consequence of this is that you can write multiple assignments together:\par
\par
{\pard\keep\li720\f1{}x = y = z = 0\par
\pard\f0{}}\par
\pard{}stores the value zero in all three variables.  It does this because the value of {\f1{}z = 0}, which is zero, is stored into {\f1{}y}, and then the value of {\f1{}y = z = 0}, which is zero, is stored into {\f1{}x}.\par
\par
\pard{}You can use an assignment anywhere an expression is called for.  For example, it is valid to write {\f1{}x != (y = 1)} to set {\f1{}y} to one and then test whether {\f1{}x} equals one.  But this style tends to make programs hard to read; except in a one-shot program, you should not use such nesting of assignments.\par
\par
\pard{}Aside from {\f1{}=}, there are several other assignment operators that do arithmetic with the old value of the variable.  For example, the operator {\f1{}+=} computes a new value by adding the right-hand value to the old value of the variable.  Thus, the following assignment adds five to the value of {\f1{}foo}:\par
\par
{\pard\keep\li720\f1{}foo += 5\par
\pard\f0{}}\par
\pard{}This is equivalent to the following:\par
\par
{\pard\keep\li720\f1{}foo = foo + 5\par
\pard\f0{}}\par
\pard{}Use whichever one makes the meaning of your program clearer.\par
\par
\pard{}There are situations where using {\f1{}+=} (or any assignment operator) is {\i not} the same as simply repeating the left-hand operand in the right-hand expression.  For example:\par
\par
\pard{}{K{\footnote K Rankin, Pat}}{\par
{\pard\keep\li720\f1{}# Thanks to Pat Rankin for this example\line
BEGIN  \'7B\line
    foo[rand()] += 5\line
    for (x in foo)\line
       print x, foo[x]\line
\line
    bar[rand()] = bar[rand()] + 5\line
    for (x in bar)\line
       print x, bar[x]\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}The indices of {\f1{}bar} are guaranteed to be different, because {\f1{}rand} will return different values each time it is called.  (Arrays and the {\f1{}rand} function haven't been covered yet.  See {\uldb Arrays in {\f1{}awk}}{\v Arrays}, and see {\uldb Numeric Built-in Functions}{\v Numeric_Functions}, for more information).  This example illustrates an important fact about the assignment operators: the left-hand expression is only evaluated {\i once}.\par
\par
\pard{}It is also up to the implementation as to which expression is evaluated first, the left-hand one or the right-hand one.  Consider this example:\par
\par
{\pard\keep\li720\f1{}i = 1\line
a[i += 2] = i + 1\par
\pard\f0{}}\par
\pard{}The value of {\f1{}a[3]} could be either two or four.\par
\par
\pard{}Here is a table of the arithmetic assignment operators.  In each case, the right-hand operand is an expression whose value is converted to a number.\par
\par
{\pard{}{\f1{}{\i lvalue} += {\i increment}}\par
\pard\li720{}Adds {\i increment} to the value of {\i lvalue} to make the new value of {\i lvalue}.\par
\par
\pard{}{\f1{}{\i lvalue} -= {\i decrement}}\par
\pard\li720{}Subtracts {\i decrement} from the value of {\i lvalue}.\par
\par
\pard{}{\f1{}{\i lvalue} *= {\i coefficient}}\par
\pard\li720{}Multiplies the value of {\i lvalue} by {\i coefficient}.\par
\par
\pard{}{\f1{}{\i lvalue} /= {\i divisor}}\par
\pard\li720{}Divides the value of {\i lvalue} by {\i divisor}.\par
\par
\pard{}{\f1{}{\i lvalue} %= {\i modulus}}\par
\pard\li720{}Sets {\i lvalue} to its remainder by {\i modulus}.\par
\par
\pard\li720{}{K{\footnote K {\f1{}awk} language, POSIX version}}{K{\footnote K POSIX {\f1{}awk}}}\par
\par
\pard{}{\f1{}{\i lvalue} ^= {\i power}}\par
\pard{}{\f1{}{\i lvalue} **= {\i power}}\par
\pard\li720{}Raises {\i lvalue} to the power {\i power}.  (Only the {\f1{}^=} operator is specified by POSIX.)\par
\pard{}}\par
\pard{}For maximum portability, do not use the {\f1{}**=} operator.\par
\par
\page\pard Node: {\b Increment Ops}, \keepn Next: {\uldb Truth Values}{\v Truth_Values}, Prev: {\uldb Assignment Ops}{\v Assignment_Ops}, Up: {\uldb Expressions}{\v Expressions}\line
K{\footnote K Increment Ops}
#{\footnote Increment_Ops}
${\footnote \pard{}Increment and Decrement Operators}\par
\pard{\fs24\b Increment and Decrement Operators}\par
\par
\pard{}{K{\footnote K increment operators}}{K{\footnote K operators, increment}}\'A2Increment\'A2 and \'A2decrement operators\'A2 increase or decrease the value of a variable by one.  You could do the same thing with an assignment operator, so the increment operators add no power to the {\f1{}awk} language; but they are convenient abbreviations for very common operations.\par
\par
\pard{}The operator to add one is written {\f1{}++}.  It can be used to increment a variable either before or after taking its value.\par
\par
\pard{}To pre-increment a variable {\i v}, write {\f1{}++{\i v}}.  This adds one to the value of {\i v} and that new value is also the value of this expression.  The assignment expression {\f1{}{\i v} += 1} is completely equivalent.\par
\par
\pard{}Writing the {\f1{}++} after the variable specifies post-increment.  This increments the variable value just the same; the difference is that the value of the increment expression itself is the variable's {\i old} value.  Thus, if {\f1{}foo} has the value four, then the expression {\f1{}foo++} has the value four, but it changes the value of {\f1{}foo} to five.\par
\par
\pard{}The post-increment {\f1{}foo++} is nearly equivalent to writing {\f1{}(foo += 1) - 1}.  It is not perfectly equivalent because all numbers in {\f1{}awk} are floating point: in floating point, {\f1{}foo + 1 - 1} does not necessarily equal {\f1{}foo}.  But the difference is minute as long as you stick to numbers that are fairly small (less than 10e12).\par
\par
\pard{}Any lvalue can be incremented.  Fields and array elements are incremented just like variables.  (Use {\f1{}$(i++)} when you wish to do a field reference and a variable increment at the same time.  The parentheses are necessary because of the precedence of the field reference operator, {\f1{}$}.)\par
\par
\pard{}{K{\footnote K decrement operators}}{K{\footnote K operators, decrement}}The decrement operator {\f1{}--} works just like {\f1{}++} except that it subtracts one instead of adding.  Like {\f1{}++}, it can be used before the lvalue to pre-decrement or after it to post-decrement.\par
\par
\pard{}Here is a summary of increment and decrement expressions.\par
\par
{\pard{}{\f1{}++{\i lvalue}}\par
\pard\li720{}This expression increments {\i lvalue} and the new value becomes the value of the expression.\par
\par
\pard{}{\f1{}{\i lvalue}++}\par
\pard\li720{}This expression increments {\i lvalue}, but the value of the expression is the {\i old} value of {\i lvalue}.\par
\par
\pard{}{\f1{}--{\i lvalue}}\par
\pard\li720{}Like {\f1{}++{\i lvalue}}, but instead of adding, it subtracts.  It decrements {\i lvalue} and delivers the value that results.\par
\par
\pard{}{\f1{}{\i lvalue}--}\par
\pard\li720{}Like {\f1{}{\i lvalue}++}, but instead of adding, it subtracts.  It decrements {\i lvalue}.  The value of the expression is the {\i old} value of {\i lvalue}.\par
\pard{}}\par
\page\pard Node: {\b Truth Values}, \keepn Next: {\uldb Typing and Comparison}{\v Typing_and_Comparison}, Prev: {\uldb Increment Ops}{\v Increment_Ops}, Up: {\uldb Expressions}{\v Expressions}\line
K{\footnote K Truth Values}
#{\footnote Truth_Values}
${\footnote \pard{}True and False in {\f1{}awk}}\par
\pard{\fs24\b True and False in {\f1{}awk}}\par
\par
\pard{}{K{\footnote K truth values}}{K{\footnote K logical true}}{K{\footnote K logical false}} Many programming languages have a special representation for the concepts of "true" and "false."  Such languages usually use the special constants {\f1{}true} and {\f1{}false}, or perhaps their upper-case equivalents.\par
\par
\pard{}{K{\footnote K null string}}{K{\footnote K empty string}}{\f1{}awk} is different.  It borrows a very simple concept of true and false from C.  In {\f1{}awk}, any non-zero numeric value, {\i or} any non-empty string value is true.  Any other value (zero or the null string, {\f1{}""}) is false.  The following program will print {\f1{}A strange truth value} three times:\par
\par
{{\pard\keep\li720\f1{}BEGIN \'7B\line
   if (3.1415927)\line
       print "A strange truth value"\line
   if ("Four Score And Seven Years Ago")\line
       print "A strange truth value"\line
   if (j = 57)\line
       print "A strange truth value"\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}{K{\footnote K dark corner}}There is a surprising consequence of the "non-zero or non-null" rule: The string constant {\f1{}"0"} is actually true, since it is non-null (d.c.).\par
\par
\page\pard Node: {\b Typing and Comparison}, \keepn Next: {\uldb Boolean Ops}{\v Boolean_Ops}, Prev: {\uldb Truth Values}{\v Truth_Values}, Up: {\uldb Expressions}{\v Expressions}\line
K{\footnote K Typing and Comparison}
#{\footnote Typing_and_Comparison}
${\footnote \pard{}Variable Typing and Comparison Expressions}\par
\pard{\fs24\b Variable Typing and Comparison Expressions}\par
\par
\pard{}{K{\footnote K comparison expressions}}{K{\footnote K expression, comparison}}{K{\footnote K expression, matching}}{K{\footnote K relational operators}}{K{\footnote K operators, relational}}{K{\footnote K regexp match/non-match operators}}{K{\footnote K variable typing}}{K{\footnote K types of variables}}{\par
\pard\li720\f1{}The Guide is definitive. Reality is frequently inaccurate.\line
The Hitchhiker's Guide to the Galaxy\par
\pard\f0{}}\par
\pard{}Unlike other programming languages, {\f1{}awk} variables do not have a fixed type. Instead, they can be either a number or a string, depending upon the value that is assigned to them.\par
\par
\pard{}{K{\footnote K numeric string}}The 1992 POSIX standard introduced the concept of a \'A2numeric string\'A2, which is simply a string that looks like a number, for example, {\f1{}" +2"}.  This concept is used for determining the type of a variable.\par
\par
\pard{}The type of the variable is important, since the types of two variables determine how they are compared.\par
\par
\pard{}In {\f1{}gawk}, variable typing follows these rules.\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}1. \tab{}A numeric literal or the result of a numeric operation has the {\i numeric} attribute.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}2. \tab{}A string literal or the result of a string operation has the {\i string} attribute.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}3. \tab{}Fields, {\f1{}getline} input, {\f1{}FILENAME}, {\f1{}ARGV} elements, {\f1{}ENVIRON} elements and the elements of an array created by {\f1{}split} that are numeric strings have the {\i strnum} attribute.  Otherwise, they have the {\i string} attribute.  Uninitialized variables also have the {\i strnum} attribute.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}4. \tab{}Attributes propagate across assignments, but are not changed by any use.\par
\pard{}}\par
\pard{}The last rule is particularly important. In the following program, {\f1{}a} has numeric type, even though it is later used in a string operation.\par
\par
{\pard\keep\li720\f1{}BEGIN \'7B\line
         a = 12.345\line
         b = a " is a cute number"\line
         print b\line
\'7D\par
\pard\f0{}}\par
\pard{}When two operands are compared, either string comparison or numeric comparison may be used, depending on the attributes of the operands, according to the following, symmetric, matrix:\par
\par
{{\pard\keep\li720\f1{}	+----------------------------------------------\line
	|	STRING		NUMERIC		STRNUM\line
--------+----------------------------------------------\line
	|\line
STRING	|	string		string		string\line
	|\line
NUMERIC	|	string		numeric		numeric\line
	|\line
STRNUM	|	string		numeric		numeric\line
--------+----------------------------------------------\par
\pard\f0{}}}\par
\pard{}The basic idea is that user input that looks numeric, and {\i only} user input, should be treated as numeric, even though it is actually made of characters, and is therefore also a string.\par
\par
\pard{}\'A2Comparison expressions\'A2 compare strings or numbers for relationships such as equality.  They are written using \'A2relational operators\'A2, which are a superset of those in C.  Here is a table of them:\par
\par
\pard{}{K{\footnote K relational operators}}{K{\footnote K operators, relational}}{K{\footnote K {\f1{}<} operator}}{K{\footnote K {\f1{}<=} operator}}{K{\footnote K {\f1{}>} operator}}{K{\footnote K {\f1{}>=} operator}}{K{\footnote K {\f1{}==} operator}}{K{\footnote K {\f1{}!=} operator}}{K{\footnote K {\f1{}~} operator}}{K{\footnote K {\f1{}!~} operator}}{K{\footnote K {\f1{}in} operator}}{\par
\pard{}{\f1{}{\i x} < {\i y}}\par
\pard\li720{}True if {\i x} is less than {\i y}.\par
\par
\pard{}{\f1{}{\i x} <= {\i y}}\par
\pard\li720{}True if {\i x} is less than or equal to {\i y}.\par
\par
\pard{}{\f1{}{\i x} > {\i y}}\par
\pard\li720{}True if {\i x} is greater than {\i y}.\par
\par
\pard{}{\f1{}{\i x} >= {\i y}}\par
\pard\li720{}True if {\i x} is greater than or equal to {\i y}.\par
\par
\pard{}{\f1{}{\i x} == {\i y}}\par
\pard\li720{}True if {\i x} is equal to {\i y}.\par
\par
\pard{}{\f1{}{\i x} != {\i y}}\par
\pard\li720{}True if {\i x} is not equal to {\i y}.\par
\par
\pard{}{\f1{}{\i x} ~ {\i y}}\par
\pard\li720{}True if the string {\i x} matches the regexp denoted by {\i y}.\par
\par
\pard{}{\f1{}{\i x} !~ {\i y}}\par
\pard\li720{}True if the string {\i x} does not match the regexp denoted by {\i y}.\par
\par
\pard{}{\f1{}{\i subscript} in {\i array}}\par
\pard\li720{}True if the array {\i array} has an element with the subscript {\i subscript}.\par
\pard{}}\par
\pard{}Comparison expressions have the value one if true and zero if false.\par
\par
\pard{}When comparing operands of mixed types, numeric operands are converted to strings using the value of {\f1{}CONVFMT} (see {\uldb Conversion of Strings and Numbers}{\v Conversion}).\par
\par
\pard{}Strings are compared by comparing the first character of each, then the second character of each, and so on.  Thus {\f1{}"10"} is less than {\f1{}"9"}.  If there are two strings where one is a prefix of the other, the shorter string is less than the longer one.  Thus {\f1{}"abc"} is less than {\f1{}"abcd"}.\par
\par
\pard{}{K{\footnote K common mistakes}}{K{\footnote K mistakes, common}}{K{\footnote K errors, common}}It is very easy to accidentally mistype the {\f1{}==} operator, and leave off one of the {\f1{}=}s.  The result is still valid {\f1{}awk} code, but the program will not do what you mean:\par
\par
{\pard\keep\li720\f1{}if (a = b)   # oops! should be a == b\line
   ...\line
else\line
   ...\par
\pard\f0{}}\par
\pard{}Unless {\f1{}b} happens to be zero or the null string, the {\f1{}if} part of the test will always succeed.  Because the operators are so similar, this kind of error is very difficult to spot when scanning the source code.\par
\par
\pard{}Here are some sample expressions, how {\f1{}gawk} compares them, and what the result of the comparison is.\par
\par
{\pard{}{\f1{}1.5 <= 2.0}\par
\pard\li720{}numeric comparison (true)\par
\par
\pard{}{\f1{}"abc" >= "xyz"}\par
\pard\li720{}string comparison (false)\par
\par
\pard{}{\f1{}1.5 != " +2"}\par
\pard\li720{}string comparison (true)\par
\par
\pard{}{\f1{}"1e2" < "3"}\par
\pard\li720{}string comparison (true)\par
\par
\pard{}{\f1{}a = 2; b = "2"}\par
\pard{}{\f1{}a == b}\par
\pard\li720{}string comparison (true)\par
\par
\pard{}{\f1{}a = 2; b = " +2"}\par
\pard{}{\f1{}a == b}\par
\pard\li720{}string comparison (false)\par
\pard{}}\par
\pard{}In this example,\par
\par
{{\pard\keep\li720\f1{}$ echo 1e2 3 | awk '\'7B print ($1 < $2) ? "true" : "false" \'7D'\line
-| false\par
\pard\keep\li720{}}}\par
\pard\f0{}the result is {\f1{}false} since both {\f1{}$1} and {\f1{}$2} are numeric strings and thus both have the {\i strnum} attribute, dictating a numeric comparison.\par
\par
\pard{}The purpose of the comparison rules and the use of numeric strings is to attempt to produce the behavior that is "least surprising," while still "doing the right thing."\par
\par
\pard{}{K{\footnote K comparisons, string vs. regexp}}{K{\footnote K string comparison vs. regexp comparison}}{K{\footnote K regexp comparison vs. string comparison}}String comparisons and regular expression comparisons are very different.  For example,\par
\par
{\pard\keep\li720\f1{}x == "foo"\par
\pard\f0{}}\par
\pard{}has the value of one, or is true, if the variable {\f1{}x} is precisely {\f1{}foo}.  By contrast,\par
\par
{\pard\keep\li720\f1{}x ~ /foo/\par
\pard\f0{}}\par
\pard{}has the value one if {\f1{}x} contains {\f1{}foo}, such as {\f1{}"Oh, what a fool am I!"}.\par
\par
\pard{}The right hand operand of the {\f1{}~} and {\f1{}!~} operators may be either a regexp constant ({\f1{}/.../}), or an ordinary expression, in which case the value of the expression as a string is used as a dynamic regexp (see {\uldb How to Use Regular Expressions}{\v Regexp_Usage}; also see {\uldb Using Dynamic Regexps}{\v Computed_Regexps}).\par
\par
\pard{}{K{\footnote K regexp as expression}}In recent implementations of {\f1{}awk}, a constant regular expression in slashes by itself is also an expression.  The regexp {\f1{}/{\i regexp}/} is an abbreviation for this comparison expression:\par
\par
{\pard\keep\li720\f1{}$0 ~ /{\i regexp}/\par
\pard\f0{}}\par
\pard{}One special place where {\f1{}/foo/} is {\i not} an abbreviation for {\f1{}$0 ~ /foo/} is when it is the right-hand operand of {\f1{}~} or {\f1{}!~}!  See {\uldb Using Regular Expression Constants}{\v Using_Constant_Regexps}, where this is discussed in more detail.\par
\par
\page\pard Node: {\b Boolean Ops}, \keepn Next: {\uldb Conditional Exp}{\v Conditional_Exp}, Prev: {\uldb Typing and Comparison}{\v Typing_and_Comparison}, Up: {\uldb Expressions}{\v Expressions}\line
K{\footnote K Boolean Ops}
#{\footnote Boolean_Ops}
${\footnote \pard{}Boolean Expressions}\par
\pard{\fs24\b Boolean Expressions}\par
\par
\pard{}{K{\footnote K expression, boolean}}{K{\footnote K boolean expressions}}{K{\footnote K operators, boolean}}{K{\footnote K boolean operators}}{K{\footnote K logical operations}}{K{\footnote K operations, logical}}{K{\footnote K short-circuit operators}}{K{\footnote K operators, short-circuit}}{K{\footnote K and operator}}{K{\footnote K or operator}}{K{\footnote K not operator}}{K{\footnote K {\f1{}&&} operator}}{K{\footnote K {\f1{}||} operator}}{K{\footnote K {\f1{}!} operator}} A \'A2boolean expression\'A2 is a combination of comparison expressions or matching expressions, using the boolean operators "or" ({\f1{}||}), "and" ({\f1{}&&}), and "not" ({\f1{}!}), along with parentheses to control nesting.  The truth value of the boolean expression is computed by combining the truth values of the component expressions.  Boolean expressions are also referred to as \'A2logical expressions\'A2.  The terms are equivalent.\par
\par
\pard{}Boolean expressions can be used wherever comparison and matching expressions can be used.  They can be used in {\f1{}if}, {\f1{}while}, {\f1{}do} and {\f1{}for} statements (see {\uldb Control Statements in Actions}{\v Statements}).  They have numeric values (one if true, zero if false), which come into play if the result of the boolean expression is stored in a variable, or used in arithmetic.\par
\par
\pard{}In addition, every boolean expression is also a valid pattern, so you can use one as a pattern to control the execution of rules.\par
\par
\pard{}Here are descriptions of the three boolean operators, with examples.\par
\par
{\pard{}{\f1{}{\i boolean1} && {\i boolean2}}\par
\pard\li720{}True if both {\i boolean1} and {\i boolean2} are true.  For example, the following statement prints the current input record if it contains both {\f1{}2400} and {\f1{}foo}.\par
\par
{\pard\keep\li1440\f1{}if ($0 ~ /2400/ && $0 ~ /foo/) print\par
\pard\li720\f0{}}\par
\pard\li720{}The subexpression {\i boolean2} is evaluated only if {\i boolean1} is true.  This can make a difference when {\i boolean2} contains expressions that have side effects: in the case of {\f1{}$0 ~ /foo/ && ($2 == bar++)}, the variable {\f1{}bar} is not incremented if there is no {\f1{}foo} in the record.\par
\par
\pard{}{\f1{}{\i boolean1} || {\i boolean2}}\par
\pard\li720{}True if at least one of {\i boolean1} or {\i boolean2} is true.  For example, the following statement prints all records in the input that contain {\i either} {\f1{}2400} or {\f1{}foo}, or both.\par
\par
{\pard\keep\li1440\f1{}if ($0 ~ /2400/ || $0 ~ /foo/) print\par
\pard\li720\f0{}}\par
\pard\li720{}The subexpression {\i boolean2} is evaluated only if {\i boolean1} is false.  This can make a difference when {\i boolean2} contains expressions that have side effects.\par
\par
\pard{}{\f1{}! {\i boolean}}\par
\pard\li720{}True if {\i boolean} is false.  For example, the following program prints all records in the input file {\f1{}BBS-list} that do {\i not} contain the string {\f1{}foo}.\par
\par
{\pard\keep\li1440\f1{}awk '\'7B if (! ($0 ~ /foo/)) print \'7D' BBS-list\par
\pard\li720\f0{}}}\par
\pard{}The {\f1{}&&} and {\f1{}||} operators are called \'A2short-circuit\'A2 operators because of the way they work.  Evaluation of the full expression is "short-circuited" if the result can be determined part way through its evaluation.\par
\par
\pard{}{K{\footnote K line continuation}}You can continue a statement that uses {\f1{}&&} or {\f1{}||} simply by putting a newline after them.  But you cannot put a newline in front of either of these operators without using backslash continuation (see {\uldb {\f1{}awk} Statements Versus Lines}{\v Statements_Lines}).\par
\par
\pard{}The actual value of an expression using the {\f1{}!} operator will be either one or zero, depending upon the truth value of the expression it is applied to.\par
\par
\pard{}The {\f1{}!} operator is often useful for changing the sense of a flag variable from false to true and back again. For example, the following program is one way to print lines in between special bracketing lines:\par
\par
{\pard\keep\li720\f1{}$1 == "START"   \'7B interested = ! interested \'7D\line
interested == 1 \'7B print \'7D\line
$1 == "END"     \'7B interested = ! interested \'7D\par
\pard\f0{}}\par
\pard{}The variable {\f1{}interested}, like all {\f1{}awk} variables, starts out initialized to zero, which is also false.  When a line is seen whose first field is {\f1{}START}, the value of {\f1{}interested} is toggled to true, using {\f1{}!}. The next rule prints lines as long as {\f1{}interested} is true.  When a line is seen whose first field is {\f1{}END}, {\f1{}interested} is toggled back to false.\par
\par
\page\pard Node: {\b Conditional Exp}, \keepn Next: {\uldb Function Calls}{\v Function_Calls}, Prev: {\uldb Boolean Ops}{\v Boolean_Ops}, Up: {\uldb Expressions}{\v Expressions}\line
K{\footnote K Conditional Exp}
#{\footnote Conditional_Exp}
${\footnote \pard{}Conditional Expressions}\par
\pard{\fs24\b Conditional Expressions}\par
\par
\pard{}{K{\footnote K conditional expression}}{K{\footnote K expression, conditional}} A \'A2conditional expression\'A2 is a special kind of expression with three operands.  It allows you to use one expression's value to select one of two other expressions.\par
\par
\pard{}The conditional expression is the same as in the C language:\par
\par
{{\i \pard\li720\f1{}selector} ? {\i if-true-exp} : {\i if-false-exp}\par
\pard\f0{}}\par
\pard{}There are three subexpressions.  The first, {\i selector}, is always computed first.  If it is "true" (not zero and not null) then {\i if-true-exp} is computed next and its value becomes the value of the whole expression.  Otherwise, {\i if-false-exp} is computed next and its value becomes the value of the whole expression.\par
\par
\pard{}For example, this expression produces the absolute value of {\f1{}x}:\par
\par
{\pard\keep\li720\f1{}x > 0 ? x : -x\par
\pard\f0{}}\par
\pard{}Each time the conditional expression is computed, exactly one of {\i if-true-exp} and {\i if-false-exp} is computed; the other is ignored.  This is important when the expressions contain side effects.  For example, this conditional expression examines element {\f1{}i} of either array {\f1{}a} or array {\f1{}b}, and increments {\f1{}i}.\par
\par
{\pard\keep\li720\f1{}x == y ? a[i++] : b[i++]\par
\pard\f0{}}\par
\pard{}This is guaranteed to increment {\f1{}i} exactly once, because each time only one of the two increment expressions is executed, and the other is not.  See {\uldb Arrays in {\f1{}awk}}{\v Arrays}, for more information about arrays.\par
\par
\pard{}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}{K{\footnote K line continuation}}As a minor {\f1{}gawk} extension, you can continue a statement that uses {\f1{}?:} simply by putting a newline after either character.  However, you cannot put a newline in front of either character without using backslash continuation (see {\uldb {\f1{}awk} Statements Versus Lines}{\v Statements_Lines}).  If {\f1{}--posix} is specified (see {\uldb Command Line Options}{\v Options}), then this extension is disabled.\par
\par
\page\pard Node: {\b Function Calls}, \keepn Next: {\uldb Precedence}{\v Precedence}, Prev: {\uldb Conditional Exp}{\v Conditional_Exp}, Up: {\uldb Expressions}{\v Expressions}\line
K{\footnote K Function Calls}
#{\footnote Function_Calls}
${\footnote \pard{}Function Calls}\par
\pard{\fs24\b Function Calls}\par
\par
\pard{}{K{\footnote K function call}}{K{\footnote K calling a function}} A \'A2function\'A2 is a name for a particular calculation.  Because it has a name, you can ask for it by name at any point in the program.  For example, the function {\f1{}sqrt} computes the square root of a number.\par
\par
\pard{}A fixed set of functions are \'A2built-in\'A2, which means they are available in every {\f1{}awk} program.  The {\f1{}sqrt} function is one of these.  See {\uldb Built-in Functions}{\v Built_in}, for a list of built-in functions and their descriptions.  In addition, you can define your own functions for use in your program.  See {\uldb User-defined Functions}{\v User_defined}, for how to do this.\par
\par
\pard{}{K{\footnote K arguments in function call}}The way to use a function is with a \'A2function call\'A2 expression, which consists of the function name followed immediately by a list of \'A2arguments\'A2 in parentheses.  The arguments are expressions which provide the raw materials for the function's calculations.  When there is more than one argument, they are separated by commas.  If there are no arguments, write just {\f1{}()} after the function name.  Here are some examples:\par
\par
{\pard\keep\li720\f1{}sqrt(x^2 + y^2)        one argument\line
atan2(y, x)            two arguments\line
rand()                 no arguments\par
\pard\f0{}}\par
{\b \pard{}Do not put any space between the function name and the open-parenthesis!}  A user-defined function name looks just like the name of a variable, and space would make the expression look like concatenation of a variable with an expression inside parentheses.  Space before the parenthesis is harmless with built-in functions, but it is best not to get into the habit of using space to avoid mistakes with user-defined functions.\par
\par
\pard{}Each function expects a particular number of arguments.  For example, the {\f1{}sqrt} function must be called with a single argument, the number to take the square root of:\par
\par
{\pard\keep\li720\f1{}sqrt({\i argument})\par
\pard\f0{}}\par
\pard{}Some of the built-in functions allow you to omit the final argument.  If you do so, they use a reasonable default.  See {\uldb Built-in Functions}{\v Built_in}, for full details.  If arguments are omitted in calls to user-defined functions, then those arguments are treated as local variables, initialized to the empty string (see {\uldb User-defined Functions}{\v User_defined}).\par
\par
\pard{}Like every other expression, the function call has a value, which is computed by the function based on the arguments you give it.  In this example, the value of {\f1{}sqrt({\i argument})} is the square root of {\i argument}.  A function can also have side effects, such as assigning values to certain variables or doing I/O.\par
\par
\pard{}Here is a command to read numbers, one number per line, and print the square root of each one:\par
\par
{{\pard\keep\li720\f1{}$ awk '\'7B print "The square root of", $1, "is", sqrt($1) \'7D'\line
1\line
-| The square root of 1 is 1\line
3\line
-| The square root of 3 is 1.73205\line
5\line
-| The square root of 5 is 2.23607\line
Control-d\par
\pard\keep\li720{}}}\par
\page\pard Node: {\b Precedence}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Function Calls}{\v Function_Calls}, Up: {\uldb Expressions}{\v Expressions}\line
K{\footnote K Precedence}
#{\footnote Precedence}
${\footnote \pard\f0{}Operator Precedence (How Operators Nest)}\par
\pard{\fs24\b Operator Precedence (How Operators Nest)}\par
\par
\pard{}{K{\footnote K precedence}}{K{\footnote K operator precedence}} \'A2Operator precedence\'A2 determines how operators are grouped, when different operators appear close by in one expression.  For example, {\f1{}*} has higher precedence than {\f1{}+}; thus, {\f1{}a + b * c} means to multiply {\f1{}b} and {\f1{}c}, and then add {\f1{}a} to the product (i.e. {\f1{}a + (b * c)}).\par
\par
\pard{}You can overrule the precedence of the operators by using parentheses.  You can think of the precedence rules as saying where the parentheses are assumed to be if you do not write parentheses yourself.  In fact, it is wise to always use parentheses whenever you have an unusual combination of operators, because other people who read the program may not remember what the precedence is in this case.  You might forget, too; then you could make a mistake.  Explicit parentheses will help prevent any such mistake.\par
\par
\pard{}When operators of equal precedence are used together, the leftmost operator groups first, except for the assignment, conditional and exponentiation operators, which group in the opposite order.  Thus, {\f1{}a - b + c} groups as {\f1{}(a - b) + c}, and {\f1{}a = b = c} groups as {\f1{}a = (b = c)}.\par
\par
\pard{}The precedence of prefix unary operators does not matter as long as only unary operators are involved, because there is only one way to interpret them--innermost first.  Thus, {\f1{}$++i} means {\f1{}$(++i)} and {\f1{}++$x} means {\f1{}++($x)}.  However, when another operator follows the operand, then the precedence of the unary operators can matter.  Thus, {\f1{}$x^2} means {\f1{}($x)^2}, but {\f1{}-x^2} means {\f1{}-(x^2)}, because {\f1{}-} has lower precedence than {\f1{}^} while {\f1{}$} has higher precedence.\par
\par
\pard{}Here is a table of {\f1{}awk}'s operators, in order from highest precedence to lowest:\par
\par
{\pard{}{\f1{}(...)}\par
\pard\li720{}Grouping.\par
\par
\pard{}{\f1{}$}\par
\pard\li720{}Field.\par
\par
\pard{}{\f1{}++ --}\par
\pard\li720{}Increment, decrement.\par
\par
\pard\li720{}{K{\footnote K {\f1{}awk} language, POSIX version}}{K{\footnote K POSIX {\f1{}awk}}}\par
\par
\pard{}{\f1{}^ **}\par
\pard\li720{}Exponentiation.  These operators group right-to-left.  (The {\f1{}**} operator is not specified by POSIX.)\par
\par
\pard{}{\f1{}+ - !}\par
\pard\li720{}Unary plus, minus, logical "not".\par
\par
\pard{}{\f1{}* / %}\par
\pard\li720{}Multiplication, division, modulus.\par
\par
\pard{}{\f1{}+ -}\par
\pard\li720{}Addition, subtraction.\par
\par
\pard{}{\f1{}Concatenation}\par
\pard\li720{}No special token is used to indicate concatenation.  The operands are simply written side by side.\par
\par
\pard{}{\f1{}< <= == !=}\par
\pard{}{\f1{}> >= >> |}\par
\pard\li720{}Relational, and redirection.  The relational operators and the redirections have the same precedence level.  Characters such as {\f1{}>} serve both as relationals and as redirections; the context distinguishes between the two meanings.\par
\par
\pard\li720{}Note that the I/O redirection operators in {\f1{}print} and {\f1{}printf} statements belong to the statement level, not to expressions.  The redirection does not produce an expression which could be the operand of another operator.  As a result, it does not make sense to use a redirection operator near another operator of lower precedence, without parentheses.  Such combinations, for example {\f1{}print foo > a ? b : c}, result in syntax errors.  The correct way to write this statement is {\f1{}print foo > (a ? b : c)}.\par
\par
\pard{}{\f1{}~ !~}\par
\pard\li720{}Matching, non-matching.\par
\par
\pard{}{\f1{}in}\par
\pard\li720{}Array membership.\par
\par
\pard{}{\f1{}&&}\par
\pard\li720{}Logical "and".\par
\par
\pard{}{\f1{}||}\par
\pard\li720{}Logical "or".\par
\par
\pard{}{\f1{}?:}\par
\pard\li720{}Conditional.  This operator groups right-to-left.\par
\par
\pard\li720{}{K{\footnote K {\f1{}awk} language, POSIX version}}{K{\footnote K POSIX {\f1{}awk}}}\par
\par
\pard{}{\f1{}= += -= *=}\par
\pard{}{\f1{}/= %= ^= **=}\par
\pard\li720{}Assignment.  These operators group right-to-left.  (The {\f1{}**=} operator is not specified by POSIX.)\par
\pard{}}\par
\page\pard Node: {\b Patterns and Actions}, \keepn Next: {\uldb Statements}{\v Statements}, Prev: {\uldb Expressions}{\v Expressions}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Patterns and Actions}
#{\footnote Patterns_and_Actions}
${\footnote \pard{}Patterns and Actions}\par
\pard{\fs24\b Patterns and Actions}\par
\par
\pard{}{K{\footnote K pattern, definition of}} As you have already seen, each {\f1{}awk} statement consists of a pattern with an associated action.  This chapter describes how you build patterns and actions.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Pattern Overview}{\v Pattern_Overview}\tab What goes into a pattern.\par
{\uldb Action Overview}{\v Action_Overview}\tab What goes into an action.\par
\pard{}}\par
\page\pard Node: {\b Pattern Overview}, \keepn Next: {\uldb Action Overview}{\v Action_Overview}, Prev: {\uldb Patterns and Actions}{\v Patterns_and_Actions}, Up: {\uldb Patterns and Actions}{\v Patterns_and_Actions}\line
K{\footnote K Pattern Overview}
#{\footnote Pattern_Overview}
${\footnote \pard{}Pattern Elements}\par
\pard{\fs24\b Pattern Elements}\par
\par
\pard{}Patterns in {\f1{}awk} control the execution of rules: a rule is executed when its pattern matches the current input record.  This section explains all about how to write patterns.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Kinds of Patterns}{\v Kinds_of_Patterns}\tab A list of all kinds of patterns.\par
{\uldb Regexp Patterns}{\v Regexp_Patterns}\tab Using regexps as patterns.\par
{\uldb Expression Patterns}{\v Expression_Patterns}\tab Any expression can be used as a pattern.\par
{\uldb Ranges}{\v Ranges}\tab Pairs of patterns specify record ranges.\par
{\uldb BEGIN/END}{\v BEGIN_END}\tab Specifying initialization and cleanup rules.\par
{\uldb Empty}{\v Empty}\tab The empty pattern, which matches every record.\par
\pard{}}\par
\page\pard Node: {\b Kinds of Patterns}, \keepn Next: {\uldb Regexp Patterns}{\v Regexp_Patterns}, Prev: {\uldb Pattern Overview}{\v Pattern_Overview}, Up: {\uldb Pattern Overview}{\v Pattern_Overview}\line
K{\footnote K Kinds of Patterns}
#{\footnote Kinds_of_Patterns}
${\footnote \pard{}Kinds of Patterns}\par
\pard{\fs24\b Kinds of Patterns}\par
\par
\pard{}{K{\footnote K patterns, types of}} Here is a summary of the types of patterns supported in {\f1{}awk}.\par
\par
{\pard{}{\f1{}/{\i regular expression}/}\par
\pard\li720{}A regular expression as a pattern.  It matches when the text of the input record fits the regular expression.  (See {\uldb Regular Expressions}{\v Regexp}.)\par
\par
\pard{}{\f1{}{\i expression}}\par
\pard\li720{}A single expression.  It matches when its value is non-zero (if a number) or non-null (if a string).  (See {\uldb Expressions as Patterns}{\v Expression_Patterns}.)\par
\par
\pard{}{\f1{}{\i pat1}, {\i pat2}}\par
\pard\li720{}A pair of patterns separated by a comma, specifying a range of records.  The range includes both the initial record that matches {\i pat1}, and the final record that matches {\i pat2}.  (See {\uldb Specifying Record Ranges with Patterns}{\v Ranges}.)\par
\par
\pard{}{\f1{}BEGIN}\par
\pard{}{\f1{}END}\par
\pard\li720{}Special patterns for you to supply start-up or clean-up actions for your {\f1{}awk} program.  (See {\uldb The {\f1{}BEGIN} and {\f1{}END} Special Patterns}{\v BEGIN_END}.)\par
\par
\pard{}{\f1{}{\i empty}}\par
\pard\li720{}The empty pattern matches every input record.  (See {\uldb The Empty Pattern}{\v Empty}.)\par
\pard{}}\par
\page\pard Node: {\b Regexp Patterns}, \keepn Next: {\uldb Expression Patterns}{\v Expression_Patterns}, Prev: {\uldb Kinds of Patterns}{\v Kinds_of_Patterns}, Up: {\uldb Pattern Overview}{\v Pattern_Overview}\line
K{\footnote K Regexp Patterns}
#{\footnote Regexp_Patterns}
${\footnote \pard{}Regular Expressions as Patterns}\par
\pard{\fs24\b Regular Expressions as Patterns}\par
\par
\pard{}We have been using regular expressions as patterns since our early examples.  This kind of pattern is simply a regexp constant in the pattern part of a rule.  Its  meaning is {\f1{}$0 ~ /{\i pattern}/}.  The pattern matches when the input record matches the regexp.  For example:\par
\par
{\pard\keep\li720\f1{}/foo|bar|baz/  \'7B buzzwords++ \'7D\line
END            \'7B print buzzwords, "buzzwords seen" \'7D\par
\pard\f0{}}\par
\page\pard Node: {\b Expression Patterns}, \keepn Next: {\uldb Ranges}{\v Ranges}, Prev: {\uldb Regexp Patterns}{\v Regexp_Patterns}, Up: {\uldb Pattern Overview}{\v Pattern_Overview}\line
K{\footnote K Expression Patterns}
#{\footnote Expression_Patterns}
${\footnote \pard{}Expressions as Patterns}\par
\pard{\fs24\b Expressions as Patterns}\par
\par
\pard{}Any {\f1{}awk} expression is valid as an {\f1{}awk} pattern.  Then the pattern matches if the expression's value is non-zero (if a number) or non-null (if a string).\par
\par
\pard{}The expression is reevaluated each time the rule is tested against a new input record.  If the expression uses fields such as {\f1{}$1}, the value depends directly on the new input record's text; otherwise, it depends only on what has happened so far in the execution of the {\f1{}awk} program, but that may still be useful.\par
\par
\pard{}A very common kind of expression used as a pattern is the comparison expression, using the comparison operators described in {\uldb Variable Typing and Comparison Expressions}{\v Typing_and_Comparison}.\par
\par
\pard{}Regexp matching and non-matching are also very common expressions.  The left operand of the {\f1{}~} and {\f1{}!~} operators is a string.  The right operand is either a constant regular expression enclosed in slashes ({\f1{}/{\i regexp}/}), or any expression, whose string value is used as a dynamic regular expression (see {\uldb Using Dynamic Regexps}{\v Computed_Regexps}).\par
\par
\pard{}The following example prints the second field of each input record whose first field is precisely {\f1{}foo}.\par
\par
{\pard\keep\li720\f1{}$ awk '$1 == "foo" \'7B print $2 \'7D' BBS-list\par
\pard\f0{}}\par
\pard{}(There is no output, since there is no BBS site named "foo".)  Contrast this with the following regular expression match, which would accept any record with a first field that contains {\f1{}foo}:\par
\par
{{\pard\keep\li720\f1{}$ awk '$1 ~ /foo/ \'7B print $2 \'7D' BBS-list\line
-| 555-1234\line
-| 555-6699\line
-| 555-6480\line
-| 555-2127\par
\pard\keep\li720{}}}\par
\pard\f0{}Boolean expressions are also commonly used as patterns.  Whether the pattern matches an input record depends on whether its subexpressions match.\par
\par
\pard{}For example, the following command prints all records in {\f1{}BBS-list} that contain both {\f1{}2400} and {\f1{}foo}.\par
\par
{\pard\keep\li720\f1{}$ awk '/2400/ && /foo/' BBS-list\line
-| fooey        555-1234     2400/1200/300     B\par
\pard\f0{}}\par
\pard{}The following command prints all records in {\f1{}BBS-list} that contain {\i either} {\f1{}2400} or {\f1{}foo}, or both.\par
\par
{{\pard\keep\li720\f1{}$ awk '/2400/ || /foo/' BBS-list\line
-| alpo-net     555-3412     2400/1200/300     A\line
-| bites        555-1675     2400/1200/300     A\line
-| fooey        555-1234     2400/1200/300     B\line
-| foot         555-6699     1200/300          B\line
-| macfoo       555-6480     1200/300          A\line
-| sdace        555-3430     2400/1200/300     A\line
-| sabafoo      555-2127     1200/300          C\par
\pard\keep\li720{}}}\par
\pard\f0{}The following command prints all records in {\f1{}BBS-list} that do {\i not} contain the string {\f1{}foo}.\par
\par
{{\pard\keep\li720\f1{}$ awk '! /foo/' BBS-list\line
-| aardvark     555-5553     1200/300          B\line
-| alpo-net     555-3412     2400/1200/300     A\line
-| barfly       555-7685     1200/300          A\line
-| bites        555-1675     2400/1200/300     A\line
-| camelot      555-0542     300               C\line
-| core         555-2912     1200/300          C\line
-| sdace        555-3430     2400/1200/300     A\par
\pard\keep\li720{}}}\par
\pard\f0{}The subexpressions of a boolean operator in a pattern can be constant regular expressions, comparisons, or any other {\f1{}awk} expressions.  Range patterns are not expressions, so they cannot appear inside boolean patterns.  Likewise, the special patterns {\f1{}BEGIN} and {\f1{}END}, which never match any input record, are not expressions and cannot appear inside boolean patterns.\par
\par
\pard{}A regexp constant as a pattern is also a special case of an expression pattern.  {\f1{}/foo/} as an expression has the value one if {\f1{}foo} appears in the current input record; thus, as a pattern, {\f1{}/foo/} matches any record containing {\f1{}foo}.\par
\par
\page\pard Node: {\b Ranges}, \keepn Next: {\uldb BEGIN/END}{\v BEGIN_END}, Prev: {\uldb Expression Patterns}{\v Expression_Patterns}, Up: {\uldb Pattern Overview}{\v Pattern_Overview}\line
K{\footnote K Ranges}
#{\footnote Ranges}
${\footnote \pard{}Specifying Record Ranges with Patterns}\par
\pard{\fs24\b Specifying Record Ranges with Patterns}\par
\par
\pard{}{K{\footnote K range pattern}}{K{\footnote K pattern, range}}{K{\footnote K matching ranges of lines}}A \'A2range pattern\'A2 is made of two patterns separated by a comma, of the form {\f1{}{\i begpat}, {\i endpat}}.  It matches ranges of consecutive input records.  The first pattern, {\i begpat}, controls where the range begins, and the second one, {\i endpat}, controls where it ends.  For example,\par
\par
{\pard\keep\li720\f1{}awk '$1 == "on", $1 == "off"'\par
\pard\f0{}}\par
\pard{}prints every record between {\f1{}on}/{\f1{}off} pairs, inclusive.\par
\par
\pard{}A range pattern starts out by matching {\i begpat} against every input record; when a record matches {\i begpat}, the range pattern becomes \'A2turned on\'A2.  The range pattern matches this record.  As long as it stays turned on, it automatically matches every input record read.  It also matches {\i endpat} against every input record; when that succeeds, the range pattern is turned off again for the following record.  Then it goes back to checking {\i begpat} against each record.\par
\par
\pard{}The record that turns on the range pattern and the one that turns it off both match the range pattern.  If you don't want to operate on these records, you can write {\f1{}if} statements in the rule's action to distinguish them from the records you are interested in.\par
\par
\pard{}It is possible for a pattern to be turned both on and off by the same record, if the record satisfies both conditions.  Then the action is executed for just that record.\par
\par
\pard{}For example, suppose you have text between two identical markers (say the {\f1{}%} symbol) that you wish to ignore.  You might try to combine a range pattern that describes the delimited text with the {\f1{}next} statement (not discussed yet, see {\uldb The {\f1{}next} Statement}{\v Next_Statement}), which causes {\f1{}awk} to skip any further processing of the current record and start over again with the next input record. Such a program would look like this:\par
\par
{\pard\keep\li720\f1{}/^%$/,/^%$/    \'7B next \'7D\line
               \'7B print \'7D\par
\pard\f0{}}\par
\pard{}{K{\footnote K skipping lines between markers}}This program fails because the range pattern is both turned on and turned off by the first line with just a {\f1{}%} on it.  To accomplish this task, you must write the program this way, using a flag:\par
\par
{\pard\keep\li720\f1{}/^%$/     \'7B skip = ! skip; next \'7D\line
skip == 1 \'7B next \'7D # skip lines with `skip' set\par
\pard\f0{}}\par
\pard{}Note that in a range pattern, the {\f1{},} has the lowest precedence (is evaluated last) of all the operators.  Thus, for example, the following program attempts to combine a range pattern with another, simpler test.\par
\par
{\pard\keep\li720\f1{}echo Yes | awk '/1/,/2/ || /Yes/'\par
\pard\f0{}}\par
\pard{}The author of this program intended it to mean {\f1{}(/1/,/2/) || /Yes/}.  However, {\f1{}awk} interprets this as {\f1{}/1/, (/2/ || /Yes/)}.  This cannot be changed or worked around; range patterns do not combine with other patterns.\par
\par
\page\pard Node: {\b BEGIN/END}, \keepn Next: {\uldb Empty}{\v Empty}, Prev: {\uldb Ranges}{\v Ranges}, Up: {\uldb Pattern Overview}{\v Pattern_Overview}\line
K{\footnote K BEGIN/END}
#{\footnote BEGIN_END}
${\footnote \pard{}The {\f1{}BEGIN} and {\f1{}END} Special Patterns}\par
\pard{\fs24\b The {\f1{}BEGIN} and {\f1{}END} Special Patterns}\par
\par
\pard{}{K{\footnote K {\f1{}BEGIN} special pattern}}{K{\footnote K pattern, {\f1{}BEGIN}}}{K{\footnote K {\f1{}END} special pattern}}{K{\footnote K pattern, {\f1{}END}}}{\f1{}BEGIN} and {\f1{}END} are special patterns.  They are not used to match input records.  Rather, they supply start-up or clean-up actions for your {\f1{}awk} script.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Using BEGIN/END}{\v Using_BEGIN_END}\tab How and why to use BEGIN/END rules.\par
{\uldb I/O And BEGIN/END}{\v I_O_And_BEGIN_END}\tab I/O issues in BEGIN/END rules.\par
\pard{}}\par
\page\pard Node: {\b Using BEGIN/END}, \keepn Next: {\uldb I/O And BEGIN/END}{\v I_O_And_BEGIN_END}, Prev: {\uldb BEGIN/END}{\v BEGIN_END}, Up: {\uldb BEGIN/END}{\v BEGIN_END}\line
K{\footnote K Using BEGIN/END}
#{\footnote Using_BEGIN_END}
${\footnote \pard{}Startup and Cleanup Actions}\par
\pard{\fs24\b Startup and Cleanup Actions}\par
\par
\pard{}A {\f1{}BEGIN} rule is executed, once, before the first input record has been read.  An {\f1{}END} rule is executed, once, after all the input has been read.  For example:\par
\par
{{\pard\keep\li720\f1{}$ awk '\line
> BEGIN \'7B print "Analysis of \'5C"foo\'5C"" \'7D\line
> /foo/ \'7B ++n \'7D\line
> END   \'7B print "\'5C"foo\'5C" appears " n " times." \'7D' BBS-list\line
-| Analysis of "foo"\line
-| "foo" appears 4 times.\par
\pard\keep\li720{}}}\par
\pard\f0{}This program finds the number of records in the input file {\f1{}BBS-list} that contain the string {\f1{}foo}.  The {\f1{}BEGIN} rule prints a title for the report.  There is no need to use the {\f1{}BEGIN} rule to initialize the counter {\f1{}n} to zero, as {\f1{}awk} does this automatically (see {\uldb Variables}{\v Variables}).\par
\par
\pard{}The second rule increments the variable {\f1{}n} every time a record containing the pattern {\f1{}foo} is read.  The {\f1{}END} rule prints the value of {\f1{}n} at the end of the run.\par
\par
\pard{}The special patterns {\f1{}BEGIN} and {\f1{}END} cannot be used in ranges or with boolean operators (indeed, they cannot be used with any operators).\par
\par
\pard{}An {\f1{}awk} program may have multiple {\f1{}BEGIN} and/or {\f1{}END} rules.  They are executed in the order they appear, all the {\f1{}BEGIN} rules at start-up and all the {\f1{}END} rules at termination.  {\f1{}BEGIN} and {\f1{}END} rules may be intermixed with other rules.  This feature was added in the 1987 version of {\f1{}awk}, and is included in the POSIX standard.  The original (1978) version of {\f1{}awk} required you to put the {\f1{}BEGIN} rule at the beginning of the program, and the {\f1{}END} rule at the end, and only allowed one of each.  This is no longer required, but it is a good idea in terms of program organization and readability.\par
\par
\pard{}Multiple {\f1{}BEGIN} and {\f1{}END} rules are useful for writing library functions, since each library file can have its own {\f1{}BEGIN} and/or {\f1{}END} rule to do its own initialization and/or cleanup.  Note that the order in which library functions are named on the command line controls the order in which their {\f1{}BEGIN} and {\f1{}END} rules are executed.  Therefore you have to be careful to write such rules in library files so that the order in which they are executed doesn't matter.  See {\uldb Command Line Options}{\v Options}, for more information on using library functions.  See {\uldb A Library of {\f1{}awk} Functions}{\v Library_Functions}, for a number of useful library functions.\par
\par
\pard{}{K{\footnote K dark corner}}If an {\f1{}awk} program only has a {\f1{}BEGIN} rule, and no other rules, then the program exits after the {\f1{}BEGIN} rule has been run.  (The original version of {\f1{}awk} used to keep reading and ignoring input until end of file was seen.)  However, if an {\f1{}END} rule exists, then the input will be read, even if there are no other rules in the program.  This is necessary in case the {\f1{}END} rule checks the {\f1{}FNR} and {\f1{}NR} variables (d.c.).\par
\par
{\f1{}\pard{}BEGIN} and {\f1{}END} rules must have actions; there is no default action for these rules since there is no current record when they run.\par
\par
\page\pard Node: {\b I/O And BEGIN/END}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Using BEGIN/END}{\v Using_BEGIN_END}, Up: {\uldb BEGIN/END}{\v BEGIN_END}\line
K{\footnote K I/O And BEGIN/END}
#{\footnote I_O_And_BEGIN_END}
${\footnote \pard{}Input/Output from {\f1{}BEGIN} and {\f1{}END} Rules}\par
\pard{\fs24\b Input/Output from {\f1{}BEGIN} and {\f1{}END} Rules}\par
\par
\pard{}{K{\footnote K I/O from {\f1{}BEGIN} and {\f1{}END}}}There are several (sometimes subtle) issues involved when doing I/O from a {\f1{}BEGIN} or {\f1{}END} rule.\par
\par
\pard{}The first has to do with the value of {\f1{}$0} in a {\f1{}BEGIN} rule.  Since {\f1{}BEGIN} rules are executed before any input is read, there simply is no input record, and therefore no fields, when executing {\f1{}BEGIN} rules.  References to {\f1{}$0} and the fields yield a null string or zero, depending upon the context.  One way to give {\f1{}$0} a real value is to execute a {\f1{}getline} command without a variable (see {\uldb Explicit Input with {\f1{}getline}}{\v Getline}).  Another way is to simply assign a value to it.\par
\par
\pard{}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}The second point is similar to the first, but from the other direction.  Inside an {\f1{}END} rule, what is the value of {\f1{}$0} and {\f1{}NF}?  Traditionally, due largely to implementation issues, {\f1{}$0} and {\f1{}NF} were {\i undefined} inside an {\f1{}END} rule.  The POSIX standard specified that {\f1{}NF} was available in an {\f1{}END} rule, containing the number of fields from the last input record.  Due most probably to an oversight, the standard does not say that {\f1{}$0} is also preserved, although logically one would think that it should be.  In fact, {\f1{}gawk} does preserve the value of {\f1{}$0} for use in {\f1{}END} rules.  Be aware, however, that Unix {\f1{}awk}, and possibly other implementations, do not.\par
\par
\pard{}The third point follows from the first two.  What is the meaning of {\f1{}print} inside a {\f1{}BEGIN} or {\f1{}END} rule?  The meaning is the same as always, {\f1{}print $0}.  If {\f1{}$0} is the null string, then this prints an empty line.  Many long time {\f1{}awk} programmers use {\f1{}print} in {\f1{}BEGIN} and {\f1{}END} rules, to mean {\f1{}print ""}, relying on {\f1{}$0} being null.  While you might generally get away with this in {\f1{}BEGIN} rules, in {\f1{}gawk} at least, it is a very bad idea in {\f1{}END} rules.  It is also poor style, since if you want an empty line in the output, you should say so explicitly in your program.\par
\par
\page\pard Node: {\b Empty}, \keepn Next: {\uldb }{\v }, Prev: {\uldb BEGIN/END}{\v BEGIN_END}, Up: {\uldb Pattern Overview}{\v Pattern_Overview}\line
K{\footnote K Empty}
#{\footnote Empty}
${\footnote \pard{}The Empty Pattern}\par
\pard{\fs24\b The Empty Pattern}\par
\par
\pard{}{K{\footnote K empty pattern}}{K{\footnote K pattern, empty}}An empty (i.e. non-existent) pattern is considered to match {\i every} input record.  For example, the program:\par
\par
{\pard\keep\li720\f1{}awk '\'7B print $1 \'7D' BBS-list\par
\pard\f0{}}\par
\pard{}prints the first field of every record.\par
\par
\page\pard Node: {\b Action Overview}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Pattern Overview}{\v Pattern_Overview}, Up: {\uldb Patterns and Actions}{\v Patterns_and_Actions}\line
K{\footnote K Action Overview}
#{\footnote Action_Overview}
${\footnote \pard{}Overview of Actions}\par
\pard{\fs24\b Overview of Actions}\par
\par
\pard{}{K{\footnote K action, definition of}}{K{\footnote K curly braces}}{K{\footnote K action, curly braces}}{K{\footnote K action, separating statements}} An {\f1{}awk} program or script consists of a series of rules and function definitions, interspersed.  (Functions are described later.  See {\uldb User-defined Functions}{\v User_defined}.)\par
\par
\pard{}A rule contains a pattern and an action, either of which (but not both) may be omitted.  The purpose of the \'A2action\'A2 is to tell {\f1{}awk} what to do once a match for the pattern is found.  Thus, in outline, an {\f1{}awk} program generally looks like this:\par
\par
{\pard\li720\f1{}[{\i pattern}] [\'7B {\i action} \'7D]\line
[{\i pattern}] [\'7B {\i action} \'7D]\line
...\line
function {\i name}({\i args}) \'7B ... \'7D\line
...\par
\pard\f0{}}\par
\pard{}An action consists of one or more {\f1{}awk} \'A2statements\'A2, enclosed in curly braces ({\f1{}\'7B} and {\f1{}\'7D}).  Each statement specifies one thing to be done.  The statements are separated by newlines or semicolons.\par
\par
\pard{}The curly braces around an action must be used even if the action contains only one statement, or even if it contains no statements at all.  However, if you omit the action entirely, omit the curly braces as well.  An omitted action is equivalent to {\f1{}\'7B print $0 \'7D}.\par
\par
{\pard\keep\li720\f1{}/foo/  \'7B \'7D  # match foo, do nothing - empty action\line
/foo/       # match foo, print the record - omitted action\par
\pard\f0{}}\par
\pard{}Here are the kinds of statements supported in {\f1{}awk}:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Expressions, which can call functions or assign values to variables (see {\uldb Expressions}{\v Expressions}).  Executing this kind of statement simply computes the value of the expression.  This is useful when the expression has side effects (see {\uldb Assignment Expressions}{\v Assignment_Ops}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Control statements, which specify the control flow of {\f1{}awk} programs.  The {\f1{}awk} language gives you C-like constructs ({\f1{}if}, {\f1{}for}, {\f1{}while}, and {\f1{}do}) as well as a few special ones (see {\uldb Control Statements in Actions}{\v Statements}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Compound statements, which consist of one or more statements enclosed in curly braces.  A compound statement is used in order to put several statements together in the body of an {\f1{}if}, {\f1{}while}, {\f1{}do} or {\f1{}for} statement.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Input statements, using the {\f1{}getline} command (see {\uldb Explicit Input with {\f1{}getline}}{\v Getline}), the {\f1{}next} statement (see {\uldb The {\f1{}next} Statement}{\v Next_Statement}), and the {\f1{}nextfile} statement (see {\uldb The {\f1{}nextfile} Statement}{\v Nextfile_Statement}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Output statements, {\f1{}print} and {\f1{}printf}.  See {\uldb Printing Output}{\v Printing}.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Deletion statements, for deleting array elements.  See {\uldb The {\f1{}delete} Statement}{\v Delete}.\par
\pard{}}\par
\page\pard Node: {\b Statements}, \keepn Next: {\uldb Built-in Variables}{\v Built_in_Variables}, Prev: {\uldb Patterns and Actions}{\v Patterns_and_Actions}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Statements}
#{\footnote Statements}
${\footnote \pard{}Control Statements in Actions}\par
\pard{\fs24\b Control Statements in Actions}\par
\par
\pard{}{K{\footnote K control statement}} \'A2Control statements\'A2 such as {\f1{}if}, {\f1{}while}, and so on control the flow of execution in {\f1{}awk} programs.  Most of the control statements in {\f1{}awk} are patterned on similar statements in C.\par
\par
\pard{}All the control statements start with special keywords such as {\f1{}if} and {\f1{}while}, to distinguish them from simple expressions.\par
\par
\pard{}{K{\footnote K compound statement}}{K{\footnote K statement, compound}}Many control statements contain other statements; for example, the {\f1{}if} statement contains another statement which may or may not be executed.  The contained statement is called the \'A2body\'A2.  If you want to include more than one statement in the body, group them into a single \'A2compound statement\'A2 with curly braces, separating them with newlines or semicolons.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb If Statement}{\v If_Statement}\tab Conditionally execute some {\f1{}awk} statements.\par
{\uldb While Statement}{\v While_Statement}\tab Loop until some condition is satisfied.\par
{\uldb Do Statement}{\v Do_Statement}\tab Do specified action while looping until some condition is satisfied.\par
{\uldb For Statement}{\v For_Statement}\tab Another looping statement, that provides initialization and increment clauses.\par
{\uldb Break Statement}{\v Break_Statement}\tab Immediately exit the innermost enclosing loop.\par
{\uldb Continue Statement}{\v Continue_Statement}\tab Skip to the end of the innermost enclosing loop.\par
{\uldb Next Statement}{\v Next_Statement}\tab Stop processing the current input record.\par
{\uldb Nextfile Statement}{\v Nextfile_Statement}\tab Stop processing the current file.\par
{\uldb Exit Statement}{\v Exit_Statement}\tab Stop execution of {\f1{}awk}.\par
\pard{}}\par
\page\pard Node: {\b If Statement}, \keepn Next: {\uldb While Statement}{\v While_Statement}, Prev: {\uldb Statements}{\v Statements}, Up: {\uldb Statements}{\v Statements}\line
K{\footnote K If Statement}
#{\footnote If_Statement}
${\footnote \pard{}The {\f1{}if}-{\f1{}else} Statement}\par
\pard{\fs24\b The {\f1{}if}-{\f1{}else} Statement}\par
\par
\pard{}{K{\footnote K {\f1{}if}-{\f1{}else} statement}}The {\f1{}if}-{\f1{}else} statement is {\f1{}awk}'s decision-making statement.  It looks like this:\par
\par
{\pard\keep\li720\f1{}if ({\i condition}) {\i then-body} [else {\i else-body}]\par
\pard\f0{}}\par
\pard{}The {\i condition} is an expression that controls what the rest of the statement will do.  If {\i condition} is true, {\i then-body} is executed; otherwise, {\i else-body} is executed.  The {\f1{}else} part of the statement is optional.  The condition is considered false if its value is zero or the null string, and true otherwise.\par
\par
\pard{}Here is an example:\par
\par
{\pard\keep\li720\f1{}if (x % 2 == 0)\line
    print "x is even"\line
else\line
    print "x is odd"\par
\pard\f0{}}\par
\pard{}In this example, if the expression {\f1{}x % 2 == 0} is true (that is, the value of {\f1{}x} is evenly divisible by two), then the first {\f1{}print} statement is executed, otherwise the second {\f1{}print} statement is executed.\par
\par
\pard{}If the {\f1{}else} appears on the same line as {\i then-body}, and {\i then-body} is not a compound statement (i.e. not surrounded by curly braces), then a semicolon must separate {\i then-body} from {\f1{}else}.  To illustrate this, let's rewrite the previous example:\par
\par
{\pard\keep\li720\f1{}if (x % 2 == 0) print "x is even"; else\line
        print "x is odd"\par
\pard\f0{}}\par
\pard{}If you forget the {\f1{};}, {\f1{}awk} won't be able to interpret the statement, and you will get a syntax error.\par
\par
\pard{}We would not actually write this example this way, because a human reader might fail to see the {\f1{}else} if it were not the first thing on its line.\par
\par
\page\pard Node: {\b While Statement}, \keepn Next: {\uldb Do Statement}{\v Do_Statement}, Prev: {\uldb If Statement}{\v If_Statement}, Up: {\uldb Statements}{\v Statements}\line
K{\footnote K While Statement}
#{\footnote While_Statement}
${\footnote \pard{}The {\f1{}while} Statement}\par
\pard{\fs24\b The {\f1{}while} Statement}\par
\par
\pard{}{K{\footnote K {\f1{}while} statement}}{K{\footnote K loop}}{K{\footnote K body of a loop}} In programming, a \'A2loop\'A2 means a part of a program that can be executed two or more times in succession.\par
\par
\pard{}The {\f1{}while} statement is the simplest looping statement in {\f1{}awk}.  It repeatedly executes a statement as long as a condition is true.  It looks like this:\par
\par
{\pard\keep\li720\f1{}while ({\i condition})\line
  {\i body}\par
\pard\f0{}}\par
\pard{}Here {\i body} is a statement that we call the \'A2body\'A2 of the loop, and {\i condition} is an expression that controls how long the loop keeps running.\par
\par
\pard{}The first thing the {\f1{}while} statement does is test {\i condition}.  If {\i condition} is true, it executes the statement {\i body}.  {(The {\i condition} is true when the value is not zero and not a null string.)  }After {\i body} has been executed, {\i condition} is tested again, and if it is still true, {\i body} is executed again.  This process repeats until {\i condition} is no longer true.  If {\i condition} is initially false, the body of the loop is never executed, and {\f1{}awk} continues with the statement following the loop.\par
\par
\pard{}This example prints the first three fields of each record, one per line.\par
\par
{\pard\keep\li720\f1{}awk '\'7B i = 1\line
       while (i <= 3) \'7B\line
           print $i\line
           i++\line
       \'7D\line
\'7D' inventory-shipped\par
\pard\f0{}}\par
\pard{}Here the body of the loop is a compound statement enclosed in braces, containing two statements.\par
\par
\pard{}The loop works like this: first, the value of {\f1{}i} is set to one.  Then, the {\f1{}while} tests whether {\f1{}i} is less than or equal to three.  This is true when {\f1{}i} equals one, so the {\f1{}i}-th field is printed.  Then the {\f1{}i++} increments the value of {\f1{}i} and the loop repeats.  The loop terminates when {\f1{}i} reaches four.\par
\par
\pard{}As you can see, a newline is not required between the condition and the body; but using one makes the program clearer unless the body is a compound statement or is very simple.  The newline after the open-brace that begins the compound statement is not required either, but the program would be harder to read without it.\par
\par
\page\pard Node: {\b Do Statement}, \keepn Next: {\uldb For Statement}{\v For_Statement}, Prev: {\uldb While Statement}{\v While_Statement}, Up: {\uldb Statements}{\v Statements}\line
K{\footnote K Do Statement}
#{\footnote Do_Statement}
${\footnote \pard{}The {\f1{}do}-{\f1{}while} Statement}\par
\pard{\fs24\b The {\f1{}do}-{\f1{}while} Statement}\par
\par
\pard{}The {\f1{}do} loop is a variation of the {\f1{}while} looping statement.  The {\f1{}do} loop executes the {\i body} once, and then repeats {\i body} as long as {\i condition} is true.  It looks like this:\par
\par
{{\pard\keep\li720\f1{}do\line
  {\i body}\line
while ({\i condition})\par
\pard\keep\li720{}}}\par
\pard\f0{}Even if {\i condition} is false at the start, {\i body} is executed at least once (and only once, unless executing {\i body} makes {\i condition} true).  Contrast this with the corresponding {\f1{}while} statement:\par
\par
{\pard\keep\li720\f1{}while ({\i condition})\line
  {\i body}\par
\pard\f0{}}\par
\pard{}This statement does not execute {\i body} even once if {\i condition} is false to begin with.\par
\par
\pard{}Here is an example of a {\f1{}do} statement:\par
\par
{\pard\keep\li720\f1{}awk '\'7B i = 1\line
       do \'7B\line
          print $0\line
          i++\line
       \'7D while (i <= 10)\line
\'7D'\par
\pard\f0{}}\par
\pard{}This program prints each input record ten times.  It isn't a very realistic example, since in this case an ordinary {\f1{}while} would do just as well.  But this reflects actual experience; there is only occasionally a real use for a {\f1{}do} statement.\par
\par
\page\pard Node: {\b For Statement}, \keepn Next: {\uldb Break Statement}{\v Break_Statement}, Prev: {\uldb Do Statement}{\v Do_Statement}, Up: {\uldb Statements}{\v Statements}\line
K{\footnote K For Statement}
#{\footnote For_Statement}
${\footnote \pard{}The {\f1{}for} Statement}\par
\pard{\fs24\b The {\f1{}for} Statement}\par
\par
\pard{}{K{\footnote K {\f1{}for} statement}} The {\f1{}for} statement makes it more convenient to count iterations of a loop.  The general form of the {\f1{}for} statement looks like this:\par
\par
{\pard\keep\li720\f1{}for ({\i initialization}; {\i condition}; {\i increment})\line
  {\i body}\par
\pard\f0{}}\par
\pard{}The {\i initialization}, {\i condition} and {\i increment} parts are arbitrary {\f1{}awk} expressions, and {\i body} stands for any {\f1{}awk} statement.\par
\par
\pard{}The {\f1{}for} statement starts by executing {\i initialization}.  Then, as long as {\i condition} is true, it repeatedly executes {\i body} and then {\i increment}.  Typically {\i initialization} sets a variable to either zero or one, {\i increment} adds one to it, and {\i condition} compares it against the desired number of iterations.\par
\par
\pard{}Here is an example of a {\f1{}for} statement:\par
\par
{{\pard\keep\li720\f1{}awk '\'7B for (i = 1; i <= 3; i++)\line
          print $i\line
\'7D' inventory-shipped\par
\pard\keep\li720{}}}\par
\pard\f0{}This prints the first three fields of each input record, one field per line.\par
\par
\pard{}You cannot set more than one variable in the {\i initialization} part unless you use a multiple assignment statement such as {\f1{}x = y = 0}, which is possible only if all the initial values are equal.  (But you can initialize additional variables by writing their assignments as separate statements preceding the {\f1{}for} loop.)\par
\par
\pard{}The same is true of the {\i increment} part; to increment additional variables, you must write separate statements at the end of the loop.  The C compound expression, using C's comma operator, would be useful in this context, but it is not supported in {\f1{}awk}.\par
\par
\pard{}Most often, {\i increment} is an increment expression, as in the example above.  But this is not required; it can be any expression whatever.  For example, this statement prints all the powers of two between one and 100:\par
\par
{\pard\keep\li720\f1{}for (i = 1; i <= 100; i *= 2)\line
  print i\par
\pard\f0{}}\par
\pard{}Any of the three expressions in the parentheses following the {\f1{}for} may be omitted if there is nothing to be done there.  Thus, {\f1{}for (; x > 0;)} is equivalent to {\f1{}while (x > 0)}.  If the {\i condition} is omitted, it is treated as {\i true}, effectively yielding an \'A2infinite loop\'A2 (i.e. a loop that will never terminate).\par
\par
\pard{}In most cases, a {\f1{}for} loop is an abbreviation for a {\f1{}while} loop, as shown here:\par
\par
{{\i \pard\li720\f1{}initialization}\line
while ({\i condition}) \'7B\line
  {\i body}\line
  {\i increment}\line
\'7D\par
\pard\f0{}}\par
\pard{}The only exception is when the {\f1{}continue} statement (see {\uldb The {\f1{}continue} Statement}{\v Continue_Statement}) is used inside the loop; changing a {\f1{}for} statement to a {\f1{}while} statement in this way can change the effect of the {\f1{}continue} statement inside the loop.\par
\par
\pard{}There is an alternate version of the {\f1{}for} loop, for iterating over all the indices of an array:\par
\par
{\pard\keep\li720\f1{}for (i in array)\line
    {\i do something with} array[i]\par
\pard\f0{}}\par
\pard{}See {\uldb Scanning All Elements of an Array}{\v Scanning_an_Array}, for more information on this version of the {\f1{}for} loop.\par
\par
\pard{}The {\f1{}awk} language has a {\f1{}for} statement in addition to a {\f1{}while} statement because often a {\f1{}for} loop is both less work to type and more natural to think of.  Counting the number of iterations is very common in loops.  It can be easier to think of this counting as part of looping rather than as something to do inside the loop.\par
\par
\pard{}The next section has more complicated examples of {\f1{}for} loops.\par
\par
\page\pard Node: {\b Break Statement}, \keepn Next: {\uldb Continue Statement}{\v Continue_Statement}, Prev: {\uldb For Statement}{\v For_Statement}, Up: {\uldb Statements}{\v Statements}\line
K{\footnote K Break Statement}
#{\footnote Break_Statement}
${\footnote \pard{}The {\f1{}break} Statement}\par
\pard{\fs24\b The {\f1{}break} Statement}\par
\par
\pard{}{K{\footnote K {\f1{}break} statement}}{K{\footnote K loops, exiting}} The {\f1{}break} statement jumps out of the innermost {\f1{}for}, {\f1{}while}, or {\f1{}do} loop that encloses it.  The following example finds the smallest divisor of any integer, and also identifies prime numbers:\par
\par
{\pard\keep\li720\f1{}awk '# find smallest divisor of num\line
     \'7B num = $1\line
       for (div = 2; div*div <= num; div++)\line
         if (num % div == 0)\line
           break\line
       if (num % div == 0)\line
         printf "Smallest divisor of %d is %d\'5Cn", num, div\line
       else\line
         printf "%d is prime\'5Cn", num\line
     \'7D'\par
\pard\f0{}}\par
\pard{}When the remainder is zero in the first {\f1{}if} statement, {\f1{}awk} immediately \'A2breaks out\'A2 of the containing {\f1{}for} loop.  This means that {\f1{}awk} proceeds immediately to the statement following the loop and continues processing.  (This is very different from the {\f1{}exit} statement which stops the entire {\f1{}awk} program.  See {\uldb The {\f1{}exit} Statement}{\v Exit_Statement}.)\par
\par
\pard{}Here is another program equivalent to the previous one.  It illustrates how the {\i condition} of a {\f1{}for} or {\f1{}while} could just as well be replaced with a {\f1{}break} inside an {\f1{}if}:\par
\par
{{\pard\keep\li720\f1{}awk '# find smallest divisor of num\line
     \'7B num = $1\line
       for (div = 2; ; div++) \'7B\line
         if (num % div == 0) \'7B\line
           printf "Smallest divisor of %d is %d\'5Cn", num, div\line
           break\line
         \'7D\line
         if (div*div > num) \'7B\line
           printf "%d is prime\'5Cn", num\line
           break\line
         \'7D\line
       \'7D\line
\'7D'\par
\pard\keep\li720{}}}\par
\pard\f0{}{K{\footnote K {\f1{}break}, outside of loops}}{K{\footnote K historical features}}{K{\footnote K {\f1{}awk} language, POSIX version}}{K{\footnote K POSIX {\f1{}awk}}}{K{\footnote K dark corner}}As described above, the {\f1{}break} statement has no meaning when used outside the body of a loop.  However, although it was never documented, historical implementations of {\f1{}awk} have treated the {\f1{}break} statement outside of a loop as if it were a {\f1{}next} statement (see {\uldb The {\f1{}next} Statement}{\v Next_Statement}).  Recent versions of Unix {\f1{}awk} no longer allow this usage.  {\f1{}gawk} will support this use of {\f1{}break} only if {\f1{}--traditional} has been specified on the command line (see {\uldb Command Line Options}{\v Options}).  Otherwise, it will be treated as an error, since the POSIX standard specifies that {\f1{}break} should only be used inside the body of a loop (d.c.).\par
\par
\page\pard Node: {\b Continue Statement}, \keepn Next: {\uldb Next Statement}{\v Next_Statement}, Prev: {\uldb Break Statement}{\v Break_Statement}, Up: {\uldb Statements}{\v Statements}\line
K{\footnote K Continue Statement}
#{\footnote Continue_Statement}
${\footnote \pard{}The {\f1{}continue} Statement}\par
\pard{\fs24\b The {\f1{}continue} Statement}\par
\par
\pard{}{K{\footnote K {\f1{}continue} statement}}The {\f1{}continue} statement, like {\f1{}break}, is used only inside {\f1{}for}, {\f1{}while}, and {\f1{}do} loops.  It skips over the rest of the loop body, causing the next cycle around the loop to begin immediately.  Contrast this with {\f1{}break}, which jumps out of the loop altogether.\par
\par
\pard{}The {\f1{}continue} statement in a {\f1{}for} loop directs {\f1{}awk} to skip the rest of the body of the loop, and resume execution with the increment-expression of the {\f1{}for} statement.  The following program illustrates this fact:\par
\par
{\pard\keep\li720\f1{}awk 'BEGIN \'7B\line
     for (x = 0; x <= 20; x++) \'7B\line
         if (x == 5)\line
             continue\line
         printf "%d ", x\line
     \'7D\line
     print ""\line
\'7D'\par
\pard\f0{}}\par
\pard{}This program prints all the numbers from zero to 20, except for five, for which the {\f1{}printf} is skipped.  Since the increment {\f1{}x++} is not skipped, {\f1{}x} does not remain stuck at five.  Contrast the {\f1{}for} loop above with this {\f1{}while} loop:\par
\par
{\pard\keep\li720\f1{}awk 'BEGIN \'7B\line
     x = 0\line
     while (x <= 20) \'7B\line
         if (x == 5)\line
             continue\line
         printf "%d ", x\line
         x++\line
     \'7D\line
     print ""\line
\'7D'\par
\pard\f0{}}\par
\pard{}This program loops forever once {\f1{}x} gets to five.\par
\par
\pard{}{K{\footnote K {\f1{}continue}, outside of loops}}{K{\footnote K historical features}}{K{\footnote K {\f1{}awk} language, POSIX version}}{K{\footnote K POSIX {\f1{}awk}}}{K{\footnote K dark corner}}As described above, the {\f1{}continue} statement has no meaning when used outside the body of a loop.  However, although it was never documented, historical implementations of {\f1{}awk} have treated the {\f1{}continue} statement outside of a loop as if it were a {\f1{}next} statement (see {\uldb The {\f1{}next} Statement}{\v Next_Statement}).  Recent versions of Unix {\f1{}awk} no longer allow this usage.  {\f1{}gawk} will support this use of {\f1{}continue} only if {\f1{}--traditional} has been specified on the command line (see {\uldb Command Line Options}{\v Options}).  Otherwise, it will be treated as an error, since the POSIX standard specifies that {\f1{}continue} should only be used inside the body of a loop (d.c.).\par
\par
\page\pard Node: {\b Next Statement}, \keepn Next: {\uldb Nextfile Statement}{\v Nextfile_Statement}, Prev: {\uldb Continue Statement}{\v Continue_Statement}, Up: {\uldb Statements}{\v Statements}\line
K{\footnote K Next Statement}
#{\footnote Next_Statement}
${\footnote \pard{}The {\f1{}next} Statement}\par
\pard{\fs24\b The {\f1{}next} Statement}\par
\par
\pard{}{K{\footnote K {\f1{}next} statement}} The {\f1{}next} statement forces {\f1{}awk} to immediately stop processing the current record and go on to the next record.  This means that no further rules are executed for the current record.  The rest of the current rule's action is not executed either.\par
\par
\pard{}Contrast this with the effect of the {\f1{}getline} function (see {\uldb Explicit Input with {\f1{}getline}}{\v Getline}).  That too causes {\f1{}awk} to read the next record immediately, but it does not alter the flow of control in any way.  So the rest of the current action executes with a new input record.\par
\par
\pard{}At the highest level, {\f1{}awk} program execution is a loop that reads an input record and then tests each rule's pattern against it.  If you think of this loop as a {\f1{}for} statement whose body contains the rules, then the {\f1{}next} statement is analogous to a {\f1{}continue} statement: it skips to the end of the body of this implicit loop, and executes the increment (which reads another record).\par
\par
\pard{}For example, if your {\f1{}awk} program works only on records with four fields, and you don't want it to fail when given bad input, you might use this rule near the beginning of the program:\par
\par
{{\pard\keep\li720\f1{}NF != 4 \'7B\line
  err = sprintf("%s:%d: skipped: NF != 4\'5Cn", FILENAME, FNR)\line
  print err > "/dev/stderr"\line
  next\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}so that the following rules will not see the bad record.  The error message is redirected to the standard error output stream, as error messages should be.  See {\uldb Special File Names in {\f1{}gawk}}{\v Special_Files}.\par
\par
\pard{}{K{\footnote K {\f1{}awk} language, POSIX version}}{K{\footnote K POSIX {\f1{}awk}}}According to the POSIX standard, the behavior is undefined if the {\f1{}next} statement is used in a {\f1{}BEGIN} or {\f1{}END} rule.  {\f1{}gawk} will treat it as a syntax error.  Although POSIX permits it, some other {\f1{}awk} implementations don't allow the {\f1{}next} statement inside function bodies (see {\uldb User-defined Functions}{\v User_defined}).  Just as any other {\f1{}next} statement, a {\f1{}next} inside a function body reads the next record and starts processing it with the first rule in the program.\par
\par
\pard{}If the {\f1{}next} statement causes the end of the input to be reached, then the code in any {\f1{}END} rules will be executed.  See {\uldb The {\f1{}BEGIN} and {\f1{}END} Special Patterns}{\v BEGIN_END}.\par
\par
\pard{}{K{\footnote K {\f1{}next}, inside a user-defined function}}{\b Caution:} Some {\f1{}awk} implementations generate a run-time error if you use the {\f1{}next} statement inside a user-defined function (see {\uldb User-defined Functions}{\v User_defined}).  {\f1{}gawk} does not have this problem.\par
\par
\page\pard Node: {\b Nextfile Statement}, \keepn Next: {\uldb Exit Statement}{\v Exit_Statement}, Prev: {\uldb Next Statement}{\v Next_Statement}, Up: {\uldb Statements}{\v Statements}\line
K{\footnote K Nextfile Statement}
#{\footnote Nextfile_Statement}
${\footnote \pard{}The {\f1{}nextfile} Statement}\par
\pard{\fs24\b The {\f1{}nextfile} Statement}\par
\par
\pard{}{K{\footnote K {\f1{}nextfile} statement}}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}} {\f1{}gawk} provides the {\f1{}nextfile} statement, which is similar to the {\f1{}next} statement.  However, instead of abandoning processing of the current record, the {\f1{}nextfile} statement instructs {\f1{}gawk} to stop processing the current data file.\par
\par
\pard{}Upon execution of the {\f1{}nextfile} statement, {\f1{}FILENAME} is updated to the name of the next data file listed on the command line, {\f1{}FNR} is reset to one, {\f1{}ARGIND} is incremented, and processing starts over with the first rule in the progam.  See {\uldb Built-in Variables}{\v Built_in_Variables}.\par
\par
\pard{}If the {\f1{}nextfile} statement causes the end of the input to be reached, then the code in any {\f1{}END} rules will be executed.  See {\uldb The {\f1{}BEGIN} and {\f1{}END} Special Patterns}{\v BEGIN_END}.\par
\par
\pard{}The {\f1{}nextfile} statement is a {\f1{}gawk} extension; it is not (currently) available in any other {\f1{}awk} implementation.  See {\uldb Implementing {\f1{}nextfile} as a Function}{\v Nextfile_Function}, for a user-defined function you can use to simulate the {\f1{}nextfile} statement.\par
\par
\pard{}The {\f1{}nextfile} statement would be useful if you have many data files to process, and you expect that you would not want to process every record in every file.  Normally, in order to move on to the next data file, you would have to continue scanning the unwanted records.  The {\f1{}nextfile} statement accomplishes this much more efficiently.\par
\par
\pard{}{K{\footnote K {\f1{}next file} statement}}{\b Caution:}  Versions of {\f1{}gawk} prior to 3.0 used two words ({\f1{}next file}) for the {\f1{}nextfile} statement.  This was changed in 3.0 to one word, since the treatment of {\f1{}file} was inconsistent. When it appeared after {\f1{}next}, it was a keyword.  Otherwise, it was a regular identifier.  The old usage is still accepted. However, {\f1{}gawk} will generate a warning message, and support for {\f1{}next file} will eventually be discontinued in a future version of {\f1{}gawk}.\par
\par
\page\pard Node: {\b Exit Statement}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Nextfile Statement}{\v Nextfile_Statement}, Up: {\uldb Statements}{\v Statements}\line
K{\footnote K Exit Statement}
#{\footnote Exit_Statement}
${\footnote \pard{}The {\f1{}exit} Statement}\par
\pard{\fs24\b The {\f1{}exit} Statement}\par
\par
\pard{}{K{\footnote K {\f1{}exit} statement}}The {\f1{}exit} statement causes {\f1{}awk} to immediately stop executing the current rule and to stop processing input; any remaining input is ignored.  It looks like this:\par
\par
{\pard\keep\li720\f1{}exit [{\i return code}]\par
\pard\f0{}}\par
\pard{}If an {\f1{}exit} statement is executed from a {\f1{}BEGIN} rule the program stops processing everything immediately.  No input records are read.  However, if an {\f1{}END} rule is present, it is executed (see {\uldb The {\f1{}BEGIN} and {\f1{}END} Special Patterns}{\v BEGIN_END}).\par
\par
\pard{}If {\f1{}exit} is used as part of an {\f1{}END} rule, it causes the program to stop immediately.\par
\par
\pard{}An {\f1{}exit} statement that is not part of a {\f1{}BEGIN} or {\f1{}END} rule stops the execution of any further automatic rules for the current record, skips reading any remaining input records, and executes the {\f1{}END} rule if there is one.\par
\par
\pard{}If you do not want the {\f1{}END} rule to do its job in this case, you can set a variable to non-zero before the {\f1{}exit} statement, and check that variable in the {\f1{}END} rule.  See {\uldb Assertions}{\v Assert_Function}, for an example that does this.\par
\par
\pard{}{K{\footnote K dark corner}}If an argument is supplied to {\f1{}exit}, its value is used as the exit status code for the {\f1{}awk} process.  If no argument is supplied, {\f1{}exit} returns status zero (success).  In the case where an argument is supplied to a first {\f1{}exit} statement, and then {\f1{}exit} is called a second time with no argument, the previously supplied exit value is used (d.c.).\par
\par
\pard{}For example, let's say you've discovered an error condition you really don't know how to handle.  Conventionally, programs report this by exiting with a non-zero status.  Your {\f1{}awk} program can do this using an {\f1{}exit} statement with a non-zero argument.  Here is an example:\par
\par
{{\pard\keep\li720\f1{}BEGIN \'7B\line
       if (("date" | getline date_now) <= 0) \'7B\line
         print "Can't get system date" > "/dev/stderr"\line
         exit 1\line
       \'7D\line
       print "current date is", date_now\line
       close("date")\line
\'7D\par
\pard\keep\li720{}}}\par
\page\pard Node: {\b Built-in Variables}, \keepn Next: {\uldb Arrays}{\v Arrays}, Prev: {\uldb Statements}{\v Statements}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Built-in Variables}
#{\footnote Built_in_Variables}
${\footnote \pard\f0{}Built-in Variables}\par
\pard{\fs24\b Built-in Variables}\par
\par
\pard{}{K{\footnote K built-in variables}} Most {\f1{}awk} variables are available for you to use for your own purposes; they never change except when your program assigns values to them, and never affect anything except when your program examines them.  However, a few variables in {\f1{}awk} have special built-in meanings.  Some of them {\f1{}awk} examines automatically, so that they enable you to tell {\f1{}awk} how to do certain things.  Others are set automatically by {\f1{}awk}, so that they carry information from the internal workings of {\f1{}awk} to your program.\par
\par
\pard{}This chapter documents all the built-in variables of {\f1{}gawk}.  Most of them are also documented in the chapters describing their areas of activity.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb User-modified}{\v User_modified}\tab Built-in variables that you change to control {\f1{}awk}.\par
{\uldb Auto-set}{\v Auto_set}\tab Built-in variables where {\f1{}awk} gives you information.\par
{\uldb ARGC and ARGV}{\v ARGC_and_ARGV}\tab Ways to use {\f1{}ARGC} and {\f1{}ARGV}.\par
\pard{}}\par
\page\pard Node: {\b User-modified}, \keepn Next: {\uldb Auto-set}{\v Auto_set}, Prev: {\uldb Built-in Variables}{\v Built_in_Variables}, Up: {\uldb Built-in Variables}{\v Built_in_Variables}\line
K{\footnote K User-modified}
#{\footnote User_modified}
${\footnote \pard{}Built-in Variables that Control {\f1{}awk}}\par
\pard{\fs24\b Built-in Variables that Control {\f1{}awk}}\par
\par
\pard{}{K{\footnote K built-in variables, user modifiable}} This is an alphabetical list of the variables which you can change to control how {\f1{}awk} does certain things. Those variables that are specific to {\f1{}gawk} are marked with an asterisk, {\f1{}*}.\par
\par
{\pard\li720{}{K{\footnote K CONVFMT}}{K{\footnote K {\f1{}awk} language, POSIX version}}{K{\footnote K POSIX {\f1{}awk}}}\par
\par
\pard{}{\f1{}CONVFMT}\par
\pard\li720{}This string controls conversion of numbers to strings (see {\uldb Conversion of Strings and Numbers}{\v Conversion}).  It works by being passed, in effect, as the first argument to the {\f1{}sprintf} function (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}).  Its default value is {\f1{}"%.6g"}.  {\f1{}CONVFMT} was introduced by the POSIX standard.\par
\par
\pard\li720{}{K{\footnote K FIELDWIDTHS}}\par
\par
\pard{}{\f1{}FIELDWIDTHS *}\par
\pard\li720{}This is a space separated list of columns that tells {\f1{}gawk} how to split input with fixed, columnar boundaries.  It is an experimental feature.  Assigning to {\f1{}FIELDWIDTHS} overrides the use of {\f1{}FS} for field splitting.  See {\uldb Reading Fixed-width Data}{\v Constant_Size}, for more information.\par
\par
\pard\li720{}If {\f1{}gawk} is in compatibility mode (see {\uldb Command Line Options}{\v Options}), then {\f1{}FIELDWIDTHS} has no special meaning, and field splitting operations are done based exclusively on the value of {\f1{}FS}.\par
\par
\pard\li720{}{K{\footnote K FS}}\par
\par
\pard{}{\f1{}FS}\par
{\f1{}\pard\li720{}FS} is the input field separator (see {\uldb Specifying How Fields are Separated}{\v Field_Separators}).  The value is a single-character string or a multi-character regular expression that matches the separations between fields in an input record.  If the value is the null string ({\f1{}""}), then each character in the record becomes a separate field.\par
\par
\pard\li720{}The default value is {\f1{}" "}, a string consisting of a single space.  As a special exception, this value means that any sequence of spaces, tabs, and/or newlines is a single separator.({\ul 1}{\v User_modified_1})  It also causes spaces, tabs, and newlines at the beginning and end of a record to be ignored.\par
\par
\pard\li720{}You can set the value of {\f1{}FS} on the command line using the {\f1{}-F} option:\par
\par
{\pard\keep\li1440\f1{}awk -F, '{\i program}' {\i input-files}\par
\pard\li720\f0{}}\par
\pard\li720{}If {\f1{}gawk} is using {\f1{}FIELDWIDTHS} for field-splitting, assigning a value to {\f1{}FS} will cause {\f1{}gawk} to return to the normal, {\f1{}FS}-based, field splitting. An easy way to do this is to simply say {\f1{}FS = FS}, perhaps with an explanatory comment.\par
\par
\pard\li720{}{K{\footnote K IGNORECASE}}\par
\par
\pard{}{\f1{}IGNORECASE *}\par
\pard\li720{}If {\f1{}IGNORECASE} is non-zero or non-null, then all string comparisons, and all regular expression matching are case-independent.  Thus, regexp matching with {\f1{}~} and {\f1{}!~}, and the {\f1{}gensub}, {\f1{}gsub}, {\f1{}index}, {\f1{}match}, {\f1{}split} and {\f1{}sub} functions, record termination with {\f1{}RS}, and field splitting with {\f1{}FS} all ignore case when doing their particular regexp operations.  The value of {\f1{}IGNORECASE} does {\i not} affect array subscripting.  See {\uldb Case-sensitivity in Matching}{\v Case_sensitivity}.\par
\par
\pard\li720{}If {\f1{}gawk} is in compatibility mode (see {\uldb Command Line Options}{\v Options}), then {\f1{}IGNORECASE} has no special meaning, and string and regexp operations are always case-sensitive.\par
\par
\pard\li720{}{K{\footnote K OFMT}}\par
\par
\pard{}{\f1{}OFMT}\par
\pard\li720{}This string controls conversion of numbers to strings (see {\uldb Conversion of Strings and Numbers}{\v Conversion}) for printing with the {\f1{}print} statement.  It works by being passed, in effect, as the first argument to the {\f1{}sprintf} function (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}).  Its default value is {\f1{}"%.6g"}.  Earlier versions of {\f1{}awk} also used {\f1{}OFMT} to specify the format for converting numbers to strings in general expressions; this is now done by {\f1{}CONVFMT}.\par
\par
\pard\li720{}{K{\footnote K OFS}}\par
\par
\pard{}{\f1{}OFS}\par
\pard\li720{}This is the output field separator (see {\uldb Output Separators}{\v Output_Separators}).  It is output between the fields output by a {\f1{}print} statement.  Its default value is {\f1{}" "}, a string consisting of a single space.\par
\par
\pard\li720{}{K{\footnote K ORS}}\par
\par
\pard{}{\f1{}ORS}\par
\pard\li720{}This is the output record separator.  It is output at the end of every {\f1{}print} statement.  Its default value is {\f1{}"\'5Cn"}.  (See {\uldb Output Separators}{\v Output_Separators}.)\par
\par
\pard\li720{}{K{\footnote K RS}}\par
\par
\pard{}{\f1{}RS}\par
\pard\li720{}This is {\f1{}awk}'s input record separator.  Its default value is a string containing a single newline character, which means that an input record consists of a single line of text.  It can also be the null string, in which case records are separated by runs of blank lines, or a regexp, in which case records are separated by matches of the regexp in the input text.  (See {\uldb How Input is Split into Records}{\v Records}.)\par
\par
\pard\li720{}{K{\footnote K SUBSEP}}\par
\par
\pard{}{\f1{}SUBSEP}\par
{\f1{}\pard\li720{}SUBSEP} is the subscript separator.  It has the default value of {\f1{}"\'5C034"}, and is used to separate the parts of the indices of a multi-dimensional array.  Thus, the expression {\f1{}foo["A", "B"]} really accesses {\f1{}foo["A\'5C034B"]} (see {\uldb Multi-dimensional Arrays}{\v Multi_dimensional}).\par
\pard{}}\par
\page\pard#{\footnote User_modified_1}
\pard{}(1) In POSIX {\f1{}awk}, newline does not count as whitespace.\par
\par
\page\pard Node: {\b Auto-set}, \keepn Next: {\uldb ARGC and ARGV}{\v ARGC_and_ARGV}, Prev: {\uldb User-modified}{\v User_modified}, Up: {\uldb Built-in Variables}{\v Built_in_Variables}\line
K{\footnote K Auto-set}
#{\footnote Auto_set}
${\footnote \pard{}Built-in Variables that Convey Information}\par
\pard{\fs24\b Built-in Variables that Convey Information}\par
\par
\pard{}{K{\footnote K built-in variables, convey information}} This is an alphabetical list of the variables that are set automatically by {\f1{}awk} on certain occasions in order to provide information to your program.  Those variables that are specific to {\f1{}gawk} are marked with an asterisk, {\f1{}*}.\par
\par
{\pard\li720{}{K{\footnote K ARGC}}{K{\footnote K ARGV}}\par
\par
\pard{}{\f1{}ARGC}\par
\pard{}{\f1{}ARGV}\par
\pard\li720{}The command-line arguments available to {\f1{}awk} programs are stored in an array called {\f1{}ARGV}.  {\f1{}ARGC} is the number of command-line arguments present.  See {\uldb Other Command Line Arguments}{\v Other_Arguments}.  Unlike most {\f1{}awk} arrays, {\f1{}ARGV} is indexed from zero to {\f1{}ARGC} - 1.  For example:\par
\par
{{\pard\keep\li1440\f1{}$ awk 'BEGIN \'7B\line
>        for (i = 0; i < ARGC; i++)\line
>            print ARGV[i]\line
>      \'7D' inventory-shipped BBS-list\line
-| awk\line
-| inventory-shipped\line
-| BBS-list\par
\pard\keep\li1440{}}}\par
\pard\li720\f0{}In this example, {\f1{}ARGV[0]} contains {\f1{}"awk"}, {\f1{}ARGV[1]} contains {\f1{}"inventory-shipped"}, and {\f1{}ARGV[2]} contains {\f1{}"BBS-list"}.  The value of {\f1{}ARGC} is three, one more than the index of the last element in {\f1{}ARGV}, since the elements are numbered from zero.\par
\par
\pard\li720{}The names {\f1{}ARGC} and {\f1{}ARGV}, as well as the convention of indexing the array from zero to {\f1{}ARGC} - 1, are derived from the C language's method of accessing command line arguments.  See {\uldb Using {\f1{}ARGC} and {\f1{}ARGV}}{\v ARGC_and_ARGV}, for information about how {\f1{}awk} uses these variables.\par
\par
\pard\li720{}{K{\footnote K ARGIND}}\par
\par
\pard{}{\f1{}ARGIND *}\par
\pard\li720{}The index in {\f1{}ARGV} of the current file being processed.  Every time {\f1{}gawk} opens a new data file for processing, it sets {\f1{}ARGIND} to the index in {\f1{}ARGV} of the file name.  When {\f1{}gawk} is processing the input files, it is always true that {\f1{}FILENAME == ARGV[ARGIND]}.\par
\par
\pard\li720{}This variable is useful in file processing; it allows you to tell how far along you are in the list of data files, and to distinguish between successive instances of the same filename on the command line.\par
\par
\pard\li720{}While you can change the value of {\f1{}ARGIND} within your {\f1{}awk} program, {\f1{}gawk} will automatically set it to a new value when the next file is opened.\par
\par
\pard\li720{}This variable is a {\f1{}gawk} extension. In other {\f1{}awk} implementations, or if {\f1{}gawk} is in compatibility mode (see {\uldb Command Line Options}{\v Options}), it is not special.\par
\par
\pard\li720{}{K{\footnote K ENVIRON}}\par
\par
\pard{}{\f1{}ENVIRON}\par
\pard\li720{}An associative array that contains the values of the environment.  The array indices are the environment variable names; the values are the values of the particular environment variables.  For example, {\f1{}ENVIRON["HOME"]} might be {\f1{}/home/arnold}.  Changing this array does not affect the environment passed on to any programs that {\f1{}awk} may spawn via redirection or the {\f1{}system} function.  (In a future version of {\f1{}gawk}, it may do so.)\par
\par
\pard\li720{}Some operating systems may not have environment variables.  On such systems, the {\f1{}ENVIRON} array is empty (except for {\f1{}ENVIRON["AWKPATH"]}).\par
\par
\pard\li720{}{K{\footnote K ERRNO}}\par
\par
\pard{}{\f1{}ERRNO *}\par
\pard\li720{}If a system error occurs either doing a redirection for {\f1{}getline}, during a read for {\f1{}getline}, or during a {\f1{}close} operation, then {\f1{}ERRNO} will contain a string describing the error.\par
\par
\pard\li720{}This variable is a {\f1{}gawk} extension. In other {\f1{}awk} implementations, or if {\f1{}gawk} is in compatibility mode (see {\uldb Command Line Options}{\v Options}), it is not special.\par
\par
\pard\li720{}{K{\footnote K dark corner}}{K{\footnote K FILENAME}}\par
\par
\pard{}{\f1{}FILENAME}\par
\pard\li720{}This is the name of the file that {\f1{}awk} is currently reading.  When no data files are listed on the command line, {\f1{}awk} reads from the standard input, and {\f1{}FILENAME} is set to {\f1{}"-"}.  {\f1{}FILENAME} is changed each time a new file is read (see {\uldb Reading Input Files}{\v Reading_Files}).  Inside a {\f1{}BEGIN} rule, the value of {\f1{}FILENAME} is {\f1{}""}, since there are no input files being processed yet.({\ul 1}{\v Auto_set_1}) (d.c.)\par
\par
\pard\li720{}{K{\footnote K FNR}}\par
\par
\pard{}{\f1{}FNR}\par
{\f1{}\pard\li720{}FNR} is the current record number in the current file.  {\f1{}FNR} is incremented each time a new record is read (see {\uldb Explicit Input with {\f1{}getline}}{\v Getline}).  It is reinitialized to zero each time a new input file is started.\par
\par
\pard\li720{}{K{\footnote K NF}}\par
\par
\pard{}{\f1{}NF}\par
{\f1{}\pard\li720{}NF} is the number of fields in the current input record.  {\f1{}NF} is set each time a new record is read, when a new field is created, or when {\f1{}$0} changes (see {\uldb Examining Fields}{\v Fields}).\par
\par
\pard\li720{}{K{\footnote K NR}}\par
\par
\pard{}{\f1{}NR}\par
\pard\li720{}This is the number of input records {\f1{}awk} has processed since the beginning of the program's execution (see {\uldb How Input is Split into Records}{\v Records}).  {\f1{}NR} is set each time a new record is read.\par
\par
\pard\li720{}{K{\footnote K RLENGTH}}\par
\par
\pard{}{\f1{}RLENGTH}\par
{\f1{}\pard\li720{}RLENGTH} is the length of the substring matched by the {\f1{}match} function (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}).  {\f1{}RLENGTH} is set by invoking the {\f1{}match} function.  Its value is the length of the matched string, or -1 if no match was found.\par
\par
\pard\li720{}{K{\footnote K RSTART}}\par
\par
\pard{}{\f1{}RSTART}\par
{\f1{}\pard\li720{}RSTART} is the start-index in characters of the substring matched by the {\f1{}match} function (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}).  {\f1{}RSTART} is set by invoking the {\f1{}match} function.  Its value is the position of the string where the matched substring starts, or zero if no match was found.\par
\par
\pard\li720{}{K{\footnote K RT}}\par
\par
\pard{}{\f1{}RT *}\par
{\f1{}\pard\li720{}RT} is set each time a record is read. It contains the input text that matched the text denoted by {\f1{}RS}, the record separator.\par
\par
\pard\li720{}This variable is a {\f1{}gawk} extension. In other {\f1{}awk} implementations, or if {\f1{}gawk} is in compatibility mode (see {\uldb Command Line Options}{\v Options}), it is not special.\par
\pard{}}\par
\pard{}{K{\footnote K dark corner}}A side note about {\f1{}NR} and {\f1{}FNR}.  {\f1{}awk} simply increments both of these variables each time it reads a record, instead of setting them to the absolute value of the number of records read.  This means that your program can change these variables, and their new values will be incremented for each record (d.c.).  For example:\par
\par
{{\pard\keep\li720\f1{}$ echo '1\line
> 2\line
> 3\line
> 4' | awk 'NR == 2 \'7B NR = 17 \'7D\line
> \'7B print NR \'7D'\line
-| 1\line
-| 17\line
-| 18\line
-| 19\par
\pard\keep\li720{}}}\par
\pard\f0{}Before {\f1{}FNR} was added to the {\f1{}awk} language (see {\uldb Major Changes between V7 and SVR3.1}{\v V7_SVR3_1}), many {\f1{}awk} programs used this feature to track the number of records in a file by resetting {\f1{}NR} to zero when {\f1{}FILENAME} changed.\par
\par
\page\pard#{\footnote Auto_set_1}
\pard{}(1) Some early implementations of Unix {\f1{}awk} initialized {\f1{}FILENAME} to {\f1{}"-"}, even if there were data files to be processed. This behavior was incorrect, and should not be relied upon in your programs.\par
\par
\page\pard Node: {\b ARGC and ARGV}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Auto-set}{\v Auto_set}, Up: {\uldb Built-in Variables}{\v Built_in_Variables}\line
K{\footnote K ARGC and ARGV}
#{\footnote ARGC_and_ARGV}
${\footnote \pard{}Using {\f1{}ARGC} and {\f1{}ARGV}}\par
\pard{\fs24\b Using {\f1{}ARGC} and {\f1{}ARGV}}\par
\par
\pard{}In {\uldb Built-in Variables that Convey Information}{\v Auto_set}, you saw this program describing the information contained in {\f1{}ARGC} and {\f1{}ARGV}:\par
\par
{{\pard\keep\li720\f1{}$ awk 'BEGIN \'7B\line
>        for (i = 0; i < ARGC; i++)\line
>            print ARGV[i]\line
>      \'7D' inventory-shipped BBS-list\line
-| awk\line
-| inventory-shipped\line
-| BBS-list\par
\pard\keep\li720{}}}\par
\pard\f0{}In this example, {\f1{}ARGV[0]} contains {\f1{}"awk"}, {\f1{}ARGV[1]} contains {\f1{}"inventory-shipped"}, and {\f1{}ARGV[2]} contains {\f1{}"BBS-list"}.\par
\par
\pard{}Notice that the {\f1{}awk} program is not entered in {\f1{}ARGV}.  The other special command line options, with their arguments, are also not entered.  This includes variable assignments done with the {\f1{}-v} option (see {\uldb Command Line Options}{\v Options}).  Normal variable assignments on the command line {\i are} treated as arguments, and do show up in the {\f1{}ARGV} array.\par
\par
{\pard\keep\li720\f1{}$ cat showargs.awk\line
-| BEGIN \'7B\line
-|     printf "A=%d, B=%d\'5Cn", A, B\line
-|     for (i = 0; i < ARGC; i++)\line
-|         printf "\'5CtARGV[%d] = %s\'5Cn", i, ARGV[i]\line
-| \'7D\line
-| END   \'7B printf "A=%d, B=%d\'5Cn", A, B \'7D\line
$ awk -v A=1 -f showargs.awk B=2 /dev/null\line
-| A=1, B=0\line
-| 	ARGV[0] = awk\line
-| 	ARGV[1] = B=2\line
-| 	ARGV[2] = /dev/null\line
-| A=1, B=2\par
\pard\f0{}}\par
\pard{}Your program can alter {\f1{}ARGC} and the elements of {\f1{}ARGV}.  Each time {\f1{}awk} reaches the end of an input file, it uses the next element of {\f1{}ARGV} as the name of the next input file.  By storing a different string there, your program can change which files are read.  You can use {\f1{}"-"} to represent the standard input.  By storing additional elements and incrementing {\f1{}ARGC} you can cause additional files to be read.\par
\par
\pard{}If you decrease the value of {\f1{}ARGC}, that eliminates input files from the end of the list.  By recording the old value of {\f1{}ARGC} elsewhere, your program can treat the eliminated arguments as something other than file names.\par
\par
\pard{}To eliminate a file from the middle of the list, store the null string ({\f1{}""}) into {\f1{}ARGV} in place of the file's name.  As a special feature, {\f1{}awk} ignores file names that have been replaced with the null string.  You may also use the {\f1{}delete} statement to remove elements from {\f1{}ARGV} (see {\uldb The {\f1{}delete} Statement}{\v Delete}).\par
\par
\pard{}All of these actions are typically done from the {\f1{}BEGIN} rule, before actual processing of the input begins.  See {\uldb Splitting a Large File Into Pieces}{\v Split_Program}, and see {\uldb Duplicating Output Into Multiple Files}{\v Tee_Program}, for an example of each way of removing elements from {\f1{}ARGV}.\par
\par
\pard{}The following fragment processes {\f1{}ARGV} in order to examine, and then remove, command line options.\par
\par
{{\pard\keep\li720\f1{}BEGIN \'7B\line
    for (i = 1; i < ARGC; i++) \'7B\line
        if (ARGV[i] == "-v")\line
            verbose = 1\line
        else if (ARGV[i] == "-d")\line
            debug = 1\par
\pard\keep\li720{}}{        else if (ARGV[i] ~ /^-?/) \'7B\line
            e = sprintf("%s: unrecognized option -- %c",\line
                    ARGV[0], substr(ARGV[i], 1, ,1))\line
            print e > "/dev/stderr"\line
        \'7D else\line
            break\line
        delete ARGV[i]\line
    \'7D\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}To actually get the options into the {\f1{}awk} program, you have to end the {\f1{}awk} options with {\f1{}--}, and then supply your options, like so:\par
\par
{\pard\keep\li720\f1{}awk -f myprog -- -v -d file1 file2 ...\par
\pard\f0{}}\par
\pard{}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}This is not necessary in {\f1{}gawk}: Unless {\f1{}--posix} has been specified, {\f1{}gawk} silently puts any unrecognized options into {\f1{}ARGV} for the {\f1{}awk} program to deal with.\par
\par
\pard{}As soon as it sees an unknown option, {\f1{}gawk} stops looking for other options it might otherwise recognize.  The above example with {\f1{}gawk} would be:\par
\par
{\pard\keep\li720\f1{}gawk -f myprog -d -v file1 file2 ...\par
\pard\f0{}}\par
\pard{}Since {\f1{}-d} is not a valid {\f1{}gawk} option, the following {\f1{}-v} is passed on to the {\f1{}awk} program.\par
\par
\page\pard Node: {\b Arrays}, \keepn Next: {\uldb Built-in}{\v Built_in}, Prev: {\uldb Built-in Variables}{\v Built_in_Variables}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Arrays}
#{\footnote Arrays}
${\footnote \pard{}Arrays in {\f1{}awk}}\par
\pard{\fs24\b Arrays in {\f1{}awk}}\par
\par
\pard{}An \'A2array\'A2 is a table of values, called \'A2elements\'A2.  The elements of an array are distinguished by their indices.  \'A2Indices\'A2 may be either numbers or strings.  {\f1{}awk} maintains a single set of names that may be used for naming variables, arrays and functions (see {\uldb User-defined Functions}{\v User_defined}).  Thus, you cannot have a variable and an array with the same name in the same {\f1{}awk} program.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Array Intro}{\v Array_Intro}\tab Introduction to Arrays\par
{\uldb Reference to Elements}{\v Reference_to_Elements}\tab How to examine one element of an array.\par
{\uldb Assigning Elements}{\v Assigning_Elements}\tab How to change an element of an array.\par
{\uldb Array Example}{\v Array_Example}\tab Basic Example of an Array\par
{\uldb Scanning an Array}{\v Scanning_an_Array}\tab A variation of the {\f1{}for} statement. It loops through the indices of an array's existing elements.\par
{\uldb Delete}{\v Delete}\tab The {\f1{}delete} statement removes an element from an array.\par
{\uldb Numeric Array Subscripts}{\v Numeric_Array_Subscripts}\tab How to use numbers as subscripts in {\f1{}awk}.\par
{\uldb Uninitialized Subscripts}{\v Uninitialized_Subscripts}\tab Using Uninitialized variables as subscripts.\par
{\uldb Multi-dimensional}{\v Multi_dimensional}\tab Emulating multi-dimensional arrays in {\f1{}awk}.\par
{\uldb Multi-scanning}{\v Multi_scanning}\tab Scanning multi-dimensional arrays.\par
\pard{}}\par
\page\pard Node: {\b Array Intro}, \keepn Next: {\uldb Reference to Elements}{\v Reference_to_Elements}, Prev: {\uldb Arrays}{\v Arrays}, Up: {\uldb Arrays}{\v Arrays}\line
K{\footnote K Array Intro}
#{\footnote Array_Intro}
${\footnote \pard{}Introduction to Arrays}\par
\pard{\fs24\b Introduction to Arrays}\par
\par
\pard{}{K{\footnote K arrays}}The {\f1{}awk} language provides one-dimensional \'A2arrays\'A2 for storing groups of related strings or numbers.\par
\par
\pard{}Every {\f1{}awk} array must have a name.  Array names have the same syntax as variable names; any valid variable name would also be a valid array name.  But you cannot use one name in both ways (as an array and as a variable) in one {\f1{}awk} program.\par
\par
\pard{}Arrays in {\f1{}awk} superficially resemble arrays in other programming languages; but there are fundamental differences.  In {\f1{}awk}, you don't need to specify the size of an array before you start to use it.  Additionally, any number or string in {\f1{}awk} may be used as an array index, not just consecutive integers.\par
\par
\pard{}In most other languages, you have to \'A2declare\'A2 an array and specify how many elements or components it contains.  In such languages, the declaration causes a contiguous block of memory to be allocated for that many elements.  An index in the array usually must be a positive integer; for example, the index zero specifies the first element in the array, which is actually stored at the beginning of the block of memory.  Index one specifies the second element, which is stored in memory right after the first element, and so on.  It is impossible to add more elements to the array, because it has room for only as many elements as you declared.  (Some languages allow arbitrary starting and ending indices, e.g., {\f1{}15 .. 27}, but the size of the array is still fixed when the array is declared.)\par
\par
\pard{}A contiguous array of four elements might look like this, conceptually, if the element values are eight, {\f1{}"foo"}, {\f1{}""} and 30:\par
\par
{{\pard\keep\li720\f1{}+---------+---------+--------+---------+\line
|    8    |  "foo"  |   ""   |    30   |    value\line
+---------+---------+--------+---------+\line
     0         1         2         3        index\par
\pard\f0{}}}\par
\pard{}Only the values are stored; the indices are implicit from the order of the values.  Eight is the value at index zero, because eight appears in the position with zero elements before it.\par
\par
\pard{}{K{\footnote K arrays, definition of}}{K{\footnote K associative arrays}}{K{\footnote K arrays, associative}}Arrays in {\f1{}awk} are different: they are \'A2associative\'A2.  This means that each array is a collection of pairs: an index, and its corresponding array element value:\par
\par
{\pard\li720\f1{}Element 4     Value 30\line
Element 2     Value "foo"\line
Element 1     Value 8\line
Element 3     Value ""\par
\pard\f0{}}\par
\pard{}We have shown the pairs in jumbled order because their order is irrelevant.\par
\par
\pard{}One advantage of associative arrays is that new pairs can be added at any time.  For example, suppose we add to the above array a tenth element whose value is {\f1{}"number ten"}.  The result is this:\par
\par
{\pard\li720\f1{}Element 10    Value "number ten"\line
Element 4     Value 30\line
Element 2     Value "foo"\line
Element 1     Value 8\line
Element 3     Value ""\par
\pard\f0{}}\par
\pard{}{K{\footnote K sparse arrays}}{K{\footnote K arrays, sparse}}Now the array is \'A2sparse\'A2, which just means some indices are missing: it has elements 1-4 and 10, but doesn't have elements 5, 6, 7, 8, or 9.\par
\par
\pard{}Another consequence of associative arrays is that the indices don't have to be positive integers.  Any number, or even a string, can be an index.  For example, here is an array which translates words from English into French:\par
\par
{\pard\li720\f1{}Element "dog" Value "chien"\line
Element "cat" Value "chat"\line
Element "one" Value "un"\line
Element 1     Value "un"\par
\pard\f0{}}\par
\pard{}Here we decided to translate the number one in both spelled-out and numeric form--thus illustrating that a single array can have both numbers and strings as indices.  (In fact, array subscripts are always strings; this is discussed in more detail in {\uldb Using Numbers to Subscript Arrays}{\v Numeric_Array_Subscripts}.)\par
\par
\pard{}{K{\footnote K Array subscripts and {\f1{}IGNORECASE}}}{K{\footnote K {\f1{}IGNORECASE} and array subscripts}}{K{\footnote K IGNORECASE}}The value of {\f1{}IGNORECASE} has no effect upon array subscripting.  You must use the exact same string value to retrieve an array element as you used to store it.\par
\par
\pard{}When {\f1{}awk} creates an array for you, e.g., with the {\f1{}split} built-in function, that array's indices are consecutive integers starting at one.  (See {\uldb Built-in Functions for String Manipulation}{\v String_Functions}.)\par
\par
\page\pard Node: {\b Reference to Elements}, \keepn Next: {\uldb Assigning Elements}{\v Assigning_Elements}, Prev: {\uldb Array Intro}{\v Array_Intro}, Up: {\uldb Arrays}{\v Arrays}\line
K{\footnote K Reference to Elements}
#{\footnote Reference_to_Elements}
${\footnote \pard{}Referring to an Array Element}\par
\pard{\fs24\b Referring to an Array Element}\par
\par
\pard{}{K{\footnote K array reference}}{K{\footnote K element of array}}{K{\footnote K reference to array}} The principal way of using an array is to refer to one of its elements.  An array reference is an expression which looks like this:\par
\par
{{\i \pard\li720\f1{}array}[{\i index}]\par
\pard\f0{}}\par
\pard{}Here, {\i array} is the name of an array.  The expression {\i index} is the index of the element of the array that you want.\par
\par
\pard{}The value of the array reference is the current value of that array element.  For example, {\f1{}foo[4.3]} is an expression for the element of array {\f1{}foo} at index {\f1{}4.3}.\par
\par
\pard{}If you refer to an array element that has no recorded value, the value of the reference is {\f1{}""}, the null string.  This includes elements to which you have not assigned any value, and elements that have been deleted (see {\uldb The {\f1{}delete} Statement}{\v Delete}).  Such a reference automatically creates that array element, with the null string as its value.  (In some cases, this is unfortunate, because it might waste memory inside {\f1{}awk}.)\par
\par
\pard{}{K{\footnote K arrays, presence of elements}}{K{\footnote K arrays, the {\f1{}in} operator}}You can find out if an element exists in an array at a certain index with the expression:\par
\par
{{\i \pard\li720\f1{}index} in {\i array}\par
\pard\f0{}}\par
\pard{}This expression tests whether or not the particular index exists, without the side effect of creating that element if it is not present.  The expression has the value one (true) if {\f1{}{\i array}[{\i index}]} exists, and zero (false) if it does not exist.\par
\par
\pard{}For example, to test whether the array {\f1{}frequencies} contains the index {\f1{}2}, you could write this statement:\par
\par
{\pard\keep\li720\f1{}if (2 in frequencies)\line
    print "Subscript 2 is present."\par
\pard\f0{}}\par
\pard{}Note that this is {\i not} a test of whether or not the array {\f1{}frequencies} contains an element whose {\i value} is two.  (There is no way to do that except to scan all the elements.)  Also, this {\i does not} create {\f1{}frequencies[2]}, while the following (incorrect) alternative would do so:\par
\par
{\pard\keep\li720\f1{}if (frequencies[2] != "")\line
    print "Subscript 2 is present."\par
\pard\f0{}}\par
\page\pard Node: {\b Assigning Elements}, \keepn Next: {\uldb Array Example}{\v Array_Example}, Prev: {\uldb Reference to Elements}{\v Reference_to_Elements}, Up: {\uldb Arrays}{\v Arrays}\line
K{\footnote K Assigning Elements}
#{\footnote Assigning_Elements}
${\footnote \pard{}Assigning Array Elements}\par
\pard{\fs24\b Assigning Array Elements}\par
\par
\pard{}{K{\footnote K array assignment}}{K{\footnote K element assignment}} Array elements are lvalues: they can be assigned values just like {\f1{}awk} variables:\par
\par
{{\i \pard\li720\f1{}array}[{\i subscript}] = {\i value}\par
\pard\f0{}}\par
\pard{}Here {\i array} is the name of your array.  The expression {\i subscript} is the index of the element of the array that you want to assign a value.  The expression {\i value} is the value you are assigning to that element of the array.\par
\par
\page\pard Node: {\b Array Example}, \keepn Next: {\uldb Scanning an Array}{\v Scanning_an_Array}, Prev: {\uldb Assigning Elements}{\v Assigning_Elements}, Up: {\uldb Arrays}{\v Arrays}\line
K{\footnote K Array Example}
#{\footnote Array_Example}
${\footnote \pard{}Basic Array Example}\par
\pard{\fs24\b Basic Array Example}\par
\par
\pard{}The following program takes a list of lines, each beginning with a line number, and prints them out in order of line number.  The line numbers are not in order, however, when they are first read:  they are scrambled.  This program sorts the lines by making an array using the line numbers as subscripts.  It then prints out the lines in sorted order of their numbers.  It is a very simple program, and gets confused if it encounters repeated numbers, gaps, or lines that don't begin with a number.\par
\par
{\pard\keep\li720\f1{}\'7B\line
  if ($1 > max)\line
    max = $1\line
  arr[$1] = $0\line
\'7D\line
\line
END \'7B\line
  for (x = 1; x <= max; x++)\line
    print arr[x]\line
\'7D\par
\pard\f0{}}\par
\pard{}The first rule keeps track of the largest line number seen so far; it also stores each line into the array {\f1{}arr}, at an index that is the line's number.\par
\par
\pard{}The second rule runs after all the input has been read, to print out all the lines.\par
\par
\pard{}When this program is run with the following input:\par
\par
{{\pard\keep\li720\f1{}5  I am the Five man\line
2  Who are you?  The new number two!\line
4  . . . And four on the floor\line
1  Who is number one?\line
3  I three you.\par
\pard\keep\li720{}}}\par
\pard\f0{}its output is this:\par
\par
{\pard\keep\li720\f1{}1  Who is number one?\line
2  Who are you?  The new number two!\line
3  I three you.\line
4  . . . And four on the floor\line
5  I am the Five man\par
\pard\f0{}}\par
\pard{}If a line number is repeated, the last line with a given number overrides the others.\par
\par
\pard{}Gaps in the line numbers can be handled with an easy improvement to the program's {\f1{}END} rule:\par
\par
{\pard\keep\li720\f1{}END \'7B\line
  for (x = 1; x <= max; x++)\line
    if (x in arr)\line
      print arr[x]\line
\'7D\par
\pard\f0{}}\par
\page\pard Node: {\b Scanning an Array}, \keepn Next: {\uldb Delete}{\v Delete}, Prev: {\uldb Array Example}{\v Array_Example}, Up: {\uldb Arrays}{\v Arrays}\line
K{\footnote K Scanning an Array}
#{\footnote Scanning_an_Array}
${\footnote \pard{}Scanning All Elements of an Array}\par
\pard{\fs24\b Scanning All Elements of an Array}\par
\par
\pard{}{K{\footnote K {\f1{}for (x in ...)}}}{K{\footnote K arrays, special {\f1{}for} statement}}{K{\footnote K scanning an array}} In programs that use arrays, you often need a loop that executes once for each element of an array.  In other languages, where arrays are contiguous and indices are limited to positive integers, this is easy: you can find all the valid indices by counting from the lowest index up to the highest.  This technique won't do the job in {\f1{}awk}, since any number or string can be an array index.  So {\f1{}awk} has a special kind of {\f1{}for} statement for scanning an array:\par
\par
{\pard\keep\li720\f1{}for ({\i var} in {\i array})\line
  {\i body}\par
\pard\f0{}}\par
\pard{}This loop executes {\i body} once for each index in {\i array} that your program has previously used, with the variable {\i var} set to that index.\par
\par
\pard{}Here is a program that uses this form of the {\f1{}for} statement.  The first rule scans the input records and notes which words appear (at least once) in the input, by storing a one into the array {\f1{}used} with the word as index.  The second rule scans the elements of {\f1{}used} to find all the distinct words that appear in the input.  It prints each word that is more than 10 characters long, and also prints the number of such words.  See {\uldb Built-in Functions for String Manipulation}{\v String_Functions}, for more information on the built-in function {\f1{}length}.\par
\par
{\pard\keep\li720\f1{}# Record a 1 for each word that is used at least once.\line
\'7B\line
    for (i = 1; i <= NF; i++)\line
        used[$i] = 1\line
\'7D\line
\line
# Find number of distinct words more than 10 characters long.\line
END \'7B\line
    for (x in used)\line
        if (length(x) > 10) \'7B\line
            ++num_long_words\line
            print x\line
        \'7D\line
    print num_long_words, "words longer than 10 characters"\line
\'7D\par
\pard\f0{}}\par
\pard{}See {\uldb Generating Word Usage Counts}{\v Word_Sorting}, for a more detailed example of this type.\par
\par
\pard{}The order in which elements of the array are accessed by this statement is determined by the internal arrangement of the array elements within {\f1{}awk} and cannot be controlled or changed.  This can lead to problems if new elements are added to {\i array} by statements in the loop body; you cannot predict whether or not the {\f1{}for} loop will reach them.  Similarly, changing {\i var} inside the loop may produce strange results.  It is best to avoid such things.\par
\par
\page\pard Node: {\b Delete}, \keepn Next: {\uldb Numeric Array Subscripts}{\v Numeric_Array_Subscripts}, Prev: {\uldb Scanning an Array}{\v Scanning_an_Array}, Up: {\uldb Arrays}{\v Arrays}\line
K{\footnote K Delete}
#{\footnote Delete}
${\footnote \pard{}The {\f1{}delete} Statement}\par
\pard{\fs24\b The {\f1{}delete} Statement}\par
\par
\pard{}{K{\footnote K {\f1{}delete} statement}}{K{\footnote K deleting elements of arrays}}{K{\footnote K removing elements of arrays}}{K{\footnote K arrays, deleting an element}} You can remove an individual element of an array using the {\f1{}delete} statement:\par
\par
{\pard\keep\li720\f1{}delete {\i array}[{\i index}]\par
\pard\f0{}}\par
\pard{}Once you have deleted an array element, you can no longer obtain any value the element once had.  It is as if you had never referred to it and had never given it any value.\par
\par
\pard{}Here is an example of deleting elements in an array:\par
\par
{\pard\keep\li720\f1{}for (i in frequencies)\line
  delete frequencies[i]\par
\pard\f0{}}\par
\pard{}This example removes all the elements from the array {\f1{}frequencies}.\par
\par
\pard{}If you delete an element, a subsequent {\f1{}for} statement to scan the array will not report that element, and the {\f1{}in} operator to check for the presence of that element will return zero (i.e. false):\par
\par
{\pard\keep\li720\f1{}delete foo[4]\line
if (4 in foo)\line
    print "This will never be printed"\par
\pard\f0{}}\par
\pard{}It is important to note that deleting an element is {\i not} the same as assigning it a null value (the empty string, {\f1{}""}).\par
\par
{\pard\keep\li720\f1{}foo[4] = ""\line
if (4 in foo)\line
  print "This is printed, even though foo[4] is empty"\par
\pard\f0{}}\par
\pard{}It is not an error to delete an element that does not exist.\par
\par
\pard{}{K{\footnote K arrays, deleting entire contents}}{K{\footnote K deleting entire arrays}}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}You can delete all the elements of an array with a single statement, by leaving off the subscript in the {\f1{}delete} statement.\par
\par
{\pard\keep\li720\f1{}delete {\i array}\par
\pard\f0{}}\par
\pard{}This ability is a {\f1{}gawk} extension; it is not available in compatibility mode (see {\uldb Command Line Options}{\v Options}).\par
\par
\pard{}Using this version of the {\f1{}delete} statement is about three times more efficient than the equivalent loop that deletes each element one at a time.\par
\par
\pard{}{K{\footnote K portability issues}}The following statement provides a portable, but non-obvious way to clear out an array.\par
\par
\pard{}{K{\footnote K Brennan, Michael}}{\par
{\pard\keep\li720\f1{}# thanks to Michael Brennan for pointing this out\line
split("", array)\par
\pard\keep\li720{}}}\par
\pard\f0{}The {\f1{}split} function (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}) clears out the target array first. This call asks it to split apart the null string. Since there is no data to split out, the function simply clears the array and then returns.\par
\par
{\b \pard{}Caution:} Deleting an array does not change its type; you cannot delete an array and then use the array's name as a scalar. For example, this will not work:\par
\par
{\pard\keep\li720\f1{}a[1] = 3; delete a; a = 3\par
\pard\f0{}}\par
\page\pard Node: {\b Numeric Array Subscripts}, \keepn Next: {\uldb Uninitialized Subscripts}{\v Uninitialized_Subscripts}, Prev: {\uldb Delete}{\v Delete}, Up: {\uldb Arrays}{\v Arrays}\line
K{\footnote K Numeric Array Subscripts}
#{\footnote Numeric_Array_Subscripts}
${\footnote \pard{}Using Numbers to Subscript Arrays}\par
\pard{\fs24\b Using Numbers to Subscript Arrays}\par
\par
\pard{}An important aspect of arrays to remember is that {\i array subscripts are always strings}.  If you use a numeric value as a subscript, it will be converted to a string value before it is used for subscripting (see {\uldb Conversion of Strings and Numbers}{\v Conversion}).\par
\par
\pard{}{K{\footnote K conversions, during subscripting}}{K{\footnote K numbers, used as subscripts}}{K{\footnote K CONVFMT}}This means that the value of the built-in variable {\f1{}CONVFMT} can potentially affect how your program accesses elements of an array.  For example:\par
\par
{\pard\keep\li720\f1{}xyz = 12.153\line
data[xyz] = 1\line
CONVFMT = "%2.2f"\line
{if (xyz in data)\line
    printf "%s is in data\'5Cn", xyz\line
else\line
    printf "%s is not in data\'5Cn", xyz\par
\pard\keep\li720{}}}\par
\pard\f0{}This prints {\f1{}12.15 is not in data}.  The first statement gives {\f1{}xyz} a numeric value.  Assigning to {\f1{}data[xyz]} subscripts {\f1{}data} with the string value {\f1{}"12.153"} (using the default conversion value of {\f1{}CONVFMT}, {\f1{}"%.6g"}), and assigns one to {\f1{}data["12.153"]}.  The program then changes the value of {\f1{}CONVFMT}.  The test {\f1{}(xyz in data)} generates a new string value from {\f1{}xyz}, this time {\f1{}"12.15"}, since the value of {\f1{}CONVFMT} only allows two significant digits.  This test fails, since {\f1{}"12.15"} is a different string from {\f1{}"12.153"}.\par
\par
\pard{}According to the rules for conversions (see {\uldb Conversion of Strings and Numbers}{\v Conversion}), integer values are always converted to strings as integers, no matter what the value of {\f1{}CONVFMT} may happen to be.  So the usual case of:\par
\par
{\pard\keep\li720\f1{}for (i = 1; i <= maxsub; i++)\line
    do something with array[i]\par
\pard\f0{}}\par
\pard{}will work, no matter what the value of {\f1{}CONVFMT}.\par
\par
\pard{}Like many things in {\f1{}awk}, the majority of the time things work as you would expect them to work.  But it is useful to have a precise knowledge of the actual rules, since sometimes they can have a subtle effect on your programs.\par
\par
\page\pard Node: {\b Uninitialized Subscripts}, \keepn Next: {\uldb Multi-dimensional}{\v Multi_dimensional}, Prev: {\uldb Numeric Array Subscripts}{\v Numeric_Array_Subscripts}, Up: {\uldb Arrays}{\v Arrays}\line
K{\footnote K Uninitialized Subscripts}
#{\footnote Uninitialized_Subscripts}
${\footnote \pard{}Using Uninitialized Variables as Subscripts}\par
\pard{\fs24\b Using Uninitialized Variables as Subscripts}\par
\par
\pard{}{K{\footnote K uninitialized variables, as array subscripts}}{K{\footnote K array subscripts, uninitialized variables}}Suppose you want to print your input data in reverse order.  A reasonable attempt at a program to do so (with some test data) might look like this:\par
\par
{{\pard\keep\li720\f1{}$ echo 'line 1\line
> line 2\line
> line 3' | awk '\'7B l[lines] = $0; ++lines \'7D\line
> END \'7B\line
>     for (i = lines-1; i >= 0; --i)\line
>        print l[i]\line
> \'7D'\line
-| line 3\line
-| line 2\par
\pard\keep\li720{}}}\par
\pard\f0{}Unfortunately, the very first line of input data did not come out in the output!\par
\par
\pard{}At first glance, this program should have worked.  The variable {\f1{}lines} is uninitialized, and uninitialized variables have the numeric value zero.  So, the value of {\f1{}l[0]} should have been printed.\par
\par
\pard{}The issue here is that subscripts for {\f1{}awk} arrays are {\b always} strings. And uninitialized variables, when used as strings, have the value {\f1{}""}, not zero.  Thus, {\f1{}line 1} ended up stored in {\f1{}l[""]}.\par
\par
\pard{}The following version of the program works correctly:\par
\par
{\pard\keep\li720\f1{}\'7B l[lines++] = $0 \'7D\line
END \'7B\line
    for (i = lines - 1; i >= 0; --i)\line
       print l[i]\line
\'7D\par
\pard\f0{}}\par
\pard{}Here, the {\f1{}++} forces {\f1{}lines} to be numeric, thus making the "old value" numeric zero, which is then converted to {\f1{}"0"} as the array subscript.\par
\par
\pard{}{K{\footnote K null string, as array subscript}}{K{\footnote K dark corner}}As we have just seen, even though it is somewhat unusual, the null string ({\f1{}""}) is a valid array subscript (d.c.). If {\f1{}--lint} is provided on the command line (see {\uldb Command Line Options}{\v Options}), {\f1{}gawk} will warn about the use of the null string as a subscript.\par
\par
\page\pard Node: {\b Multi-dimensional}, \keepn Next: {\uldb Multi-scanning}{\v Multi_scanning}, Prev: {\uldb Uninitialized Subscripts}{\v Uninitialized_Subscripts}, Up: {\uldb Arrays}{\v Arrays}\line
K{\footnote K Multi-dimensional}
#{\footnote Multi_dimensional}
${\footnote \pard{}Multi-dimensional Arrays}\par
\pard{\fs24\b Multi-dimensional Arrays}\par
\par
\pard{}{K{\footnote K subscripts in arrays}}{K{\footnote K arrays, multi-dimensional subscripts}}{K{\footnote K multi-dimensional subscripts}}A multi-dimensional array is an array in which an element is identified by a sequence of indices, instead of a single index.  For example, a two-dimensional array requires two indices.  The usual way (in most languages, including {\f1{}awk}) to refer to an element of a two-dimensional array named {\f1{}grid} is with {\f1{}grid[{\i x},{\i y}]}.\par
\par
\pard{}{K{\footnote K SUBSEP}}Multi-dimensional arrays are supported in {\f1{}awk} through concatenation of indices into one string.  What happens is that {\f1{}awk} converts the indices into strings (see {\uldb Conversion of Strings and Numbers}{\v Conversion}) and concatenates them together, with a separator between them.  This creates a single string that describes the values of the separate indices.  The combined string is used as a single index into an ordinary, one-dimensional array.  The separator used is the value of the built-in variable {\f1{}SUBSEP}.\par
\par
\pard{}For example, suppose we evaluate the expression {\f1{}foo[5,12] = "value"} when the value of {\f1{}SUBSEP} is {\f1{}"@"}.  The numbers five and 12 are converted to strings and concatenated with an {\f1{}@} between them, yielding {\f1{}"5@12"}; thus, the array element {\f1{}foo["5@12"]} is set to {\f1{}"value"}.\par
\par
\pard{}Once the element's value is stored, {\f1{}awk} has no record of whether it was stored with a single index or a sequence of indices.  The two expressions {\f1{}foo[5,12]} and {\f1{}foo[5 SUBSEP 12]} are always equivalent.\par
\par
\pard{}The default value of {\f1{}SUBSEP} is the string {\f1{}"\'5C034"}, which contains a non-printing character that is unlikely to appear in an {\f1{}awk} program or in most input data.\par
\par
\pard{}The usefulness of choosing an unlikely character comes from the fact that index values that contain a string matching {\f1{}SUBSEP} lead to combined strings that are ambiguous.  Suppose that {\f1{}SUBSEP} were {\f1{}"@"}; then {\f1{}foo["a@b", "c"]} and {\f1{}foo["a", "b@c"]} would be indistinguishable because both would actually be stored as {\f1{}foo["a@b@c"]}.\par
\par
\pard{}You can test whether a particular index-sequence exists in a "multi-dimensional" array with the same operator {\f1{}in} used for single dimensional arrays.  Instead of a single index as the left-hand operand, write the whole sequence of indices, separated by commas, in parentheses:\par
\par
{\pard\keep\li720\f1{}({\i subscript1}, {\i subscript2}, ...) in {\i array}\par
\pard\f0{}}\par
\pard{}The following example treats its input as a two-dimensional array of fields; it rotates this array 90 degrees clockwise and prints the result.  It assumes that all lines have the same number of elements.\par
\par
{{\pard\keep\li720\f1{}awk '\'7B\line
     if (max_nf < NF)\line
          max_nf = NF\line
     max_nr = NR\line
     for (x = 1; x <= NF; x++)\line
          vector[x, NR] = $x\line
\'7D\par
\pard\keep\li720{}}\line
{END \'7B\line
     for (x = 1; x <= max_nf; x++) \'7B\line
          for (y = max_nr; y >= 1; --y)\line
               printf("%s ", vector[x, y])\line
          printf("\'5Cn")\line
     \'7D\line
\'7D'\par
\pard\keep\li720{}}}\par
\pard\f0{}When given the input:\par
\par
{{\pard\keep\li720\f1{}1 2 3 4 5 6\line
2 3 4 5 6 1\line
3 4 5 6 1 2\line
4 5 6 1 2 3\par
\pard\keep\li720{}}}\par
\pard\f0{}it produces:\par
\par
{{\pard\keep\li720\f1{}4 3 2 1\line
5 4 3 2\line
6 5 4 3\line
1 6 5 4\line
2 1 6 5\line
3 2 1 6\par
\pard\keep\li720{}}}\par
\page\pard Node: {\b Multi-scanning}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Multi-dimensional}{\v Multi_dimensional}, Up: {\uldb Arrays}{\v Arrays}\line
K{\footnote K Multi-scanning}
#{\footnote Multi_scanning}
${\footnote \pard\f0{}Scanning Multi-dimensional Arrays}\par
\pard{\fs24\b Scanning Multi-dimensional Arrays}\par
\par
\pard{}There is no special {\f1{}for} statement for scanning a "multi-dimensional" array; there cannot be one, because in truth there are no multi-dimensional arrays or elements; there is only a multi-dimensional {\i way of accessing} an array.\par
\par
\pard{}However, if your program has an array that is always accessed as multi-dimensional, you can get the effect of scanning it by combining the scanning {\f1{}for} statement (see {\uldb Scanning All Elements of an Array}{\v Scanning_an_Array}) with the {\f1{}split} built-in function (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}).  It works like this:\par
\par
{\pard\keep\li720\f1{}for (combined in array) \'7B\line
  split(combined, separate, SUBSEP)\line
  ...\line
\'7D\par
\pard\f0{}}\par
\pard{}This sets {\f1{}combined} to each concatenated, combined index in the array, and splits it into the individual indices by breaking it apart where the value of {\f1{}SUBSEP} appears.  The split-out indices become the elements of the array {\f1{}separate}.\par
\par
\pard{}Thus, suppose you have previously stored a value in {\f1{}array[1, "foo"]}; then an element with index {\f1{}"1\'5C034foo"} exists in {\f1{}array}.  (Recall that the default value of {\f1{}SUBSEP} is the character with code 034.)  Sooner or later the {\f1{}for} statement will find that index and do an iteration with {\f1{}combined} set to {\f1{}"1\'5C034foo"}.  Then the {\f1{}split} function is called as follows:\par
\par
{\pard\keep\li720\f1{}split("1\'5C034foo", separate, "\'5C034")\par
\pard\f0{}}\par
\pard{}The result of this is to set {\f1{}separate[1]} to {\f1{}"1"} and {\f1{}separate[2]} to {\f1{}"foo"}.  Presto, the original sequence of separate indices has been recovered.\par
\par
\page\pard Node: {\b Built-in}, \keepn Next: {\uldb User-defined}{\v User_defined}, Prev: {\uldb Arrays}{\v Arrays}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Built-in}
#{\footnote Built_in}
${\footnote \pard{}Built-in Functions}\par
\pard{\fs24\b Built-in Functions}\par
\par
\pard{}{K{\footnote K built-in functions}}\'A2Built-in\'A2 functions are functions that are always available for your {\f1{}awk} program to call.  This chapter defines all the built-in functions in {\f1{}awk}; some of them are mentioned in other sections, but they are summarized here for your convenience.  (You can also define new functions yourself.  See {\uldb User-defined Functions}{\v User_defined}.)\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Calling Built-in}{\v Calling_Built_in}\tab How to call built-in functions.\par
{\uldb Numeric Functions}{\v Numeric_Functions}\tab Functions that work with numbers, including {\f1{}int}, {\f1{}sin} and {\f1{}rand}.\par
{\uldb String Functions}{\v String_Functions}\tab Functions for string manipulation, such as {\f1{}split}, {\f1{}match}, and {\f1{}sprintf}.\par
{\uldb I/O Functions}{\v I_O_Functions}\tab Functions for files and shell commands.\par
{\uldb Time Functions}{\v Time_Functions}\tab Functions for dealing with time stamps.\par
\pard{}}\par
\page\pard Node: {\b Calling Built-in}, \keepn Next: {\uldb Numeric Functions}{\v Numeric_Functions}, Prev: {\uldb Built-in}{\v Built_in}, Up: {\uldb Built-in}{\v Built_in}\line
K{\footnote K Calling Built-in}
#{\footnote Calling_Built_in}
${\footnote \pard{}Calling Built-in Functions}\par
\pard{\fs24\b Calling Built-in Functions}\par
\par
\pard{}To call a built-in function, write the name of the function followed by arguments in parentheses.  For example, {\f1{}atan2(y + z, 1)} is a call to the function {\f1{}atan2}, with two arguments.\par
\par
\pard{}Whitespace is ignored between the built-in function name and the open-parenthesis, but we recommend that you avoid using whitespace there.  User-defined functions do not permit whitespace in this way, and you will find it easier to avoid mistakes by following a simple convention which always works: no whitespace after a function name.\par
\par
\pard{}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}Each built-in function accepts a certain number of arguments.  In some cases, arguments can be omitted. The defaults for omitted arguments vary from function to function and are described under the individual functions.  In some {\f1{}awk} implementations, extra arguments given to built-in functions are ignored.  However, in {\f1{}gawk}, it is a fatal error to give extra arguments to a built-in function.\par
\par
\pard{}When a function is called, expressions that create the function's actual parameters are evaluated completely before the function call is performed.  For example, in the code fragment:\par
\par
{\pard\keep\li720\f1{}i = 4\line
j = sqrt(i++)\par
\pard\f0{}}\par
\pard{}the variable {\f1{}i} is set to five before {\f1{}sqrt} is called with a value of four for its actual parameter.\par
\par
\pard{}{K{\footnote K evaluation, order of}}{K{\footnote K order of evaluation}}The order of evaluation of the expressions used for the function's parameters is undefined.  Thus, you should not write programs that assume that parameters are evaluated from left to right or from right to left.  For example,\par
\par
{\pard\keep\li720\f1{}i = 5\line
j = atan2(i++, i *= 2)\par
\pard\f0{}}\par
\pard{}If the order of evaluation is left to right, then {\f1{}i} first becomes six, and then 12, and {\f1{}atan2} is called with the two arguments six and 12.  But if the order of evaluation is right to left, {\f1{}i} first becomes 10, and then 11, and {\f1{}atan2} is called with the two arguments 11 and 10.\par
\par
\page\pard Node: {\b Numeric Functions}, \keepn Next: {\uldb String Functions}{\v String_Functions}, Prev: {\uldb Calling Built-in}{\v Calling_Built_in}, Up: {\uldb Built-in}{\v Built_in}\line
K{\footnote K Numeric Functions}
#{\footnote Numeric_Functions}
${\footnote \pard{}Numeric Built-in Functions}\par
\pard{\fs24\b Numeric Built-in Functions}\par
\par
\pard{}Here is a full list of built-in functions that work with numbers.  Optional parameters are enclosed in square brackets ("[" and "]").\par
\par
{\pard{}{\f1{}int({\i x})}\par
\pard\li720{}{K{\footnote K int}}This produces the nearest integer to {\i x}, located between {\i x} and zero, truncated toward zero.\par
\par
\pard\li720{}For example, {\f1{}int(3)} is three, {\f1{}int(3.9)} is three, {\f1{}int(-3.9)} is -3, and {\f1{}int(-3)} is -3 as well.\par
\par
\pard{}{\f1{}sqrt({\i x})}\par
\pard\li720{}{K{\footnote K sqrt}}This gives you the positive square root of {\i x}.  It reports an error if {\i x} is negative.  Thus, {\f1{}sqrt(4)} is two.\par
\par
\pard{}{\f1{}exp({\i x})}\par
\pard\li720{}{K{\footnote K exp}}This gives you the exponential of {\i x} ({\f1{}e ^ {\i x}}), or reports an error if {\i x} is out of range.  The range of values {\i x} can have depends on your machine's floating point representation.\par
\par
\pard{}{\f1{}log({\i x})}\par
\pard\li720{}{K{\footnote K log}}This gives you the natural logarithm of {\i x}, if {\i x} is positive; otherwise, it reports an error.\par
\par
\pard{}{\f1{}sin({\i x})}\par
\pard\li720{}{K{\footnote K sin}}This gives you the sine of {\i x}, with {\i x} in radians.\par
\par
\pard{}{\f1{}cos({\i x})}\par
\pard\li720{}{K{\footnote K cos}}This gives you the cosine of {\i x}, with {\i x} in radians.\par
\par
\pard{}{\f1{}atan2({\i y}, {\i x})}\par
\pard\li720{}{K{\footnote K atan2}}This gives you the arctangent of {\f1{}{\i y} / {\i x}} in radians.\par
\par
\pard{}{\f1{}rand()}\par
\pard\li720{}{K{\footnote K rand}}This gives you a random number.  The values of {\f1{}rand} are uniformly-distributed between zero and one.  The value is never zero and never one.\par
\par
\pard\li720{}Often you want random integers instead.  Here is a user-defined function you can use to obtain a random non-negative integer less than {\i n}:\par
\par
{\pard\keep\li1440\f1{}function randint(n) \'7B\line
     return int(n * rand())\line
\'7D\par
\pard\li720\f0{}}\par
\pard\li720{}The multiplication produces a random real number greater than zero and less than {\f1{}n}.  We then make it an integer (using {\f1{}int}) between zero and {\f1{}n} - 1, inclusive.\par
\par
\pard\li720{}Here is an example where a similar function is used to produce random integers between one and {\i n}.  This program prints a new random number for each input record.\par
\par
{{\pard\keep\li1440\f1{}awk '\line
# Function to roll a simulated die.\line
function roll(n) \'7B return 1 + int(rand() * n) \'7D\par
\pard\keep\li1440{}}\line
{# Roll 3 six-sided dice and\line
# print total number of points.\line
\'7B\line
      printf("%d points\'5Cn",\line
             roll(6)+roll(6)+roll(6))\line
\'7D'\par
\pard\keep\li1440{}}}\par
\pard\li720\f0{}{K{\footnote K seed for random numbers}}{K{\footnote K random numbers, seed of}}{\b Caution:} In most {\f1{}awk} implementations, including {\f1{}gawk}, {\f1{}rand} starts generating numbers from the same starting number, or \'A2seed\'A2, each time you run {\f1{}awk}.  Thus, a program will generate the same results each time you run it.  The numbers are random within one {\f1{}awk} run, but predictable from run to run.  This is convenient for debugging, but if you want a program to do different things each time it is used, you must change the seed to a value that will be different in each run.  To do this, use {\f1{}srand}.\par
\par
\pard{}{\f1{}srand([{\i x}])}\par
\pard\li720{}{K{\footnote K srand}}The function {\f1{}srand} sets the starting point, or seed, for generating random numbers to the value {\i x}.\par
\par
\pard\li720{}Each seed value leads to a particular sequence of random numbers.({\ul 1}{\v Numeric_Functions_1}) Thus, if you set the seed to the same value a second time, you will get the same sequence of random numbers again.\par
\par
\pard\li720{}If you omit the argument {\i x}, as in {\f1{}srand()}, then the current date and time of day are used for a seed.  This is the way to get random numbers that are truly unpredictable.\par
\par
\pard\li720{}The return value of {\f1{}srand} is the previous seed.  This makes it easy to keep track of the seeds for use in consistently reproducing sequences of random numbers.\par
\pard{}}\par
\page\pard#{\footnote Numeric_Functions_1}
\pard{}(1) Computer generated random numbers really are not truly random.  They are technically known as "pseudo-random."  This means that while the numbers in a sequence appear to be random, you can in fact generate the same sequence of random numbers over and over again.\par
\par
\page\pard Node: {\b String Functions}, \keepn Next: {\uldb I/O Functions}{\v I_O_Functions}, Prev: {\uldb Numeric Functions}{\v Numeric_Functions}, Up: {\uldb Built-in}{\v Built_in}\line
K{\footnote K String Functions}
#{\footnote String_Functions}
${\footnote \pard{}Built-in Functions for String Manipulation}\par
\pard{\fs24\b Built-in Functions for String Manipulation}\par
\par
\pard{}The functions in this section look at or change the text of one or more strings.  Optional parameters are enclosed in square brackets ("[" and "]").\par
\par
{\pard{}{\f1{}index({\i in}, {\i find})}\par
\pard\li720{}{K{\footnote K index}}This searches the string {\i in} for the first occurrence of the string {\i find}, and returns the position in characters where that occurrence begins in the string {\i in}.  For example:\par
\par
{\pard\keep\li1440\f1{}$ awk 'BEGIN \'7B print index("peanut", "an") \'7D'\line
-| 3\par
\pard\li720\f0{}}\par
\pard\li720{}If {\i find} is not found, {\f1{}index} returns zero.  (Remember that string indices in {\f1{}awk} start at one.)\par
\par
\pard{}{\f1{}length([{\i string}])}\par
\pard\li720{}{K{\footnote K length}}This gives you the number of characters in {\i string}.  If {\i string} is a number, the length of the digit string representing that number is returned.  For example, {\f1{}length("abcde")} is five.  By contrast, {\f1{}length(15 * 35)} works out to three.  How?  Well, 15 * 35 = 525, and 525 is then converted to the string {\f1{}"525"}, which has three characters.\par
\par
\pard\li720{}If no argument is supplied, {\f1{}length} returns the length of {\f1{}$0}.\par
\par
\pard\li720{}{K{\footnote K historical features}}{K{\footnote K portability issues}}{K{\footnote K {\f1{}awk} language, POSIX version}}{K{\footnote K POSIX {\f1{}awk}}}In older versions of {\f1{}awk}, you could call the {\f1{}length} function without any parentheses.  Doing so is marked as "deprecated" in the POSIX standard.  This means that while you can do this in your programs, it is a feature that can eventually be removed from a future version of the standard.  Therefore, for maximal portability of your {\f1{}awk} programs, you should always supply the parentheses.\par
\par
\pard{}{\f1{}match({\i string}, {\i regexp})}\par
\pard\li720{}{K{\footnote K match}}The {\f1{}match} function searches the string, {\i string}, for the longest, leftmost substring matched by the regular expression, {\i regexp}.  It returns the character position, or \'A2index\'A2, of where that substring begins (one, if it starts at the beginning of {\i string}).  If no match is found, it returns zero.\par
\par
\pard\li720{}{K{\footnote K RSTART}}{K{\footnote K RLENGTH}}The {\f1{}match} function sets the built-in variable {\f1{}RSTART} to the index.  It also sets the built-in variable {\f1{}RLENGTH} to the length in characters of the matched substring.  If no match is found, {\f1{}RSTART} is set to zero, and {\f1{}RLENGTH} to -1.\par
\par
\pard\li720{}For example:\par
\par
{{\pard\keep\li1440\f1{}awk '\'7B\line
       if ($1 == "FIND")\line
         regex = $2\line
       else \'7B\line
         where = match($0, regex)\line
         if (where != 0)\line
           print "Match of", regex, "found at", \'5C\line
                     where, "in", $0\line
       \'7D\line
\'7D'\par
\pard\keep\li1440{}}}\par
\pard\li720\f0{}This program looks for lines that match the regular expression stored in the variable {\f1{}regex}.  This regular expression can be changed.  If the first word on a line is {\f1{}FIND}, {\f1{}regex} is changed to be the second word on that line.  Therefore, given:\par
\par
{\pard\keep\li1440\f1{}FIND ru+n\line
My program runs\line
but not very quickly\line
FIND Melvin\line
JF+KM\line
This line is property of Reality Engineering Co.\line
Melvin was here.\par
\pard\li720\f0{}}\par
{\f1{}\pard\li720{}awk} prints:\par
\par
{\pard\keep\li1440\f1{}Match of ru+n found at 12 in My program runs\line
Match of Melvin found at 1 in Melvin was here.\par
\pard\li720\f0{}}\par
\pard{}{\f1{}split({\i string}, {\i array} [, {\i fieldsep}])}\par
\pard\li720{}{K{\footnote K split}}This divides {\i string} into pieces separated by {\i fieldsep}, and stores the pieces in {\i array}.  The first piece is stored in {\f1{}{\i array}[1]}, the second piece in {\f1{}{\i array}[2]}, and so forth.  The string value of the third argument, {\i fieldsep}, is a regexp describing where to split {\i string} (much as {\f1{}FS} can be a regexp describing where to split input records).  If the {\i fieldsep} is omitted, the value of {\f1{}FS} is used.  {\f1{}split} returns the number of elements created.\par
\par
\pard\li720{}The {\f1{}split} function splits strings into pieces in a manner similar to the way input lines are split into fields.  For example:\par
\par
{\pard\keep\li1440\f1{}split("cul-de-sac", a, "-")\par
\pard\li720\f0{}}\par
\pard\li720{}splits the string {\f1{}cul-de-sac} into three fields using {\f1{}-} as the separator.  It sets the contents of the array {\f1{}a} as follows:\par
\par
{\pard\keep\li1440\f1{}a[1] = "cul"\line
a[2] = "de"\line
a[3] = "sac"\par
\pard\li720\f0{}}\par
\pard\li720{}The value returned by this call to {\f1{}split} is three.\par
\par
\pard\li720{}As with input field-splitting, when the value of {\i fieldsep} is {\f1{}" "}, leading and trailing whitespace is ignored, and the elements are separated by runs of whitespace.\par
\par
\pard\li720{}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}Also as with input field-splitting, if {\i fieldsep} is the null string, each individual character in the string is split into its own array element.  (This is a {\f1{}gawk}-specific extension.)\par
\par
\pard\li720{}{K{\footnote K dark corner}}Recent implementations of {\f1{}awk}, including {\f1{}gawk}, allow the third argument to be a regexp constant ({\f1{}/abc/}), as well as a string (d.c.).  The POSIX standard allows this as well.\par
\par
\pard\li720{}Before splitting the string, {\f1{}split} deletes any previously existing elements in the array {\i array} (d.c.).\par
\par
\pard\li720{}If {\i string} does not match {\i fieldsep} at all, {\i array} will have one element. The value of that element will be the original {\i string}.\par
\par
\pard{}{\f1{}sprintf({\i format}, {\i expression1},...)}\par
\pard\li720{}{K{\footnote K sprintf}}This returns (without printing) the string that {\f1{}printf} would have printed out with the same arguments (see {\uldb Using {\f1{}printf} Statements for Fancier Printing}{\v Printf}).  For example:\par
\par
{\pard\keep\li1440\f1{}sprintf("pi = %.2f (approx.)", 22/7)\par
\pard\li720\f0{}}\par
\pard\li720{}returns the string {\f1{}"pi = 3.14 (approx.)"}.\par
\par
\pard{}{\f1{}sub({\i regexp}, {\i replacement} [, {\i target}])}\par
\pard\li720{}{K{\footnote K sub}}The {\f1{}sub} function alters the value of {\i target}.  It searches this value, which is treated as a string, for the leftmost longest substring matched by the regular expression, {\i regexp}, extending this match as far as possible.  Then the entire string is changed by replacing the matched text with {\i replacement}.  The modified string becomes the new value of {\i target}.\par
\par
\pard\li720{}This function is peculiar because {\i target} is not simply used to compute a value, and not just any expression will do: it must be a variable, field or array element, so that {\f1{}sub} can store a modified value there.  If this argument is omitted, then the default is to use and alter {\f1{}$0}.\par
\par
\pard\li720{}For example:\par
\par
{\pard\keep\li1440\f1{}str = "water, water, everywhere"\line
sub(/at/, "ith", str)\par
\pard\li720\f0{}}\par
\pard\li720{}sets {\f1{}str} to {\f1{}"wither, water, everywhere"}, by replacing the leftmost, longest occurrence of {\f1{}at} with {\f1{}ith}.\par
\par
\pard\li720{}The {\f1{}sub} function returns the number of substitutions made (either one or zero).\par
\par
\pard\li720{}If the special character {\f1{}&} appears in {\i replacement}, it stands for the precise substring that was matched by {\i regexp}.  (If the regexp can match more than one string, then this precise substring may vary.)  For example:\par
\par
{\pard\keep\li1440\f1{}awk '\'7B sub(/candidate/, "& and his wife"); print \'7D'\par
\pard\li720\f0{}}\par
\pard\li720{}changes the first occurrence of {\f1{}candidate} to {\f1{}candidate and his wife} on each input line.\par
\par
\pard\li720{}Here is another example:\par
\par
{\pard\keep\li1440\f1{}awk 'BEGIN \'7B\line
        str = "daabaaa"\line
        sub(/a*/, "c&c", str)\line
        print str\line
\'7D'\line
-| dcaacbaaa\par
\pard\li720\f0{}}\par
\pard\li720{}This shows how {\f1{}&} can represent a non-constant string, and also illustrates the "leftmost, longest" rule in regexp matching (see {\uldb How Much Text Matches?}{\v Leftmost_Longest}).\par
\par
\pard\li720{}The effect of this special character ({\f1{}&}) can be turned off by putting a backslash before it in the string.  As usual, to insert one backslash in the string, you must write two backslashes.  Therefore, write {\f1{}\'5C\'5C&} in a string constant to include a literal {\f1{}&} in the replacement.  For example, here is how to replace the first {\f1{}|} on each line with an {\f1{}&}:\par
\par
{\pard\keep\li1440\f1{}awk '\'7B sub(/\'5C|/, "\'5C\'5C&"); print \'7D'\par
\pard\li720\f0{}}\par
\pard\li720{}{K{\footnote K {\f1{}sub}, third argument of}}{K{\footnote K {\f1{}gsub}, third argument of}}{\b Note:} As mentioned above, the third argument to {\f1{}sub} must be a variable, field or array reference.  Some versions of {\f1{}awk} allow the third argument to be an expression which is not an lvalue.  In such a case, {\f1{}sub} would still search for the pattern and return zero or one, but the result of the substitution (if any) would be thrown away because there is no place to put it.  Such versions of {\f1{}awk} accept expressions like this:\par
\par
{\pard\keep\li1440\f1{}sub(/USA/, "United States", "the USA and Canada")\par
\pard\li720\f0{}}\par
\pard\li720{}For historical compatibility, {\f1{}gawk} will accept erroneous code, such as in the above example. However, using any other non-changeable object as the third parameter will cause a fatal error, and your program will not run.\par
\par
\pard\li720{}Finally, if the {\i regexp} is not a regexp constant, it is converted into a string and then the value of that string is treated as the regexp to match.\par
\par
\pard{}{\f1{}gsub({\i regexp}, {\i replacement} [, {\i target}])}\par
\pard\li720{}{K{\footnote K gsub}}This is similar to the {\f1{}sub} function, except {\f1{}gsub} replaces {\i all} of the longest, leftmost, {\i non-overlapping} matching substrings it can find.  The {\f1{}g} in {\f1{}gsub} stands for "global," which means replace everywhere.  For example:\par
\par
{\pard\keep\li1440\f1{}awk '\'7B gsub(/Britain/, "United Kingdom"); print \'7D'\par
\pard\li720\f0{}}\par
\pard\li720{}replaces all occurrences of the string {\f1{}Britain} with {\f1{}United Kingdom} for all input records.\par
\par
\pard\li720{}The {\f1{}gsub} function returns the number of substitutions made.  If the variable to be searched and altered, {\i target}, is omitted, then the entire input record, {\f1{}$0}, is used.\par
\par
\pard\li720{}As in {\f1{}sub}, the characters {\f1{}&} and {\f1{}\'5C} are special, and the third argument must be an lvalue.\par
\pard{}}\par
{\pard{}{\f1{}gensub({\i regexp}, {\i replacement}, {\i how} [, {\i target}])}\par
\pard\li720{}{K{\footnote K gensub}}{\f1{}gensub} is a general substitution function.  Like {\f1{}sub} and {\f1{}gsub}, it searches the target string {\i target} for matches of the regular expression {\i regexp}.  Unlike {\f1{}sub} and {\f1{}gsub}, the modified string is returned as the result of the function, and the original target string is {\i not} changed.  If {\i how} is a string beginning with {\f1{}g} or {\f1{}G}, then it replaces all matches of {\i regexp} with {\i replacement}.  Otherwise, {\i how} is a number indicating which match of {\i regexp} to replace. If no {\i target} is supplied, {\f1{}$0} is used instead.\par
\par
{\f1{}\pard\li720{}gensub} provides an additional feature that is not available in {\f1{}sub} or {\f1{}gsub}: the ability to specify components of a regexp in the replacement text.  This is done by using parentheses in the regexp to mark the components, and then specifying {\f1{}\'5C{\i n}} in the replacement text, where {\i n} is a digit from one to nine.  For example:\par
\par
{{\pard\keep\li1440\f1{}$ gawk '\line
> BEGIN \'7B\line
>      a = "abc def"\line
>      b = gensub(/(.+) (.+)/, "\'5C\'5C2 \'5C\'5C1", "g", a)\line
>      print b\line
> \'7D'\line
-| def abc\par
\pard\keep\li1440{}}}\par
\pard\li720\f0{}As described above for {\f1{}sub}, you must type two backslashes in order to get one into the string.\par
\par
\pard\li720{}In the replacement text, the sequence {\f1{}\'5C0} represents the entire matched text, as does the character {\f1{}&}.\par
\par
\pard\li720{}This example shows how you can use the third argument to control which match of the regexp should be changed.\par
\par
{\pard\keep\li1440\f1{}$ echo a b c a b c |\line
> gawk '\'7B print gensub(/a/, "AA", 2) \'7D'\line
-| a b c AA b c\par
\pard\li720\f0{}}\par
\pard\li720{}In this case, {\f1{}$0} is used as the default target string.  {\f1{}gensub} returns the new string as its result, which is passed directly to {\f1{}print} for printing.\par
\par
\pard\li720{}If the {\i how} argument is a string that does not begin with {\f1{}g} or {\f1{}G}, or if it is a number that is less than zero, only one substitution is performed.\par
\par
\pard\li720{}If {\i regexp} does not match {\i target}, {\f1{}gensub}'s return value is the original, unchanged value of {\i target}.\par
\par
\pard\li720{}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}}{\f1{}gensub} is a {\f1{}gawk} extension; it is not available in compatibility mode (see {\uldb Command Line Options}{\v Options}).\par
\par
\pard{}{\f1{}substr({\i string}, {\i start} [, {\i length}])}\par
\pard\li720{}{K{\footnote K substr}}This returns a {\i length}-character-long substring of {\i string}, starting at character number {\i start}.  The first character of a string is character number one.  For example, {\f1{}substr("washington", 5, 3)} returns {\f1{}"ing"}.\par
\par
\pard\li720{}If {\i length} is not present, this function returns the whole suffix of {\i string} that begins at character number {\i start}.  For example, {\f1{}substr("washington", 5)} returns {\f1{}"ington"}.  The whole suffix is also returned if {\i length} is greater than the number of characters remaining in the string, counting from character number {\i start}.\par
\par
{\b \pard\li720{}Note:} The string returned by {\f1{}substr} {\i cannot} be assigned to.  Thus, it is a mistake to attempt to change a portion of a string, like this:\par
\par
{\pard\keep\li1440\f1{}string = "abcdef"\line
# try to get "abCDEf", won't work\line
substr(string, 3, 3) = "CDE"\par
\pard\li720\f0{}}\par
\pard\li720{}or to use {\f1{}substr} as the third agument of {\f1{}sub} or {\f1{}gsub}:\par
\par
{\pard\keep\li1440\f1{}gsub(/xyz/, "pdq", substr($0, 5, 20))  # WRONG\par
\pard\li720\f0{}}\par
\pard\li720{}{K{\footnote K case conversion}}{K{\footnote K conversion of case}}\par
\par
\pard{}{\f1{}tolower({\i string})}\par
\pard\li720{}{K{\footnote K tolower}}This returns a copy of {\i string}, with each upper-case character in the string replaced with its corresponding lower-case character.  Non-alphabetic characters are left unchanged.  For example, {\f1{}tolower("MiXeD cAsE 123")} returns {\f1{}"mixed case 123"}.\par
\par
\pard{}{\f1{}toupper({\i string})}\par
\pard\li720{}{K{\footnote K toupper}}This returns a copy of {\i string}, with each lower-case character in the string replaced with its corresponding upper-case character.  Non-alphabetic characters are left unchanged.  For example, {\f1{}toupper("MiXeD cAsE 123")} returns {\f1{}"MIXED CASE 123"}.\par
\pard{}}\par
\pard{\b More About {\f1{}\'5C} and {\f1{}&} with {\f1{}sub}, {\f1{}gsub} and {\f1{}gensub}}\par
\par
\pard{}{K{\footnote K escape processing, {\f1{}sub} et. al.}}When using {\f1{}sub}, {\f1{}gsub} or {\f1{}gensub}, and trying to get literal backslashes and ampersands into the replacement text, you need to remember that there are several levels of \'A2escape processing\'A2 going on.\par
\par
\pard{}First, there is the \'A2lexical\'A2 level, which is when {\f1{}awk} reads your program, and builds an internal copy of your program that can be executed.\par
\par
\pard{}Then there is the run-time level, when {\f1{}awk} actually scans the replacement string to determine what to generate.\par
\par
\pard{}At both levels, {\f1{}awk} looks for a defined set of characters that can come after a backslash.  At the lexical level, it looks for the escape sequences listed in {\uldb Escape Sequences}{\v Escape_Sequences}.  Thus, for every {\f1{}\'5C} that {\f1{}awk} will process at the run-time level, you type two {\f1{}\'5C}s at the lexical level.  When a character that is not valid for an escape sequence follows the {\f1{}\'5C}, Unix {\f1{}awk} and {\f1{}gawk} both simply remove the initial {\f1{}\'5C}, and put the following character into the string. Thus, for example, {\f1{}"a\'5Cqb"} is treated as {\f1{}"aqb"}.\par
\par
\pard{}At the run-time level, the various functions handle sequences of {\f1{}\'5C} and {\f1{}&} differently.  The situation is (sadly) somewhat complex.\par
\par
\pard{}Historically, the {\f1{}sub} and {\f1{}gsub} functions treated the two character sequence {\f1{}\'5C&} specially; this sequence was replaced in the generated text with a single {\f1{}&}.  Any other {\f1{}\'5C} within the {\i replacement} string that did not precede an {\f1{}&} was passed through unchanged.  To illustrate with a table:\par
\par
{{\pard\keep\li720\f1{} You type         {\f1{}sub} sees          {\f1{}sub} generates\line
 --------         ----------          ---------------\line
     {\f1{}\'5C&}              {\f1{}&}            the matched text\line
    {\f1{}\'5C\'5C&}             {\f1{}\'5C&}            a literal {\f1{}&}\line
   {\f1{}\'5C\'5C\'5C&}             {\f1{}\'5C&}            a literal {\f1{}&}\line
  {\f1{}\'5C\'5C\'5C\'5C&}            {\f1{}\'5C\'5C&}            a literal {\f1{}\'5C&}\line
 {\f1{}\'5C\'5C\'5C\'5C\'5C&}            {\f1{}\'5C\'5C&}            a literal {\f1{}\'5C&}\line
{\f1{}\'5C\'5C\'5C\'5C\'5C\'5C&}           {\f1{}\'5C\'5C\'5C&}            a literal {\f1{}\'5C\'5C&}\line
    {\f1{}\'5C\'5Cq}             {\f1{}\'5Cq}            a literal {\f1{}\'5Cq}\par
\pard\f0{}}}\par
\pard{}This table shows both the lexical level processing, where an odd number of backslashes becomes an even number at the run time level, and the run-time processing done by {\f1{}sub}.  (For the sake of simplicity, the rest of the tables below only show the case of even numbers of {\f1{}\'5C}s entered at the lexical level.)\par
\par
\pard{}The problem with the historical approach is that there is no way to get a literal {\f1{}\'5C} followed by the matched text.\par
\par
\pard{}{K{\footnote K {\f1{}awk} language, POSIX version}}{K{\footnote K POSIX {\f1{}awk}}}The 1992 POSIX standard attempted to fix this problem. The standard says that {\f1{}sub} and {\f1{}gsub} look for either a {\f1{}\'5C} or an {\f1{}&} after the {\f1{}\'5C}. If either one follows a {\f1{}\'5C}, that character is output literally.  The interpretation of {\f1{}\'5C} and {\f1{}&} then becomes like this:\par
\par
{{\pard\keep\li720\f1{} You type         {\f1{}sub} sees          {\f1{}sub} generates\line
 --------         ----------          ---------------\line
      {\f1{}&}              {\f1{}&}            the matched text\line
    {\f1{}\'5C\'5C&}             {\f1{}\'5C&}            a literal {\f1{}&}\line
  {\f1{}\'5C\'5C\'5C\'5C&}            {\f1{}\'5C\'5C&}            a literal {\f1{}\'5C}, then the matched text\line
{\f1{}\'5C\'5C\'5C\'5C\'5C\'5C&}           {\f1{}\'5C\'5C\'5C&}            a literal {\f1{}\'5C&}\par
\pard\f0{}}}\par
\pard{}This would appear to solve the problem.  Unfortunately, the phrasing of the standard is unusual. It says, in effect, that {\f1{}\'5C} turns off the special meaning of any following character, but that for anything other than {\f1{}\'5C} and {\f1{}&}, such special meaning is undefined.  This wording leads to two problems.\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}1. \tab{}Backslashes must now be doubled in the {\i replacement} string, breaking historical {\f1{}awk} programs.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}2. \tab{}To make sure that an {\f1{}awk} program is portable, {\i every} character in the {\i replacement} string must be preceded with a backslash.({\ul 1}{\v String_Functions_1})\par
\pard{}}\par
\pard{}The POSIX standard is under revision.({\ul 2}{\v String_Functions_2}) Because of the above problems, proposed text for the revised standard reverts to rules that correspond more closely to the original existing practice. The proposed rules have special cases that make it possible to produce a {\f1{}\'5C} preceding the matched text.\par
\par
{{\pard\keep\li720\f1{} You type         {\f1{}sub} sees         {\f1{}sub} generates\line
 --------         ----------         ---------------\line
{\f1{}\'5C\'5C\'5C\'5C\'5C\'5C&}           {\f1{}\'5C\'5C\'5C&}            a literal {\f1{}\'5C&}\line
  {\f1{}\'5C\'5C\'5C\'5C&}            {\f1{}\'5C\'5C&}            a literal {\f1{}\'5C}, followed by the matched text\line
    {\f1{}\'5C\'5C&}             {\f1{}\'5C&}            a literal {\f1{}&}\line
    {\f1{}\'5C\'5Cq}             {\f1{}\'5Cq}            a literal {\f1{}\'5Cq}\par
\pard\f0{}}}\par
\pard{}In a nutshell, at the run-time level, there are now three special sequences of characters, {\f1{}\'5C\'5C\'5C&}, {\f1{}\'5C\'5C&} and {\f1{}\'5C&}, whereas historically, there was only one.  However, as in the historical case, any {\f1{}\'5C} that is not part of one of these three sequences is not special, and appears in the output literally.\par
\par
{\f1{}\pard{}gawk} 3.0 follows these proposed POSIX rules for {\f1{}sub} and {\f1{}gsub}.  Whether these proposed rules will actually become codified into the standard is unknown at this point. Subsequent {\f1{}gawk} releases will track the standard and implement whatever the final version specifies; this Info file will be updated as well.\par
\par
\pard{}The rules for {\f1{}gensub} are considerably simpler. At the run-time level, whenever {\f1{}gawk} sees a {\f1{}\'5C}, if the following character is a digit, then the text that matched the corresponding parenthesized subexpression is placed in the generated output.  Otherwise, no matter what the character after the {\f1{}\'5C} is, that character will appear in the generated text, and the {\f1{}\'5C} will not.\par
\par
{{\pard\keep\li720\f1{}  You type          {\f1{}gensub} sees         {\f1{}gensub} generates\line
  --------          -------------         ------------------\line
      {\f1{}&}                    {\f1{}&}            the matched text\line
    {\f1{}\'5C\'5C&}                   {\f1{}\'5C&}            a literal {\f1{}&}\line
   {\f1{}\'5C\'5C\'5C\'5C}                   {\f1{}\'5C\'5C}            a literal {\f1{}\'5C}\line
  {\f1{}\'5C\'5C\'5C\'5C&}                  {\f1{}\'5C\'5C&}            a literal {\f1{}\'5C}, then the matched text\line
{\f1{}\'5C\'5C\'5C\'5C\'5C\'5C&}                 {\f1{}\'5C\'5C\'5C&}            a literal {\f1{}\'5C&}\line
    {\f1{}\'5C\'5Cq}                   {\f1{}\'5Cq}            a literal {\f1{}q}\par
\pard\f0{}}}\par
\pard{}Because of the complexity of the lexical and run-time level processing, and the special cases for {\f1{}sub} and {\f1{}gsub}, we recommend the use of {\f1{}gawk} and {\f1{}gensub} for when you have to do substitutions.\par
\par
\page\pard#{\footnote String_Functions_1}
\pard{}(1) This consequence was certainly unintended.\par
\par
\page\pard#{\footnote String_Functions_2}
\pard{}(2) As of April, 1999, with final approval and publication hopefully sometime in 1997.\par
\par
\page\pard Node: {\b I/O Functions}, \keepn Next: {\uldb Time Functions}{\v Time_Functions}, Prev: {\uldb String Functions}{\v String_Functions}, Up: {\uldb Built-in}{\v Built_in}\line
K{\footnote K I/O Functions}
#{\footnote I_O_Functions}
${\footnote \pard{}Built-in Functions for Input/Output}\par
\pard{\fs24\b Built-in Functions for Input/Output}\par
\par
\pard{}The following functions are related to Input/Output (I/O).  Optional parameters are enclosed in square brackets ("[" and "]").\par
\par
{\pard{}{\f1{}close({\i filename})}\par
\pard\li720{}{K{\footnote K close}}Close the file {\i filename}, for input or output.  The argument may alternatively be a shell command that was used for redirecting to or from a pipe; then the pipe is closed.  See {\uldb Closing Input and Output Files and Pipes}{\v Close_Files_And_Pipes}, for more information.\par
\par
\pard{}{\f1{}fflush([{\i filename}])}\par
\pard\li720{}{K{\footnote K fflush}}{K{\footnote K portability issues}}{K{\footnote K flushing buffers}}{K{\footnote K buffers, flushing}}{K{\footnote K buffering output}}{K{\footnote K output, buffering}}Flush any buffered output associated {\i filename}, which is either a file opened for writing, or a shell command for redirecting output to a pipe.\par
\par
\pard\li720{}Many utility programs will \'A2buffer\'A2 their output; they save information to be written to a disk file or terminal in memory, until there is enough for it to be worthwhile to send the data to the ouput device.  This is often more efficient than writing every little bit of information as soon as it is ready.  However, sometimes it is necessary to force a program to \'A2flush\'A2 its buffers; that is, write the information to its destination, even if a buffer is not full.  This is the purpose of the {\f1{}fflush} function; {\f1{}gawk} too buffers its output, and the {\f1{}fflush} function can be used to force {\f1{}gawk} to flush its buffers.\par
\par
{\f1{}\pard\li720{}fflush} is a recent (1994) addition to the Bell Labs research version of {\f1{}awk}; it is not part of the POSIX standard, and will not be available if {\f1{}--posix} has been specified on the command line (see {\uldb Command Line Options}{\v Options}).\par
\par
{\f1{}\pard\li720{}gawk} extends the {\f1{}fflush} function in two ways.  The first is to allow no argument at all. In this case, the buffer for the standard output is flushed.  The second way is to allow the null string ({\f1{}""}) as the argument. In this case, the buffers for {\i all} open output files and pipes are flushed.\par
\par
{\f1{}\pard\li720{}fflush} returns zero if the buffer was successfully flushed, and nonzero otherwise.\par
\par
\pard{}{\f1{}system({\i command})}\par
\pard\li720{}{K{\footnote K system}}{K{\footnote K interaction, {\f1{}awk} and other programs}}The {\f1{}system} function allows the user to execute operating system commands and then return to the {\f1{}awk} program.  The {\f1{}system} function executes the command given by the string {\i command}.  It returns, as its value, the status returned by the command that was executed.\par
\par
\pard\li720{}For example, if the following fragment of code is put in your {\f1{}awk} program:\par
\par
{\pard\keep\li1440\f1{}END \'7B\line
     system("date | mail -s 'awk run done' root")\line
\'7D\par
\pard\li720\f0{}}\par
\pard\li720{}the system administrator will be sent mail when the {\f1{}awk} program finishes processing input and begins its end-of-input processing.\par
\par
\pard\li720{}Note that redirecting {\f1{}print} or {\f1{}printf} into a pipe is often enough to accomplish your task.  If you need to run many commands, it will be more efficient to simply print them to a pipe to the shell:\par
\par
{\pard\keep\li1440\f1{}while ({\i more stuff to do})\line
    print {\i command} | "/bin/sh"\line
close("/bin/sh")\par
\pard\li720\f0{}}\par
\pard\li720{}However, if your {\f1{}awk} program is interactive, {\f1{}system} is useful for cranking up large self-contained programs, such as a shell or an editor.\par
\par
\pard\li720{}Some operating systems cannot implement the {\f1{}system} function.  {\f1{}system} causes a fatal error if it is not supported.\par
\pard{}}\par
\pard{\b Interactive vs. Non-Interactive Buffering}\par
\par
\pard{}{K{\footnote K buffering, interactive vs. non-interactive}}{K{\footnote K buffering, non-interactive vs. interactive}}{K{\footnote K interactive buffering vs. non-interactive}}{K{\footnote K non-interactive buffering vs. interactive}} As a side point, buffering issues can be even more confusing depending upon whether or not your program is \'A2interactive\'A2, i.e., communicating with a user sitting at a keyboard.({\ul 1}{\v I_O_Functions_1})\par
\par
\pard{}Interactive programs generally \'A2line buffer\'A2 their output; they write out every line.  Non-interactive programs wait until they have a full buffer, which may be many lines of output.\par
\par
\pard{}Here is an example of the difference.\par
\par
{\pard\keep\li720\f1{}$ awk '\'7B print $1 + $2 \'7D'\line
1 1\line
-| 2\line
2 3\line
-| 5\line
Control-d\par
\pard\f0{}}\par
\pard{}Each line of output is printed immediately. Compare that behavior with this example.\par
\par
{\pard\keep\li720\f1{}$ awk '\'7B print $1 + $2 \'7D' | cat\line
1 1\line
2 3\line
Control-d\line
-| 2\line
-| 5\par
\pard\f0{}}\par
\pard{}Here, no output is printed until after the {\f1{}Control-d} is typed, since it is all buffered, and sent down the pipe to {\f1{}cat} in one shot.\par
\par
\pard{\b Controlling Output Buffering with {\f1{}system}}\par
\par
\pard{}{K{\footnote K flushing buffers}}{K{\footnote K buffers, flushing}}{K{\footnote K buffering output}}{K{\footnote K output, buffering}} The {\f1{}fflush} function provides explicit control over output buffering for individual files and pipes.  However, its use is not portable to many other {\f1{}awk} implementations.  An alternative method to flush output buffers is by calling {\f1{}system} with a null string as its argument:\par
\par
{\pard\keep\li720\f1{}system("")   # flush output\par
\pard\f0{}}\par
{\f1{}\pard{}gawk} treats this use of the {\f1{}system} function as a special case, and is smart enough not to run a shell (or other command interpreter) with the empty command.  Therefore, with {\f1{}gawk}, this idiom is not only useful, it is efficient.  While this method should work with other {\f1{}awk} implementations, it will not necessarily avoid starting an unnecessary shell.  (Other implementations may only flush the buffer associated with the standard output, and not necessarily all buffered output.)\par
\par
\pard{}If you think about what a programmer expects, it makes sense that {\f1{}system} should flush any pending output.  The following program:\par
\par
{\pard\keep\li720\f1{}BEGIN \'7B\line
     print "first print"\line
     system("echo system echo")\line
     print "second print"\line
\'7D\par
\pard\f0{}}\par
\pard{}must print\par
\par
{\pard\keep\li720\f1{}first print\line
system echo\line
second print\par
\pard\f0{}}\par
\pard{}and not\par
\par
{\pard\keep\li720\f1{}system echo\line
first print\line
second print\par
\pard\f0{}}\par
\pard{}If {\f1{}awk} did not flush its buffers before calling {\f1{}system}, the latter (undesirable) output is what you would see.\par
\par
\page\pard#{\footnote I_O_Functions_1}
\pard{}(1) A program is interactive if the standard output is connected to a terminal device.\par
\par
\page\pard Node: {\b Time Functions}, \keepn Next: {\uldb }{\v }, Prev: {\uldb I/O Functions}{\v I_O_Functions}, Up: {\uldb Built-in}{\v Built_in}\line
K{\footnote K Time Functions}
#{\footnote Time_Functions}
${\footnote \pard{}Functions for Dealing with Time Stamps}\par
\pard{\fs24\b Functions for Dealing with Time Stamps}\par
\par
\pard{}{K{\footnote K timestamps}}{K{\footnote K time of day}}A common use for {\f1{}awk} programs is the processing of log files containing time stamp information, indicating when a particular log record was written.  Many programs log their time stamp in the form returned by the {\f1{}time} system call, which is the number of seconds since a particular epoch.  On POSIX systems, it is the number of seconds since Midnight, January 1, 1970, UTC.\par
\par
\pard{}In order to make it easier to process such log files, and to produce useful reports, {\f1{}gawk} provides two functions for working with time stamps.  Both of these are {\f1{}gawk} extensions; they are not specified in the POSIX standard, nor are they in any other known version of {\f1{}awk}.\par
\par
\pard{}Optional parameters are enclosed in square brackets ("[" and "]").\par
\par
{\pard{}{\f1{}systime()}\par
\pard\li720{}{K{\footnote K systime}}This function returns the current time as the number of seconds since the system epoch.  On POSIX systems, this is the number of seconds since Midnight, January 1, 1970, UTC.  It may be a different number on other systems.\par
\par
\pard{}{\f1{}strftime([{\i format} [, {\i timestamp}]])}\par
\pard\li720{}{K{\footnote K strftime}}This function returns a string.  It is similar to the function of the same name in ANSI C.  The time specified by {\i timestamp} is used to produce a string, based on the contents of the {\i format} string.  The {\i timestamp} is in the same format as the value returned by the {\f1{}systime} function.  If no {\i timestamp} argument is supplied, {\f1{}gawk} will use the current time of day as the time stamp.  If no {\i format} argument is supplied, {\f1{}strftime} uses {\f1{}"%a %b %d %H:%M:%S %Z %Y"}.  This format string produces output (almost) equivalent to that of the {\f1{}date} utility.  (Versions of {\f1{}gawk} prior to 3.0 require the {\i format} argument.)\par
\pard{}}\par
\pard{}The {\f1{}systime} function allows you to compare a time stamp from a log file with the current time of day.  In particular, it is easy to determine how long ago a particular record was logged.  It also allows you to produce log records using the "seconds since the epoch" format.\par
\par
\pard{}The {\f1{}strftime} function allows you to easily turn a time stamp into human-readable information.  It is similar in nature to the {\f1{}sprintf} function (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}), in that it copies non-format specification characters verbatim to the returned string, while substituting date and time values for format specifications in the {\i format} string.\par
\par
{\f1{}\pard{}strftime} is guaranteed by the ANSI C standard to support the following date format specifications:\par
\par
{\pard{}{\f1{}%a}\par
\pard\li720{}The locale's abbreviated weekday name.\par
\par
\pard{}{\f1{}%A}\par
\pard\li720{}The locale's full weekday name.\par
\par
\pard{}{\f1{}%b}\par
\pard\li720{}The locale's abbreviated month name.\par
\par
\pard{}{\f1{}%B}\par
\pard\li720{}The locale's full month name.\par
\par
\pard{}{\f1{}%c}\par
\pard\li720{}The locale's "appropriate" date and time representation.\par
\par
\pard{}{\f1{}%d}\par
\pard\li720{}The day of the month as a decimal number (01-31).\par
\par
\pard{}{\f1{}%H}\par
\pard\li720{}The hour (24-hour clock) as a decimal number (00-23).\par
\par
\pard{}{\f1{}%I}\par
\pard\li720{}The hour (12-hour clock) as a decimal number (01-12).\par
\par
\pard{}{\f1{}%j}\par
\pard\li720{}The day of the year as a decimal number (001-366).\par
\par
\pard{}{\f1{}%m}\par
\pard\li720{}The month as a decimal number (01-12).\par
\par
\pard{}{\f1{}%M}\par
\pard\li720{}The minute as a decimal number (00-59).\par
\par
\pard{}{\f1{}%p}\par
\pard\li720{}The locale's equivalent of the AM/PM designations associated with a 12-hour clock.\par
\par
\pard{}{\f1{}%S}\par
\pard\li720{}The second as a decimal number (00-60).({\ul 1}{\v Time_Functions_1})\par
\par
\pard{}{\f1{}%U}\par
\pard\li720{}The week number of the year (the first Sunday as the first day of week one) as a decimal number (00-53).\par
\par
\pard{}{\f1{}%w}\par
\pard\li720{}The weekday as a decimal number (0-6).  Sunday is day zero.\par
\par
\pard{}{\f1{}%W}\par
\pard\li720{}The week number of the year (the first Monday as the first day of week one) as a decimal number (00-53).\par
\par
\pard{}{\f1{}%x}\par
\pard\li720{}The locale's "appropriate" date representation.\par
\par
\pard{}{\f1{}%X}\par
\pard\li720{}The locale's "appropriate" time representation.\par
\par
\pard{}{\f1{}%y}\par
\pard\li720{}The year without century as a decimal number (00-99).\par
\par
\pard{}{\f1{}%Y}\par
\pard\li720{}The year with century as a decimal number (e.g., 1995).\par
\par
\pard{}{\f1{}%Z}\par
\pard\li720{}The time zone name or abbreviation, or no characters if no time zone is determinable.\par
\par
\pard{}{\f1{}%%}\par
\pard\li720{}A literal {\f1{}%}.\par
\pard{}}\par
\pard{}If a conversion specifier is not one of the above, the behavior is undefined.({\ul 2}{\v Time_Functions_2})\par
\par
\pard{}{K{\footnote K locale, definition of}}Informally, a \'A2locale\'A2 is the geographic place in which a program is meant to run.  For example, a common way to abbreviate the date September 4, 1991 in the United States would be "9/4/91".  In many countries in Europe, however, it would be abbreviated "4.9.91".  Thus, the {\f1{}%x} specification in a {\f1{}"US"} locale might produce {\f1{}9/4/91}, while in a {\f1{}"EUROPE"} locale, it might produce {\f1{}4.9.91}.  The ANSI C standard defines a default {\f1{}"C"} locale, which is an environment that is typical of what most C programmers are used to.\par
\par
\pard{}A public-domain C version of {\f1{}strftime} is supplied with {\f1{}gawk} for systems that are not yet fully ANSI-compliant.  If that version is used to compile {\f1{}gawk} (see {\uldb Installing {\f1{}gawk}}{\v Installation}), then the following additional format specifications are available:\par
\par
{\pard{}{\f1{}%D}\par
\pard\li720{}Equivalent to specifying {\f1{}%m/%d/%y}.\par
\par
\pard{}{\f1{}%e}\par
\pard\li720{}The day of the month, padded with a space if it is only one digit.\par
\par
\pard{}{\f1{}%h}\par
\pard\li720{}Equivalent to {\f1{}%b}, above.\par
\par
\pard{}{\f1{}%n}\par
\pard\li720{}A newline character (ASCII LF).\par
\par
\pard{}{\f1{}%r}\par
\pard\li720{}Equivalent to specifying {\f1{}%I:%M:%S %p}.\par
\par
\pard{}{\f1{}%R}\par
\pard\li720{}Equivalent to specifying {\f1{}%H:%M}.\par
\par
\pard{}{\f1{}%T}\par
\pard\li720{}Equivalent to specifying {\f1{}%H:%M:%S}.\par
\par
\pard{}{\f1{}%t}\par
\pard\li720{}A tab character.\par
\par
\pard{}{\f1{}%k}\par
\pard\li720{}The hour (24-hour clock) as a decimal number (0-23).  Single digit numbers are padded with a space.\par
\par
\pard{}{\f1{}%l}\par
\pard\li720{}The hour (12-hour clock) as a decimal number (1-12).  Single digit numbers are padded with a space.\par
\par
\pard{}{\f1{}%C}\par
\pard\li720{}The century, as a number between 00 and 99.\par
\par
\pard{}{\f1{}%u}\par
\pard\li720{}The weekday as a decimal number [1 (Monday)-7].\par
\par
\pard\li720{}{K{\footnote K ISO 8601}}\par
\par
\pard{}{\f1{}%V}\par
\pard\li720{}The week number of the year (the first Monday as the first day of week one) as a decimal number (01-53).  The method for determining the week number is as specified by ISO 8601 (to wit: if the week containing January 1 has four or more days in the new year, then it is week one, otherwise it is week 53 of the previous year and the next week is week one).\par
\par
\pard{}{\f1{}%G}\par
\pard\li720{}The year with century of the ISO week number, as a decimal number.\par
\par
\pard\li720{}For example, January 1, 1993, is in week 53 of 1992. Thus, the year of its ISO week number is 1992, even though its year is 1993.  Similarly, December 31, 1973, is in week 1 of 1974. Thus, the year of its ISO week number is 1974, even though its year is 1973.\par
\par
\pard{}{\f1{}%g}\par
\pard\li720{}The year without century of the ISO week number, as a decimal number (00-99).\par
\par
\pard{}{\f1{}%Ec %EC %Ex %Ey %EY %Od %Oe %OH %OI}\par
\pard{}{\f1{}%Om %OM %OS %Ou %OU %OV %Ow %OW %Oy}\par
\pard\li720{}These are "alternate representations" for the specifications that use only the second letter ({\f1{}%c}, {\f1{}%C}, and so on).  They are recognized, but their normal representations are used.({\ul 3}{\v Time_Functions_3}) (These facilitate compliance with the POSIX {\f1{}date} utility.)\par
\par
\pard{}{\f1{}%v}\par
\pard\li720{}The date in VMS format (e.g., 20-JUN-1991).\par
\par
\pard\li720{}{K{\footnote K RFC-822}}{K{\footnote K RFC-1036}}\par
\par
\pard{}{\f1{}%z}\par
\pard\li720{}The timezone offset in a +HHMM format (e.g., the format necessary to produce RFC-822/RFC-1036 date headers).\par
\pard{}}\par
\pard{}This example is an {\f1{}awk} implementation of the POSIX {\f1{}date} utility.  Normally, the {\f1{}date} utility prints the current date and time of day in a well known format.  However, if you provide an argument to it that begins with a {\f1{}+}, {\f1{}date} will copy non-format specifier characters to the standard output, and will interpret the current time according to the format specifiers in the string.  For example:\par
\par
{\pard\keep\li720\f1{}$ date '+Today is %A, %B %d, %Y.'\line
-| Today is Thursday, July 11, 1991.\par
\pard\f0{}}\par
\pard{}Here is the {\f1{}gawk} version of the {\f1{}date} utility.  It has a shell "wrapper", to handle the {\f1{}-u} option, which requires that {\f1{}date} run as if the time zone was set to UTC.\par
\par
{{\pard\keep\li720\f1{}#! /bin/sh\line
#\line
# date --- approximate the P1003.2 'date' command\line
\line
case $1 in\line
-u)  TZ=GMT0     # use UTC\line
     export TZ\line
     shift ;;\line
esac\par
\pard\keep\li720{}}\line
{gawk 'BEGIN  \'7B\line
    format = "%a %b %d %H:%M:%S %Z %Y"\line
    exitval = 0\par
\pard\keep\li720{}}\line
{    if (ARGC > 2)\line
        exitval = 1\line
    else if (ARGC == 2) \'7B\line
        format = ARGV[1]\line
        if (format ~ /^\'5C+/)\line
            format = substr(format, 2)   # remove leading +\line
    \'7D\line
    print strftime(format)\line
    exit exitval\line
\'7D' "$@"\par
\pard\keep\li720{}}}\par
\page\pard#{\footnote Time_Functions_1}
\pard\f0{}(1) Occasionally there are minutes in a year with a leap second, which is why the seconds can go up to 60.\par
\par
\page\pard#{\footnote Time_Functions_2}
\pard{}(2) This is because ANSI C leaves the behavior of the C version of {\f1{}strftime} undefined, and {\f1{}gawk} will use the system's version of {\f1{}strftime} if it's there.  Typically, the conversion specifier will either not appear in the returned string, or it will appear literally.\par
\par
\page\pard#{\footnote Time_Functions_3}
\pard{}(3) If you don't understand any of this, don't worry about it; these facilities are meant to make it easier to "internationalize" programs.\par
\par
\page\pard Node: {\b User-defined}, \keepn Next: {\uldb Invoking Gawk}{\v Invoking_Gawk}, Prev: {\uldb Built-in}{\v Built_in}, Up: {\uldb Top}{\v Top}\line
K{\footnote K User-defined}
#{\footnote User_defined}
${\footnote \pard{}User-defined Functions}\par
\pard{\fs24\b User-defined Functions}\par
\par
\pard{}{K{\footnote K user-defined functions}}{K{\footnote K functions, user-defined}}Complicated {\f1{}awk} programs can often be simplified by defining your own functions.  User-defined functions can be called just like built-in ones (see {\uldb Function Calls}{\v Function_Calls}), but it is up to you to define them--to tell {\f1{}awk} what they should do.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Definition Syntax}{\v Definition_Syntax}\tab How to write definitions and what they mean.\par
{\uldb Function Example}{\v Function_Example}\tab An example function definition and what it does.\par
{\uldb Function Caveats}{\v Function_Caveats}\tab Things to watch out for.\par
{\uldb Return Statement}{\v Return_Statement}\tab Specifying the value a function returns.\par
\pard{}}\par
\page\pard Node: {\b Definition Syntax}, \keepn Next: {\uldb Function Example}{\v Function_Example}, Prev: {\uldb User-defined}{\v User_defined}, Up: {\uldb User-defined}{\v User_defined}\line
K{\footnote K Definition Syntax}
#{\footnote Definition_Syntax}
${\footnote \pard{}Function Definition Syntax}\par
\pard{\fs24\b Function Definition Syntax}\par
\par
\pard{}{K{\footnote K defining functions}}{K{\footnote K function definition}} Definitions of functions can appear anywhere between the rules of an {\f1{}awk} program.  Thus, the general form of an {\f1{}awk} program is extended to include sequences of rules {\i and} user-defined function definitions.  There is no need in {\f1{}awk} to put the definition of a function before all uses of the function.  This is because {\f1{}awk} reads the entire program before starting to execute any of it.\par
\par
\pard{}The definition of a function named {\i name} looks like this:\par
\par
{\pard\keep\li720\f1{}function {\i name}({\i parameter-list})\line
\'7B\line
     {\i body-of-function}\line
\'7D\par
\pard\f0{}}\par
\pard{}{K{\footnote K names, use of}}{K{\footnote K namespaces}} {\i name} is the name of the function to be defined.  A valid function name is like a valid variable name: a sequence of letters, digits and underscores, not starting with a digit.  Within a single {\f1{}awk} program, any particular name can only be used as a variable, array or function.\par
\par
{\i \pard{}parameter-list} is a list of the function's arguments and local variable names, separated by commas.  When the function is called, the argument names are used to hold the argument values given in the call.  The local variables are initialized to the empty string.  A function cannot have two parameters with the same name.\par
\par
\pard{}The {\i body-of-function} consists of {\f1{}awk} statements.  It is the most important part of the definition, because it says what the function should actually {\i do}.  The argument names exist to give the body a way to talk about the arguments; local variables, to give the body places to keep temporary values.\par
\par
\pard{}Argument names are not distinguished syntactically from local variable names; instead, the number of arguments supplied when the function is called determines how many argument variables there are.  Thus, if three argument values are given, the first three names in {\i parameter-list} are arguments, and the rest are local variables.\par
\par
\pard{}It follows that if the number of arguments is not the same in all calls to the function, some of the names in {\i parameter-list} may be arguments on some occasions and local variables on others.  Another way to think of this is that omitted arguments default to the null string.\par
\par
\pard{}Usually when you write a function you know how many names you intend to use for arguments and how many you intend to use as local variables.  It is conventional to place some extra space between the arguments and the local variables, to document how your function is supposed to be used.\par
\par
\pard{}{K{\footnote K variable shadowing}}During execution of the function body, the arguments and local variable values hide or \'A2shadow\'A2 any variables of the same names used in the rest of the program.  The shadowed variables are not accessible in the function definition, because there is no way to name them while their names have been taken away for the local variables.  All other variables used in the {\f1{}awk} program can be referenced or set normally in the function's body.\par
\par
\pard{}The arguments and local variables last only as long as the function body is executing.  Once the body finishes, you can once again access the variables that were shadowed while the function was running.\par
\par
\pard{}{K{\footnote K recursive function}}{K{\footnote K function, recursive}}The function body can contain expressions which call functions.  They can even call this function, either directly or by way of another function.  When this happens, we say the function is \'A2recursive\'A2.\par
\par
\pard{}{K{\footnote K {\f1{}awk} language, POSIX version}}{K{\footnote K POSIX {\f1{}awk}}}In many {\f1{}awk} implementations, including {\f1{}gawk}, the keyword {\f1{}function} may be abbreviated {\f1{}func}.  However, POSIX only specifies the use of the keyword {\f1{}function}.  This actually has some practical implications.  If {\f1{}gawk} is in POSIX-compatibility mode (see {\uldb Command Line Options}{\v Options}), then the following statement will {\i not} define a function:\par
\par
{\pard\keep\li720\f1{}func foo() \'7B a = sqrt($1) ; print a \'7D\par
\pard\f0{}}\par
\pard{}Instead it defines a rule that, for each record, concatenates the value of the variable {\f1{}func} with the return value of the function {\f1{}foo}.  If the resulting string is non-null, the action is executed.  This is probably not what was desired.  ({\f1{}awk} accepts this input as syntactically valid, since functions may be used before they are defined in {\f1{}awk} programs.)\par
\par
\pard{}{K{\footnote K portability issues}}To ensure that your {\f1{}awk} programs are portable, always use the keyword {\f1{}function} when defining a function.\par
\par
\page\pard Node: {\b Function Example}, \keepn Next: {\uldb Function Caveats}{\v Function_Caveats}, Prev: {\uldb Definition Syntax}{\v Definition_Syntax}, Up: {\uldb User-defined}{\v User_defined}\line
K{\footnote K Function Example}
#{\footnote Function_Example}
${\footnote \pard{}Function Definition Examples}\par
\pard{\fs24\b Function Definition Examples}\par
\par
\pard{}Here is an example of a user-defined function, called {\f1{}myprint}, that takes a number and prints it in a specific format.\par
\par
{\pard\keep\li720\f1{}function myprint(num)\line
\'7B\line
     printf "%6.3g\'5Cn", num\line
\'7D\par
\pard\f0{}}\par
\pard{}To illustrate, here is an {\f1{}awk} rule which uses our {\f1{}myprint} function:\par
\par
{\pard\keep\li720\f1{}$3 > 0     \'7B myprint($3) \'7D\par
\pard\f0{}}\par
\pard{}This program prints, in our special format, all the third fields that contain a positive number in our input.  Therefore, when given:\par
\par
{{\pard\keep\li720\f1{} 1.2   3.4    5.6   7.8\line
 9.10 11.12 -13.14 15.16\line
17.18 19.20  21.22 23.24\par
\pard\keep\li720{}}}\par
\pard\f0{}this program, using our function to format the results, prints:\par
\par
{\pard\keep\li720\f1{}   5.6\line
  21.2\par
\pard\f0{}}\par
\pard{}This function deletes all the elements in an array.\par
\par
{\pard\keep\li720\f1{}function delarray(a,    i)\line
\'7B\line
    for (i in a)\line
       delete a[i]\line
\'7D\par
\pard\f0{}}\par
\pard{}When working with arrays, it is often necessary to delete all the elements in an array and start over with a new list of elements (see {\uldb The {\f1{}delete} Statement}{\v Delete}).  Instead of having to repeat this loop everywhere in your program that you need to clear out an array, your program can just call {\f1{}delarray}.\par
\par
\pard{}Here is an example of a recursive function.  It takes a string as an input parameter, and returns the string in backwards order.\par
\par
{\pard\keep\li720\f1{}function rev(str, start)\line
\'7B\line
    if (start == 0)\line
        return ""\line
\line
    return (substr(str, start, 1) rev(str, start - 1))\line
\'7D\par
\pard\f0{}}\par
\pard{}If this function is in a file named {\f1{}rev.awk}, we can test it this way:\par
\par
{\pard\keep\li720\f1{}$ echo "Don't Panic!" |\line
> gawk --source '\'7B print rev($0, length($0)) \'7D' -f rev.awk\line
-| !cinaP t'noD\par
\pard\f0{}}\par
\pard{}Here is an example that uses the built-in function {\f1{}strftime}.  (See {\uldb Functions for Dealing with Time Stamps}{\v Time_Functions}, for more information on {\f1{}strftime}.)  The C {\f1{}ctime} function takes a timestamp and returns it in a string, formatted in a well known fashion.  Here is an {\f1{}awk} version:\par
\par
{{\pard\keep\li720\f1{}# ctime.awk\line
#\line
# awk version of C ctime(3) function\line
\line
function ctime(ts,    format)\line
\'7B\line
    format = "%a %b %d %H:%M:%S %Z %Y"\line
    if (ts == 0)\line
        ts = systime()       # use current time as default\line
    return strftime(format, ts)\line
\'7D\par
\pard\keep\li720{}}}\par
\page\pard Node: {\b Function Caveats}, \keepn Next: {\uldb Return Statement}{\v Return_Statement}, Prev: {\uldb Function Example}{\v Function_Example}, Up: {\uldb User-defined}{\v User_defined}\line
K{\footnote K Function Caveats}
#{\footnote Function_Caveats}
${\footnote \pard\f0{}Calling User-defined Functions}\par
\pard{\fs24\b Calling User-defined Functions}\par
\par
\pard{}{K{\footnote K call by value}}{K{\footnote K call by reference}}{K{\footnote K calling a function}}{K{\footnote K function call}}\'A2Calling a function\'A2 means causing the function to run and do its job.  A function call is an expression, and its value is the value returned by the function.\par
\par
\pard{}A function call consists of the function name followed by the arguments in parentheses.  What you write in the call for the arguments are {\f1{}awk} expressions; each time the call is executed, these expressions are evaluated, and the values are the actual arguments.  For example, here is a call to {\f1{}foo} with three arguments (the first being a string concatenation):\par
\par
{\pard\keep\li720\f1{}foo(x y, "lose", 4 * z)\par
\pard\f0{}}\par
{\b \pard{}Caution:} whitespace characters (spaces and tabs) are not allowed between the function name and the open-parenthesis of the argument list.  If you write whitespace by mistake, {\f1{}awk} might think that you mean to concatenate a variable with an expression in parentheses.  However, it notices that you used a function name and not a variable name, and reports an error.\par
\par
\pard{}{K{\footnote K call by value}}When a function is called, it is given a {\i copy} of the values of its arguments.  This is known as \'A2call by value\'A2.  The caller may use a variable as the expression for the argument, but the called function does not know this: it only knows what value the argument had.  For example, if you write this code:\par
\par
{\pard\keep\li720\f1{}foo = "bar"\line
z = myfunc(foo)\par
\pard\f0{}}\par
\pard{}then you should not think of the argument to {\f1{}myfunc} as being "the variable {\f1{}foo}."  Instead, think of the argument as the string value, {\f1{}"bar"}.\par
\par
\pard{}If the function {\f1{}myfunc} alters the values of its local variables, this has no effect on any other variables.  Thus, if {\f1{}myfunc} does this:\par
\par
{{\pard\keep\li720\f1{}function myfunc(str)\line
\'7B\line
  print str\line
  str = "zzz"\line
  print str\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}to change its first argument variable {\f1{}str}, this {\i does not} change the value of {\f1{}foo} in the caller.  The role of {\f1{}foo} in calling {\f1{}myfunc} ended when its value, {\f1{}"bar"}, was computed.  If {\f1{}str} also exists outside of {\f1{}myfunc}, the function body cannot alter this outer value, because it is shadowed during the execution of {\f1{}myfunc} and cannot be seen or changed from there.\par
\par
\pard{}{K{\footnote K call by reference}}However, when arrays are the parameters to functions, they are {\i not} copied.  Instead, the array itself is made available for direct manipulation by the function.  This is usually called \'A2call by reference\'A2.  Changes made to an array parameter inside the body of a function {\i are} visible outside that function.  {This can be {\b very} dangerous if you do not watch what you are doing.  For example: }\par
\par
{\pard\keep\li720\f1{}function changeit(array, ind, nvalue)\line
\'7B\line
     array[ind] = nvalue\line
\'7D\line
\line
BEGIN \'7B\line
    a[1] = 1; a[2] = 2; a[3] = 3\line
    changeit(a, 2, "two")\line
    printf "a[1] = %s, a[2] = %s, a[3] = %s\'5Cn",\line
            a[1], a[2], a[3]\line
\'7D\par
\pard\f0{}}\par
\pard{}This program prints {\f1{}a[1] = 1, a[2] = two, a[3] = 3}, because {\f1{}changeit} stores {\f1{}"two"} in the second element of {\f1{}a}.\par
\par
\pard{}{K{\footnote K undefined functions}}{K{\footnote K functions, undefined}}Some {\f1{}awk} implementations allow you to call a function that has not been defined, and only report a problem at run-time when the program actually tries to call the function. For example:\par
\par
{{\pard\keep\li720\f1{}BEGIN \'7B\line
    if (0)\line
        foo()\line
    else\line
        bar()\line
\'7D\line
function bar() \'7B ... \'7D\line
# note that `foo' is not defined\par
\pard\keep\li720{}}}\par
\pard\f0{}Since the {\f1{}if} statement will never be true, it is not really a problem that {\f1{}foo} has not been defined.  Usually though, it is a problem if a program calls an undefined function.\par
\par
\pard{}If {\f1{}--lint} has been specified (see {\uldb Command Line Options}{\v Options}), {\f1{}gawk} will report about calls to undefined functions.\par
\par
\pard{}Some {\f1{}awk} implementations generate a run-time error if you use the {\f1{}next} statement (see {\uldb The {\f1{}next} Statement}{\v Next_Statement}) inside a user-defined function.  {\f1{}gawk} does not have this problem.\par
\par
\page\pard Node: {\b Return Statement}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Function Caveats}{\v Function_Caveats}, Up: {\uldb User-defined}{\v User_defined}\line
K{\footnote K Return Statement}
#{\footnote Return_Statement}
${\footnote \pard{}The {\f1{}return} Statement}\par
\pard{\fs24\b The {\f1{}return} Statement}\par
\par
\pard{}{K{\footnote K {\f1{}return} statement}} The body of a user-defined function can contain a {\f1{}return} statement.  This statement returns control to the rest of the {\f1{}awk} program.  It can also be used to return a value for use in the rest of the {\f1{}awk} program.  It looks like this:\par
\par
{\pard\keep\li720\f1{}return [{\i expression}]\par
\pard\f0{}}\par
\pard{}The {\i expression} part is optional.  If it is omitted, then the returned value is undefined and, therefore, unpredictable.\par
\par
\pard{}A {\f1{}return} statement with no value expression is assumed at the end of every function definition.  So if control reaches the end of the function body, then the function returns an unpredictable value.  {\f1{}awk} will {\i not} warn you if you use the return value of such a function.\par
\par
\pard{}Sometimes, you want to write a function for what it does, not for what it returns.  Such a function corresponds to a {\f1{}void} function in C or to a {\f1{}procedure} in Pascal.  Thus, it may be appropriate to not return any value; you should simply bear in mind that if you use the return value of such a function, you do so at your own risk.\par
\par
\pard{}Here is an example of a user-defined function that returns a value for the largest number among the elements of an array:\par
\par
{{\pard\keep\li720\f1{}function maxelt(vec,   i, ret)\line
\'7B\line
     for (i in vec) \'7B\line
          if (ret == "" || vec[i] > ret)\line
               ret = vec[i]\line
     \'7D\line
     return ret\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}You call {\f1{}maxelt} with one argument, which is an array name.  The local variables {\f1{}i} and {\f1{}ret} are not intended to be arguments; while there is nothing to stop you from passing two or three arguments to {\f1{}maxelt}, the results would be strange.  The extra space before {\f1{}i} in the function parameter list indicates that {\f1{}i} and {\f1{}ret} are not supposed to be arguments.  This is a convention that you should follow when you define functions.\par
\par
\pard{}Here is a program that uses our {\f1{}maxelt} function.  It loads an array, calls {\f1{}maxelt}, and then reports the maximum number in that array:\par
\par
{{\pard\keep\li720\f1{}awk '\line
function maxelt(vec,   i, ret)\line
\'7B\line
     for (i in vec) \'7B\line
          if (ret == "" || vec[i] > ret)\line
               ret = vec[i]\line
     \'7D\line
     return ret\line
\'7D\par
\pard\keep\li720{}}\line
{# Load all fields of each record into nums.\line
\'7B\line
     for(i = 1; i <= NF; i++)\line
          nums[NR, i] = $i\line
\'7D\line
\line
END \'7B\line
     print maxelt(nums)\line
\'7D'\par
\pard\keep\li720{}}}\par
\pard\f0{}Given the following input:\par
\par
{{\pard\keep\li720\f1{} 1 5 23 8 16\line
44 3 5 2 8 26\line
256 291 1396 2962 100\line
-6 467 998 1101\line
99385 11 0 225\par
\pard\keep\li720{}}}\par
\pard\f0{}our program tells us (predictably) that {\f1{}99385} is the largest number in our array.\par
\par
\page\pard Node: {\b Invoking Gawk}, \keepn Next: {\uldb Library Functions}{\v Library_Functions}, Prev: {\uldb User-defined}{\v User_defined}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Invoking Gawk}
#{\footnote Invoking_Gawk}
${\footnote \pard{}Running {\f1{}awk}}\par
\pard{\fs24\b Running {\f1{}awk}}\par
\par
\pard{}{K{\footnote K command line}}{K{\footnote K invocation of {\f1{}gawk}}}{K{\footnote K arguments, command line}}{K{\footnote K options, command line}}{K{\footnote K long options}}{K{\footnote K options, long}} There are two ways to run {\f1{}awk}: with an explicit program, or with one or more program files.  Here are templates for both of them; items enclosed in {\f1{}[...]} in these templates are optional.\par
\par
\pard{}Besides traditional one-letter POSIX-style options, {\f1{}gawk} also supports GNU long options.\par
\par
{\pard\keep\li720\f1{}awk [{\i options}] -f progfile [{\f1{}--}] {\i file} ...\line
awk [{\i options}] [{\f1{}--}] '{\i program}' {\i file} ...\par
\pard\f0{}}\par
\pard{}{K{\footnote K empty program}}{K{\footnote K dark corner}}It is possible to invoke {\f1{}awk} with an empty program:\par
\par
{\pard\keep\li720\f1{}$ awk '' datafile1 datafile2\par
\pard\f0{}}\par
\pard{}Doing so makes little sense though; {\f1{}awk} will simply exit silently when given an empty program (d.c.).  If {\f1{}--lint} has been specified on the command line, {\f1{}gawk} will issue a warning that the program is empty.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Options}{\v Options}\tab Command line options and their meanings.\par
{\uldb Other Arguments}{\v Other_Arguments}\tab Input file names and variable assignments.\par
{\uldb AWKPATH Variable}{\v AWKPATH_Variable}\tab Searching directories for {\f1{}awk} programs.\par
{\uldb Obsolete}{\v Obsolete}\tab Obsolete Options and/or features.\par
{\uldb Undocumented}{\v Undocumented}\tab Undocumented Options and Features.\par
{\uldb Known Bugs}{\v Known_Bugs}\tab Known Bugs in {\f1{}gawk}.\par
\pard{}}\par
\page\pard Node: {\b Options}, \keepn Next: {\uldb Other Arguments}{\v Other_Arguments}, Prev: {\uldb Invoking Gawk}{\v Invoking_Gawk}, Up: {\uldb Invoking Gawk}{\v Invoking_Gawk}\line
K{\footnote K Options}
#{\footnote Options}
${\footnote \pard{}Command Line Options}\par
\pard{\fs24\b Command Line Options}\par
\par
\pard{}Options begin with a dash, and consist of a single character.  GNU style long options consist of two dashes and a keyword.  The keyword can be abbreviated, as long the abbreviation allows the option to be uniquely identified.  If the option takes an argument, then the keyword is either immediately followed by an equals sign ({\f1{}=}) and the argument's value, or the keyword and the argument's value are separated by whitespace.  For brevity, the discussion below only refers to the traditional short options; however the long and short options are interchangeable in all contexts.\par
\par
\pard{}Each long option for {\f1{}gawk} has a corresponding POSIX-style option.  The options and their meanings are as follows:\par
\par
{\pard{}{\f1{}-F {\i fs}}\par
\pard{}{\f1{}--field-separator {\i fs}}\par
\pard\li720{}{K{\footnote K {\f1{}-F} option}}{K{\footnote K {\f1{}--field-separator} option}}Sets the {\f1{}FS} variable to {\i fs} (see {\uldb Specifying How Fields are Separated}{\v Field_Separators}).\par
\par
\pard{}{\f1{}-f {\i source-file}}\par
\pard{}{\f1{}--file {\i source-file}}\par
\pard\li720{}{K{\footnote K {\f1{}-f} option}}{K{\footnote K {\f1{}--file} option}}Indicates that the {\f1{}awk} program is to be found in {\i source-file} instead of in the first non-option argument.\par
\par
\pard{}{\f1{}-v {\i var}={\i val}}\par
\pard{}{\f1{}--assign {\i var}={\i val}}\par
\pard\li720{}{K{\footnote K {\f1{}-v} option}}{K{\footnote K {\f1{}--assign} option}}Sets the variable {\i var} to the value {\i val} {\b before} execution of the program begins.  Such variable values are available inside the {\f1{}BEGIN} rule (see {\uldb Other Command Line Arguments}{\v Other_Arguments}).\par
\par
\pard\li720{}The {\f1{}-v} option can only set one variable, but you can use it more than once, setting another variable each time, like this: {\f1{}awk -v foo=1 -v bar=2 ...}.\par
\par
\pard{}{\f1{}-mf {\i NNN}}\par
\pard{}{\f1{}-mr {\i NNN}}\par
\pard\li720{}Set various memory limits to the value {\i NNN}.  The {\f1{}f} flag sets the maximum number of fields, and the {\f1{}r} flag sets the maximum record size.  These two flags and the {\f1{}-m} option are from the Bell Labs research version of Unix {\f1{}awk}.  They are provided for compatibility, but otherwise ignored by {\f1{}gawk}, since {\f1{}gawk} has no predefined limits.\par
\par
\pard{}{\f1{}-W {\i gawk-opt}}\par
\pard\li720{}{K{\footnote K {\f1{}-W} option}}Following the POSIX standard, options that are implementation specific are supplied as arguments to the {\f1{}-W} option.  These options also have corresponding GNU style long options.  See below.\par
\par
\pard{}{\f1{}--}\par
\pard\li720{}Signals the end of the command line options.  The following arguments are not treated as options even if they begin with {\f1{}-}.  This interpretation of {\f1{}--} follows the POSIX argument parsing conventions.\par
\par
\pard\li720{}This is useful if you have file names that start with {\f1{}-}, or in shell scripts, if you have file names that will be specified by the user which could start with {\f1{}-}.\par
\pard{}}\par
\pard{}The following {\f1{}gawk}-specific options are available:\par
\par
{\pard{}{\f1{}-W traditional}\par
\pard{}{\f1{}-W compat}\par
\pard{}{\f1{}--traditional}\par
\pard{}{\f1{}--compat}\par
\pard\li720{}{K{\footnote K {\f1{}--compat} option}}{K{\footnote K {\f1{}--traditional} option}}{K{\footnote K compatibility mode}}Specifies \'A2compatibility mode\'A2, in which the GNU extensions to the {\f1{}awk} language are disabled, so that {\f1{}gawk} behaves just like the Bell Labs research version of Unix {\f1{}awk}.  {\f1{}--traditional} is the preferred form of this option.  See {\uldb Extensions in {\f1{}gawk} Not in POSIX {\f1{}awk}}{\v POSIX_GNU}, which summarizes the extensions.  Also see {\uldb Downward Compatibility and Debugging}{\v Compatibility_Mode}.\par
\par
\pard{}{\f1{}-W copyleft}\par
\pard{}{\f1{}-W copyright}\par
\pard{}{\f1{}--copyleft}\par
\pard{}{\f1{}--copyright}\par
\pard\li720{}{K{\footnote K {\f1{}--copyleft} option}}{K{\footnote K {\f1{}--copyright} option}}Print the short version of the General Public License, and then exit.  This option may disappear in a future version of {\f1{}gawk}.\par
\par
\pard{}{\f1{}-W help}\par
\pard{}{\f1{}-W usage}\par
\pard{}{\f1{}--help}\par
\pard{}{\f1{}--usage}\par
\pard\li720{}{K{\footnote K {\f1{}--help} option}}{K{\footnote K {\f1{}--usage} option}}Print a "usage" message summarizing the short and long style options that {\f1{}gawk} accepts, and then exit.\par
\par
\pard{}{\f1{}-W lint}\par
\pard{}{\f1{}--lint}\par
\pard\li720{}{K{\footnote K {\f1{}--lint} option}}Warn about constructs that are dubious or non-portable to other {\f1{}awk} implementations.  Some warnings are issued when {\f1{}gawk} first reads your program.  Others are issued at run-time, as your program executes.\par
\par
\pard{}{\f1{}-W lint-old}\par
\pard{}{\f1{}--lint-old}\par
\pard\li720{}{K{\footnote K {\f1{}--lint-old} option}}Warn about constructs that are not available in the original Version 7 Unix version of {\f1{}awk} (see {\uldb Major Changes between V7 and SVR3.1}{\v V7_SVR3_1}).\par
\par
\pard{}{\f1{}-W posix}\par
\pard{}{\f1{}--posix}\par
\pard\li720{}{K{\footnote K {\f1{}--posix} option}}{K{\footnote K POSIX mode}}Operate in strict POSIX mode.  This disables all {\f1{}gawk} extensions (just like {\f1{}--traditional}), and adds the following additional restrictions:\par
\par
{\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}{\f1{}\'5Cx} escape sequences are not recognized (see {\uldb Escape Sequences}{\v Escape_Sequences}).\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}Newlines do not act as whitespace to separate fields when {\f1{}FS} is equal to a single space.\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}The synonym {\f1{}func} for the keyword {\f1{}function} is not recognized (see {\uldb Function Definition Syntax}{\v Definition_Syntax}).\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}The operators {\f1{}**} and {\f1{}**=} cannot be used in place of {\f1{}^} and {\f1{}^=} (see {\uldb Arithmetic Operators}{\v Arithmetic_Ops}, and also see {\uldb Assignment Expressions}{\v Assignment_Ops}).\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}Specifying {\f1{}-Ft} on the command line does not set the value of {\f1{}FS} to be a single tab character (see {\uldb Specifying How Fields are Separated}{\v Field_Separators}).\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}The {\f1{}fflush} built-in function is not supported (see {\uldb Built-in Functions for Input/Output}{\v I_O_Functions}).\par
\pard\li720{}}\par
\pard\li720{}If you supply both {\f1{}--traditional} and {\f1{}--posix} on the command line, {\f1{}--posix} will take precedence. {\f1{}gawk} will also issue a warning if both options are supplied.\par
\par
\pard{}{\f1{}-W re-interval}\par
\pard{}{\f1{}--re-interval}\par
\pard\li720{}Allow interval expressions (see {\uldb Regular Expression Operators}{\v Regexp_Operators}), in regexps.  Because interval expressions were traditionally not available in {\f1{}awk}, {\f1{}gawk} does not provide them by default. This prevents old {\f1{}awk} programs from breaking.\par
\par
\pard{}{\f1{}-W source {\i program-text}}\par
\pard{}{\f1{}--source {\i program-text}}\par
\pard\li720{}{K{\footnote K {\f1{}--source} option}}Program source code is taken from the {\i program-text}.  This option allows you to mix source code in files with source code that you enter on the command line. This is particularly useful when you have library functions that you wish to use from your command line programs (see {\uldb The {\f1{}AWKPATH} Environment Variable}{\v AWKPATH_Variable}).\par
\par
\pard{}{\f1{}-W version}\par
\pard{}{\f1{}--version}\par
\pard\li720{}{K{\footnote K {\f1{}--version} option}}Prints version information for this particular copy of {\f1{}gawk}.  This allows you to determine if your copy of {\f1{}gawk} is up to date with respect to whatever the Free Software Foundation is currently distributing.  It is also useful for bug reports (see {\uldb Reporting Problems and Bugs}{\v Bugs}).\par
\pard{}}\par
\pard{}Any other options are flagged as invalid with a warning message, but are otherwise ignored.\par
\par
\pard{}In compatibility mode, as a special case, if the value of {\i fs} supplied to the {\f1{}-F} option is {\f1{}t}, then {\f1{}FS} is set to the tab character ({\f1{}"\'5Ct"}).  This is only true for {\f1{}--traditional}, and not for {\f1{}--posix} (see {\uldb Specifying How Fields are Separated}{\v Field_Separators}).\par
\par
\pard{}The {\f1{}-f} option may be used more than once on the command line.  If it is, {\f1{}awk} reads its program source from all of the named files, as if they had been concatenated together into one big file.  This is useful for creating libraries of {\f1{}awk} functions.  Useful functions can be written once, and then retrieved from a standard place, instead of having to be included into each individual program.\par
\par
\pard{}You can type in a program at the terminal and still use library functions, by specifying {\f1{}-f /dev/tty}.  {\f1{}awk} will read a file from the terminal to use as part of the {\f1{}awk} program.  After typing your program, type {\f1{}Control-d} (the end-of-file character) to terminate it.  (You may also use {\f1{}-f -} to read program source from the standard input, but then you will not be able to also use the standard input as a source of data.)\par
\par
\pard{}Because it is clumsy using the standard {\f1{}awk} mechanisms to mix source file and command line {\f1{}awk} programs, {\f1{}gawk} provides the {\f1{}--source} option.  This does not require you to pre-empt the standard input for your source code, and allows you to easily mix command line and library source code (see {\uldb The {\f1{}AWKPATH} Environment Variable}{\v AWKPATH_Variable}).\par
\par
\pard{}If no {\f1{}-f} or {\f1{}--source} option is specified, then {\f1{}gawk} will use the first non-option command line argument as the text of the program source code.\par
\par
\pard{}{K{\footnote K {\f1{}POSIXLY_CORRECT} environment variable}}{K{\footnote K environment variable, {\f1{}POSIXLY_CORRECT}}}If the environment variable {\f1{}POSIXLY_CORRECT} exists, then {\f1{}gawk} will behave in strict POSIX mode, exactly as if you had supplied the {\f1{}--posix} command line option.  Many GNU programs look for this environment variable to turn on strict POSIX mode. If you supply {\f1{}--lint} on the command line, and {\f1{}gawk} turns on POSIX mode because of {\f1{}POSIXLY_CORRECT}, then it will print a warning message indicating that POSIX mode is in effect.\par
\par
\pard{}You would typically set this variable in your shell's startup file.  For a Bourne compatible shell (such as Bash), you would add these lines to the {\f1{}.profile} file in your home directory.\par
\par
{{\pard\keep\li720\f1{}POSIXLY_CORRECT=true\line
export POSIXLY_CORRECT\par
\pard\keep\li720{}}}\par
\pard\f0{}For a {\f1{}csh} compatible shell,({\ul 1}{\v Options_1}) you would add this line to the {\f1{}.login} file in your home directory.\par
\par
{\pard\keep\li720\f1{}setenv POSIXLY_CORRECT true\par
\pard\f0{}}\par
\page\pard#{\footnote Options_1}
\pard{}(1) Not recommended.\par
\par
\page\pard Node: {\b Other Arguments}, \keepn Next: {\uldb AWKPATH Variable}{\v AWKPATH_Variable}, Prev: {\uldb Options}{\v Options}, Up: {\uldb Invoking Gawk}{\v Invoking_Gawk}\line
K{\footnote K Other Arguments}
#{\footnote Other_Arguments}
${\footnote \pard{}Other Command Line Arguments}\par
\pard{\fs24\b Other Command Line Arguments}\par
\par
\pard{}Any additional arguments on the command line are normally treated as input files to be processed in the order specified.   However, an argument that has the form {\f1{}{\i var}={\i value}}, assigns the value {\i value} to the variable {\i var}--it does not specify a file at all.\par
\par
\pard{}{K{\footnote K ARGIND}}{K{\footnote K ARGV}}All these arguments are made available to your {\f1{}awk} program in the {\f1{}ARGV} array (see {\uldb Built-in Variables}{\v Built_in_Variables}).  Command line options and the program text (if present) are omitted from {\f1{}ARGV}.  All other arguments, including variable assignments, are included.   As each element of {\f1{}ARGV} is processed, {\f1{}gawk} sets the variable {\f1{}ARGIND} to the index in {\f1{}ARGV} of the current element.\par
\par
\pard{}The distinction between file name arguments and variable-assignment arguments is made when {\f1{}awk} is about to open the next input file.  At that point in execution, it checks the "file name" to see whether it is really a variable assignment; if so, {\f1{}awk} sets the variable instead of reading a file.\par
\par
\pard{}Therefore, the variables actually receive the given values after all previously specified files have been read.  In particular, the values of variables assigned in this fashion are {\i not} available inside a {\f1{}BEGIN} rule (see {\uldb The {\f1{}BEGIN} and {\f1{}END} Special Patterns}{\v BEGIN_END}), since such rules are run before {\f1{}awk} begins scanning the argument list.\par
\par
\pard{}{K{\footnote K dark corner}}The variable values given on the command line are processed for escape sequences (d.c.) (see {\uldb Escape Sequences}{\v Escape_Sequences}).\par
\par
\pard{}In some earlier implementations of {\f1{}awk}, when a variable assignment occurred before any file names, the assignment would happen {\i before} the {\f1{}BEGIN} rule was executed.  {\f1{}awk}'s behavior was thus inconsistent; some command line assignments were available inside the {\f1{}BEGIN} rule, while others were not.  However, some applications came to depend upon this "feature."  When {\f1{}awk} was changed to be more consistent, the {\f1{}-v} option was added to accommodate applications that depended upon the old behavior.\par
\par
\pard{}The variable assignment feature is most useful for assigning to variables such as {\f1{}RS}, {\f1{}OFS}, and {\f1{}ORS}, which control input and output formats, before scanning the data files.  It is also useful for controlling state if multiple passes are needed over a data file.  For example:\par
\par
\pard{}{K{\footnote K multiple passes over data}}{K{\footnote K passes, multiple}}{\par
\pard\keep\li720\f1{}awk 'pass == 1  \'7B {\i pass 1 stuff} \'7D\line
     pass == 2  \'7B {\i pass 2 stuff} \'7D' pass=1 mydata pass=2 mydata\par
\pard\f0{}}\par
\pard{}Given the variable assignment feature, the {\f1{}-F} option for setting the value of {\f1{}FS} is not strictly necessary.  It remains for historical compatibility.\par
\par
\page\pard Node: {\b AWKPATH Variable}, \keepn Next: {\uldb Obsolete}{\v Obsolete}, Prev: {\uldb Other Arguments}{\v Other_Arguments}, Up: {\uldb Invoking Gawk}{\v Invoking_Gawk}\line
K{\footnote K AWKPATH Variable}
#{\footnote AWKPATH_Variable}
${\footnote \pard{}The {\f1{}AWKPATH} Environment Variable}\par
\pard{\fs24\b The {\f1{}AWKPATH} Environment Variable}\par
\par
\pard{}{K{\footnote K {\f1{}AWKPATH} environment variable}}{K{\footnote K environment variable, {\f1{}AWKPATH}}}{K{\footnote K search path}}{K{\footnote K directory search}}{K{\footnote K path, search}}{K{\footnote K differences between {\f1{}gawk} and {\f1{}awk}}} The previous section described how {\f1{}awk} program files can be named on the command line with the {\f1{}-f} option.  In most {\f1{}awk} implementations, you must supply a precise path name for each program file, unless the file is in the current directory.\par
\par
\pard{}{K{\footnote K search path, for source files}}But in {\f1{}gawk}, if the file name supplied to the {\f1{}-f} option does not contain a {\f1{}/}, then {\f1{}gawk} searches a list of directories (called the \'A2search path\'A2), one by one, looking for a file with the specified name.\par
\par
\pard{}The search path is a string consisting of directory names separated by colons.  {\f1{}gawk} gets its search path from the {\f1{}AWKPATH} environment variable.  If that variable does not exist, {\f1{}gawk} uses a default path, which is {\f1{}.:/usr/local/share/awk}.({\ul 1}{\v AWKPATH_Variable_1}) (Programs written for use by system administrators should use an {\f1{}AWKPATH} variable that does not include the current directory, {\f1{}.}.)\par
\par
\pard{}The search path feature is particularly useful for building up libraries of useful {\f1{}awk} functions.  The library files can be placed in a standard directory that is in the default path, and then specified on the command line with a short file name.  Otherwise, the full file name would have to be typed for each file.\par
\par
\pard{}By using both the {\f1{}--source} and {\f1{}-f} options, your command line {\f1{}awk} programs can use facilities in {\f1{}awk} library files.  See {\uldb A Library of {\f1{}awk} Functions}{\v Library_Functions}.\par
\par
\pard{}Path searching is not done if {\f1{}gawk} is in compatibility mode.  This is true for both {\f1{}--traditional} and {\f1{}--posix}.  See {\uldb Command Line Options}{\v Options}.\par
\par
{\b \pard{}Note:} if you want files in the current directory to be found, you must include the current directory in the path, either by including {\f1{}.} explicitly in the path, or by writing a null entry in the path.  (A null entry is indicated by starting or ending the path with a colon, or by placing two colons next to each other ({\f1{}::}).)  If the current directory is not included in the path, then files cannot be found in the current directory.  This path search mechanism is identical to the shell's.\par
\par
\pard{}Starting with version 3.0, if {\f1{}AWKPATH} is not defined in the environment, {\f1{}gawk} will place its default search path into {\f1{}ENVIRON["AWKPATH"]}. This makes it easy to determine the actual search path {\f1{}gawk} will use.\par
\par
\page\pard#{\footnote AWKPATH_Variable_1}
\pard{}(1) Your version of {\f1{}gawk} may use a directory that is different than {\f1{}/usr/local/share/awk}; it will depend upon how {\f1{}gawk} was built and installed. The actual directory will be the value of {\f1{}$(datadir)} generated when {\f1{}gawk} was configured.  You probably don't need to worry about this though.\par
\par
\page\pard Node: {\b Obsolete}, \keepn Next: {\uldb Undocumented}{\v Undocumented}, Prev: {\uldb AWKPATH Variable}{\v AWKPATH_Variable}, Up: {\uldb Invoking Gawk}{\v Invoking_Gawk}\line
K{\footnote K Obsolete}
#{\footnote Obsolete}
${\footnote \pard{}Obsolete Options and/or Features}\par
\pard{\fs24\b Obsolete Options and/or Features}\par
\par
\pard{}{K{\footnote K deprecated options}}{K{\footnote K obsolete options}}{K{\footnote K deprecated features}}{K{\footnote K obsolete features}}This section describes features and/or command line options from previous releases of {\f1{}gawk} that are either not available in the current version, or that are still supported but deprecated (meaning that they will {\i not} be in the next release).\par
\par
\pard{}For version 3.0.4 of {\f1{}gawk}, there are no command line options or other deprecated features from the previous version of {\f1{}gawk}.  {This node }is thus essentially a place holder, in case some option becomes obsolete in a future version of {\f1{}gawk}.\par
\par
\page\pard Node: {\b Undocumented}, \keepn Next: {\uldb Known Bugs}{\v Known_Bugs}, Prev: {\uldb Obsolete}{\v Obsolete}, Up: {\uldb Invoking Gawk}{\v Invoking_Gawk}\line
K{\footnote K Undocumented}
#{\footnote Undocumented}
${\footnote \pard{}Undocumented Options and Features}\par
\pard{\fs24\b Undocumented Options and Features}\par
\par
\pard{}{K{\footnote K undocumented features}}{\par
\pard\li720\f1{}Use the Source, Luke!\line
Obi-Wan\par
\pard\f0{}}\par
\pard{}This section intentionally left blank.\par
\par
\page\pard Node: {\b Known Bugs}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Undocumented}{\v Undocumented}, Up: {\uldb Invoking Gawk}{\v Invoking_Gawk}\line
K{\footnote K Known Bugs}
#{\footnote Known_Bugs}
${\footnote \pard{}Known Bugs in {\f1{}gawk}}\par
\pard{\fs24\b Known Bugs in {\f1{}gawk}}\par
\par
\pard{}{K{\footnote K bugs, known in {\f1{}gawk}}}{K{\footnote K known bugs}} {\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}-F} option for changing the value of {\f1{}FS} (see {\uldb Command Line Options}{\v Options}) is not necessary given the command line variable assignment feature; it remains only for backwards compatibility.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}If your system actually has support for {\f1{}/dev/fd} and the associated {\f1{}/dev/stdin}, {\f1{}/dev/stdout}, and {\f1{}/dev/stderr} files, you may get different output from {\f1{}gawk} than you would get on a system without those files.  When {\f1{}gawk} interprets these files internally, it synchronizes output to the standard output with output to {\f1{}/dev/stdout}, while on a system with those files, the output is actually to different open files (see {\uldb Special File Names in {\f1{}gawk}}{\v Special_Files}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Syntactically invalid single character programs tend to overflow the parse stack, generating a rather unhelpful message.  Such programs are surprisingly difficult to diagnose in the completely general case, and the effort to do so really is not worth it.\par
\pard{}}\par
\page\pard Node: {\b Library Functions}, \keepn Next: {\uldb Sample Programs}{\v Sample_Programs}, Prev: {\uldb Invoking Gawk}{\v Invoking_Gawk}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Library Functions}
#{\footnote Library_Functions}
${\footnote \pard{}A Library of {\f1{}awk} Functions}\par
\pard{\fs24\b A Library of {\f1{}awk} Functions}\par
\par
\pard{}This chapter presents a library of useful {\f1{}awk} functions.  The sample programs presented later (see {\uldb Practical {\f1{}awk} Programs}{\v Sample_Programs}) use these functions.  The functions are presented here in a progression from simple to complex.\par
\par
{\uldb \pard{}Extracting Programs from Texinfo Source Files}{\v Extract_Program}, presents a program that you can use to extract the source code for these example library functions and programs from the Texinfo source for this Info file.  (This has already been done as part of the {\f1{}gawk} distribution.)\par
\par
\pard{}If you have written one or more useful, general purpose {\f1{}awk} functions, and would like to contribute them for a subsequent edition of this Info file, please contact the author.  See {\uldb Reporting Problems and Bugs}{\v Bugs}, for information on doing this.  Don't just send code, as you will be required to either place your code in the public domain, publish it under the GPL (see {\uldb GNU GENERAL PUBLIC LICENSE}{\v Copying}), or assign the copyright in it to the Free Software Foundation.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Portability Notes}{\v Portability_Notes}\tab What to do if you don't have {\f1{}gawk}.\par
{\uldb Nextfile Function}{\v Nextfile_Function}\tab Two implementations of a {\f1{}nextfile} function.\par
{\uldb Assert Function}{\v Assert_Function}\tab A function for assertions in {\f1{}awk} programs.\par
{\uldb Round Function}{\v Round_Function}\tab A function for rounding if {\f1{}sprintf} does not do it correctly.\par
{\uldb Ordinal Functions}{\v Ordinal_Functions}\tab Functions for using characters as numbers and vice versa.\par
{\uldb Join Function}{\v Join_Function}\tab A function to join an array into a string.\par
{\uldb Mktime Function}{\v Mktime_Function}\tab A function to turn a date into a timestamp.\par
{\uldb Gettimeofday Function}{\v Gettimeofday_Function}\tab A function to get formatted times.\par
{\uldb Filetrans Function}{\v Filetrans_Function}\tab A function for handling data file transitions.\par
{\uldb Getopt Function}{\v Getopt_Function}\tab A function for processing command line arguments.\par
{\uldb Passwd Functions}{\v Passwd_Functions}\tab Functions for getting user information.\par
{\uldb Group Functions}{\v Group_Functions}\tab Functions for getting group information.\par
{\uldb Library Names}{\v Library_Names}\tab How to best name private global variables in library functions.\par
\pard{}}\par
\page\pard Node: {\b Portability Notes}, \keepn Next: {\uldb Nextfile Function}{\v Nextfile_Function}, Prev: {\uldb Library Functions}{\v Library_Functions}, Up: {\uldb Library Functions}{\v Library_Functions}\line
K{\footnote K Portability Notes}
#{\footnote Portability_Notes}
${\footnote \pard{}Simulating {\f1{}gawk}-specific Features}\par
\pard{\fs24\b Simulating {\f1{}gawk}-specific Features}\par
\par
\pard{}{K{\footnote K portability issues}} The programs in this chapter and in {\uldb Practical {\f1{}awk} Programs}{\v Sample_Programs}, freely use features that are specific to {\f1{}gawk}.  This section briefly discusses how you can rewrite these programs for different implementations of {\f1{}awk}.\par
\par
\pard{}Diagnostic error messages are sent to {\f1{}/dev/stderr}.  Use {\f1{}| "cat 1>&2"} instead of {\f1{}> "/dev/stderr"}, if your system does not have a {\f1{}/dev/stderr}, or if you cannot use {\f1{}gawk}.\par
\par
\pard{}A number of programs use {\f1{}nextfile} (see {\uldb The {\f1{}nextfile} Statement}{\v Nextfile_Statement}), to skip any remaining input in the input file.  {\uldb Implementing {\f1{}nextfile} as a Function}{\v Nextfile_Function}, shows you how to write a function that will do the same thing.\par
\par
\pard{}Finally, some of the programs choose to ignore upper-case and lower-case distinctions in their input. They do this by assigning one to {\f1{}IGNORECASE}.  You can achieve the same effect by adding the following rule to the beginning of the program:\par
\par
{\pard\keep\li720\f1{}# ignore case\line
\'7B $0 = tolower($0) \'7D\par
\pard\f0{}}\par
\pard{}Also, verify that all regexp and string constants used in comparisons only use lower-case letters.\par
\par
\page\pard Node: {\b Nextfile Function}, \keepn Next: {\uldb Assert Function}{\v Assert_Function}, Prev: {\uldb Portability Notes}{\v Portability_Notes}, Up: {\uldb Library Functions}{\v Library_Functions}\line
K{\footnote K Nextfile Function}
#{\footnote Nextfile_Function}
${\footnote \pard{}Implementing {\f1{}nextfile} as a Function}\par
\pard{\fs24\b Implementing {\f1{}nextfile} as a Function}\par
\par
\pard{}{K{\footnote K skipping input files}}{K{\footnote K input files, skipping}}The {\f1{}nextfile} statement presented in {\uldb The {\f1{}nextfile} Statement}{\v Nextfile_Statement}, is a {\f1{}gawk}-specific extension.  It is not available in other implementations of {\f1{}awk}.  This section shows two versions of a {\f1{}nextfile} function that you can use to simulate {\f1{}gawk}'s {\f1{}nextfile} statement if you cannot use {\f1{}gawk}.\par
\par
\pard{}Here is a first attempt at writing a {\f1{}nextfile} function.\par
\par
{{\pard\keep\li720\f1{}# nextfile --- skip remaining records in current file\line
\line
# this should be read in before the "main" awk program\line
\line
function nextfile()    \'7B _abandon_ = FILENAME; next \'7D\line
\line
_abandon_ == FILENAME  \'7B next \'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}This file should be included before the main program, because it supplies a rule that must be executed first.  This rule compares the current data file's name (which is always in the {\f1{}FILENAME} variable) to a private variable named {\f1{}_abandon_}.  If the file name matches, then the action part of the rule executes a {\f1{}next} statement, to go on to the next record.  (The use of {\f1{}_} in the variable name is a convention.  It is discussed more fully in {\uldb Naming Library Function Global Variables}{\v Library_Names}.)\par
\par
\pard{}The use of the {\f1{}next} statement effectively creates a loop that reads all the records from the current data file.  Eventually, the end of the file is reached, and a new data file is opened, changing the value of {\f1{}FILENAME}.  Once this happens, the comparison of {\f1{}_abandon_} to {\f1{}FILENAME} fails, and execution continues with the first rule of the "real" program.\par
\par
\pard{}The {\f1{}nextfile} function itself simply sets the value of {\f1{}_abandon_} and then executes a {\f1{}next} statement to start the loop going.({\ul 1}{\v Nextfile_Function_1})\par
\par
\pard{}This initial version has a subtle problem.  What happens if the same data file is listed {\i twice} on the command line, one right after the other, or even with just a variable assignment between the two occurrences of the file name?\par
\par
\pard{}{K{\footnote K {\f1{}nextfile} function}}In such a case, this code will skip right through the file, a second time, even though it should stop when it gets to the end of the first occurrence.  Here is a second version of {\f1{}nextfile} that remedies this problem.\par
\par
{{\pard\keep\li720\f1{}# nextfile --- skip remaining records in current file\line
# correctly handle successive occurrences of the same file\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# May, 1993\line
\line
# this should be read in before the "main" awk program\line
\line
function nextfile()   \'7B _abandon_ = FILENAME; next \'7D\line
\line
_abandon_ == FILENAME \'7B\line
      if (FNR == 1)\line
          _abandon_ = ""\line
      else\line
          next\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}The {\f1{}nextfile} function has not changed.  It sets {\f1{}_abandon_} equal to the current file name and then executes a {\f1{}next} satement.  The {\f1{}next} statement reads the next record and increments {\f1{}FNR}, so {\f1{}FNR} is guaranteed to have a value of at least two.  However, if {\f1{}nextfile} is called for the last record in the file, then {\f1{}awk} will close the current data file and move on to the next one.  Upon doing so, {\f1{}FILENAME} will be set to the name of the new file, and {\f1{}FNR} will be reset to one.  If this next file is the same as the previous one, {\f1{}_abandon_} will still be equal to {\f1{}FILENAME}.  However, {\f1{}FNR} will be equal to one, telling us that this is a new occurrence of the file, and not the one we were reading when the {\f1{}nextfile} function was executed.  In that case, {\f1{}_abandon_} is reset to the empty string, so that further executions of this rule will fail (until the next time that {\f1{}nextfile} is called).\par
\par
\pard{}If {\f1{}FNR} is not one, then we are still in the original data file, and the program executes a {\f1{}next} statement to skip through it.\par
\par
\pard{}An important question to ask at this point is: "Given that the functionality of {\f1{}nextfile} can be provided with a library file, why is it built into {\f1{}gawk}?"  This is an important question.  Adding features for little reason leads to larger, slower programs that are harder to maintain.\par
\par
\pard{}The answer is that building {\f1{}nextfile} into {\f1{}gawk} provides significant gains in efficiency.  If the {\f1{}nextfile} function is executed at the beginning of a large data file, {\f1{}awk} still has to scan the entire file, splitting it up into records, just to skip over it.  The built-in {\f1{}nextfile} can simply close the file immediately and proceed to the next one, saving a lot of time.  This is particularly important in {\f1{}awk}, since {\f1{}awk} programs are generally I/O bound (i.e.  they spend most of their time doing input and output, instead of performing computations).\par
\par
\page\pard#{\footnote Nextfile_Function_1}
\pard{}(1) Some implementations of {\f1{}awk} do not allow you to execute {\f1{}next} from within a function body. Some other work-around will be necessary if you use such a version.\par
\par
\page\pard Node: {\b Assert Function}, \keepn Next: {\uldb Round Function}{\v Round_Function}, Prev: {\uldb Nextfile Function}{\v Nextfile_Function}, Up: {\uldb Library Functions}{\v Library_Functions}\line
K{\footnote K Assert Function}
#{\footnote Assert_Function}
${\footnote \pard{}Assertions}\par
\pard{\fs24\b Assertions}\par
\par
\pard{}{K{\footnote K assertions}}{K{\footnote K {\f1{}assert}, C version}}When writing large programs, it is often useful to be able to know that a condition or set of conditions is true.  Before proceeding with a particular computation, you make a statement about what you believe to be the case.  Such a statement is known as an "assertion."  The C language provides an {\f1{}<assert.h>} header file and corresponding {\f1{}assert} macro that the programmer can use to make assertions.  If an assertion fails, the {\f1{}assert} macro arranges to print a diagnostic message describing the condition that should have been true but was not, and then it kills the program.  In C, using {\f1{}assert} looks this:\par
\par
{\pard\keep\li720\f1{}#include <assert.h>\line
\line
int myfunc(int a, double b)\line
\'7B\line
     assert(a <= 5 && b >= 17);\line
     ...\line
\'7D\par
\pard\f0{}}\par
\pard{}If the assertion failed, the program would print a message similar to this:\par
\par
{\pard\keep\li720\f1{}prog.c:5: assertion failed: a <= 5 && b >= 17\par
\pard\f0{}}\par
\pard{}{K{\footnote K assert}}The ANSI C language makes it possible to turn the condition into a string for use in printing the diagnostic message.  This is not possible in {\f1{}awk}, so this {\f1{}assert} function also requires a string version of the condition that is being tested.\par
\par
{\pard\keep\li720\f1{}# assert --- assert that a condition is true. Otherwise exit.\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# May, 1993\line
\line
function assert(condition, string)\line
\'7B\line
    if (! condition) \'7B\line
        printf("%s:%d: assertion failed: %s\'5Cn",\line
            FILENAME, FNR, string) > "/dev/stderr"\line
        _assert_exit = 1\line
        exit 1\line
    \'7D\line
\'7D\line
\line
END \'7B\line
    if (_assert_exit)\line
        exit 1\line
\'7D\par
\pard\f0{}}\par
\pard{}The {\f1{}assert} function tests the {\f1{}condition} parameter. If it is false, it prints a message to standard error, using the {\f1{}string} parameter to describe the failed condition.  It then sets the variable {\f1{}_assert_exit} to one, and executes the {\f1{}exit} statement.  The {\f1{}exit} statement jumps to the {\f1{}END} rule. If the {\f1{}END} rules finds {\f1{}_assert_exit} to be true, then it exits immediately.\par
\par
\pard{}The purpose of the {\f1{}END} rule with its test is to keep any other {\f1{}END} rules from running.  When an assertion fails, the program should exit immediately.  If no assertions fail, then {\f1{}_assert_exit} will still be false when the {\f1{}END} rule is run normally, and the rest of the program's {\f1{}END} rules will execute.  For all of this to work correctly, {\f1{}assert.awk} must be the first source file read by {\f1{}awk}.\par
\par
\pard{}You would use this function in your programs this way:\par
\par
{\pard\keep\li720\f1{}function myfunc(a, b)\line
\'7B\line
     assert(a <= 5 && b >= 17, "a <= 5 && b >= 17")\line
     ...\line
\'7D\par
\pard\f0{}}\par
\pard{}If the assertion failed, you would see a message like this:\par
\par
{\pard\keep\li720\f1{}mydata:1357: assertion failed: a <= 5 && b >= 17\par
\pard\f0{}}\par
\pard{}There is a problem with this version of {\f1{}assert}, that it may not be possible to work around with standard {\f1{}awk}.  An {\f1{}END} rule is automatically added to the program calling {\f1{}assert}.  Normally, if a program consists of just a {\f1{}BEGIN} rule, the input files and/or standard input are not read. However, now that the program has an {\f1{}END} rule, {\f1{}awk} will attempt to read the input data files, or standard input (see {\uldb Startup and Cleanup Actions}{\v Using_BEGIN_END}), most likely causing the program to hang, waiting for input.\par
\par
\page\pard Node: {\b Round Function}, \keepn Next: {\uldb Ordinal Functions}{\v Ordinal_Functions}, Prev: {\uldb Assert Function}{\v Assert_Function}, Up: {\uldb Library Functions}{\v Library_Functions}\line
K{\footnote K Round Function}
#{\footnote Round_Function}
${\footnote \pard{}Rounding Numbers}\par
\pard{\fs24\b Rounding Numbers}\par
\par
\pard{}{K{\footnote K rounding}}The way {\f1{}printf} and {\f1{}sprintf} (see {\uldb Using {\f1{}printf} Statements for Fancier Printing}{\v Printf}) do rounding will often depend upon the system's C {\f1{}sprintf} subroutine.  On many machines, {\f1{}sprintf} rounding is "unbiased," which means it doesn't always round a trailing {\f1{}.5} up, contrary to naive expectations.  In unbiased rounding, {\f1{}.5} rounds to even, rather than always up, so 1.5 rounds to 2 but 4.5 rounds to 4.  The result is that if you are using a format that does rounding (e.g., {\f1{}"%.0f"}) you should check what your system does.  The following function does traditional rounding; it might be useful if your awk's {\f1{}printf} does unbiased rounding.\par
\par
\pard{}{K{\footnote K round}}{\par
\pard\keep\li720\f1{}# round --- do normal rounding\line
#\line
# Arnold Robbins, arnold@gnu.org, August, 1996\line
# Public Domain\line
\line
function round(x,   ival, aval, fraction)\line
\'7B\line
   ival = int(x)    # integer part, int() truncates\line
\line
   # see if fractional part\line
   if (ival == x)   # no fraction\line
      return x\line
\line
   if (x < 0) \'7B\line
      aval = -x     # absolute value\line
      ival = int(aval)\line
      fraction = aval - ival\line
      if (fraction >= .5)\line
         return int(x) - 1   # -2.5 --> -3\line
      else\line
         return int(x)       # -2.3 --> -2\line
   \'7D else \'7B\line
      fraction = x - ival\line
      if (fraction >= .5)\line
         return ival + 1\line
      else\line
         return ival\line
   \'7D\line
\'7D\line
\line
# test harness\line
\'7B print $0, round($0) \'7D\par
\pard\f0{}}\par
\page\pard Node: {\b Ordinal Functions}, \keepn Next: {\uldb Join Function}{\v Join_Function}, Prev: {\uldb Round Function}{\v Round_Function}, Up: {\uldb Library Functions}{\v Library_Functions}\line
K{\footnote K Ordinal Functions}
#{\footnote Ordinal_Functions}
${\footnote \pard{}Translating Between Characters and Numbers}\par
\pard{\fs24\b Translating Between Characters and Numbers}\par
\par
\pard{}{K{\footnote K numeric character values}}{K{\footnote K values of characters as numbers}}One commercial implementation of {\f1{}awk} supplies a built-in function, {\f1{}ord}, which takes a character and returns the numeric value for that character in the machine's character set.  If the string passed to {\f1{}ord} has more than one character, only the first one is used.\par
\par
\pard{}The inverse of this function is {\f1{}chr} (from the function of the same name in Pascal), which takes a number and returns the corresponding character.\par
\par
\pard{}Both functions can be written very nicely in {\f1{}awk}; there is no real reason to build them into the {\f1{}awk} interpreter.\par
\par
\pard{}{K{\footnote K ord}}{K{\footnote K chr}}{\par
{\pard\keep\li720\f1{}# ord.awk --- do ord and chr\line
#\line
# Global identifiers:\line
#    _ord_:        numerical values indexed by characters\line
#    _ord_init:    function to initialize _ord_\line
#\line
# Arnold Robbins\line
# arnold@gnu.org\line
# Public Domain\line
# 16 January, 1992\line
# 20 July, 1992, revised\line
\line
BEGIN    \'7B _ord_init() \'7D\par
\pard\keep\li720{}}\line
function _ord_init(    low, high, i, t)\line
\'7B\line
    low = sprintf("%c", 7) # BEL is ascii 7\line
    if (low == "\'5Ca") \'7B    # regular ascii\line
        low = 0\line
        high = 127\line
    \'7D else if (sprintf("%c", 128 + 7) == "\'5Ca") \'7B\line
        # ascii, mark parity\line
        low = 128\line
        high = 255\line
    \'7D else \'7B        # ebcdic(!)\line
        low = 0\line
        high = 255\line
    \'7D\line
\line
    for (i = low; i <= high; i++) \'7B\line
        t = sprintf("%c", i)\line
        _ord_[t] = i\line
    \'7D\line
\'7D\par
\pard\f0{}}\par
\pard{}{K{\footnote K character sets}}{K{\footnote K character encodings}}{K{\footnote K ASCII}}{K{\footnote K EBCDIC}}{K{\footnote K mark parity}}Some explanation of the numbers used by {\f1{}chr} is worthwhile.  The most prominent character set in use today is ASCII. Although an eight-bit byte can hold 256 distinct values (from zero to 255), ASCII only defines characters that use the values from zero to 127.({\ul 1}{\v Ordinal_Functions_1}) At least one computer manufacturer that we know of uses ASCII, but with mark parity, meaning that the leftmost bit in the byte is always one.  What this means is that on those systems, characters have numeric values from 128 to 255.  Finally, large mainframe systems use the EBCDIC character set, which uses all 256 values.  While there are other character sets in use on some older systems, they are not really worth worrying about.\par
\par
{{\pard\keep\li720\f1{}function ord(str,    c)\line
\'7B\line
    # only first character is of interest\line
    c = substr(str, 1, 1)\line
    return _ord_[c]\line
\'7D\par
\pard\keep\li720{}}\line
{function chr(c)\line
\'7B\line
    # force c to be numeric by adding 0\line
    return sprintf("%c", c + 0)\line
\'7D\par
\pard\keep\li720{}}\line
#### test code ####\line
# BEGIN    \'5C\line
# \'7B\line
#    for (;;) \'7B\line
#        printf("enter a character: ")\line
#        if (getline var <= 0)\line
#            break\line
#        printf("ord(%s) = %d\'5Cn", var, ord(var))\line
#    \'7D\line
# \'7D\par
\pard\f0{}}\par
\pard{}An obvious improvement to these functions would be to move the code for the {\f1{}_ord_init} function into the body of the {\f1{}BEGIN} rule.  It was written this way initially for ease of development.\par
\par
\pard{}There is a "test program" in a {\f1{}BEGIN} rule, for testing the function.  It is commented out for production use.\par
\par
\page\pard#{\footnote Ordinal_Functions_1}
\pard{}(1) ASCII has been extended in many countries to use the values from 128 to 255 for country-specific characters.  If your  system uses these extensions, you can simplify {\f1{}_ord_init} to simply loop from zero to 255.\par
\par
\page\pard Node: {\b Join Function}, \keepn Next: {\uldb Mktime Function}{\v Mktime_Function}, Prev: {\uldb Ordinal Functions}{\v Ordinal_Functions}, Up: {\uldb Library Functions}{\v Library_Functions}\line
K{\footnote K Join Function}
#{\footnote Join_Function}
${\footnote \pard{}Merging an Array Into a String}\par
\pard{\fs24\b Merging an Array Into a String}\par
\par
\pard{}{K{\footnote K merging strings}}When doing string processing, it is often useful to be able to join all the strings in an array into one long string.  The following function, {\f1{}join}, accomplishes this task.  It is used later in several of the application programs (see {\uldb Practical {\f1{}awk} Programs}{\v Sample_Programs}).\par
\par
\pard{}Good function design is important; this function needs to be general, but it should also have a reasonable default behavior.  It is called with an array and the beginning and ending indices of the elements in the array to be merged.  This assumes that the array indices are numeric--a reasonable assumption since the array was likely created with {\f1{}split} (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}).\par
\par
\pard{}{K{\footnote K join}}{\par
{\pard\keep\li720\f1{}# join.awk --- join an array into a string\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# May 1993\line
\line
function join(array, start, end, sep,    result, i)\line
\'7B\line
    if (sep == "")\line
       sep = " "\line
    else if (sep == SUBSEP) # magic value\line
       sep = ""\line
    result = array[start]\line
    for (i = start + 1; i <= end; i++)\line
        result = result sep array[i]\line
    return result\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}An optional additional argument is the separator to use when joining the strings back together.  If the caller supplies a non-empty value, {\f1{}join} uses it.  If it is not supplied, it will have a null value.  In this case, {\f1{}join} uses a single blank as a default separator for the strings.  If the value is equal to {\f1{}SUBSEP}, then {\f1{}join} joins the strings with no separator between them.  {\f1{}SUBSEP} serves as a "magic" value to indicate that there should be no separation between the component strings.\par
\par
\pard{}It would be nice if {\f1{}awk} had an assignment operator for concatenation.  The lack of an explicit operator for concatenation makes string operations more difficult than they really need to be.\par
\par
\page\pard Node: {\b Mktime Function}, \keepn Next: {\uldb Gettimeofday Function}{\v Gettimeofday_Function}, Prev: {\uldb Join Function}{\v Join_Function}, Up: {\uldb Library Functions}{\v Library_Functions}\line
K{\footnote K Mktime Function}
#{\footnote Mktime_Function}
${\footnote \pard{}Turning Dates Into Timestamps}\par
\pard{\fs24\b Turning Dates Into Timestamps}\par
\par
\pard{}The {\f1{}systime} function built in to {\f1{}gawk} returns the current time of day as a timestamp in "seconds since the Epoch."  This timestamp can be converted into a printable date of almost infinitely variable format using the built-in {\f1{}strftime} function.  (For more information on {\f1{}systime} and {\f1{}strftime}, see {\uldb Functions for Dealing with Time Stamps}{\v Time_Functions}.)\par
\par
\pard{}{K{\footnote K converting dates to timestamps}}{K{\footnote K dates, converting to timestamps}}{K{\footnote K timestamps, converting from dates}}An interesting but difficult problem is to convert a readable representation of a date back into a timestamp.  The ANSI C library provides a {\f1{}mktime} function that does the basic job, converting a canonical representation of a date into a timestamp.\par
\par
\pard{}It would appear at first glance that {\f1{}gawk} would have to supply a {\f1{}mktime} built-in function that was simply a "hook" to the C language version.  In fact though, {\f1{}mktime} can be implemented entirely in {\f1{}awk}.\par
\par
\pard{}Here is a version of {\f1{}mktime} for {\f1{}awk}.  It takes a simple representation of the date and time, and converts it into a timestamp.\par
\par
\pard{}The code is presented here intermixed with explanatory prose.  In {\uldb Extracting Programs from Texinfo Source Files}{\v Extract_Program}, you will see how the Texinfo source file for this Info file can be processed to extract the code into a single source file.\par
\par
\pard{}The program begins with a descriptive comment and a {\f1{}BEGIN} rule that initializes a table {\f1{}_tm_months}.  This table is a two-dimensional array that has the lengths of the months.  The first index is zero for regular years, and one for leap years.  The values are the same for all the months in both kinds of years, except for February; thus the use of multiple assignment.\par
\par
{\pard\keep\li720\f1{}# mktime.awk --- convert a canonical date representation\line
#                into a timestamp\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# May 1993\line
\line
BEGIN    \'5C\line
\'7B\line
    # Initialize table of month lengths\line
    _tm_months[0,1] = _tm_months[1,1] = 31\line
    _tm_months[0,2] = 28; _tm_months[1,2] = 29\line
    _tm_months[0,3] = _tm_months[1,3] = 31\line
    _tm_months[0,4] = _tm_months[1,4] = 30\line
    _tm_months[0,5] = _tm_months[1,5] = 31\line
    _tm_months[0,6] = _tm_months[1,6] = 30\line
    _tm_months[0,7] = _tm_months[1,7] = 31\line
    _tm_months[0,8] = _tm_months[1,8] = 31\line
    _tm_months[0,9] = _tm_months[1,9] = 30\line
    _tm_months[0,10] = _tm_months[1,10] = 31\line
    _tm_months[0,11] = _tm_months[1,11] = 30\line
    _tm_months[0,12] = _tm_months[1,12] = 31\line
\'7D\par
\pard\f0{}}\par
\pard{}The benefit of merging multiple {\f1{}BEGIN} rules (see {\uldb The {\f1{}BEGIN} and {\f1{}END} Special Patterns}{\v BEGIN_END}) is particularly clear when writing library files.  Functions in library files can cleanly initialize their own private data and also provide clean-up actions in private {\f1{}END} rules.\par
\par
\pard{}The next function is a simple one that computes whether a given year is or is not a leap year.  If a year is evenly divisible by four, but not evenly divisible by 100, or if it is evenly divisible by 400, then it is a leap year.  Thus, 1904 was a leap year, 1900 was not, but 2000 will be.\par
\par
\pard{}{K{\footnote K _tm_isleap}}{\par
{\pard\keep\li720\f1{}# decide if a year is a leap year\line
function _tm_isleap(year,    ret)\line
\'7B\line
    ret = (year % 4 == 0 && year % 100 != 0) ||\line
            (year % 400 == 0)\line
\line
    return ret\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}This function is only used a few times in this file, and its computation could have been written \'A2in-line\'A2 (at the point where it's used).  Making it a separate function made the original development easier, and also avoids the possibility of typing errors when duplicating the code in multiple places.\par
\par
\pard{}The next function is more interesting.  It does most of the work of generating a timestamp, which is converting a date and time into some number of seconds since the Epoch.  The caller passes an array (rather imaginatively named {\f1{}a}) containing six values: the year including century, the month as a number between one and 12, the day of the month, the hour as a number between zero and 23, the minute in the hour, and the seconds within the minute.\par
\par
\pard{}The function uses several local variables to precompute the number of seconds in an hour, seconds in a day, and seconds in a year.  Often, similar C code simply writes out the expression in-line, expecting the compiler to do \'A2constant folding\'A2.  E.g., most C compilers would turn {\f1{}60 * 60} into {\f1{}3600} at compile time, instead of recomputing it every time at run time.  Precomputing these values makes the function more efficient.\par
\par
\pard{}{K{\footnote K _tm_addup}}{\par
\pard\keep\li720\f1{}# convert a date into seconds\line
function _tm_addup(a,    total, yearsecs, daysecs,\line
                         hoursecs, i, j)\line
\'7B\line
    hoursecs = 60 * 60\line
    daysecs = 24 * hoursecs\line
    yearsecs = 365 * daysecs\line
\line
    total = (a[1] - 1970) * yearsecs\line
\line
{    # extra day for leap years\line
    for (i = 1970; i < a[1]; i++)\line
        if (_tm_isleap(i))\line
            total += daysecs\par
\pard\keep\li720{}}\line
{    j = _tm_isleap(a[1])\line
    for (i = 1; i < a[2]; i++)\line
        total += _tm_months[j, i] * daysecs\par
\pard\keep\li720{}}\line
    total += (a[3] - 1) * daysecs\line
    total += a[4] * hoursecs\line
    total += a[5] * 60\line
    total += a[6]\line
\line
    return total\line
\'7D\par
\pard\f0{}}\par
\pard{}The function starts with a first approximation of all the seconds between Midnight, January 1, 1970,({\ul 1}{\v Mktime_Function_1}) and the beginning of the current year.  It then goes through all those years, and for every leap year, adds an additional day's worth of seconds.\par
\par
\pard{}The variable {\f1{}j} holds either one or zero, if the current year is or is not a leap year.  For every month in the current year prior to the current month, it adds the number of seconds in the month, using the appropriate entry in the {\f1{}_tm_months} array.\par
\par
\pard{}Finally, it adds in the seconds for the number of days prior to the current day, and the number of hours, minutes, and seconds in the current day.\par
\par
\pard{}The result is a count of seconds since January 1, 1970.  This value is not yet what is needed though.  The reason why is described shortly.\par
\par
\pard{}The main {\f1{}mktime} function takes a single character string argument.  This string is a representation of a date and time in a "canonical" (fixed) form.  This string should be {\f1{}"{\i year} {\i month} {\i day} {\i hour} {\i minute} {\i second}"}.\par
\par
\pard{}{K{\footnote K mktime}}{\par
\pard\keep\li720\f1{}# mktime --- convert a date into seconds,\line
#            compensate for time zone\line
\line
function mktime(str,    res1, res2, a, b, i, j, t, diff)\line
\'7B\line
    i = split(str, a, " ")    # don't rely on FS\line
\line
    if (i != 6)\line
        return -1\line
\line
    # force numeric\line
    for (j in a)\line
        a[j] += 0\line
\line
{    # validate\line
    if (a[1] < 1970 ||\line
        a[2] < 1 || a[2] > 12 ||\line
        a[3] < 1 || a[3] > 31 ||\line
        a[4] < 0 || a[4] > 23 ||\line
        a[5] < 0 || a[5] > 59 ||\line
        a[6] < 0 || a[6] > 60 )\line
            return -1\par
\pard\keep\li720{}}\line
    res1 = _tm_addup(a)\line
    t = strftime("%Y %m %d %H %M %S", res1)\line
\line
    if (_tm_debug)\line
        printf("(%s) -> (%s)\'5Cn", str, t) > "/dev/stderr"\line
\line
    split(t, b, " ")\line
    res2 = _tm_addup(b)\line
\line
    diff = res1 - res2\line
\line
    if (_tm_debug)\line
        printf("diff = %d seconds\'5Cn", diff) > "/dev/stderr"\line
\line
    res1 += diff\line
\line
    return res1\line
\'7D\par
\pard\f0{}}\par
\pard{}The function first splits the string into an array, using spaces and tabs as separators.  If there are not six elements in the array, it returns an error, signaled as the value -1.  Next, it forces each element of the array to be numeric, by adding zero to it.  The following {\f1{}if} statement then makes sure that each element is within an allowable range.  (This checking could be extended further, e.g., to make sure that the day of the month is within the correct range for the particular month supplied.)  All of this is essentially preliminary set-up and error checking.\par
\par
\pard{}Recall that {\f1{}_tm_addup} generated a value in seconds since Midnight, January 1, 1970.  This value is not directly usable as the result we want, {\i since the calculation does not account for the local timezone}.  In other words, the value represents the count in seconds since the Epoch, but only for UTC (Universal Coordinated Time).  If the local timezone is east or west of UTC, then some number of hours should be either added to, or subtracted from the resulting timestamp.\par
\par
\pard{}For example, 6:23 p.m. in Atlanta, Georgia (USA), is normally five hours west of (behind) UTC.  It is only four hours behind UTC if daylight savings time is in effect.  If you are calling {\f1{}mktime} in Atlanta, with the argument {\f1{}"1993 5 23 18 23 12"}, the result from {\f1{}_tm_addup} will be for 6:23 p.m. UTC, which is only 2:23 p.m. in Atlanta.  It is necessary to add another four hours worth of seconds to the result.\par
\par
\pard{}How can {\f1{}mktime} determine how far away it is from UTC?  This is surprisingly easy.  The returned timestamp represents the time passed to {\f1{}mktime} {\i as UTC}.  This timestamp can be fed back to {\f1{}strftime}, which will format it as a {\i local} time; i.e. as if it already had the UTC difference added in to it.  This is done by giving {\f1{}"%Y %m %d %H %M %S"} to {\f1{}strftime} as the format argument.  It returns the computed timestamp in the original string format.  The result represents a time that accounts for the UTC difference.  When the new time is converted back to a timestamp, the difference between the two timestamps is the difference (in seconds) between the local timezone and UTC.  This difference is then added back to the original result.  An example demonstrating this is presented below.\par
\par
\pard{}Finally, there is a "main" program for testing the function.\par
\par
{\pard\keep\li720\f1{}BEGIN  \'7B\line
    if (_tm_test) \'7B\line
        printf "Enter date as yyyy mm dd hh mm ss: "\line
        getline _tm_test_date\line
\line
        t = mktime(_tm_test_date)\line
        r = strftime("%Y %m %d %H %M %S", t)\line
        printf "Got back (%s)\'5Cn", r\line
    \'7D\line
\'7D\par
\pard\f0{}}\par
\pard{}The entire program uses two variables that can be set on the command line to control debugging output and to enable the test in the final {\f1{}BEGIN} rule.  Here is the result of a test run. (Note that debugging output is to standard error, and test output is to standard output.)\par
\par
{\pard\keep\li720\f1{}$ gawk -f mktime.awk -v _tm_test=1 -v _tm_debug=1\line
-| Enter date as yyyy mm dd hh mm ss: 1993 5 23 15 35 10\line
error--> (1993 5 23 15 35 10) -> (1993 05 23 11 35 10)\line
error--> diff = 14400 seconds\line
-| Got back (1993 05 23 15 35 10)\par
\pard\f0{}}\par
\pard{}The time entered was 3:35 p.m. (15:35 on a 24-hour clock), on May 23, 1993.  The first line of debugging output shows the resulting time as UTC--four hours ahead of the local time zone.  The second line shows that the difference is 14400 seconds, which is four hours.  (The difference is only four hours, since daylight savings time is in effect during May.)  The final line of test output shows that the timezone compensation algorithm works; the returned time is the same as the entered time.\par
\par
\pard{}This program does not solve the general problem of turning an arbitrary date representation into a timestamp.  That problem is very involved.  However, the {\f1{}mktime} function provides a foundation upon which to build. Other software can convert month names into numeric months, and AM/PM times into 24-hour clocks, to generate the "canonical" format that {\f1{}mktime} requires.\par
\par
\page\pard#{\footnote Mktime_Function_1}
\pard{}(1) This is the Epoch on POSIX systems.  It may be different on other systems.\par
\par
\page\pard Node: {\b Gettimeofday Function}, \keepn Next: {\uldb Filetrans Function}{\v Filetrans_Function}, Prev: {\uldb Mktime Function}{\v Mktime_Function}, Up: {\uldb Library Functions}{\v Library_Functions}\line
K{\footnote K Gettimeofday Function}
#{\footnote Gettimeofday_Function}
${\footnote \pard{}Managing the Time of Day}\par
\pard{\fs24\b Managing the Time of Day}\par
\par
\pard{}{K{\footnote K formatted timestamps}}{K{\footnote K timestamps, formatted}}The {\f1{}systime} and {\f1{}strftime} functions described in {\uldb Functions for Dealing with Time Stamps}{\v Time_Functions}, provide the minimum functionality necessary for dealing with the time of day in human readable form.  While {\f1{}strftime} is extensive, the control formats are not necessarily easy to remember or intuitively obvious when reading a program.\par
\par
\pard{}The following function, {\f1{}gettimeofday}, populates a user-supplied array with pre-formatted time information.  It returns a string with the current time formatted in the same way as the {\f1{}date} utility.\par
\par
\pard{}{K{\footnote K gettimeofday}}{\par
\pard\keep\li720\f1{}# gettimeofday --- get the time of day in a usable format\line
# Arnold Robbins, arnold@gnu.org, Public Domain, May 1993\line
#\line
# Returns a string in the format of output of date(1)\line
# Populates the array argument time with individual values:\line
#    time["second"]       -- seconds (0 - 59)\line
#    time["minute"]       -- minutes (0 - 59)\line
#    time["hour"]         -- hours (0 - 23)\line
#    time["althour"]      -- hours (0 - 12)\line
#    time["monthday"]     -- day of month (1 - 31)\line
#    time["month"]        -- month of year (1 - 12)\line
#    time["monthname"]    -- name of the month\line
#    time["shortmonth"]   -- short name of the month\line
#    time["year"]         -- year within century (0 - 99)\line
#    time["fullyear"]     -- year with century (19xx or 20xx)\line
#    time["weekday"]      -- day of week (Sunday = 0)\line
#    time["altweekday"]   -- day of week (Monday = 0)\line
#    time["weeknum"]      -- week number, Sunday first day\line
#    time["altweeknum"]   -- week number, Monday first day\line
#    time["dayname"]      -- name of weekday\line
#    time["shortdayname"] -- short name of weekday\line
#    time["yearday"]      -- day of year (0 - 365)\line
#    time["timezone"]     -- abbreviation of timezone name\line
#    time["ampm"]         -- AM or PM designation\line
\line
{function gettimeofday(time,    ret, now, i)\line
\'7B\line
    # get time once, avoids unnecessary system calls\line
    now = systime()\line
\line
    # return date(1)-style output\line
    ret = strftime("%a %b %d %H:%M:%S %Z %Y", now)\line
\line
    # clear out target array\line
    for (i in time)\line
        delete time[i]\par
\pard\keep\li720{}}\line
{    # fill in values, force numeric values to be\line
    # numeric by adding 0\line
    time["second"]       = strftime("%S", now) + 0\line
    time["minute"]       = strftime("%M", now) + 0\line
    time["hour"]         = strftime("%H", now) + 0\line
    time["althour"]      = strftime("%I", now) + 0\line
    time["monthday"]     = strftime("%d", now) + 0\line
    time["month"]        = strftime("%m", now) + 0\line
    time["monthname"]    = strftime("%B", now)\line
    time["shortmonth"]   = strftime("%b", now)\line
    time["year"]         = strftime("%y", now) + 0\line
    time["fullyear"]     = strftime("%Y", now) + 0\line
    time["weekday"]      = strftime("%w", now) + 0\line
    time["altweekday"]   = strftime("%u", now) + 0\line
    time["dayname"]      = strftime("%A", now)\line
    time["shortdayname"] = strftime("%a", now)\line
    time["yearday"]      = strftime("%j", now) + 0\line
    time["timezone"]     = strftime("%Z", now)\line
    time["ampm"]         = strftime("%p", now)\line
    time["weeknum"]      = strftime("%U", now) + 0\line
    time["altweeknum"]   = strftime("%W", now) + 0\line
\line
    return ret\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}The string indices are easier to use and read than the various formats required by {\f1{}strftime}.  The {\f1{}alarm} program presented in {\uldb An Alarm Clock Program}{\v Alarm_Program}, uses this function.\par
\par
\pard{}The {\f1{}gettimeofday} function is presented above as it was written. A more general design for this function would have allowed the user to supply an optional timestamp value that would have been used instead of the current time.\par
\par
\page\pard Node: {\b Filetrans Function}, \keepn Next: {\uldb Getopt Function}{\v Getopt_Function}, Prev: {\uldb Gettimeofday Function}{\v Gettimeofday_Function}, Up: {\uldb Library Functions}{\v Library_Functions}\line
K{\footnote K Filetrans Function}
#{\footnote Filetrans_Function}
${\footnote \pard{}Noting Data File Boundaries}\par
\pard{\fs24\b Noting Data File Boundaries}\par
\par
\pard{}{K{\footnote K per file initialization and clean-up}}The {\f1{}BEGIN} and {\f1{}END} rules are each executed exactly once, at the beginning and end respectively of your {\f1{}awk} program (see {\uldb The {\f1{}BEGIN} and {\f1{}END} Special Patterns}{\v BEGIN_END}).  We (the {\f1{}gawk} authors) once had a user who mistakenly thought that the {\f1{}BEGIN} rule was executed at the beginning of each data file and the {\f1{}END} rule was executed at the end of each data file.  When informed that this was not the case, the user requested that we add new special patterns to {\f1{}gawk}, named {\f1{}BEGIN_FILE} and {\f1{}END_FILE}, that would have the desired behavior.  He even supplied us the code to do so.\par
\par
\pard{}However, after a little thought, I came up with the following library program.  It arranges to call two user-supplied functions, {\f1{}beginfile} and {\f1{}endfile}, at the beginning and end of each data file.  Besides solving the problem in only nine(!) lines of code, it does so {\i portably}; this will work with any implementation of {\f1{}awk}.\par
\par
{\pard\keep\li720\f1{}# transfile.awk\line
#\line
# Give the user a hook for filename transitions\line
#\line
# The user must supply functions beginfile() and endfile()\line
# that each take the name of the file being started or\line
# finished, respectively.\line
#\line
# Arnold Robbins, arnold@gnu.org, January 1992\line
# Public Domain\line
\line
FILENAME != _oldfilename \'5C\line
\'7B\line
    if (_oldfilename != "")\line
        endfile(_oldfilename)\line
    _oldfilename = FILENAME\line
    beginfile(FILENAME)\line
\'7D\line
\line
END   \'7B endfile(FILENAME) \'7D\par
\pard\f0{}}\par
\pard{}This file must be loaded before the user's "main" program, so that the rule it supplies will be executed first.\par
\par
\pard{}This rule relies on {\f1{}awk}'s {\f1{}FILENAME} variable that automatically changes for each new data file.  The current file name is saved in a private variable, {\f1{}_oldfilename}.  If {\f1{}FILENAME} does not equal {\f1{}_oldfilename}, then a new data file is being processed, and it is necessary to call {\f1{}endfile} for the old file.  Since {\f1{}endfile} should only be called if a file has been processed, the program first checks to make sure that {\f1{}_oldfilename} is not the null string.  The program then assigns the current file name to {\f1{}_oldfilename}, and calls {\f1{}beginfile} for the file.  Since, like all {\f1{}awk} variables, {\f1{}_oldfilename} will be initialized to the null string, this rule executes correctly even for the first data file.\par
\par
\pard{}The program also supplies an {\f1{}END} rule, to do the final processing for the last file.  Since this {\f1{}END} rule comes before any {\f1{}END} rules supplied in the "main" program, {\f1{}endfile} will be called first.  Once again the value of multiple {\f1{}BEGIN} and {\f1{}END} rules should be clear.\par
\par
\pard{}{K{\footnote K beginfile}}{K{\footnote K endfile}}This version has same problem as the first version of {\f1{}nextfile} (see {\uldb Implementing {\f1{}nextfile} as a Function}{\v Nextfile_Function}).  If the same data file occurs twice in a row on command line, then {\f1{}endfile} and {\f1{}beginfile} will not be executed at the end of the first pass and at the beginning of the second pass.  This version solves the problem.\par
\par
{\pard\keep\li720\f1{}# ftrans.awk --- handle data file transitions\line
#\line
# user supplies beginfile() and endfile() functions\line
#\line
# Arnold Robbins, arnold@gnu.org, November 1992\line
# Public Domain\line
\line
FNR == 1 \'7B\line
    if (_filename_ != "")\line
        endfile(_filename_)\line
    _filename_ = FILENAME\line
    beginfile(FILENAME)\line
\'7D\line
\line
END  \'7B endfile(_filename_) \'7D\par
\pard\f0{}}\par
\pard{}In {\uldb Counting Things}{\v Wc_Program}, you will see how this library function can be used, and how it simplifies writing the main program.\par
\par
\page\pard Node: {\b Getopt Function}, \keepn Next: {\uldb Passwd Functions}{\v Passwd_Functions}, Prev: {\uldb Filetrans Function}{\v Filetrans_Function}, Up: {\uldb Library Functions}{\v Library_Functions}\line
K{\footnote K Getopt Function}
#{\footnote Getopt_Function}
${\footnote \pard{}Processing Command Line Options}\par
\pard{\fs24\b Processing Command Line Options}\par
\par
\pard{}{K{\footnote K {\f1{}getopt}, C version}}{K{\footnote K processing arguments}}{K{\footnote K argument processing}}Most utilities on POSIX compatible systems take options or "switches" on the command line that can be used to change the way a program behaves.  {\f1{}awk} is an example of such a program (see {\uldb Command Line Options}{\v Options}).  Often, options take \'A2arguments\'A2, data that the program needs to correctly obey the command line option.  For example, {\f1{}awk}'s {\f1{}-F} option requires a string to use as the field separator.  The first occurrence on the command line of either {\f1{}--} or a string that does not begin with {\f1{}-} ends the options.\par
\par
\pard{}Most Unix systems provide a C function named {\f1{}getopt} for processing command line arguments.  The programmer provides a string describing the one letter options. If an option requires an argument, it is followed in the string with a colon.  {\f1{}getopt} is also passed the count and values of the command line arguments, and is called in a loop.  {\f1{}getopt} processes the command line arguments for option letters.  Each time around the loop, it returns a single character representing the next option letter that it found, or {\f1{}?} if it found an invalid option.  When it returns -1, there are no options left on the command line.\par
\par
\pard{}When using {\f1{}getopt}, options that do not take arguments can be grouped together.  Furthermore, options that take arguments require that the argument be present.  The argument can immediately follow the option letter, or it can be a separate command line argument.\par
\par
\pard{}Given a hypothetical program that takes three command line options, {\f1{}-a}, {\f1{}-b}, and {\f1{}-c}, and {\f1{}-b} requires an argument, all of the following are valid ways of invoking the program:\par
\par
{\pard\keep\li720\f1{}prog -a -b foo -c data1 data2 data3\line
prog -ac -bfoo -- data1 data2 data3\line
prog -acbfoo data1 data2 data3\par
\pard\f0{}}\par
\pard{}Notice that when the argument is grouped with its option, the rest of the command line argument is considered to be the option's argument.  In the above example, {\f1{}-acbfoo} indicates that all of the {\f1{}-a}, {\f1{}-b}, and {\f1{}-c} options were supplied, and that {\f1{}foo} is the argument to the {\f1{}-b} option.\par
\par
{\f1{}\pard{}getopt} provides four external variables that the programmer can use.\par
\par
{\pard{}{\f1{}optind}\par
\pard\li720{}The index in the argument value array ({\f1{}argv}) where the first non-option command line argument can be found.\par
\par
\pard{}{\f1{}optarg}\par
\pard\li720{}The string value of the argument to an option.\par
\par
\pard{}{\f1{}opterr}\par
\pard\li720{}Usually {\f1{}getopt} prints an error message when it finds an invalid option.  Setting {\f1{}opterr} to zero disables this feature.  (An application might wish to print its own error message.)\par
\par
\pard{}{\f1{}optopt}\par
\pard\li720{}The letter representing the command line option.  While not usually documented, most versions supply this variable.\par
\pard{}}\par
\pard{}The following C fragment shows how {\f1{}getopt} might process command line arguments for {\f1{}awk}.\par
\par
{{\pard\keep\li720\f1{}int\line
main(int argc, char *argv[])\line
\'7B\line
    ...\line
    /* print our own message */\line
    opterr = 0;\par
\pard\keep\li720{}}{    while ((c = getopt(argc, argv, "v:f:F:W:")) != -1) \'7B\line
        switch (c) \'7B\line
        case 'f':    /* file */\line
            ...\line
            break;\line
        case 'F':    /* field separator */\line
            ...\line
            break;\line
        case 'v':    /* variable assignment */\line
            ...\line
            break;\line
        case 'W':    /* extension */\line
            ...\line
            break;\line
        case '?':\line
        default:\line
            usage();\line
            break;\line
        \'7D\line
    \'7D\line
    ...\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}As a side point, {\f1{}gawk} actually uses the GNU {\f1{}getopt_long} function to process both normal and GNU-style long options (see {\uldb Command Line Options}{\v Options}).\par
\par
\pard{}The abstraction provided by {\f1{}getopt} is very useful, and would be quite handy in {\f1{}awk} programs as well.  Here is an {\f1{}awk} version of {\f1{}getopt}.  This function highlights one of the greatest weaknesses in {\f1{}awk}, which is that it is very poor at manipulating single characters.  Repeated calls to {\f1{}substr} are necessary for accessing individual characters (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}).\par
\par
\pard{}The discussion walks through the code a bit at a time.\par
\par
{\pard\keep\li720\f1{}# getopt --- do C library getopt(3) function in awk\line
#\line
# arnold@gnu.org\line
# Public domain\line
#\line
# Initial version: March, 1991\line
# Revised: May, 1993\line
\line
{# External variables:\line
#    Optind -- index of ARGV for first non-option argument\line
#    Optarg -- string value of argument to current option\line
#    Opterr -- if non-zero, print our own diagnostic\line
#    Optopt -- current option letter\par
\pard\keep\li720{}}\line
# Returns\line
#    -1     at end of options\line
#    ?      for unrecognized option\line
#    <c>    a character representing the current option\line
\line
# Private Data\line
#    _opti  index in multi-flag option, e.g., -abc\par
\pard\f0{}}\par
\pard{}The function starts out with some documentation: who wrote the code, and when it was revised, followed by a list of the global variables it uses, what the return values are and what they mean, and any global variables that are "private" to this library function.  Such documentation is essential for any program, and particularly for library functions.\par
\par
\pard{}{K{\footnote K getopt}}{\par
\pard\keep\li720\f1{}function getopt(argc, argv, options,    optl, thisopt, i)\line
\'7B\line
    optl = length(options)\line
    if (optl == 0)        # no options given\line
        return -1\line
\line
    if (argv[Optind] == "--") \'7B  # all done\line
        Optind++\line
        _opti = 0\line
        return -1\line
    \'7D else if (argv[Optind] !~ /^-[^: \'5Ct\'5Cn\'5Cf\'5Cr\'5Cv\'5Cb]/) \'7B\line
        _opti = 0\line
        return -1\line
    \'7D\par
\pard\f0{}}\par
\pard{}The function first checks that it was indeed called with a string of options (the {\f1{}options} parameter).  If {\f1{}options} has a zero length, {\f1{}getopt} immediately returns -1.\par
\par
\pard{}The next thing to check for is the end of the options.  A {\f1{}--} ends the command line options, as does any command line argument that does not begin with a {\f1{}-}.  {\f1{}Optind} is used to step through the array of command line arguments; it retains its value across calls to {\f1{}getopt}, since it is a global variable.\par
\par
\pard{}The regexp used, {\f1{}/^-[^: \'5Ct\'5Cn\'5Cf\'5Cr\'5Cv\'5Cb]/}, is perhaps a bit of overkill; it checks for a {\f1{}-} followed by anything that is not whitespace and not a colon.  If the current command line argument does not match this pattern, it is not an option, and it ends option processing.\par
\par
{{\pard\keep\li720\f1{}    if (_opti == 0)\line
        _opti = 2\line
    thisopt = substr(argv[Optind], _opti, 1)\line
    Optopt = thisopt\line
    i = index(options, thisopt)\line
    if (i == 0) \'7B\line
        if (Opterr)\line
            printf("%c -- invalid option\'5Cn",\line
                                  thisopt) > "/dev/stderr"\line
        if (_opti >= length(argv[Optind])) \'7B\line
            Optind++\line
            _opti = 0\line
        \'7D else\line
            _opti++\line
        return "?"\line
    \'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}The {\f1{}_opti} variable tracks the position in the current command line argument ({\f1{}argv[Optind]}).  In the case that multiple options were grouped together with one {\f1{}-} (e.g., {\f1{}-abx}), it is necessary to return them to the user one at a time.\par
\par
\pard{}If {\f1{}_opti} is equal to zero, it is set to two, the index in the string of the next character to look at (we skip the {\f1{}-}, which is at position one).  The variable {\f1{}thisopt} holds the character, obtained with {\f1{}substr}.  It is saved in {\f1{}Optopt} for the main program to use.\par
\par
\pard{}If {\f1{}thisopt} is not in the {\f1{}options} string, then it is an invalid option.  If {\f1{}Opterr} is non-zero, {\f1{}getopt} prints an error message on the standard error that is similar to the message from the C version of {\f1{}getopt}.\par
\par
\pard{}Since the option is invalid, it is necessary to skip it and move on to the next option character.  If {\f1{}_opti} is greater than or equal to the length of the current command line argument, then it is necessary to move on to the next one, so {\f1{}Optind} is incremented and {\f1{}_opti} is reset to zero. Otherwise, {\f1{}Optind} is left alone and {\f1{}_opti} is merely incremented.\par
\par
\pard{}In any case, since the option was invalid, {\f1{}getopt} returns {\f1{}?}.  The main program can examine {\f1{}Optopt} if it needs to know what the invalid option letter actually was.\par
\par
{{\pard\keep\li720\f1{}    if (substr(options, i + 1, 1) == ":") \'7B\line
        # get option argument\line
        if (length(substr(argv[Optind], _opti + 1)) > 0)\line
            Optarg = substr(argv[Optind], _opti + 1)\line
        else\line
            Optarg = argv[++Optind]\line
        _opti = 0\line
    \'7D else\line
        Optarg = ""\par
\pard\keep\li720{}}}\par
\pard\f0{}If the option requires an argument, the option letter is followed by a colon in the {\f1{}options} string.  If there are remaining characters in the current command line argument ({\f1{}argv[Optind]}), then the rest of that string is assigned to {\f1{}Optarg}.  Otherwise, the next command line argument is used ({\f1{}-xFOO} vs. {\f1{}-x FOO}). In either case, {\f1{}_opti} is reset to zero, since there are no more characters left to examine in the current command line argument.\par
\par
{\pard\keep\li720\f1{}    if (_opti == 0 || _opti >= length(argv[Optind])) \'7B\line
        Optind++\line
        _opti = 0\line
    \'7D else\line
        _opti++\line
    return thisopt\line
\'7D\par
\pard\f0{}}\par
\pard{}Finally, if {\f1{}_opti} is either zero or greater than the length of the current command line argument, it means this element in {\f1{}argv} is through being processed, so {\f1{}Optind} is incremented to point to the next element in {\f1{}argv}.  If neither condition is true, then only {\f1{}_opti} is incremented, so that the next option letter can be processed on the next call to {\f1{}getopt}.\par
\par
{\pard\keep\li720\f1{}BEGIN \'7B\line
    Opterr = 1    # default is to diagnose\line
    Optind = 1    # skip ARGV[0]\line
\line
    # test program\line
    if (_getopt_test) \'7B\line
        while ((_go_c = getopt(ARGC, ARGV, "ab:cd")) != -1)\line
            printf("c = <%c>, optarg = <%s>\'5Cn",\line
                                       _go_c, Optarg)\line
        printf("non-option arguments:\'5Cn")\line
        for (; Optind < ARGC; Optind++)\line
            printf("\'5CtARGV[%d] = <%s>\'5Cn",\line
                                    Optind, ARGV[Optind])\line
    \'7D\line
\'7D\par
\pard\f0{}}\par
\pard{}The {\f1{}BEGIN} rule initializes both {\f1{}Opterr} and {\f1{}Optind} to one.  {\f1{}Opterr} is set to one, since the default behavior is for {\f1{}getopt} to print a diagnostic message upon seeing an invalid option.  {\f1{}Optind} is set to one, since there's no reason to look at the program name, which is in {\f1{}ARGV[0]}.\par
\par
\pard{}The rest of the {\f1{}BEGIN} rule is a simple test program.  Here is the result of two sample runs of the test program.\par
\par
{{\pard\keep\li720\f1{}$ awk -f getopt.awk -v _getopt_test=1 -- -a -cbARG bax -x\line
-| c = <a>, optarg = <>\line
-| c = <c>, optarg = <>\line
-| c = <b>, optarg = <ARG>\line
-| non-option arguments:\line
-|         ARGV[3] = <bax>\line
-|         ARGV[4] = <-x>\par
\pard\keep\li720{}}\line
{$ awk -f getopt.awk -v _getopt_test=1 -- -a -x -- xyz abc\line
-| c = <a>, optarg = <>\line
error--> x -- invalid option\line
-| c = <?>, optarg = <>\line
-| non-option arguments:\line
-|         ARGV[4] = <xyz>\line
-|         ARGV[5] = <abc>\par
\pard\keep\li720{}}}\par
\pard\f0{}The first {\f1{}--} terminates the arguments to {\f1{}awk}, so that it does not try to interpret the {\f1{}-a} etc. as its own options.\par
\par
\pard{}Several of the sample programs presented in {\uldb Practical {\f1{}awk} Programs}{\v Sample_Programs}, use {\f1{}getopt} to process their arguments.\par
\par
\page\pard Node: {\b Passwd Functions}, \keepn Next: {\uldb Group Functions}{\v Group_Functions}, Prev: {\uldb Getopt Function}{\v Getopt_Function}, Up: {\uldb Library Functions}{\v Library_Functions}\line
K{\footnote K Passwd Functions}
#{\footnote Passwd_Functions}
${\footnote \pard{}Reading the User Database}\par
\pard{\fs24\b Reading the User Database}\par
\par
\pard{}{K{\footnote K {\f1{}/dev/user}}}The {\f1{}/dev/user} special file (see {\uldb Special File Names in {\f1{}gawk}}{\v Special_Files}) provides access to the current user's real and effective user and group id numbers, and if available, the user's supplementary group set.  However, since these are numbers, they do not provide very useful information to the average user.  There needs to be some way to find the user information associated with the user and group numbers.  This section presents a suite of functions for retrieving information from the user database.  See {\uldb Reading the Group Database}{\v Group_Functions}, for a similar suite that retrieves information from the group database.\par
\par
\pard{}{K{\footnote K {\f1{}getpwent}, C version}}{K{\footnote K user information}}{K{\footnote K login information}}{K{\footnote K account information}}{K{\footnote K password file}}The POSIX standard does not define the file where user information is kept.  Instead, it provides the {\f1{}<pwd.h>} header file and several C language subroutines for obtaining user information.  The primary function is {\f1{}getpwent}, for "get password entry."  The "password" comes from the original user database file, {\f1{}/etc/passwd}, which kept user information, along with the encrypted passwords (hence the name).\par
\par
\pard{}While an {\f1{}awk} program could simply read {\f1{}/etc/passwd} directly (the format is well known), because of the way password files are handled on networked systems, this file may not contain complete information about the system's set of users.\par
\par
\pard{}{K{\footnote K {\f1{}pwcat} program}}To be sure of being able to produce a readable, complete version of the user database, it is necessary to write a small C program that calls {\f1{}getpwent}.  {\f1{}getpwent} is defined to return a pointer to a {\f1{}struct passwd}.  Each time it is called, it returns the next entry in the database.  When there are no more entries, it returns {\f1{}NULL}, the null pointer.  When this happens, the C program should call {\f1{}endpwent} to close the database.  Here is {\f1{}pwcat}, a C program that "cats" the password database.\par
\par
\pard{}{K{\footnote K pwcat.c}}{\par
\pard\keep\li720\f1{}/*\line
 * pwcat.c\line
 *\line
 * Generate a printable version of the password database\line
 *\line
 * Arnold Robbins\line
 * arnold@gnu.org\line
 * May 1993\line
 * Public Domain\line
 */\line
\line
#include <stdio.h>\line
#include <pwd.h>\line
\line
int\line
main(argc, argv)\line
int argc;\line
char **argv;\line
\'7B\line
    struct passwd *p;\line
\line
    while ((p = getpwent()) != NULL)\line
        printf("%s:%s:%d:%d:%s:%s:%s\'5Cn",\line
            p->pw_name, p->pw_passwd, p->pw_uid,\line
            p->pw_gid, p->pw_gecos, p->pw_dir, p->pw_shell);\line
\line
    endpwent();\line
    exit(0);\line
\'7D\par
\pard\f0{}}\par
\pard{}If you don't understand C, don't worry about it.  The output from {\f1{}pwcat} is the user database, in the traditional {\f1{}/etc/passwd} format of colon-separated fields.  The fields are:\par
\par
{\pard{}Login name\par
\pard\li720{}The user's login name.\par
\par
\pard{}Encrypted password\par
\pard\li720{}The user's encrypted password.  This may not be available on some systems.\par
\par
\pard{}User-ID\par
\pard\li720{}The user's numeric user-id number.\par
\par
\pard{}Group-ID\par
\pard\li720{}The user's numeric group-id number.\par
\par
\pard{}Full name\par
\pard\li720{}The user's full name, and perhaps other information associated with the user.\par
\par
\pard{}Home directory\par
\pard\li720{}The user's login, or "home" directory (familiar to shell programmers as {\f1{}$HOME}).\par
\par
\pard{}Login shell\par
\pard\li720{}The program that will be run when the user logs in.  This is usually a shell, such as Bash (the Gnu Bourne-Again shell).\par
\pard{}}\par
\pard{}Here are a few lines representative of {\f1{}pwcat}'s output.\par
\par
{\pard\keep\li720\f1{}$ pwcat\line
-| root:3Ov02d5VaUPB6:0:1:Operator:/:/bin/sh\line
-| nobody:*:65534:65534::/:\line
-| daemon:*:1:1::/:\line
-| sys:*:2:2::/:/bin/csh\line
-| bin:*:3:3::/bin:\line
-| arnold:xyzzy:2076:10:Arnold Robbins:/home/arnold:/bin/sh\line
-| miriam:yxaay:112:10:Miriam Robbins:/home/miriam:/bin/sh\line
-| andy:abcca2:113:10:Andy Jacobs:/home/andy:/bin/sh\line
...\par
\pard\f0{}}\par
\pard{}With that introduction, here is a group of functions for getting user information.  There are several functions here, corresponding to the C functions of the same name.\par
\par
\pard{}{K{\footnote K _pw_init}}{\par
{\pard\keep\li720\f1{}# passwd.awk --- access password file information\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# May 1993\line
\line
BEGIN \'7B\line
    # tailor this to suit your system\line
    _pw_awklib = "/usr/local/libexec/awk/"\line
\'7D\par
\pard\keep\li720{}}\line
{function _pw_init(    oldfs, oldrs, olddol0, pwcat)\line
\'7B\line
    if (_pw_inited)\line
        return\line
    oldfs = FS\line
    oldrs = RS\line
    olddol0 = $0\line
    FS = ":"\line
    RS = "\'5Cn"\line
    pwcat = _pw_awklib "pwcat"\line
    while ((pwcat | getline) > 0) \'7B\line
        _pw_byname[$1] = $0\line
        _pw_byuid[$3] = $0\line
        _pw_bycount[++_pw_total] = $0\line
    \'7D\line
    close(pwcat)\line
    _pw_count = 0\line
    _pw_inited = 1\line
    FS = oldfs\line
    RS = oldrs\line
    $0 = olddol0\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}The {\f1{}BEGIN} rule sets a private variable to the directory where {\f1{}pwcat} is stored.  Since it is used to help out an {\f1{}awk} library routine, we have chosen to put it in {\f1{}/usr/local/libexec/awk}.  You might want it to be in a different directory on your system.\par
\par
\pard{}The function {\f1{}_pw_init} keeps three copies of the user information in three associative arrays.  The arrays are indexed by user name ({\f1{}_pw_byname}), by user-id number ({\f1{}_pw_byuid}), and by order of occurrence ({\f1{}_pw_bycount}).\par
\par
\pard{}The variable {\f1{}_pw_inited} is used for efficiency; {\f1{}_pw_init} only needs to be called once.\par
\par
\pard{}Since this function uses {\f1{}getline} to read information from {\f1{}pwcat}, it first saves the values of {\f1{}FS}, {\f1{}RS}, and {\f1{}$0}.  Doing so is necessary, since these functions could be called from anywhere within a user's program, and the user may have his or her own values for {\f1{}FS} and {\f1{}RS}.\par
\par
\pard{}The main part of the function uses a loop to read database lines, split the line into fields, and then store the line into each array as necessary.  When the loop is done, {\f1{}_pw_init} cleans up by closing the pipeline, setting {\f1{}_pw_inited} to one, and restoring {\f1{}FS}, {\f1{}RS}, and {\f1{}$0}.  The use of {\f1{}_pw_count} will be explained below.\par
\par
\pard{}{K{\footnote K getpwnam}}{\par
{\pard\keep\li720\f1{}function getpwnam(name)\line
\'7B\line
    _pw_init()\line
    if (name in _pw_byname)\line
        return _pw_byname[name]\line
    return ""\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}The {\f1{}getpwnam} function takes a user name as a string argument. If that user is in the database, it returns the appropriate line. Otherwise it returns the null string.\par
\par
\pard{}{K{\footnote K getpwuid}}{\par
{\pard\keep\li720\f1{}function getpwuid(uid)\line
\'7B\line
    _pw_init()\line
    if (uid in _pw_byuid)\line
        return _pw_byuid[uid]\line
    return ""\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}Similarly, the {\f1{}getpwuid} function takes a user-id number argument. If that user number is in the database, it returns the appropriate line. Otherwise it returns the null string.\par
\par
\pard{}{K{\footnote K getpwent}}{\par
\pard\keep\li720\f1{}function getpwent()\line
\'7B\line
    _pw_init()\line
    if (_pw_count < _pw_total)\line
        return _pw_bycount[++_pw_count]\line
    return ""\line
\'7D\par
\pard\f0{}}\par
\pard{}The {\f1{}getpwent} function simply steps through the database, one entry at a time.  It uses {\f1{}_pw_count} to track its current position in the {\f1{}_pw_bycount} array.\par
\par
\pard{}{K{\footnote K endpwent}}{\par
\pard\keep\li720\f1{}function endpwent()\line
\'7B\line
    _pw_count = 0\line
\'7D\par
\pard\f0{}}\par
\pard{}The {\f1{}endpwent} function resets {\f1{}_pw_count} to zero, so that subsequent calls to {\f1{}getpwent} will start over again.\par
\par
\pard{}A conscious design decision in this suite is that each subroutine calls {\f1{}_pw_init} to initialize the database arrays.  The overhead of running a separate process to generate the user database, and the I/O to scan it, will only be incurred if the user's main program actually calls one of these functions.  If this library file is loaded along with a user's program, but none of the routines are ever called, then there is no extra run-time overhead.  (The alternative would be to move the body of {\f1{}_pw_init} into a {\f1{}BEGIN} rule, which would always run {\f1{}pwcat}.  This simplifies the code but runs an extra process that may never be needed.)\par
\par
\pard{}In turn, calling {\f1{}_pw_init} is not too expensive, since the {\f1{}_pw_inited} variable keeps the program from reading the data more than once.  If you are worried about squeezing every last cycle out of your {\f1{}awk} program, the check of {\f1{}_pw_inited} could be moved out of {\f1{}_pw_init} and duplicated in all the other functions.  In practice, this is not necessary, since most {\f1{}awk} programs are I/O bound, and it would clutter up the code.\par
\par
\pard{}The {\f1{}id} program in {\uldb Printing Out User Information}{\v Id_Program}, uses these functions.\par
\par
\page\pard Node: {\b Group Functions}, \keepn Next: {\uldb Library Names}{\v Library_Names}, Prev: {\uldb Passwd Functions}{\v Passwd_Functions}, Up: {\uldb Library Functions}{\v Library_Functions}\line
K{\footnote K Group Functions}
#{\footnote Group_Functions}
${\footnote \pard{}Reading the Group Database}\par
\pard{\fs24\b Reading the Group Database}\par
\par
\pard{}{K{\footnote K {\f1{}getgrent}, C version}}{K{\footnote K group information}}{K{\footnote K account information}}{K{\footnote K group file}}Much of the discussion presented in {\uldb Reading the User Database}{\v Passwd_Functions}, applies to the group database as well.  Although there has traditionally been a well known file, {\f1{}/etc/group}, in a well known format, the POSIX standard only provides a set of C library routines ({\f1{}<grp.h>} and {\f1{}getgrent}) for accessing the information.  Even though this file may exist, it likely does not have complete information.  Therefore, as with the user database, it is necessary to have a small C program that generates the group database as its output.\par
\par
\pard{}{K{\footnote K {\f1{}grcat} program}}Here is {\f1{}grcat}, a C program that "cats" the group database.\par
\par
\pard{}{K{\footnote K grcat.c}}{\par
\pard\keep\li720\f1{}/*\line
 * grcat.c\line
 *\line
 * Generate a printable version of the group database\line
 *\line
 * Arnold Robbins, arnold@gnu.org\line
 * May 1993\line
 * Public Domain\line
 */\line
\line
#include <stdio.h>\line
#include <grp.h>\line
\line
{int\line
main(argc, argv)\line
int argc;\line
char **argv;\line
\'7B\line
    struct group *g;\line
    int i;\par
\pard\keep\li720{}}\line
    while ((g = getgrent()) != NULL) \'7B\line
        printf("%s:%s:%d:", g->gr_name, g->gr_passwd,\line
                                            g->gr_gid);\line
        for (i = 0; g->gr_mem[i] != NULL; i++) \'7B\line
            printf("%s", g->gr_mem[i]);\line
            if (g->gr_mem[i+1] != NULL)\line
                putchar(',');\line
        \'7D\line
        putchar('\'5Cn');\line
    \'7D\line
    endgrent();\line
    exit(0);\line
\'7D\par
\pard\f0{}}\par
\pard{}Each line in the group database represent one group.  The fields are separated with colons, and represent the following information.\par
\par
{\pard{}Group Name\par
\pard\li720{}The name of the group.\par
\par
\pard{}Group Password\par
\pard\li720{}The encrypted group password. In practice, this field is never used. It is usually empty, or set to {\f1{}*}.\par
\par
\pard{}Group ID Number\par
\pard\li720{}The numeric group-id number. This number should be unique within the file.\par
\par
\pard{}Group Member List\par
\pard\li720{}A comma-separated list of user names.  These users are members of the group.  Most Unix systems allow users to be members of several groups simultaneously.  If your system does, then reading {\f1{}/dev/user} will return those group-id numbers in {\f1{}$5} through {\f1{}$NF}.  (Note that {\f1{}/dev/user} is a {\f1{}gawk} extension; see {\uldb Special File Names in {\f1{}gawk}}{\v Special_Files}.)\par
\pard{}}\par
\pard{}Here is what running {\f1{}grcat} might produce:\par
\par
{{\pard\keep\li720\f1{}$ grcat\line
-| wheel:*:0:arnold\line
-| nogroup:*:65534:\line
-| daemon:*:1:\line
-| kmem:*:2:\line
-| staff:*:10:arnold,miriam,andy\line
-| other:*:20:\line
...\par
\pard\keep\li720{}}}\par
\pard\f0{}Here are the functions for obtaining information from the group database.  There are several, modeled after the C library functions of the same names.\par
\par
\pard{}{K{\footnote K _gr_init}}{\par
{\pard\keep\li720\f1{}# group.awk --- functions for dealing with the group file\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# May 1993\line
\line
BEGIN    \'5C\line
\'7B\line
    # Change to suit your system\line
    _gr_awklib = "/usr/local/libexec/awk/"\line
\'7D\par
\pard\keep\li720{}}\line
{function _gr_init(    oldfs, oldrs, olddol0, grcat, n, a, i)\line
\'7B\line
    if (_gr_inited)\line
        return\par
\pard\keep\li720{}}\line
{    oldfs = FS\line
    oldrs = RS\line
    olddol0 = $0\line
    FS = ":"\line
    RS = "\'5Cn"\par
\pard\keep\li720{}}\line
{    grcat = _gr_awklib "grcat"\line
    while ((grcat | getline) > 0) \'7B\line
        if ($1 in _gr_byname)\line
            _gr_byname[$1] = _gr_byname[$1] "," $4\line
        else\line
            _gr_byname[$1] = $0\line
        if ($3 in _gr_bygid)\line
            _gr_bygid[$3] = _gr_bygid[$3] "," $4\line
        else\line
            _gr_bygid[$3] = $0\line
\line
        n = split($4, a, "[ \'5Ct]*,[ \'5Ct]*")\par
\pard\keep\li720{}}{        for (i = 1; i <= n; i++)\line
            if (a[i] in _gr_groupsbyuser)\line
                _gr_groupsbyuser[a[i]] = \'5C\line
                    _gr_groupsbyuser[a[i]] " " $1\line
            else\line
                _gr_groupsbyuser[a[i]] = $1\par
\pard\keep\li720{}}\line
{        _gr_bycount[++_gr_count] = $0\line
    \'7D\par
\pard\keep\li720{}}{    close(grcat)\line
    _gr_count = 0\line
    _gr_inited++\line
    FS = oldfs\line
    RS = oldrs\line
    $0 = olddol0\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}The {\f1{}BEGIN} rule sets a private variable to the directory where {\f1{}grcat} is stored.  Since it is used to help out an {\f1{}awk} library routine, we have chosen to put it in {\f1{}/usr/local/libexec/awk}.  You might want it to be in a different directory on your system.\par
\par
\pard{}These routines follow the same general outline as the user database routines (see {\uldb Reading the User Database}{\v Passwd_Functions}).  The {\f1{}_gr_inited} variable is used to ensure that the database is scanned no more than once.  The {\f1{}_gr_init} function first saves {\f1{}FS}, {\f1{}RS}, and {\f1{}$0}, and then sets {\f1{}FS} and {\f1{}RS} to the correct values for scanning the group information.\par
\par
\pard{}The group information is stored is several associative arrays.  The arrays are indexed by group name ({\f1{}_gr_byname}), by group-id number ({\f1{}_gr_bygid}), and by position in the database ({\f1{}_gr_bycount}).  There is an additional array indexed by user name ({\f1{}_gr_groupsbyuser}), that is a space separated list of groups that each user belongs to.\par
\par
\pard{}Unlike the user database, it is possible to have multiple records in the database for the same group.  This is common when a group has a large number of members.  Such a pair of entries might look like:\par
\par
{\pard\keep\li720\f1{}tvpeople:*:101:johny,jay,arsenio\line
tvpeople:*:101:david,conan,tom,joan\par
\pard\f0{}}\par
\pard{}For this reason, {\f1{}_gr_init} looks to see if a group name or group-id number has already been seen.  If it has, then the user names are simply concatenated onto the previous list of users.  (There is actually a subtle problem with the code presented above.  Suppose that the first time there were no names. This code adds the names with a leading comma. It also doesn't check that there is a {\f1{}$4}.)\par
\par
\pard{}Finally, {\f1{}_gr_init} closes the pipeline to {\f1{}grcat}, restores {\f1{}FS}, {\f1{}RS}, and {\f1{}$0}, initializes {\f1{}_gr_count} to zero (it is used later), and makes {\f1{}_gr_inited} non-zero.\par
\par
\pard{}{K{\footnote K getgrnam}}{\par
\pard\keep\li720\f1{}function getgrnam(group)\line
\'7B\line
    _gr_init()\line
    if (group in _gr_byname)\line
        return _gr_byname[group]\line
    return ""\line
\'7D\par
\pard\f0{}}\par
\pard{}The {\f1{}getgrnam} function takes a group name as its argument, and if that group exists, it is returned. Otherwise, {\f1{}getgrnam} returns the null string.\par
\par
\pard{}{K{\footnote K getgrgid}}{\par
\pard\keep\li720\f1{}function getgrgid(gid)\line
\'7B\line
    _gr_init()\line
    if (gid in _gr_bygid)\line
        return _gr_bygid[gid]\line
    return ""\line
\'7D\par
\pard\f0{}}\par
\pard{}The {\f1{}getgrgid} function is similar, it takes a numeric group-id, and looks up the information associated with that group-id.\par
\par
\pard{}{K{\footnote K getgruser}}{\par
{\pard\keep\li720\f1{}function getgruser(user)\line
\'7B\line
    _gr_init()\line
    if (user in _gr_groupsbyuser)\line
        return _gr_groupsbyuser[user]\line
    return ""\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}The {\f1{}getgruser} function does not have a C counterpart. It takes a user name, and returns the list of groups that have the user as a member.\par
\par
\pard{}{K{\footnote K getgrent}}{\par
\pard\keep\li720\f1{}function getgrent()\line
\'7B\line
    _gr_init()\line
    if (++_gr_count in _gr_bycount)\line
        return _gr_bycount[_gr_count]\line
    return ""\line
\'7D\par
\pard\f0{}}\par
\pard{}The {\f1{}getgrent} function steps through the database one entry at a time.  It uses {\f1{}_gr_count} to track its position in the list.\par
\par
\pard{}{K{\footnote K endgrent}}{\par
{\pard\keep\li720\f1{}function endgrent()\line
\'7B\line
    _gr_count = 0\line
\'7D\par
\pard\keep\li720{}}}\par
{\f1{}\pard\f0{}endgrent} resets {\f1{}_gr_count} to zero so that {\f1{}getgrent} can start over again.\par
\par
\pard{}As with the user database routines, each function calls {\f1{}_gr_init} to initialize the arrays.  Doing so only incurs the extra overhead of running {\f1{}grcat} if these functions are used (as opposed to moving the body of {\f1{}_gr_init} into a {\f1{}BEGIN} rule).\par
\par
\pard{}Most of the work is in scanning the database and building the various associative arrays.  The functions that the user calls are themselves very simple, relying on {\f1{}awk}'s associative arrays to do work.\par
\par
\pard{}The {\f1{}id} program in {\uldb Printing Out User Information}{\v Id_Program}, uses these functions.\par
\par
\page\pard Node: {\b Library Names}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Group Functions}{\v Group_Functions}, Up: {\uldb Library Functions}{\v Library_Functions}\line
K{\footnote K Library Names}
#{\footnote Library_Names}
${\footnote \pard{}Naming Library Function Global Variables}\par
\pard{\fs24\b Naming Library Function Global Variables}\par
\par
\pard{}{K{\footnote K namespace issues in {\f1{}awk}}}{K{\footnote K documenting {\f1{}awk} programs}}{K{\footnote K programs, documenting}}Due to the way the {\f1{}awk} language evolved, variables are either \'A2global\'A2 (usable by the entire program), or \'A2local\'A2 (usable just by a specific function).  There is no intermediate state analogous to {\f1{}static} variables in C.\par
\par
\pard{}Library functions often need to have global variables that they can use to preserve state information between calls to the function. For example, {\f1{}getopt}'s variable {\f1{}_opti} (see {\uldb Processing Command Line Options}{\v Getopt_Function}), and the {\f1{}_tm_months} array used by {\f1{}mktime} (see {\uldb Turning Dates Into Timestamps}{\v Mktime_Function}).  Such variables are called \'A2private\'A2, since the only functions that need to use them are the ones in the library.\par
\par
\pard{}When writing a library function, you should try to choose names for your private variables so that they will not conflict with any variables used by either another library function or a user's main program.  For example, a name like {\f1{}i} or {\f1{}j} is not a good choice, since user programs often use variable names like these for their own purposes.\par
\par
\pard{}The example programs shown in this chapter all start the names of their private variables with an underscore ({\f1{}_}).  Users generally don't use leading underscores in their variable names, so this convention immediately decreases the chances that the variable name will be accidentally shared with the user's program.\par
\par
\pard{}In addition, several of the library functions use a prefix that helps indicate what function or set of functions uses the variables. For example, {\f1{}_tm_months} in {\f1{}mktime} (see {\uldb Turning Dates Into Timestamps}{\v Mktime_Function}), and {\f1{}_pw_byname} in the user data base routines (see {\uldb Reading the User Database}{\v Passwd_Functions}).  This convention is recommended, since it even further decreases the chance of inadvertent conflict among variable names.  Note that this convention can be used equally well both for variable names and for private function names too.\par
\par
\pard{}While I could have re-written all the library routines to use this convention, I did not do so, in order to show how my own {\f1{}awk} programming style has evolved, and to provide some basis for this discussion.\par
\par
\pard{}As a final note on variable naming, if a function makes global variables available for use by a main program, it is a good convention to start that variable's name with a capital letter.  For example, {\f1{}getopt}'s {\f1{}Opterr} and {\f1{}Optind} variables (see {\uldb Processing Command Line Options}{\v Getopt_Function}).  The leading capital letter indicates that it is global, while the fact that the variable name is not all capital letters indicates that the variable is not one of {\f1{}awk}'s built-in variables, like {\f1{}FS}.\par
\par
\pard{}It is also important that {\i all} variables in library functions that do not need to save state are in fact declared local.  If this is not done, the variable could accidentally be used in the user's program, leading to bugs that are very difficult to track down.\par
\par
{\pard\keep\li720\f1{}function lib_func(x, y,    l1, l2)\line
\'7B\line
    ...\line
    {\i use variable} some_var  # some_var could be local\line
    ...                   # but is not by oversight\line
\'7D\par
\pard\f0{}}\par
\pard{}{K{\footnote K Tcl}}A different convention, common in the Tcl community, is to use a single associative array to hold the values needed by the library function(s), or "package."  This significantly decreases the number of actual global names in use.  For example, the functions described in {\uldb Reading the User Database}{\v Passwd_Functions}, might have used {\f1{}PW_data["inited"]}, {\f1{}PW_data["total"]}, {\f1{}PW_data["count"]} and {\f1{}PW_data["awklib"]}, instead of {\f1{}_pw_inited}, {\f1{}_pw_awklib}, {\f1{}_pw_total}, and {\f1{}_pw_count}.\par
\par
\pard{}The conventions presented in this section are exactly that, conventions. You are not required to write your programs this way, we merely recommend that you do so.\par
\par
\page\pard Node: {\b Sample Programs}, \keepn Next: {\uldb Language History}{\v Language_History}, Prev: {\uldb Library Functions}{\v Library_Functions}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Sample Programs}
#{\footnote Sample_Programs}
${\footnote \pard{}Practical {\f1{}awk} Programs}\par
\pard{\fs24\b Practical {\f1{}awk} Programs}\par
\par
\pard{}This chapter presents a potpourri of {\f1{}awk} programs for your reading enjoyment.\par
\par
\pard{}Many of these programs use the library functions presented in {\uldb A Library of {\f1{}awk} Functions}{\v Library_Functions}.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Clones}{\v Clones}\tab Clones of common utilities.\par
{\uldb Miscellaneous Programs}{\v Miscellaneous_Programs}\tab Some interesting {\f1{}awk} programs.\par
\pard{}}\par
\page\pard Node: {\b Clones}, \keepn Next: {\uldb Miscellaneous Programs}{\v Miscellaneous_Programs}, Prev: {\uldb Sample Programs}{\v Sample_Programs}, Up: {\uldb Sample Programs}{\v Sample_Programs}\line
K{\footnote K Clones}
#{\footnote Clones}
${\footnote \pard{}Re-inventing Wheels for Fun and Profit}\par
\pard{\fs24\b Re-inventing Wheels for Fun and Profit}\par
\par
\pard{}This section presents a number of POSIX utilities that are implemented in {\f1{}awk}.  Re-inventing these programs in {\f1{}awk} is often enjoyable, since the algorithms can be very clearly expressed, and usually the code is very concise and simple.  This is true because {\f1{}awk} does so much for you.\par
\par
\pard{}It should be noted that these programs are not necessarily intended to replace the installed versions on your system.  Instead, their purpose is to illustrate {\f1{}awk} language programming for "real world" tasks.\par
\par
\pard{}The programs are presented in alphabetical order.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Cut Program}{\v Cut_Program}\tab The {\f1{}cut} utility.\par
{\uldb Egrep Program}{\v Egrep_Program}\tab The {\f1{}egrep} utility.\par
{\uldb Id Program}{\v Id_Program}\tab The {\f1{}id} utility.\par
{\uldb Split Program}{\v Split_Program}\tab The {\f1{}split} utility.\par
{\uldb Tee Program}{\v Tee_Program}\tab The {\f1{}tee} utility.\par
{\uldb Uniq Program}{\v Uniq_Program}\tab The {\f1{}uniq} utility.\par
{\uldb Wc Program}{\v Wc_Program}\tab The {\f1{}wc} utility.\par
\pard{}}\par
\page\pard Node: {\b Cut Program}, \keepn Next: {\uldb Egrep Program}{\v Egrep_Program}, Prev: {\uldb Clones}{\v Clones}, Up: {\uldb Clones}{\v Clones}\line
K{\footnote K Cut Program}
#{\footnote Cut_Program}
${\footnote \pard{}Cutting Out Fields and Columns}\par
\pard{\fs24\b Cutting Out Fields and Columns}\par
\par
\pard{}{K{\footnote K {\f1{}cut} utility}}The {\f1{}cut} utility selects, or "cuts," either characters or fields from its standard input and sends them to its standard output.  {\f1{}cut} can cut out either a list of characters, or a list of fields.  By default, fields are separated by tabs, but you may supply a command line option to change the field \'A2delimiter\'A2, i.e. the field separator character. {\f1{}cut}'s definition of fields is less general than {\f1{}awk}'s.\par
\par
\pard{}A common use of {\f1{}cut} might be to pull out just the login name of logged-on users from the output of {\f1{}who}.  For example, the following pipeline generates a sorted, unique list of the logged on users:\par
\par
{\pard\keep\li720\f1{}who | cut -c1-8 | sort | uniq\par
\pard\f0{}}\par
\pard{}The options for {\f1{}cut} are:\par
\par
{\pard{}{\f1{}-c {\i list}}\par
\pard\li720{}Use {\i list} as the list of characters to cut out.  Items within the list may be separated by commas, and ranges of characters can be separated with dashes.  The list {\f1{}1-8,15,22-35} specifies characters one through eight, 15, and 22 through 35.\par
\par
\pard{}{\f1{}-f {\i list}}\par
\pard\li720{}Use {\i list} as the list of fields to cut out.\par
\par
\pard{}{\f1{}-d {\i delim}}\par
\pard\li720{}Use {\i delim} as the field separator character instead of the tab character.\par
\par
\pard{}{\f1{}-s}\par
\pard\li720{}Suppress printing of lines that do not contain the field delimiter.\par
\pard{}}\par
\pard{}The {\f1{}awk} implementation of {\f1{}cut} uses the {\f1{}getopt} library function (see {\uldb Processing Command Line Options}{\v Getopt_Function}), and the {\f1{}join} library function (see {\uldb Merging an Array Into a String}{\v Join_Function}).\par
\par
\pard{}The program begins with a comment describing the options and a {\f1{}usage} function which prints out a usage message and exits.  {\f1{}usage} is called if invalid arguments are supplied.\par
\par
\pard{}{K{\footnote K cut.awk}}{\par
\pard\keep\li720\f1{}# cut.awk --- implement cut in awk\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# May 1993\line
\line
# Options:\line
#    -f list        Cut fields\line
#    -d c           Field delimiter character\line
#    -c list        Cut characters\line
#\line
#    -s        Suppress lines without the delimiter character\line
\line
function usage(    e1, e2)\line
\'7B\line
    e1 = "usage: cut [-f list] [-d c] [-s] [files...]"\line
    e2 = "usage: cut [-c list] [files...]"\line
    print e1 > "/dev/stderr"\line
    print e2 > "/dev/stderr"\line
    exit 1\line
\'7D\par
\pard\f0{}}\par
\pard{}The variables {\f1{}e1} and {\f1{}e2} are used so that the function fits nicely on the {screen.  }\par
\par
\pard{}Next comes a {\f1{}BEGIN} rule that parses the command line options.  It sets {\f1{}FS} to a single tab character, since that is {\f1{}cut}'s default field separator.  The output field separator is also set to be the same as the input field separator.  Then {\f1{}getopt} is used to step through the command line options.  One or the other of the variables {\f1{}by_fields} or {\f1{}by_chars} is set to true, to indicate that processing should be done by fields or by characters respectively.  When cutting by characters, the output field separator is set to the null string.\par
\par
{\pard\keep\li720\f1{}BEGIN    \'5C\line
\'7B\line
    FS = "\'5Ct"    # default\line
    OFS = FS\line
    while ((c = getopt(ARGC, ARGV, "sf:c:d:")) != -1) \'7B\line
        if (c == "f") \'7B\line
            by_fields = 1\line
            fieldlist = Optarg\line
{        \'7D else if (c == "c") \'7B\line
            by_chars = 1\line
            fieldlist = Optarg\line
            OFS = ""\line
        \'7D else if (c == "d") \'7B\line
            if (length(Optarg) > 1) \'7B\line
                printf("Using first character of %s" \'5C\line
                " for delimiter\'5Cn", Optarg) > "/dev/stderr"\line
                Optarg = substr(Optarg, 1, 1)\line
            \'7D\line
            FS = Optarg\line
            OFS = FS\line
            if (FS == " ")    # defeat awk semantics\line
                FS = "[ ]"\line
        \'7D else if (c == "s")\line
            suppress++\line
        else\line
            usage()\line
    \'7D\par
\pard\keep\li720{}}\line
    for (i = 1; i < Optind; i++)\line
        ARGV[i] = ""\par
\pard\f0{}}\par
\pard{}Special care is taken when the field delimiter is a space. Using {\f1{}" "} (a single space) for the value of {\f1{}FS} is incorrect--{\f1{}awk} would separate fields with runs of spaces, tabs and/or newlines, and we want them to be separated with individual spaces.  Also, note that after {\f1{}getopt} is through, we have to clear out all the elements of {\f1{}ARGV} from one to {\f1{}Optind}, so that {\f1{}awk} will not try to process the command line options as file names.\par
\par
\pard{}After dealing with the command line options, the program verifies that the options make sense.  Only one or the other of {\f1{}-c} and {\f1{}-f} should be used, and both require a field list.  Then either {\f1{}set_fieldlist} or {\f1{}set_charlist} is called to pull apart the list of fields or characters.\par
\par
{\pard\keep\li720\f1{}    if (by_fields && by_chars)\line
        usage()\line
\line
    if (by_fields == 0 && by_chars == 0)\line
        by_fields = 1    # default\line
\line
    if (fieldlist == "") \'7B\line
        print "cut: needs list for -c or -f" > "/dev/stderr"\line
        exit 1\line
    \'7D\line
\line
{    if (by_fields)\line
        set_fieldlist()\line
    else\line
        set_charlist()\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}Here is {\f1{}set_fieldlist}.  It first splits the field list apart at the commas, into an array.  Then, for each element of the array, it looks to see if it is actually a range, and if so splits it apart. The range is verified to make sure the first number is smaller than the second.  Each number in the list is added to the {\f1{}flist} array, which simply lists the fields that will be printed.  Normal field splitting is used.  The program lets {\f1{}awk} handle the job of doing the field splitting.\par
\par
{\pard\keep\li720\f1{}function set_fieldlist(        n, m, i, j, k, f, g)\line
\'7B\line
    n = split(fieldlist, f, ",")\line
    j = 1    # index in flist\line
    for (i = 1; i <= n; i++) \'7B\line
        if (index(f[i], "-") != 0) \'7B # a range\line
            m = split(f[i], g, "-")\line
            if (m != 2 || g[1] >= g[2]) \'7B\line
                printf("bad field list: %s\'5Cn",\line
                                  f[i]) > "/dev/stderr"\line
                exit 1\line
            \'7D\line
            for (k = g[1]; k <= g[2]; k++)\line
                flist[j++] = k\line
        \'7D else\line
            flist[j++] = f[i]\line
    \'7D\line
    nfields = j - 1\line
\'7D\par
\pard\f0{}}\par
\pard{}The {\f1{}set_charlist} function is more complicated than {\f1{}set_fieldlist}.  The idea here is to use {\f1{}gawk}'s {\f1{}FIELDWIDTHS} variable (see {\uldb Reading Fixed-width Data}{\v Constant_Size}), which describes constant width input.  When using a character list, that is exactly what we have.\par
\par
\pard{}Setting up {\f1{}FIELDWIDTHS} is more complicated than simply listing the fields that need to be printed.  We have to keep track of the fields to be printed, and also the intervening characters that have to be skipped.  For example, suppose you wanted characters one through eight, 15, and 22 through 35.  You would use {\f1{}-c 1-8,15,22-35}.  The necessary value for {\f1{}FIELDWIDTHS} would be {\f1{}"8 6 1 6 14"}.  This gives us five fields, and what should be printed are {\f1{}$1}, {\f1{}$3}, and {\f1{}$5}.  The intermediate fields are "filler," stuff in between the desired data.\par
\par
{\f1{}\pard{}flist} lists the fields to be printed, and {\f1{}t} tracks the complete field list, including filler fields.\par
\par
{\pard\keep\li720\f1{}function set_charlist(    field, i, j, f, g, t,\line
                          filler, last, len)\line
\'7B\line
    field = 1   # count total fields\line
    n = split(fieldlist, f, ",")\line
    j = 1       # index in flist\line
    for (i = 1; i <= n; i++) \'7B\line
        if (index(f[i], "-") != 0) \'7B # range\line
            m = split(f[i], g, "-")\line
            if (m != 2 || g[1] >= g[2]) \'7B\line
                printf("bad character list: %s\'5Cn",\line
                               f[i]) > "/dev/stderr"\line
                exit 1\line
            \'7D\line
            len = g[2] - g[1] + 1\line
            if (g[1] > 1)  # compute length of filler\line
                filler = g[1] - last - 1\line
            else\line
                filler = 0\line
            if (filler)\line
                t[field++] = filler\line
            t[field++] = len  # length of field\line
            last = g[2]\line
            flist[j++] = field - 1\line
        \'7D else \'7B\line
            if (f[i] > 1)\line
                filler = f[i] - last - 1\line
            else\line
                filler = 0\line
            if (filler)\line
                t[field++] = filler\line
            t[field++] = 1\line
            last = f[i]\line
            flist[j++] = field - 1\line
        \'7D\line
    \'7D\line
{    FIELDWIDTHS = join(t, 1, field - 1)\line
    nfields = j - 1\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}Here is the rule that actually processes the data.  If the {\f1{}-s} option was given, then {\f1{}suppress} will be true.  The first {\f1{}if} statement makes sure that the input record does have the field separator.  If {\f1{}cut} is processing fields, {\f1{}suppress} is true, and the field separator character is not in the record, then the record is skipped.\par
\par
\pard{}If the record is valid, then at this point, {\f1{}gawk} has split the data into fields, either using the character in {\f1{}FS} or using fixed-length fields and {\f1{}FIELDWIDTHS}.  The loop goes through the list of fields that should be printed.  If the corresponding field has data in it, it is printed.  If the next field also has data, then the separator character is written out in between the fields.\par
\par
{\pard\keep\li720\f1{}\'7B\line
    if (by_fields && suppress && $0 !~ FS)\line
        next\line
\line
    for (i = 1; i <= nfields; i++) \'7B\line
        if ($flist[i] != "") \'7B\line
            printf "%s", $flist[i]\line
            if (i < nfields && $flist[i+1] != "")\line
                printf "%s", OFS\line
        \'7D\line
    \'7D\line
    print ""\line
\'7D\par
\pard\f0{}}\par
\pard{}This version of {\f1{}cut} relies on {\f1{}gawk}'s {\f1{}FIELDWIDTHS} variable to do the character-based cutting.  While it would be possible in other {\f1{}awk} implementations to use {\f1{}substr} (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}), it would also be extremely painful to do so.  The {\f1{}FIELDWIDTHS} variable supplies an elegant solution to the problem of picking the input line apart by characters.\par
\par
\page\pard Node: {\b Egrep Program}, \keepn Next: {\uldb Id Program}{\v Id_Program}, Prev: {\uldb Cut Program}{\v Cut_Program}, Up: {\uldb Clones}{\v Clones}\line
K{\footnote K Egrep Program}
#{\footnote Egrep_Program}
${\footnote \pard{}Searching for Regular Expressions in Files}\par
\pard{\fs24\b Searching for Regular Expressions in Files}\par
\par
\pard{}{K{\footnote K {\f1{}egrep} utility}}The {\f1{}egrep} utility searches files for patterns.  It uses regular expressions that are almost identical to those available in {\f1{}awk} (see {\uldb Regular Expression Constants}{\v Regexp_Constants}).  It is used this way:\par
\par
{\pard\keep\li720\f1{}egrep [ {\i options} ] '{\i pattern}' {\i files} ...\par
\pard\f0{}}\par
\pard{}The {\i pattern} is a regexp.  In typical usage, the regexp is quoted to prevent the shell from expanding any of the special characters as file name wildcards.  Normally, {\f1{}egrep} prints the lines that matched.  If multiple file names are provided on the command line, each output line is preceded by the name of the file and a colon.\par
\par
\pard{}The options are:\par
\par
{\pard{}{\f1{}-c}\par
\pard\li720{}Print out a count of the lines that matched the pattern, instead of the lines themselves.\par
\par
\pard{}{\f1{}-s}\par
\pard\li720{}Be silent.  No output is produced, and the exit value indicates whether or not the pattern was matched.\par
\par
\pard{}{\f1{}-v}\par
\pard\li720{}Invert the sense of the test. {\f1{}egrep} prints the lines that do {\i not} match the pattern, and exits successfully if the pattern was not matched.\par
\par
\pard{}{\f1{}-i}\par
\pard\li720{}Ignore case distinctions in both the pattern and the input data.\par
\par
\pard{}{\f1{}-l}\par
\pard\li720{}Only print the names of the files that matched, not the lines that matched.\par
\par
\pard{}{\f1{}-e {\i pattern}}\par
\pard\li720{}Use {\i pattern} as the regexp to match.  The purpose of the {\f1{}-e} option is to allow patterns that start with a {\f1{}-}.\par
\pard{}}\par
\pard{}This version uses the {\f1{}getopt} library function (see {\uldb Processing Command Line Options}{\v Getopt_Function}), and the file transition library program (see {\uldb Noting Data File Boundaries}{\v Filetrans_Function}).\par
\par
\pard{}The program begins with a descriptive comment, and then a {\f1{}BEGIN} rule that processes the command line arguments with {\f1{}getopt}.  The {\f1{}-i} (ignore case) option is particularly easy with {\f1{}gawk}; we just use the {\f1{}IGNORECASE} built in variable (see {\uldb Built-in Variables}{\v Built_in_Variables}).\par
\par
\pard{}{K{\footnote K egrep.awk}}{\par
\pard\keep\li720\f1{}# egrep.awk --- simulate egrep in awk\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# May 1993\line
\line
# Options:\line
#    -c    count of lines\line
#    -s    silent - use exit value\line
#    -v    invert test, success if no match\line
#    -i    ignore case\line
#    -l    print filenames only\line
#    -e    argument is pattern\line
\line
BEGIN \'7B\line
    while ((c = getopt(ARGC, ARGV, "ce:svil")) != -1) \'7B\line
        if (c == "c")\line
            count_only++\line
        else if (c == "s")\line
            no_print++\line
        else if (c == "v")\line
            invert++\line
        else if (c == "i")\line
            IGNORECASE = 1\line
        else if (c == "l")\line
            filenames_only++\line
        else if (c == "e")\line
            pattern = Optarg\line
        else\line
            usage()\line
    \'7D\par
\pard\f0{}}\par
\pard{}Next comes the code that handles the {\f1{}egrep} specific behavior. If no pattern was supplied with {\f1{}-e}, the first non-option on the command line is used.  The {\f1{}awk} command line arguments up to {\f1{}ARGV[Optind]} are cleared, so that {\f1{}awk} won't try to process them as files.  If no files were specified, the standard input is used, and if multiple files were specified, we make sure to note this so that the file names can precede the matched lines in the output.\par
\par
\pard{}The last two lines are commented out, since they are not needed in {\f1{}gawk}.  They should be uncommented if you have to use another version of {\f1{}awk}.\par
\par
{\pard\keep\li720\f1{}    if (pattern == "")\line
        pattern = ARGV[Optind++]\line
\line
    for (i = 1; i < Optind; i++)\line
        ARGV[i] = ""\line
    if (Optind >= ARGC) \'7B\line
        ARGV[1] = "-"\line
        ARGC = 2\line
    \'7D else if (ARGC - Optind > 1)\line
        do_filenames++\line
\line
#    if (IGNORECASE)\line
#        pattern = tolower(pattern)\line
\'7D\par
\pard\f0{}}\par
\pard{}The next set of lines should be uncommented if you are not using {\f1{}gawk}.  This rule translates all the characters in the input line into lower-case if the {\f1{}-i} option was specified.  The rule is commented out since it is not necessary with {\f1{}gawk}.\par
\par
{\pard\keep\li720\f1{}#\'7B\line
#    if (IGNORECASE)\line
#        $0 = tolower($0)\line
#\'7D\par
\pard\f0{}}\par
\pard{}The {\f1{}beginfile} function is called by the rule in {\f1{}ftrans.awk} when each new file is processed.  In this case, it is very simple; all it does is initialize a variable {\f1{}fcount} to zero. {\f1{}fcount} tracks how many lines in the current file matched the pattern.\par
\par
{{\pard\keep\li720\f1{}function beginfile(junk)\line
\'7B\line
    fcount = 0\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}The {\f1{}endfile} function is called after each file has been processed.  It is used only when the user wants a count of the number of lines that matched.  {\f1{}no_print} will be true only if the exit status is desired.  {\f1{}count_only} will be true if line counts are desired.  {\f1{}egrep} will therefore only print line counts if printing and counting are enabled.  The output format must be adjusted depending upon the number of files to be processed.  Finally, {\f1{}fcount} is added to {\f1{}total}, so that we know how many lines altogether matched the pattern.\par
\par
{\pard\keep\li720\f1{}function endfile(file)\line
\'7B\line
    if (! no_print && count_only)\line
        if (do_filenames)\line
            print file ":" fcount\line
        else\line
            print fcount\line
\line
    total += fcount\line
\'7D\par
\pard\f0{}}\par
\pard{}This rule does most of the work of matching lines. The variable {\f1{}matches} will be true if the line matched the pattern. If the user wants lines that did not match, the sense of the {\f1{}matches} is inverted using the {\f1{}!} operator. {\f1{}fcount} is incremented with the value of {\f1{}matches}, which will be either one or zero, depending upon a successful or unsuccessful match.  If the line did not match, the {\f1{}next} statement just moves on to the next record.\par
\par
\pard{}There are several optimizations for performance in the following few lines of code. If the user only wants exit status ({\f1{}no_print} is true), and we don't have to count lines, then it is enough to know that one line in this file matched, and we can skip on to the next file with {\f1{}nextfile}.  Along similar lines, if we are only printing file names, and we don't need to count lines, we can print the file name, and then skip to the next file with {\f1{}nextfile}.\par
\par
\pard{}Finally, each line is printed, with a leading filename and colon if necessary.\par
\par
{\pard\keep\li720\f1{}\'7B\line
    matches = ($0 ~ pattern)\line
    if (invert)\line
        matches = ! matches\line
\line
    fcount += matches    # 1 or 0\line
\line
{    if (! matches)\line
        next\par
\pard\keep\li720{}}\line
    if (no_print && ! count_only)\line
        nextfile\line
\line
    if (filenames_only && ! count_only) \'7B\line
        print FILENAME\line
        nextfile\line
    \'7D\line
\line
    if (do_filenames && ! count_only)\line
        print FILENAME ":" $0\line
    else if (! count_only)\line
        print\line
\'7D\par
\pard\f0{}}\par
\pard{}The {\f1{}END} rule takes care of producing the correct exit status. If there were no matches, the exit status is one, otherwise it is zero.\par
\par
{\pard\keep\li720\f1{}END    \'5C\line
\'7B\line
    if (total == 0)\line
        exit 1\line
    exit 0\line
\'7D\par
\pard\f0{}}\par
\pard{}The {\f1{}usage} function prints a usage message in case of invalid options and then exits.\par
\par
{\pard\keep\li720\f1{}function usage(    e)\line
\'7B\line
    e = "Usage: egrep [-csvil] [-e pat] [files ...]"\line
    print e > "/dev/stderr"\line
    exit 1\line
\'7D\par
\pard\f0{}}\par
\pard{}The variable {\f1{}e} is used so that the function fits nicely on the printed page.\par
\par
\pard{}{K{\footnote K backslash continuation}}Just a note on programming style. You may have noticed that the {\f1{}END} rule uses backslash continuation, with the open brace on a line by itself.  This is so that it more closely resembles the way functions are written.  Many of the examples use this style. You can decide for yourself if you like writing your {\f1{}BEGIN} and {\f1{}END} rules this way, or not.\par
\par
\page\pard Node: {\b Id Program}, \keepn Next: {\uldb Split Program}{\v Split_Program}, Prev: {\uldb Egrep Program}{\v Egrep_Program}, Up: {\uldb Clones}{\v Clones}\line
K{\footnote K Id Program}
#{\footnote Id_Program}
${\footnote \pard{}Printing Out User Information}\par
\pard{\fs24\b Printing Out User Information}\par
\par
\pard{}{K{\footnote K {\f1{}id} utility}}The {\f1{}id} utility lists a user's real and effective user-id numbers, real and effective group-id numbers, and the user's group set, if any.  {\f1{}id} will only print the effective user-id and group-id if they are different from the real ones.  If possible, {\f1{}id} will also supply the corresponding user and group names.  The output might look like this:\par
\par
{\pard\keep\li720\f1{}$ id\line
-| uid=2076(arnold) gid=10(staff) groups=10(staff),4(tty)\par
\pard\f0{}}\par
\pard{}This information is exactly what is provided by {\f1{}gawk}'s {\f1{}/dev/user} special file (see {\uldb Special File Names in {\f1{}gawk}}{\v Special_Files}).  However, the {\f1{}id} utility provides a more palatable output than just a string of numbers.\par
\par
\pard{}Here is a simple version of {\f1{}id} written in {\f1{}awk}.  It uses the user database library functions (see {\uldb Reading the User Database}{\v Passwd_Functions}), and the group database library functions (see {\uldb Reading the Group Database}{\v Group_Functions}).\par
\par
\pard{}The program is fairly straightforward.  All the work is done in the {\f1{}BEGIN} rule.  The user and group id numbers are obtained from {\f1{}/dev/user}.  If there is no support for {\f1{}/dev/user}, the program gives up.\par
\par
\pard{}The code is repetitive.  The entry in the user database for the real user-id number is split into parts at the {\f1{}:}. The name is the first field.  Similar code is used for the effective user-id number, and the group numbers.\par
\par
\pard{}{K{\footnote K id.awk}}{\par
\pard\keep\li720\f1{}# id.awk --- implement id in awk\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# May 1993\line
\line
# output is:\line
# uid=12(foo) euid=34(bar) gid=3(baz) \'5C\line
#             egid=5(blat) groups=9(nine),2(two),1(one)\line
\line
BEGIN    \'5C\line
\'7B\line
    if ((getline < "/dev/user") < 0) \'7B\line
        err = "id: no /dev/user support - cannot run"\line
        print err > "/dev/stderr"\line
        exit 1\line
    \'7D\line
    close("/dev/user")\line
\line
    uid = $1\line
    euid = $2\line
    gid = $3\line
    egid = $4\line
\line
    printf("uid=%d", uid)\line
    pw = getpwuid(uid)\line
{    if (pw != "") \'7B\line
        split(pw, a, ":")\line
        printf("(%s)", a[1])\line
    \'7D\par
\pard\keep\li720{}}\line
    if (euid != uid) \'7B\line
        printf(" euid=%d", euid)\line
        pw = getpwuid(euid)\line
        if (pw != "") \'7B\line
            split(pw, a, ":")\line
            printf("(%s)", a[1])\line
        \'7D\line
    \'7D\line
\line
    printf(" gid=%d", gid)\line
    pw = getgrgid(gid)\line
    if (pw != "") \'7B\line
        split(pw, a, ":")\line
        printf("(%s)", a[1])\line
    \'7D\line
\line
    if (egid != gid) \'7B\line
        printf(" egid=%d", egid)\line
        pw = getgrgid(egid)\line
        if (pw != "") \'7B\line
            split(pw, a, ":")\line
            printf("(%s)", a[1])\line
        \'7D\line
    \'7D\line
\line
    if (NF > 4) \'7B\line
        printf(" groups=");\line
        for (i = 5; i <= NF; i++) \'7B\line
            printf("%d", $i)\line
            pw = getgrgid($i)\line
            if (pw != "") \'7B\line
                split(pw, a, ":")\line
                printf("(%s)", a[1])\line
            \'7D\line
{            if (i < NF)\line
                printf(",")\par
\pard\keep\li720{}}        \'7D\line
    \'7D\line
    print ""\line
\'7D\par
\pard\f0{}}\par
\page\pard Node: {\b Split Program}, \keepn Next: {\uldb Tee Program}{\v Tee_Program}, Prev: {\uldb Id Program}{\v Id_Program}, Up: {\uldb Clones}{\v Clones}\line
K{\footnote K Split Program}
#{\footnote Split_Program}
${\footnote \pard{}Splitting a Large File Into Pieces}\par
\pard{\fs24\b Splitting a Large File Into Pieces}\par
\par
\pard{}{K{\footnote K {\f1{}split} utility}}The {\f1{}split} program splits large text files into smaller pieces. By default, the output files are named {\f1{}xaa}, {\f1{}xab}, and so on. Each file has 1000 lines in it, with the likely exception of the last file. To change the number of lines in each file, you supply a number on the command line preceded with a minus, e.g., {\f1{}-500} for files with 500 lines in them instead of 1000.  To change the name of the output files to something like {\f1{}myfileaa}, {\f1{}myfileab}, and so on, you supply an additional argument that specifies the filename.\par
\par
\pard{}Here is a version of {\f1{}split} in {\f1{}awk}. It uses the {\f1{}ord} and {\f1{}chr} functions presented in {\uldb Translating Between Characters and Numbers}{\v Ordinal_Functions}.\par
\par
\pard{}The program first sets its defaults, and then tests to make sure there are not too many arguments.  It then looks at each argument in turn.  The first argument could be a minus followed by a number. If it is, this happens to look like a negative number, so it is made positive, and that is the count of lines.  The data file name is skipped over, and the final argument is used as the prefix for the output file names.\par
\par
\pard{}{K{\footnote K split.awk}}{\par
\pard\keep\li720\f1{}# split.awk --- do split in awk\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# May 1993\line
\line
# usage: split [-num] [file] [outname]\line
\line
BEGIN \'7B\line
    outfile = "x"    # default\line
    count = 1000\line
    if (ARGC > 4)\line
        usage()\line
\line
    i = 1\line
    if (ARGV[i] ~ /^-[0-9]+$/) \'7B\line
        count = -ARGV[i]\line
        ARGV[i] = ""\line
        i++\line
    \'7D\line
    # test argv in case reading from stdin instead of file\line
    if (i in ARGV)\line
        i++    # skip data file name\line
    if (i in ARGV) \'7B\line
        outfile = ARGV[i]\line
        ARGV[i] = ""\line
    \'7D\line
\line
    s1 = s2 = "a"\line
    out = (outfile s1 s2)\line
\'7D\par
\pard\f0{}}\par
\pard{}The next rule does most of the work. {\f1{}tcount} (temporary count) tracks how many lines have been printed to the output file so far. If it is greater than {\f1{}count}, it is time to close the current file and start a new one.  {\f1{}s1} and {\f1{}s2} track the current suffixes for the file name. If they are both {\f1{}z}, the file is just too big.  Otherwise, {\f1{}s1} moves to the next letter in the alphabet and {\f1{}s2} starts over again at {\f1{}a}.\par
\par
{\pard\keep\li720\f1{}\'7B\line
    if (++tcount > count) \'7B\line
        close(out)\line
        if (s2 == "z") \'7B\line
            if (s1 == "z") \'7B\line
                printf("split: %s is too large to split\'5Cn", \'5C\line
                       FILENAME) > "/dev/stderr"\line
                exit 1\line
            \'7D\line
            s1 = chr(ord(s1) + 1)\line
            s2 = "a"\line
        \'7D else\line
            s2 = chr(ord(s2) + 1)\line
        out = (outfile s1 s2)\line
        tcount = 1\line
    \'7D\line
    print > out\line
\'7D\par
\pard\f0{}}\par
\pard{}The {\f1{}usage} function simply prints an error message and exits.\par
\par
{\pard\keep\li720\f1{}function usage(   e)\line
\'7B\line
    e = "usage: split [-num] [file] [outname]"\line
    print e > "/dev/stderr"\line
    exit 1\line
\'7D\par
\pard\f0{}}\par
\pard{}The variable {\f1{}e} is used so that the function fits nicely on the {screen.  }\par
\par
\pard{}This program is a bit sloppy; it relies on {\f1{}awk} to close the last file for it automatically, instead of doing it in an {\f1{}END} rule.\par
\par
\page\pard Node: {\b Tee Program}, \keepn Next: {\uldb Uniq Program}{\v Uniq_Program}, Prev: {\uldb Split Program}{\v Split_Program}, Up: {\uldb Clones}{\v Clones}\line
K{\footnote K Tee Program}
#{\footnote Tee_Program}
${\footnote \pard{}Duplicating Output Into Multiple Files}\par
\pard{\fs24\b Duplicating Output Into Multiple Files}\par
\par
\pard{}{K{\footnote K {\f1{}tee} utility}}The {\f1{}tee} program is known as a "pipe fitting."  {\f1{}tee} copies its standard input to its standard output, and also duplicates it to the files named on the command line.  Its usage is:\par
\par
{\pard\keep\li720\f1{}tee [-a] file ...\par
\pard\f0{}}\par
\pard{}The {\f1{}-a} option tells {\f1{}tee} to append to the named files, instead of truncating them and starting over.\par
\par
\pard{}The {\f1{}BEGIN} rule first makes a copy of all the command line arguments, into an array named {\f1{}copy}.  {\f1{}ARGV[0]} is not copied, since it is not needed.  {\f1{}tee} cannot use {\f1{}ARGV} directly, since {\f1{}awk} will attempt to process each file named in {\f1{}ARGV} as input data.\par
\par
\pard{}If the first argument is {\f1{}-a}, then the flag variable {\f1{}append} is set to true, and both {\f1{}ARGV[1]} and {\f1{}copy[1]} are deleted. If {\f1{}ARGC} is less than two, then no file names were supplied, and {\f1{}tee} prints a usage message and exits.  Finally, {\f1{}awk} is forced to read the standard input by setting {\f1{}ARGV[1]} to {\f1{}"-"}, and {\f1{}ARGC} to two.\par
\par
\pard{}{K{\footnote K tee.awk}}{\par
{\pard\keep\li720\f1{}# tee.awk --- tee in awk\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# May 1993\line
# Revised December 1995\par
\pard\keep\li720{}}\line
{BEGIN    \'5C\line
\'7B\line
    for (i = 1; i < ARGC; i++)\line
        copy[i] = ARGV[i]\par
\pard\keep\li720{}}\line
{    if (ARGV[1] == "-a") \'7B\line
        append = 1\line
        delete ARGV[1]\line
        delete copy[1]\line
        ARGC--\line
    \'7D\par
\pard\keep\li720{}}{    if (ARGC < 2) \'7B\line
        print "usage: tee [-a] file ..." > "/dev/stderr"\line
        exit 1\line
    \'7D\par
\pard\keep\li720{}}{    ARGV[1] = "-"\line
    ARGC = 2\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}The single rule does all the work.  Since there is no pattern, it is executed for each line of input.  The body of the rule simply prints the line into each file on the command line, and then to the standard output.\par
\par
{{\pard\keep\li720\f1{}\'7B\line
    # moving the if outside the loop makes it run faster\line
    if (append)\line
        for (i in copy)\line
            print >> copy[i]\line
    else\line
        for (i in copy)\line
            print > copy[i]\line
    print\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}It would have been possible to code the loop this way:\par
\par
{\pard\keep\li720\f1{}for (i in copy)\line
    if (append)\line
        print >> copy[i]\line
    else\line
        print > copy[i]\par
\pard\f0{}}\par
\pard{}This is more concise, but it is also less efficient.  The {\f1{}if} is tested for each record and for each output file.  By duplicating the loop body, the {\f1{}if} is only tested once for each input record.  If there are {\i N} input records and {\i M} input files, the first method only executes {\i N} {\f1{}if} statements, while the second would execute {\i N}{\f1{}*}{\i M} {\f1{}if} statements.\par
\par
\pard{}Finally, the {\f1{}END} rule cleans up, by closing all the output files.\par
\par
{\pard\keep\li720\f1{}END    \'5C\line
\'7B\line
    for (i in copy)\line
        close(copy[i])\line
\'7D\par
\pard\f0{}}\par
\page\pard Node: {\b Uniq Program}, \keepn Next: {\uldb Wc Program}{\v Wc_Program}, Prev: {\uldb Tee Program}{\v Tee_Program}, Up: {\uldb Clones}{\v Clones}\line
K{\footnote K Uniq Program}
#{\footnote Uniq_Program}
${\footnote \pard{}Printing Non-duplicated Lines of Text}\par
\pard{\fs24\b Printing Non-duplicated Lines of Text}\par
\par
\pard{}{K{\footnote K {\f1{}uniq} utility}}The {\f1{}uniq} utility reads sorted lines of data on its standard input, and (by default) removes duplicate lines.  In other words, only unique lines are printed, hence the name.  {\f1{}uniq} has a number of options. The usage is:\par
\par
{\pard\keep\li720\f1{}uniq [-udc [-{\i n}]] [+{\i n}] [ {\i input file} [ {\i output file} ]]\par
\pard\f0{}}\par
\pard{}The option meanings are:\par
\par
{\pard{}{\f1{}-d}\par
\pard\li720{}Only print repeated lines.\par
\par
\pard{}{\f1{}-u}\par
\pard\li720{}Only print non-repeated lines.\par
\par
\pard{}{\f1{}-c}\par
\pard\li720{}Count lines. This option overrides {\f1{}-d} and {\f1{}-u}.  Both repeated and non-repeated lines are counted.\par
\par
\pard{}{\f1{}-{\i n}}\par
\pard\li720{}Skip {\i n} fields before comparing lines.  The definition of fields is similar to {\f1{}awk}'s default: non-whitespace characters separated by runs of spaces and/or tabs.\par
\par
\pard{}{\f1{}+{\i n}}\par
\pard\li720{}Skip {\i n} characters before comparing lines.  Any fields specified with {\f1{}-{\i n}} are skipped first.\par
\par
\pard{}{\f1{}{\i input file}}\par
\pard\li720{}Data is read from the input file named on the command line, instead of from the standard input.\par
\par
\pard{}{\f1{}{\i output file}}\par
\pard\li720{}The generated output is sent to the named output file, instead of to the standard output.\par
\pard{}}\par
\pard{}Normally {\f1{}uniq} behaves as if both the {\f1{}-d} and {\f1{}-u} options had been provided.\par
\par
\pard{}Here is an {\f1{}awk} implementation of {\f1{}uniq}. It uses the {\f1{}getopt} library function (see {\uldb Processing Command Line Options}{\v Getopt_Function}), and the {\f1{}join} library function (see {\uldb Merging an Array Into a String}{\v Join_Function}).\par
\par
\pard{}The program begins with a {\f1{}usage} function and then a brief outline of the options and their meanings in a comment.\par
\par
\pard{}The {\f1{}BEGIN} rule deals with the command line arguments and options. It uses a trick to get {\f1{}getopt} to handle options of the form {\f1{}-25}, treating such an option as the option letter {\f1{}2} with an argument of {\f1{}5}. If indeed two or more digits were supplied ({\f1{}Optarg} looks like a number), {\f1{}Optarg} is concatenated with the option digit, and then result is added to zero to make it into a number.  If there is only one digit in the option, then {\f1{}Optarg} is not needed, and {\f1{}Optind} must be decremented so that {\f1{}getopt} will process it next time.  This code is admittedly a bit tricky.\par
\par
\pard{}If no options were supplied, then the default is taken, to print both repeated and non-repeated lines.  The output file, if provided, is assigned to {\f1{}outputfile}.  Earlier, {\f1{}outputfile} was initialized to the standard output, {\f1{}/dev/stdout}.\par
\par
\pard{}{K{\footnote K uniq.awk}}{\par
\pard\keep\li720\f1{}# uniq.awk --- do uniq in awk\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# May 1993\line
\line
{function usage(    e)\line
\'7B\line
    e = "Usage: uniq [-udc [-n]] [+n] [ in [ out ]]"\line
    print e > "/dev/stderr"\line
    exit 1\line
\'7D\par
\pard\keep\li720{}}\line
{# -c    count lines. overrides -d and -u\line
# -d    only repeated lines\line
# -u    only non-repeated lines\line
# -n    skip n fields\line
# +n    skip n characters, skip fields first\par
\pard\keep\li720{}}\line
BEGIN    \'5C\line
\'7B\line
    count = 1\line
    outputfile = "/dev/stdout"\line
    opts = "udc0:1:2:3:4:5:6:7:8:9:"\line
    while ((c = getopt(ARGC, ARGV, opts)) != -1) \'7B\line
        if (c == "u")\line
            non_repeated_only++\line
        else if (c == "d")\line
            repeated_only++\line
        else if (c == "c")\line
            do_count++\line
        else if (index("0123456789", c) != 0) \'7B\line
            # getopt requires args to options\line
            # this messes us up for things like -5\line
            if (Optarg ~ /^[0-9]+$/)\line
                fcount = (c Optarg) + 0\line
            else \'7B\line
                fcount = c + 0\line
                Optind--\line
            \'7D\line
        \'7D else\line
            usage()\line
    \'7D\line
\line
    if (ARGV[Optind] ~ /^\'5C+[0-9]+$/) \'7B\line
        charcount = substr(ARGV[Optind], 2) + 0\line
        Optind++\line
    \'7D\line
\line
    for (i = 1; i < Optind; i++)\line
        ARGV[i] = ""\line
\line
    if (repeated_only == 0 && non_repeated_only == 0)\line
        repeated_only = non_repeated_only = 1\line
\line
{    if (ARGC - Optind == 2) \'7B\line
        outputfile = ARGV[ARGC - 1]\line
        ARGV[ARGC - 1] = ""\line
    \'7D\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}The following function, {\f1{}are_equal}, compares the current line, {\f1{}$0}, to the previous line, {\f1{}last}.  It handles skipping fields and characters.\par
\par
\pard{}If no field count and no character count were specified, {\f1{}are_equal} simply returns one or zero depending upon the result of a simple string comparison of {\f1{}last} and {\f1{}$0}.  Otherwise, things get more complicated.\par
\par
\pard{}If fields have to be skipped, each line is broken into an array using {\f1{}split} (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}), and then the desired fields are joined back into a line using {\f1{}join}.  The joined lines are stored in {\f1{}clast} and {\f1{}cline}.  If no fields are skipped, {\f1{}clast} and {\f1{}cline} are set to {\f1{}last} and {\f1{}$0} respectively.\par
\par
\pard{}Finally, if characters are skipped, {\f1{}substr} is used to strip off the leading {\f1{}charcount} characters in {\f1{}clast} and {\f1{}cline}.  The two strings are then compared, and {\f1{}are_equal} returns the result.\par
\par
{\pard\keep\li720\f1{}function are_equal(    n, m, clast, cline, alast, aline)\line
\'7B\line
    if (fcount == 0 && charcount == 0)\line
        return (last == $0)\line
\line
    if (fcount > 0) \'7B\line
        n = split(last, alast)\line
        m = split($0, aline)\line
        clast = join(alast, fcount+1, n)\line
        cline = join(aline, fcount+1, m)\line
    \'7D else \'7B\line
        clast = last\line
        cline = $0\line
    \'7D\line
    if (charcount) \'7B\line
        clast = substr(clast, charcount + 1)\line
        cline = substr(cline, charcount + 1)\line
    \'7D\line
\line
    return (clast == cline)\line
\'7D\par
\pard\f0{}}\par
\pard{}The following two rules are the body of the program.  The first one is executed only for the very first line of data.  It sets {\f1{}last} equal to {\f1{}$0}, so that subsequent lines of text have something to be compared to.\par
\par
\pard{}The second rule does the work. The variable {\f1{}equal} will be one or zero depending upon the results of {\f1{}are_equal}'s comparison. If {\f1{}uniq} is counting repeated lines, then the {\f1{}count} variable is incremented if the lines are equal. Otherwise the line is printed and {\f1{}count} is reset, since the two lines are not equal.\par
\par
\pard{}If {\f1{}uniq} is not counting, {\f1{}count} is incremented if the lines are equal. Otherwise, if {\f1{}uniq} is counting repeated lines, and more than one line has been seen, or if {\f1{}uniq} is counting non-repeated lines, and only one line has been seen, then the line is printed, and {\f1{}count} is reset.\par
\par
\pard{}Finally, similar logic is used in the {\f1{}END} rule to print the final line of input data.\par
\par
{{\pard\keep\li720\f1{}NR == 1 \'7B\line
    last = $0\line
    next\line
\'7D\par
\pard\keep\li720{}}\line
\'7B\line
    equal = are_equal()\line
\line
    if (do_count) \'7B    # overrides -d and -u\line
        if (equal)\line
            count++\line
        else \'7B\line
            printf("%4d %s\'5Cn", count, last) > outputfile\line
            last = $0\line
            count = 1    # reset\line
        \'7D\line
        next\line
    \'7D\line
\line
    if (equal)\line
        count++\line
    else \'7B\line
        if ((repeated_only && count > 1) ||\line
            (non_repeated_only && count == 1))\line
                print last > outputfile\line
        last = $0\line
        count = 1\line
    \'7D\line
\'7D\line
\line
{END \'7B\line
    if (do_count)\line
        printf("%4d %s\'5Cn", count, last) > outputfile\line
    else if ((repeated_only && count > 1) ||\line
            (non_repeated_only && count == 1))\line
        print last > outputfile\line
\'7D\par
\pard\keep\li720{}}}\par
\page\pard Node: {\b Wc Program}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Uniq Program}{\v Uniq_Program}, Up: {\uldb Clones}{\v Clones}\line
K{\footnote K Wc Program}
#{\footnote Wc_Program}
${\footnote \pard\f0{}Counting Things}\par
\pard{\fs24\b Counting Things}\par
\par
\pard{}{K{\footnote K {\f1{}wc} utility}}The {\f1{}wc} (word count) utility counts lines, words, and characters in one or more input files. Its usage is:\par
\par
{\pard\keep\li720\f1{}wc [-lwc] [ {\i files} ... ]\par
\pard\f0{}}\par
\pard{}If no files are specified on the command line, {\f1{}wc} reads its standard input. If there are multiple files, it will also print total counts for all the files.  The options and their meanings are:\par
\par
{\pard{}{\f1{}-l}\par
\pard\li720{}Only count lines.\par
\par
\pard{}{\f1{}-w}\par
\pard\li720{}Only count words.  A "word" is a contiguous sequence of non-whitespace characters, separated by spaces and/or tabs.  Happily, this is the normal way {\f1{}awk} separates fields in its input data.\par
\par
\pard{}{\f1{}-c}\par
\pard\li720{}Only count characters.\par
\pard{}}\par
\pard{}Implementing {\f1{}wc} in {\f1{}awk} is particularly elegant, since {\f1{}awk} does a lot of the work for us; it splits lines into words (i.e.  fields) and counts them, it counts lines (i.e. records) for us, and it can easily tell us how long a line is.\par
\par
\pard{}This version uses the {\f1{}getopt} library function (see {\uldb Processing Command Line Options}{\v Getopt_Function}), and the file transition functions (see {\uldb Noting Data File Boundaries}{\v Filetrans_Function}).\par
\par
\pard{}This version has one major difference from traditional versions of {\f1{}wc}.  Our version always prints the counts in the order lines, words, and characters.  Traditional versions note the order of the {\f1{}-l}, {\f1{}-w}, and {\f1{}-c} options on the command line, and print the counts in that order.\par
\par
\pard{}The {\f1{}BEGIN} rule does the argument processing.  The variable {\f1{}print_total} will be true if more than one file was named on the command line.\par
\par
\pard{}{K{\footnote K wc.awk}}{\par
\pard\keep\li720\f1{}# wc.awk --- count lines, words, characters\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# May 1993\line
\line
# Options:\line
#    -l    only count lines\line
#    -w    only count words\line
#    -c    only count characters\line
#\line
# Default is to count lines, words, characters\line
\line
BEGIN \'7B\line
    # let getopt print a message about\line
    # invalid options. we ignore them\line
    while ((c = getopt(ARGC, ARGV, "lwc")) != -1) \'7B\line
        if (c == "l")\line
            do_lines = 1\line
        else if (c == "w")\line
            do_words = 1\line
        else if (c == "c")\line
            do_chars = 1\line
    \'7D\line
    for (i = 1; i < Optind; i++)\line
        ARGV[i] = ""\line
\line
    # if no options, do all\line
    if (! do_lines && ! do_words && ! do_chars)\line
        do_lines = do_words = do_chars = 1\line
\line
    print_total = (ARGC - i > 2)\line
\'7D\par
\pard\f0{}}\par
\pard{}The {\f1{}beginfile} function is simple; it just resets the counts of lines, words, and characters to zero, and saves the current file name in {\f1{}fname}.\par
\par
\pard{}The {\f1{}endfile} function adds the current file's numbers to the running totals of lines, words, and characters.  It then prints out those numbers for the file that was just read. It relies on {\f1{}beginfile} to reset the numbers for the following data file.\par
\par
{\pard\keep\li720\f1{}function beginfile(file)\line
\'7B\line
    chars = lines = words = 0\line
    fname = FILENAME\line
\'7D\line
\line
function endfile(file)\line
\'7B\line
    tchars += chars\line
    tlines += lines\line
    twords += words\line
{    if (do_lines)\line
        printf "\'5Ct%d", lines\par
\pard\keep\li720{}}    if (do_words)\line
        printf "\'5Ct%d", words\line
    if (do_chars)\line
        printf "\'5Ct%d", chars\line
    printf "\'5Ct%s\'5Cn", fname\line
\'7D\par
\pard\f0{}}\par
\pard{}There is one rule that is executed for each line. It adds the length of the record to {\f1{}chars}.  It has to add one, since the newline character separating records (the value of {\f1{}RS}) is not part of the record itself.  {\f1{}lines} is incremented for each line read, and {\f1{}words} is incremented by the value of {\f1{}NF}, the number of "words" on this line.({\ul 1}{\v Wc_Program_1})\par
\par
\pard{}Finally, the {\f1{}END} rule simply prints the totals for all the files.\par
\par
{\pard\keep\li720\f1{}# do per line\line
\'7B\line
    chars += length($0) + 1    # get newline\line
    lines++\line
    words += NF\line
\'7D\line
\line
END \'7B\line
    if (print_total) \'7B\line
        if (do_lines)\line
            printf "\'5Ct%d", tlines\line
        if (do_words)\line
            printf "\'5Ct%d", twords\line
        if (do_chars)\line
            printf "\'5Ct%d", tchars\line
        print "\'5Cttotal"\line
    \'7D\line
\'7D\par
\pard\f0{}}\par
\page\pard#{\footnote Wc_Program_1}
\pard{}(1) Examine the code in {\uldb Noting Data File Boundaries}{\v Filetrans_Function}.  Why must {\f1{}wc} use a separate {\f1{}lines} variable, instead of using the value of {\f1{}FNR} in {\f1{}endfile}?\par
\par
\page\pard Node: {\b Miscellaneous Programs}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Clones}{\v Clones}, Up: {\uldb Sample Programs}{\v Sample_Programs}\line
K{\footnote K Miscellaneous Programs}
#{\footnote Miscellaneous_Programs}
${\footnote \pard{}A Grab Bag of {\f1{}awk} Programs}\par
\pard{\fs24\b A Grab Bag of {\f1{}awk} Programs}\par
\par
\pard{}This section is a large "grab bag" of miscellaneous programs.  We hope you find them both interesting and enjoyable.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Dupword Program}{\v Dupword_Program}\tab Finding duplicated words in a document.\par
{\uldb Alarm Program}{\v Alarm_Program}\tab An alarm clock.\par
{\uldb Translate Program}{\v Translate_Program}\tab A program similar to the {\f1{}tr} utility.\par
{\uldb Labels Program}{\v Labels_Program}\tab Printing mailing labels.\par
{\uldb Word Sorting}{\v Word_Sorting}\tab A program to produce a word usage count.\par
{\uldb History Sorting}{\v History_Sorting}\tab Eliminating duplicate entries from a history file.\par
{\uldb Extract Program}{\v Extract_Program}\tab Pulling out programs from Texinfo source files.\par
{\uldb Simple Sed}{\v Simple_Sed}\tab A Simple Stream Editor.\par
{\uldb Igawk Program}{\v Igawk_Program}\tab A wrapper for {\f1{}awk} that includes files.\par
\pard{}}\par
\page\pard Node: {\b Dupword Program}, \keepn Next: {\uldb Alarm Program}{\v Alarm_Program}, Prev: {\uldb Miscellaneous Programs}{\v Miscellaneous_Programs}, Up: {\uldb Miscellaneous Programs}{\v Miscellaneous_Programs}\line
K{\footnote K Dupword Program}
#{\footnote Dupword_Program}
${\footnote \pard{}Finding Duplicated Words in a Document}\par
\pard{\fs24\b Finding Duplicated Words in a Document}\par
\par
\pard{}A common error when writing large amounts of prose is to accidentally duplicate words.  Often you will see this in text as something like "the the program does the following ...."  When the text is on-line, often the duplicated words occur at the end of one line and the beginning of another, making them very difficult to spot.\par
\par
\pard{}This program, {\f1{}dupword.awk}, scans through a file one line at a time, and looks for adjacent occurrences of the same word.  It also saves the last word on a line (in the variable {\f1{}prev}) for comparison with the first word on the next line.\par
\par
\pard{}The first two statements make sure that the line is all lower-case, so that, for example, "The" and "the" compare equal to each other.  The second statement removes all non-alphanumeric and non-whitespace characters from the line, so that punctuation does not affect the comparison either.  This sometimes leads to reports of duplicated words that really are different, but this is unusual.\par
\par
\pard{}{K{\footnote K dupword.awk}}{\par
{\pard\keep\li720\f1{}# dupword --- find duplicate words in text\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# December 1991\line
\line
\'7B\line
    $0 = tolower($0)\line
    gsub(/[^A-Za-z0-9 \'5Ct]/, "");\line
    if ($1 == prev)\line
        printf("%s:%d: duplicate %s\'5Cn",\line
            FILENAME, FNR, $1)\line
    for (i = 2; i <= NF; i++)\line
        if ($i == $(i-1))\line
            printf("%s:%d: duplicate %s\'5Cn",\line
                FILENAME, FNR, $i)\line
    prev = $NF\line
\'7D\par
\pard\keep\li720{}}}\par
\page\pard Node: {\b Alarm Program}, \keepn Next: {\uldb Translate Program}{\v Translate_Program}, Prev: {\uldb Dupword Program}{\v Dupword_Program}, Up: {\uldb Miscellaneous Programs}{\v Miscellaneous_Programs}\line
K{\footnote K Alarm Program}
#{\footnote Alarm_Program}
${\footnote \pard\f0{}An Alarm Clock Program}\par
\pard{\fs24\b An Alarm Clock Program}\par
\par
\pard{}The following program is a simple "alarm clock" program.  You give it a time of day, and an optional message.  At the given time, it prints the message on the standard output. In addition, you can give it the number of times to repeat the message, and also a delay between repetitions.\par
\par
\pard{}This program uses the {\f1{}gettimeofday} function from {\uldb Managing the Time of Day}{\v Gettimeofday_Function}.\par
\par
\pard{}All the work is done in the {\f1{}BEGIN} rule.  The first part is argument checking and setting of defaults; the delay, the count, and the message to print.  If the user supplied a message, but it does not contain the ASCII BEL character (known as the "alert" character, {\f1{}\'5Ca}), then it is added to the message.  (On many systems, printing the ASCII BEL generates some sort of audible alert. Thus, when the alarm goes off, the system calls attention to itself, in case the user is not looking at their computer or terminal.)\par
\par
\pard{}{K{\footnote K alarm.awk}}{\par
\pard\keep\li720\f1{}# alarm --- set an alarm\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# May 1993\line
\line
# usage: alarm time [ "message" [ count [ delay ] ] ]\line
\line
BEGIN    \'5C\line
\'7B\line
    # Initial argument sanity checking\line
    usage1 = "usage: alarm time ['message' [count [delay]]]"\line
    usage2 = sprintf("\'5Ct(%s) time ::= hh:mm", ARGV[1])\line
\line
    if (ARGC < 2) \'7B\line
        print usage > "/dev/stderr"\line
        exit 1\line
    \'7D else if (ARGC == 5) \'7B\line
        delay = ARGV[4] + 0\line
        count = ARGV[3] + 0\line
        message = ARGV[2]\line
    \'7D else if (ARGC == 4) \'7B\line
        count = ARGV[3] + 0\line
        message = ARGV[2]\line
    \'7D else if (ARGC == 3) \'7B\line
        message = ARGV[2]\line
    \'7D else if (ARGV[1] !~ /[0-9]?[0-9]:[0-9][0-9]/) \'7B\line
        print usage1 > "/dev/stderr"\line
        print usage2 > "/dev/stderr"\line
        exit 1\line
    \'7D\line
\line
    # set defaults for once we reach the desired time\line
    if (delay == 0)\line
        delay = 180    # 3 minutes\line
    if (count == 0)\line
        count = 5\line
{    if (message == "")\line
        message = sprintf("\'5CaIt is now %s!\'5Ca", ARGV[1])\line
    else if (index(message, "\'5Ca") == 0)\line
        message = "\'5Ca" message "\'5Ca"\par
\pard\keep\li720{}}}\par
\pard\f0{}The next section of code turns the alarm time into hours and minutes, and converts it if necessary to a 24-hour clock.  Then it turns that time into a count of the seconds since midnight.  Next it turns the current time into a count of seconds since midnight.  The difference between the two is how long to wait before setting off the alarm.\par
\par
{\pard\keep\li720\f1{}    # split up dest time\line
    split(ARGV[1], atime, ":")\line
    hour = atime[1] + 0    # force numeric\line
    minute = atime[2] + 0  # force numeric\line
\line
    # get current broken down time\line
    gettimeofday(now)\line
\line
    # if time given is 12-hour hours and it's after that\line
    # hour, e.g., `alarm 5:30' at 9 a.m. means 5:30 p.m.,\line
    # then add 12 to real hour\line
    if (hour < 12 && now["hour"] > hour)\line
        hour += 12\line
\line
    # set target time in seconds since midnight\line
    target = (hour * 60 * 60) + (minute * 60)\line
\line
    # get current time in seconds since midnight\line
    current = (now["hour"] * 60 * 60) + \'5C\line
               (now["minute"] * 60) + now["second"]\line
\line
    # how long to sleep for\line
    naptime = target - current\line
    if (naptime <= 0) \'7B\line
        print "time is in the past!" > "/dev/stderr"\line
        exit 1\line
    \'7D\par
\pard\f0{}}\par
\pard{}Finally, the program uses the {\f1{}system} function (see {\uldb Built-in Functions for Input/Output}{\v I_O_Functions}) to call the {\f1{}sleep} utility.  The {\f1{}sleep} utility simply pauses for the given number of seconds.  If the exit status is not zero, the program assumes that {\f1{}sleep} was interrupted, and exits. If {\f1{}sleep} exited with an OK status (zero), then the program prints the message in a loop, again using {\f1{}sleep} to delay for however many seconds are necessary.\par
\par
{\pard\keep\li720\f1{}    # zzzzzz..... go away if interrupted\line
    if (system(sprintf("sleep %d", naptime)) != 0)\line
        exit 1\line
\line
    # time to notify!\line
    command = sprintf("sleep %d", delay)\line
    for (i = 1; i <= count; i++) \'7B\line
        print message\line
        # if sleep command interrupted, go away\line
        if (system(command) != 0)\line
            break\line
    \'7D\line
\line
    exit 0\line
\'7D\par
\pard\f0{}}\par
\page\pard Node: {\b Translate Program}, \keepn Next: {\uldb Labels Program}{\v Labels_Program}, Prev: {\uldb Alarm Program}{\v Alarm_Program}, Up: {\uldb Miscellaneous Programs}{\v Miscellaneous_Programs}\line
K{\footnote K Translate Program}
#{\footnote Translate_Program}
${\footnote \pard{}Transliterating Characters}\par
\pard{\fs24\b Transliterating Characters}\par
\par
\pard{}The system {\f1{}tr} utility transliterates characters.  For example, it is often used to map upper-case letters into lower-case, for further processing.\par
\par
{{\i \pard\li720\f1{}generate data} | tr '[A-Z]' '[a-z]' | {\i process data} ...\par
\pard\f0{}}\par
\pard{}You give {\f1{}tr} two lists of characters enclosed in square brackets.  Usually, the lists are quoted to keep the shell from attempting to do a filename expansion.({\ul 1}{\v Translate_Program_1})  When processing the input, the first character in the first list is replaced with the first character in the second list, the second character in the first list is replaced with the second character in the second list, and so on.  If there are more characters in the "from" list than in the "to" list, the last character of the "to" list is used for the remaining characters in the "from" list.\par
\par
\pard{}Some time ago, a user proposed to us that we add a transliteration function to {\f1{}gawk}.  Being opposed to "creeping featurism," I wrote the following program to prove that character transliteration could be done with a user-level function.  This program is not as complete as the system {\f1{}tr} utility, but it will do most of the job.\par
\par
\pard{}The {\f1{}translate} program demonstrates one of the few weaknesses of standard {\f1{}awk}: dealing with individual characters is very painful, requiring repeated use of the {\f1{}substr}, {\f1{}index}, and {\f1{}gsub} built-in functions (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}).({\ul 2}{\v Translate_Program_2})\par
\par
\pard{}There are two functions.  The first, {\f1{}stranslate}, takes three arguments.\par
\par
{\pard{}{\f1{}from}\par
\pard\li720{}A list of characters to translate from.\par
\par
\pard{}{\f1{}to}\par
\pard\li720{}A list of characters to translate to.\par
\par
\pard{}{\f1{}target}\par
\pard\li720{}The string to do the translation on.\par
\pard{}}\par
\pard{}Associative arrays make the translation part fairly easy. {\f1{}t_ar} holds the "to" characters, indexed by the "from" characters.  Then a simple loop goes through {\f1{}from}, one character at a time.  For each character in {\f1{}from}, if the character appears in {\f1{}target}, {\f1{}gsub} is used to change it to the corresponding {\f1{}to} character.\par
\par
\pard{}The {\f1{}translate} function simply calls {\f1{}stranslate} using {\f1{}$0} as the target.  The main program sets two global variables, {\f1{}FROM} and {\f1{}TO}, from the command line, and then changes {\f1{}ARGV} so that {\f1{}awk} will read from the standard input.\par
\par
\pard{}Finally, the processing rule simply calls {\f1{}translate} for each record.\par
\par
\pard{}{K{\footnote K translate.awk}}{\par
\pard\keep\li720\f1{}# translate --- do tr like stuff\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# August 1989\line
\line
# bugs: does not handle things like: tr A-Z a-z, it has\line
# to be spelled out. However, if `to' is shorter than `from',\line
# the last character in `to' is used for the rest of `from'.\line
\line
function stranslate(from, to, target,     lf, lt, t_ar, i, c)\line
\'7B\line
    lf = length(from)\line
    lt = length(to)\line
    for (i = 1; i <= lt; i++)\line
        t_ar[substr(from, i, 1)] = substr(to, i, 1)\line
    if (lt < lf)\line
        for (; i <= lf; i++)\line
            t_ar[substr(from, i, 1)] = substr(to, lt, 1)\line
    for (i = 1; i <= lf; i++) \'7B\line
        c = substr(from, i, 1)\line
        if (index(target, c) > 0)\line
            gsub(c, t_ar[c], target)\line
    \'7D\line
    return target\line
\'7D\line
\line
{function translate(from, to)\line
\'7B\line
    return $0 = stranslate(from, to, $0)\line
\'7D\par
\pard\keep\li720{}}\line
# main program\line
BEGIN \'7B\line
    if (ARGC < 3) \'7B\line
        print "usage: translate from to" > "/dev/stderr"\line
        exit\line
    \'7D\line
    FROM = ARGV[1]\line
    TO = ARGV[2]\line
    ARGC = 2\line
    ARGV[1] = "-"\line
\'7D\line
\line
\'7B\line
    translate(FROM, TO)\line
    print\line
\'7D\par
\pard\f0{}}\par
\pard{}While it is possible to do character transliteration in a user-level function, it is not necessarily efficient, and we started to consider adding a built-in function.  However, shortly after writing this program, we learned that the System V Release 4 {\f1{}awk} had added the {\f1{}toupper} and {\f1{}tolower} functions.  These functions handle the vast majority of the cases where character transliteration is necessary, and so we chose to simply add those functions to {\f1{}gawk} as well, and then leave well enough alone.\par
\par
\pard{}An obvious improvement to this program would be to set up the {\f1{}t_ar} array only once, in a {\f1{}BEGIN} rule. However, this assumes that the "from" and "to" lists will never change throughout the lifetime of the program.\par
\par
\page\pard#{\footnote Translate_Program_1}
\pard{}(1) On older, non-POSIX systems, {\f1{}tr} often does not require that the lists be enclosed in square brackets and quoted.  This is a feature.\par
\par
\page\pard#{\footnote Translate_Program_2}
\pard{}(2) This program was written before {\f1{}gawk} acquired the ability to split each character in a string into separate array elements.  How might this ability simplify the program?\par
\par
\page\pard Node: {\b Labels Program}, \keepn Next: {\uldb Word Sorting}{\v Word_Sorting}, Prev: {\uldb Translate Program}{\v Translate_Program}, Up: {\uldb Miscellaneous Programs}{\v Miscellaneous_Programs}\line
K{\footnote K Labels Program}
#{\footnote Labels_Program}
${\footnote \pard{}Printing Mailing Labels}\par
\pard{\fs24\b Printing Mailing Labels}\par
\par
\pard{}Here is a "real world"({\ul 1}{\v Labels_Program_1}) program.  This script reads lists of names and addresses, and generates mailing labels.  Each page of labels has 20 labels on it, two across and ten down.  The addresses are guaranteed to be no more than five lines of data.  Each address is separated from the next by a blank line.\par
\par
\pard{}The basic idea is to read 20 labels worth of data.  Each line of each label is stored in the {\f1{}line} array.  The single rule takes care of filling the {\f1{}line} array and printing the page when 20 labels have been read.\par
\par
\pard{}The {\f1{}BEGIN} rule simply sets {\f1{}RS} to the empty string, so that {\f1{}awk} will split records at blank lines (see {\uldb How Input is Split into Records}{\v Records}).  It sets {\f1{}MAXLINES} to 100, since {\f1{}MAXLINE} is the maximum number of lines on the page (20 * 5 = 100).\par
\par
\pard{}Most of the work is done in the {\f1{}printpage} function.  The label lines are stored sequentially in the {\f1{}line} array.  But they have to be printed horizontally; {\f1{}line[1]} next to {\f1{}line[6]}, {\f1{}line[2]} next to {\f1{}line[7]}, and so on.  Two loops are used to accomplish this.  The outer loop, controlled by {\f1{}i}, steps through every 10 lines of data; this is each row of labels.  The inner loop, controlled by {\f1{}j}, goes through the lines within the row.  As {\f1{}j} goes from zero to four, {\f1{}i+j} is the {\f1{}j}'th line in the row, and {\f1{}i+j+5} is the entry next to it.  The output ends up looking something like this:\par
\par
{\pard\keep\li720\f1{}line 1          line 6\line
line 2          line 7\line
line 3          line 8\line
line 4          line 9\line
line 5          line 10\par
\pard\f0{}}\par
\pard{}As a final note, at lines 21 and 61, an extra blank line is printed, to keep the output lined up on the labels.  This is dependent on the particular brand of labels in use when the program was written.  You will also note that there are two blank lines at the top and two blank lines at the bottom.\par
\par
\pard{}The {\f1{}END} rule arranges to flush the final page of labels; there may not have been an even multiple of 20 labels in the data.\par
\par
\pard{}{K{\footnote K labels.awk}}{\par
\pard\keep\li720\f1{}# labels.awk\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# June 1992\line
\line
# Program to print labels.  Each label is 5 lines of data\line
# that may have blank lines.  The label sheets have 2\line
# blank lines at the top and 2 at the bottom.\line
\line
BEGIN    \'7B RS = "" ; MAXLINES = 100 \'7D\line
\line
function printpage(    i, j)\line
\'7B\line
    if (Nlines <= 0)\line
        return\line
\line
    printf "\'5Cn\'5Cn"        # header\line
\line
    for (i = 1; i <= Nlines; i += 10) \'7B\line
        if (i == 21 || i == 61)\line
            print ""\line
        for (j = 0; j < 5; j++) \'7B\line
            if (i + j > MAXLINES)\line
                break\line
            printf "   %-41s %s\'5Cn", line[i+j], line[i+j+5]\line
        \'7D\line
        print ""\line
    \'7D\line
\line
    printf "\'5Cn\'5Cn"        # footer\line
\line
    for (i in line)\line
        line[i] = ""\line
\'7D\line
\line
# main rule\line
\'7B\line
    if (Count >= 20) \'7B\line
        printpage()\line
        Count = 0\line
        Nlines = 0\line
    \'7D\line
    n = split($0, a, "\'5Cn")\line
    for (i = 1; i <= n; i++)\line
        line[++Nlines] = a[i]\line
    for (; i <= 5; i++)\line
        line[++Nlines] = ""\line
    Count++\line
\'7D\line
\line
END    \'5C\line
\'7B\line
    printpage()\line
\'7D\par
\pard\f0{}}\par
\page\pard#{\footnote Labels_Program_1}
\pard{}(1) "Real world" is defined as "a program actually used to get something done."\par
\par
\page\pard Node: {\b Word Sorting}, \keepn Next: {\uldb History Sorting}{\v History_Sorting}, Prev: {\uldb Labels Program}{\v Labels_Program}, Up: {\uldb Miscellaneous Programs}{\v Miscellaneous_Programs}\line
K{\footnote K Word Sorting}
#{\footnote Word_Sorting}
${\footnote \pard{}Generating Word Usage Counts}\par
\pard{\fs24\b Generating Word Usage Counts}\par
\par
\pard{}The following {\f1{}awk} program prints the number of occurrences of each word in its input.  It illustrates the associative nature of {\f1{}awk} arrays by using strings as subscripts.  It also demonstrates the {\f1{}for {\i x} in {\i array}} construction.  Finally, it shows how {\f1{}awk} can be used in conjunction with other utility programs to do a useful task of some complexity with a minimum of effort.  Some explanations follow the program listing.\par
\par
{\pard\keep\li720\f1{}awk '\line
# Print list of word frequencies\line
\'7B\line
    for (i = 1; i <= NF; i++)\line
        freq[$i]++\line
\'7D\line
\line
END \'7B\line
    for (word in freq)\line
        printf "%s\'5Ct%d\'5Cn", word, freq[word]\line
\'7D'\par
\pard\f0{}}\par
\pard{}The first thing to notice about this program is that it has two rules.  The first rule, because it has an empty pattern, is executed on every line of the input.  It uses {\f1{}awk}'s field-accessing mechanism (see {\uldb Examining Fields}{\v Fields}) to pick out the individual words from the line, and the built-in variable {\f1{}NF} (see {\uldb Built-in Variables}{\v Built_in_Variables}) to know how many fields are available.\par
\par
\pard{}For each input word, an element of the array {\f1{}freq} is incremented to reflect that the word has been seen an additional time.\par
\par
\pard{}The second rule, because it has the pattern {\f1{}END}, is not executed until the input has been exhausted.  It prints out the contents of the {\f1{}freq} table that has been built up inside the first action.\par
\par
\pard{}This program has several problems that would prevent it from being useful by itself on real text files:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Words are detected using the {\f1{}awk} convention that fields are separated by whitespace and that other characters in the input (except newlines) don't have any special meaning to {\f1{}awk}.  This means that punctuation characters count as part of words.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}awk} language considers upper- and lower-case characters to be distinct.  Therefore, {\f1{}bartender} and {\f1{}Bartender} are not treated as the same word.  This is undesirable since, in normal text, words are capitalized if they begin sentences, and a frequency analyzer should not be sensitive to capitalization.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The output does not come out in any useful order.  You're more likely to be interested in which words occur most frequently, or having an alphabetized table of how frequently each word occurs.\par
\pard{}}\par
\pard{}The way to solve these problems is to use some of the more advanced features of the {\f1{}awk} language.  First, we use {\f1{}tolower} to remove case distinctions.  Next, we use {\f1{}gsub} to remove punctuation characters.  Finally, we use the system {\f1{}sort} utility to process the output of the {\f1{}awk} script.  Here is the new version of the program:\par
\par
\pard{}{K{\footnote K wordfreq.sh}}{\par
\pard\keep\li720\f1{}# Print list of word frequencies\line
\'7B\line
    $0 = tolower($0)    # remove case distinctions\line
    gsub(/[^a-z0-9_ \'5Ct]/, "", $0)  # remove punctuation\line
    for (i = 1; i <= NF; i++)\line
        freq[$i]++\line
\'7D\line
\line
END \'7B\line
    for (word in freq)\line
        printf "%s\'5Ct%d\'5Cn", word, freq[word]\line
\'7D\par
\pard\f0{}}\par
\pard{}Assuming we have saved this program in a file named {\f1{}wordfreq.awk}, and that the data is in {\f1{}file1}, the following pipeline\par
\par
{\pard\keep\li720\f1{}awk -f wordfreq.awk file1 | sort +1 -nr\par
\pard\f0{}}\par
\pard{}produces a table of the words appearing in {\f1{}file1} in order of decreasing frequency.\par
\par
\pard{}The {\f1{}awk} program suitably massages the data and produces a word frequency table, which is not ordered.\par
\par
\pard{}The {\f1{}awk} script's output is then sorted by the {\f1{}sort} utility and printed on the terminal.  The options given to {\f1{}sort} in this example specify to sort using the second field of each input line (skipping one field), that the sort keys should be treated as numeric quantities (otherwise {\f1{}15} would come before {\f1{}5}), and that the sorting should be done in descending (reverse) order.\par
\par
\pard{}We could have even done the {\f1{}sort} from within the program, by changing the {\f1{}END} action to:\par
\par
{\pard\keep\li720\f1{}END \'7B\line
    sort = "sort +1 -nr"\line
    for (word in freq)\line
        printf "%s\'5Ct%d\'5Cn", word, freq[word] | sort\line
    close(sort)\line
\'7D\par
\pard\f0{}}\par
\pard{}You would have to use this way of sorting on systems that do not have true pipes.\par
\par
\pard{}See the general operating system documentation for more information on how to use the {\f1{}sort} program.\par
\par
\page\pard Node: {\b History Sorting}, \keepn Next: {\uldb Extract Program}{\v Extract_Program}, Prev: {\uldb Word Sorting}{\v Word_Sorting}, Up: {\uldb Miscellaneous Programs}{\v Miscellaneous_Programs}\line
K{\footnote K History Sorting}
#{\footnote History_Sorting}
${\footnote \pard{}Removing Duplicates from Unsorted Text}\par
\pard{\fs24\b Removing Duplicates from Unsorted Text}\par
\par
\pard{}The {\f1{}uniq} program (see {\uldb Printing Non-duplicated Lines of Text}{\v Uniq_Program}), removes duplicate lines from {\i sorted} data.\par
\par
\pard{}Suppose, however, you need to remove duplicate lines from a data file, but that you wish to preserve the order the lines are in?  A good example of this might be a shell history file.  The history file keeps a copy of all the commands you have entered, and it is not unusual to repeat a command several times in a row.  Occasionally you might wish to compact the history by removing duplicate entries.  Yet it is desirable to maintain the order of the original commands.\par
\par
\pard{}This simple program does the job.  It uses two arrays.  The {\f1{}data} array is indexed by the text of each line.  For each line, {\f1{}data[$0]} is incremented.\par
\par
\pard{}If a particular line has not been seen before, then {\f1{}data[$0]} will be zero.  In that case, the text of the line is stored in {\f1{}lines[count]}.  Each element of {\f1{}lines} is a unique command, and the indices of {\f1{}lines} indicate the order in which those lines were encountered.  The {\f1{}END} rule simply prints out the lines, in order.\par
\par
\pard{}{K{\footnote K Rakitzis, Byron}}{K{\footnote K histsort.awk}}{\par
{\pard\keep\li720\f1{}# histsort.awk --- compact a shell history file\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# May 1993\line
\line
# Thanks to Byron Rakitzis for the general idea\line
\'7B\line
    if (data[$0]++ == 0)\line
        lines[++count] = $0\line
\'7D\line
\line
END \'7B\line
    for (i = 1; i <= count; i++)\line
        print lines[i]\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}This program also provides a foundation for generating other useful information.  For example, using the following {\f1{}print} satement in the {\f1{}END} rule would indicate how often a particular command was used.\par
\par
{\pard\keep\li720\f1{}print data[lines[i]], lines[i]\par
\pard\f0{}}\par
\pard{}This works because {\f1{}data[$0]} was incremented each time a line was seen.\par
\par
\page\pard Node: {\b Extract Program}, \keepn Next: {\uldb Simple Sed}{\v Simple_Sed}, Prev: {\uldb History Sorting}{\v History_Sorting}, Up: {\uldb Miscellaneous Programs}{\v Miscellaneous_Programs}\line
K{\footnote K Extract Program}
#{\footnote Extract_Program}
${\footnote \pard{}Extracting Programs from Texinfo Source Files}\par
\pard{\fs24\b Extracting Programs from Texinfo Source Files}\par
\par
{\pard{}The nodes {\uldb A Library of {\f1{}awk} Functions}{\v Library_Functions}, and {\uldb Practical {\f1{}awk} Programs}{\v Sample_Programs}, are the top level nodes for a large number of {\f1{}awk} programs.  }If you wish to experiment with these programs, it is tedious to have to type them in by hand.  Here we present a program that can extract parts of a Texinfo input file into separate files.\par
\par
\pard{}This Info file is written in Texinfo, the GNU project's document formatting language.  A single Texinfo source file can be used to produce both printed and on-line documentation.  {The Texinfo language is described fully, starting with {\uldb Introduction}{\v Top @texi.hlp}.  }\par
\par
\pard{}For our purposes, it is enough to know three things about Texinfo input files.\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The "at" symbol, {\f1{}@}, is special in Texinfo, much like {\f1{}\'5C} in C or {\f1{}awk}.  Literal {\f1{}@} symbols are represented in Texinfo source files as {\f1{}@@}.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Comments start with either {\f1{}@c} or {\f1{}@comment}.  The file extraction program will work by using special comments that start at the beginning of a line.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Example text that should not be split across a page boundary is bracketed between lines containing {\f1{}@group} and {\f1{}@end group} commands.\par
\pard{}}\par
\pard{}The following program, {\f1{}extract.awk}, reads through a Texinfo source file, and does two things, based on the special comments.  Upon seeing {\f1{}@c system ...}, it runs a command, by extracting the command text from the control line and passing it on to the {\f1{}system} function (see {\uldb Built-in Functions for Input/Output}{\v I_O_Functions}).  Upon seeing {\f1{}@c file {\i filename}}, each subsequent line is sent to the file {\i filename}, until {\f1{}@c endfile} is encountered.  The rules in {\f1{}extract.awk} will match either {\f1{}@c} or {\f1{}@comment} by letting the {\f1{}omment} part be optional.  Lines containing {\f1{}@group} and {\f1{}@end group} are simply removed.  {\f1{}extract.awk} uses the {\f1{}join} library function (see {\uldb Merging an Array Into a String}{\v Join_Function}).\par
\par
\pard{}The example programs in the on-line Texinfo source for {\i Effective AWK Programming} ({\f1{}gawk.texi}) have all been bracketed inside {\f1{}file}, and {\f1{}endfile} lines.  The {\f1{}gawk} distribution uses a copy of {\f1{}extract.awk} to extract the sample programs and install many of them in a standard directory, where {\f1{}gawk} can find them.  The Texinfo file looks something like this:\par
\par
{\pard\keep\li720\f1{}...\line
This program has a @code\'7BBEGIN\'7D block,\line
which prints a nice message:\line
\line
@example\line
@c file examples/messages.awk\line
BEGIN @\'7B print "Don't panic!" @\'7D\line
@c end file\line
@end example\line
\line
It also prints some final advice:\line
\line
@example\line
@c file examples/messages.awk\line
END @\'7B print "Always avoid bored archeologists!" @\'7D\line
@c end file\line
@end example\line
...\par
\pard\f0{}}\par
{\f1{}\pard{}extract.awk} begins by setting {\f1{}IGNORECASE} to one, so that mixed upper-case and lower-case letters in the directives won't matter.\par
\par
\pard{}The first rule handles calling {\f1{}system}, checking that a command was given ({\f1{}NF} is at least three), and also checking that the command exited with a zero exit status, signifying OK.\par
\par
\pard{}{K{\footnote K extract.awk}}{\par
\pard\keep\li720\f1{}# extract.awk --- extract files and run programs\line
#                 from texinfo files\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# May 1993\line
\line
BEGIN    \'7B IGNORECASE = 1 \'7D\line
\line
{/^@c(omment)?[ \'5Ct]+system/    \'5C\line
\'7B\line
    if (NF < 3) \'7B\line
        e = (FILENAME ":" FNR)\line
        e = (e  ": badly formed `system' line")\line
        print e > "/dev/stderr"\line
        next\line
    \'7D\line
    $1 = ""\line
    $2 = ""\line
    stat = system($0)\line
    if (stat != 0) \'7B\line
        e = (FILENAME ":" FNR)\line
        e = (e ": warning: system returned " stat)\line
        print e > "/dev/stderr"\line
    \'7D\line
\'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}The variable {\f1{}e} is used so that the function fits nicely on the {screen.  }\par
\par
\pard{}The second rule handles moving data into files.  It verifies that a file name was given in the directive.  If the file named is not the current file, then the current file is closed.  This means that an {\f1{}@c endfile} was not given for that file.  (We should probably print a diagnostic in this case, although at the moment we do not.)\par
\par
\pard{}The {\f1{}for} loop does the work.  It reads lines using {\f1{}getline} (see {\uldb Explicit Input with {\f1{}getline}}{\v Getline}).  For an unexpected end of file, it calls the {\f1{}unexpected_eof} function.  If the line is an "endfile" line, then it breaks out of the loop.  If the line is an {\f1{}@group} or {\f1{}@end group} line, then it ignores it, and goes on to the next line.  (These Texinfo control lines keep blocks of code together on one page; unfortunately, TeX isn't always smart enough to do things exactly right, and we have to give it some advice.)\par
\par
\pard{}Most of the work is in the following few lines.  If the line has no {\f1{}@} symbols, it can be printed directly.  Otherwise, each leading {\f1{}@} must be stripped off.\par
\par
\pard{}To remove the {\f1{}@} symbols, the line is split into separate elements of the array {\f1{}a}, using the {\f1{}split} function (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}).  Each element of {\f1{}a} that is empty indicates two successive {\f1{}@} symbols in the original line.  For each two empty elements ({\f1{}@@} in the original file), we have to add back in a single {\f1{}@} symbol.\par
\par
\pard{}When the processing of the array is finished, {\f1{}join} is called with the value of {\f1{}SUBSEP}, to rejoin the pieces back into a single line.  That line is then printed to the output file.\par
\par
{{\pard\keep\li720\f1{}/^@c(omment)?[ \'5Ct]+file/    \'5C\line
\'7B\line
    if (NF != 3) \'7B\line
        e = (FILENAME ":" FNR ": badly formed `file' line")\line
        print e > "/dev/stderr"\line
        next\line
    \'7D\par
\pard\keep\li720{}}    if ($3 != curfile) \'7B\line
        if (curfile != "")\line
            close(curfile)\line
        curfile = $3\line
    \'7D\line
\line
    for (;;) \'7B\line
        if ((getline line) <= 0)\line
            unexpected_eof()\line
        if (line ~ /^@c(omment)?[ \'5Ct]+endfile/)\line
            break\line
        else if (line ~ /^@(end[ \'5Ct]+)?group/)\line
            continue\line
        if (index(line, "@") == 0) \'7B\line
            print line > curfile\line
            continue\line
        \'7D\line
        n = split(line, a, "@")\line
{        # if a[1] == "", means leading @,\line
        # don't add one back in.\par
\pard\keep\li720{}}        for (i = 2; i <= n; i++) \'7B\line
            if (a[i] == "") \'7B # was an @@\line
                a[i] = "@"\line
                if (a[i+1] == "")\line
                    i++\line
            \'7D\line
        \'7D\line
        print join(a, 1, n, SUBSEP) > curfile\line
    \'7D\line
\'7D\par
\pard\f0{}}\par
\pard{}An important thing to note is the use of the {\f1{}>} redirection.  Output done with {\f1{}>} only opens the file once; it stays open and subsequent output is appended to the file (see {\uldb Redirecting Output of {\f1{}print} and {\f1{}printf}}{\v Redirection}).  This allows us to easily mix program text and explanatory prose for the same sample source file (as has been done here!) without any hassle.  The file is only closed when a new data file name is encountered, or at the end of the input file.\par
\par
\pard{}Finally, the function {\f1{}unexpected_eof} prints an appropriate error message and then exits.\par
\par
\pard{}The {\f1{}END} rule handles the final cleanup, closing the open file.\par
\par
{{\pard\keep\li720\f1{}function unexpected_eof()\line
\'7B\line
    printf("%s:%d: unexpected EOF or error\'5Cn", \'5C\line
        FILENAME, FNR) > "/dev/stderr"\line
    exit 1\line
\'7D\par
\pard\keep\li720{}}\line
END \'7B\line
    if (curfile)\line
        close(curfile)\line
\'7D\par
\pard\f0{}}\par
\page\pard Node: {\b Simple Sed}, \keepn Next: {\uldb Igawk Program}{\v Igawk_Program}, Prev: {\uldb Extract Program}{\v Extract_Program}, Up: {\uldb Miscellaneous Programs}{\v Miscellaneous_Programs}\line
K{\footnote K Simple Sed}
#{\footnote Simple_Sed}
${\footnote \pard{}A Simple Stream Editor}\par
\pard{\fs24\b A Simple Stream Editor}\par
\par
\pard{}{K{\footnote K {\f1{}sed} utility}}The {\f1{}sed} utility is a "stream editor," a program that reads a stream of data, makes changes to it, and passes the modified data on.  It is often used to make global changes to a large file, or to a stream of data generated by a pipeline of commands.\par
\par
\pard{}While {\f1{}sed} is a complicated program in its own right, its most common use is to perform global substitutions in the middle of a pipeline:\par
\par
{\pard\keep\li720\f1{}command1 < orig.data | sed 's/old/new/g' | command2 > result\par
\pard\f0{}}\par
\pard{}Here, the {\f1{}s/old/new/g} tells {\f1{}sed} to look for the regexp {\f1{}old} on each input line, and replace it with the text {\f1{}new}, globally (i.e. all the occurrences on a line).  This is similar to {\f1{}awk}'s {\f1{}gsub} function (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}).\par
\par
\pard{}The following program, {\f1{}awksed.awk}, accepts at least two command line arguments; the pattern to look for and the text to replace it with. Any additional arguments are treated as data file names to process. If none are provided, the standard input is used.\par
\par
\pard{}{K{\footnote K Brennan, Michael}}{K{\footnote K {\f1{}awksed}}}{K{\footnote K simple stream editor}}{K{\footnote K stream editor, simple}}{\par
\pard\keep\li720\f1{}# awksed.awk --- do s/foo/bar/g using just print\line
#    Thanks to Michael Brennan for the idea\line
\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# August 1995\line
\line
{function usage()\line
\'7B\line
    print "usage: awksed pat repl [files...]" > "/dev/stderr"\line
    exit 1\line
\'7D\par
\pard\keep\li720{}}\line
BEGIN \'7B\line
    # validate arguments\line
    if (ARGC < 3)\line
        usage()\line
\line
    RS = ARGV[1]\line
    ORS = ARGV[2]\line
\line
    # don't use arguments as files\line
    ARGV[1] = ARGV[2] = ""\line
\'7D\line
\line
# look ma, no hands!\line
\'7B\line
    if (RT == "")\line
        printf "%s", $0\line
    else\line
        print\line
\'7D\par
\pard\f0{}}\par
\pard{}The program relies on {\f1{}gawk}'s ability to have {\f1{}RS} be a regexp and on the setting of {\f1{}RT} to the actual text that terminated the record (see {\uldb How Input is Split into Records}{\v Records}).\par
\par
\pard{}The idea is to have {\f1{}RS} be the pattern to look for. {\f1{}gawk} will automatically set {\f1{}$0} to the text between matches of the pattern.  This is text that we wish to keep, unmodified.  Then, by setting {\f1{}ORS} to the replacement text, a simple {\f1{}print} statement will output the text we wish to keep, followed by the replacement text.\par
\par
\pard{}There is one wrinkle to this scheme, which is what to do if the last record doesn't end with text that matches {\f1{}RS}?  Using a {\f1{}print} statement unconditionally prints the replacement text, which is not correct.\par
\par
\pard{}However, if the file did not end in text that matches {\f1{}RS}, {\f1{}RT} will be set to the null string.  In this case, we can print {\f1{}$0} using {\f1{}printf} (see {\uldb Using {\f1{}printf} Statements for Fancier Printing}{\v Printf}).\par
\par
\pard{}The {\f1{}BEGIN} rule handles the setup, checking for the right number of arguments, and calling {\f1{}usage} if there is a problem. Then it sets {\f1{}RS} and {\f1{}ORS} from the command line arguments, and sets {\f1{}ARGV[1]} and {\f1{}ARGV[2]} to the null string, so that they will not be treated as file names (see {\uldb Using {\f1{}ARGC} and {\f1{}ARGV}}{\v ARGC_and_ARGV}).\par
\par
\pard{}The {\f1{}usage} function prints an error message and exits.\par
\par
\pard{}Finally, the single rule handles the printing scheme outlined above, using {\f1{}print} or {\f1{}printf} as appropriate, depending upon the value of {\f1{}RT}.\par
\par
\page\pard Node: {\b Igawk Program}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Simple Sed}{\v Simple_Sed}, Up: {\uldb Miscellaneous Programs}{\v Miscellaneous_Programs}\line
K{\footnote K Igawk Program}
#{\footnote Igawk_Program}
${\footnote \pard{}An Easy Way to Use Library Functions}\par
\pard{\fs24\b An Easy Way to Use Library Functions}\par
\par
\pard{}Using library functions in {\f1{}awk} can be very beneficial. It encourages code re-use and the writing of general functions. Programs are smaller, and therefore clearer.  However, using library functions is only easy when writing {\f1{}awk} programs; it is painful when running them, requiring multiple {\f1{}-f} options.  If {\f1{}gawk} is unavailable, then so too is the {\f1{}AWKPATH} environment variable and the ability to put {\f1{}awk} functions into a library directory (see {\uldb Command Line Options}{\v Options}).\par
\par
\pard{}It would be nice to be able to write programs like so:\par
\par
{\pard\keep\li720\f1{}# library functions\line
@include getopt.awk\line
@include join.awk\line
...\line
\line
# main program\line
BEGIN \'7B\line
    while ((c = getopt(ARGC, ARGV, "a:b:cde")) != -1)\line
        ...\line
    ...\line
\'7D\par
\pard\f0{}}\par
\pard{}The following program, {\f1{}igawk.sh}, provides this service.  It simulates {\f1{}gawk}'s searching of the {\f1{}AWKPATH} variable, and also allows \'A2nested\'A2 includes; i.e. a file that has been included with {\f1{}@include} can contain further {\f1{}@include} statements.  {\f1{}igawk} will make an effort to only include files once, so that nested includes don't accidentally include a library function twice.\par
\par
{\f1{}\pard{}igawk} should behave externally just like {\f1{}gawk}.  This means it should accept all of {\f1{}gawk}'s command line arguments, including the ability to have multiple source files specified via {\f1{}-f}, and the ability to mix command line and library source files.\par
\par
\pard{}The program is written using the POSIX Shell ({\f1{}sh}) command language.  The way the program works is as follows:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}1. \tab{}Loop through the arguments, saving anything that doesn't represent {\f1{}awk} source code for later, when the expanded program is run.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}2. \tab{}For any arguments that do represent {\f1{}awk} text, put the arguments into a temporary file that will be expanded.  There are two cases.\par
\par
{\pard\fi-720\li1440\tx864\tx1440{}\tab{}a.\tab{}Literal text, provided with {\f1{}--source} or {\f1{}--source=}.  This text is just echoed directly.  The {\f1{}echo} program will automatically supply a trailing newline.\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}b.\tab{}File names provided with {\f1{}-f}.  We use a neat trick, and echo {\f1{}@include {\i filename}} into the temporary file.  Since the file inclusion program will work the way {\f1{}gawk} does, this will get the text of the file included into the program at the correct point.\par
\pard\li720{}}\par
\pard\fi-720\li720\tx144\tx720{}\tab{}3. \tab{}Run an {\f1{}awk} program (naturally) over the temporary file to expand {\f1{}@include} statements.  The expanded program is placed in a second temporary file.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}4. \tab{}Run the expanded program with {\f1{}gawk} and any other original command line arguments that the user supplied (such as the data file names).\par
\pard{}}\par
\pard{}The initial part of the program turns on shell tracing if the first argument was {\f1{}debug}.  Otherwise, a shell {\f1{}trap} statement arranges to clean up any temporary files on program exit or upon an interrupt.\par
\par
\pard{}The next part loops through all the command line arguments.  There are several cases of interest.\par
\par
{\pard{}{\f1{}--}\par
\pard\li720{}This ends the arguments to {\f1{}igawk}.  Anything else should be passed on to the user's {\f1{}awk} program without being evaluated.\par
\par
\pard{}{\f1{}-W}\par
\pard\li720{}This indicates that the next option is specific to {\f1{}gawk}.  To make argument processing easier, the {\f1{}-W} is appended to the front of the remaining arguments and the loop continues.  (This is an {\f1{}sh} programming trick.  Don't worry about it if you are not familiar with {\f1{}sh}.)\par
\par
\pard{}{\f1{}-v}\par
\pard{}{\f1{}-F}\par
\pard\li720{}These are saved and passed on to {\f1{}gawk}.\par
\par
\pard{}{\f1{}-f}\par
\pard{}{\f1{}--file}\par
\pard{}{\f1{}--file=}\par
\pard{}{\f1{}-Wfile=}\par
\pard\li720{}The file name is saved to the temporary file {\f1{}/tmp/ig.s.$$} with an {\f1{}@include} statement.  The {\f1{}sed} utility is used to remove the leading option part of the argument (e.g., {\f1{}--file=}).\par
\par
\pard{}{\f1{}--source}\par
\pard{}{\f1{}--source=}\par
\pard{}{\f1{}-Wsource=}\par
\pard\li720{}The source text is echoed into {\f1{}/tmp/ig.s.$$}.\par
\par
\pard{}{\f1{}--version}\par
\pard{}{\f1{}--version}\par
\pard{}{\f1{}-Wversion}\par
{\f1{}\pard\li720{}igawk} prints its version number, and runs {\f1{}gawk --version} to get the {\f1{}gawk} version information, and then exits.\par
\pard{}}\par
\pard{}If none of {\f1{}-f}, {\f1{}--file}, {\f1{}-Wfile}, {\f1{}--source}, or {\f1{}-Wsource}, were supplied, then the first non-option argument should be the {\f1{}awk} program.  If there are no command line arguments left, {\f1{}igawk} prints an error message and exits.  Otherwise, the first argument is echoed into {\f1{}/tmp/ig.s.$$}.\par
\par
\pard{}In any case, after the arguments have been processed, {\f1{}/tmp/ig.s.$$} contains the complete text of the original {\f1{}awk} program.\par
\par
\pard{}The {\f1{}$$} in {\f1{}sh} represents the current process ID number.  It is often used in shell programs to generate unique temporary file names.  This allows multiple users to run {\f1{}igawk} without worrying that the temporary file names will clash.\par
\par
\pard{}{K{\footnote K {\f1{}sed} utility}}Here's the program:\par
\par
\pard{}{K{\footnote K igawk.sh}}{\par
\pard\keep\li720\f1{}#! /bin/sh\line
\line
# igawk --- like gawk but do @include processing\line
# Arnold Robbins, arnold@gnu.org, Public Domain\line
# July 1993\line
\line
if [ "$1" = debug ]\line
then\line
    set -x\line
    shift\line
else\line
    # cleanup on exit, hangup, interrupt, quit, termination\line
    trap 'rm -f /tmp/ig.[se].$$' 0 1 2 3 15\line
fi\line
\line
while [ $# -ne 0 ] # loop over arguments\line
do\line
    case $1 in\line
    --)     shift; break;;\line
\line
    -W)     shift\line
            set -- -W"$@"\line
            continue;;\line
\line
    -[vF])  opts="$opts $1 '$2'"\line
            shift;;\line
\line
    -[vF]*) opts="$opts '$1'" ;;\line
\line
    -f)     echo @include "$2" >> /tmp/ig.s.$$\line
            shift;;\line
\line
{    -f*)    f=`echo "$1" | sed 's/-f//'`\line
            echo @include "$f" >> /tmp/ig.s.$$ ;;\par
\pard\keep\li720{}}\line
    -?file=*)    # -Wfile or --file\line
            f=`echo "$1" | sed 's/-.file=//'`\line
            echo @include "$f" >> /tmp/ig.s.$$ ;;\line
\line
    -?file)    # get arg, $2\line
            echo @include "$2" >> /tmp/ig.s.$$\line
            shift;;\line
\line
    -?source=*)    # -Wsource or --source\line
            t=`echo "$1" | sed 's/-.source=//'`\line
            echo "$t" >> /tmp/ig.s.$$ ;;\line
\line
    -?source)  # get arg, $2\line
            echo "$2" >> /tmp/ig.s.$$\line
            shift;;\line
\line
    -?version)\line
            echo igawk: version 1.0 1>&2\line
            gawk --version\line
            exit 0 ;;\line
\line
    -[W-]*)    opts="$opts '$1'" ;;\line
\line
    *)      break;;\line
    esac\line
    shift\line
done\line
\line
if [ ! -s /tmp/ig.s.$$ ]\line
then\line
    if [ -z "$1" ]\line
    then\line
         echo igawk: no program! 1>&2\line
         exit 1\line
    else\line
        echo "$1" > /tmp/ig.s.$$\line
        shift\line
    fi\line
fi\line
\line
# at this point, /tmp/ig.s.$$ has the program\par
\pard\f0{}}\par
\pard{}The {\f1{}awk} program to process {\f1{}@include} directives reads through the program, one line at a time using {\f1{}getline} (see {\uldb Explicit Input with {\f1{}getline}}{\v Getline}).  The input file names and {\f1{}@include} statements are managed using a stack.  As each {\f1{}@include} is encountered, the current file name is "pushed" onto the stack, and the file named in the {\f1{}@include} directive becomes the current file name.  As each file is finished, the stack is "popped," and the previous input file becomes the current input file again.  The process is started by making the original file the first one on the stack.\par
\par
\pard{}The {\f1{}pathto} function does the work of finding the full path to a file.  It simulates {\f1{}gawk}'s behavior when searching the {\f1{}AWKPATH} environment variable (see {\uldb The {\f1{}AWKPATH} Environment Variable}{\v AWKPATH_Variable}).  If a file name has a {\f1{}/} in it, no path search is done. Otherwise, the file name is concatenated with the name of each directory in the path, and an attempt is made to open the generated file name.  The only way in {\f1{}awk} to test if a file can be read is to go ahead and try to read it with {\f1{}getline}; that is what {\f1{}pathto} does.({\ul 1}{\v Igawk_Program_1}) If the file can be read, it is closed, and the file name is returned.\par
\par
{\pard\keep\li720\f1{}gawk -- '\line
# process @include directives\line
\line
function pathto(file,    i, t, junk)\line
\'7B\line
    if (index(file, "/") != 0)\line
        return file\line
\line
    for (i = 1; i <= ndirs; i++) \'7B\line
        t = (pathlist[i] "/" file)\line
        if ((getline junk < t) > 0) \'7B\line
            # found it\line
            close(t)\line
            return t\line
        \'7D\line
    \'7D\line
    return ""\line
\'7D\par
\pard\f0{}}\par
\pard{}The main program is contained inside one {\f1{}BEGIN} rule.  The first thing it does is set up the {\f1{}pathlist} array that {\f1{}pathto} uses.  After splitting the path on {\f1{}:}, null elements are replaced with {\f1{}"."}, which represents the current directory.\par
\par
{{\pard\keep\li720\f1{}BEGIN \'7B\line
    path = ENVIRON["AWKPATH"]\line
    ndirs = split(path, pathlist, ":")\line
    for (i = 1; i <= ndirs; i++) \'7B\line
        if (pathlist[i] == "")\line
            pathlist[i] = "."\line
    \'7D\par
\pard\keep\li720{}}}\par
\pard\f0{}The stack is initialized with {\f1{}ARGV[1]}, which will be {\f1{}/tmp/ig.s.$$}.  The main loop comes next.  Input lines are read in succession. Lines that do not start with {\f1{}@include} are printed verbatim.\par
\par
\pard{}If the line does start with {\f1{}@include}, the file name is in {\f1{}$2}.  {\f1{}pathto} is called to generate the full path.  If it could not, then we print an error message and continue.\par
\par
\pard{}The next thing to check is if the file has been included already.  The {\f1{}processed} array is indexed by the full file name of each included file, and it tracks this information for us.  If the file has been seen, a warning message is printed. Otherwise, the new file name is pushed onto the stack and processing continues.\par
\par
\pard{}Finally, when {\f1{}getline} encounters the end of the input file, the file is closed and the stack is popped.  When {\f1{}stackptr} is less than zero, the program is done.\par
\par
{\pard\keep\li720\f1{}    stackptr = 0\line
    input[stackptr] = ARGV[1] # ARGV[1] is first file\line
\line
    for (; stackptr >= 0; stackptr--) \'7B\line
        while ((getline < input[stackptr]) > 0) \'7B\line
            if (tolower($1) != "@include") \'7B\line
                print\line
                continue\line
            \'7D\line
            fpath = pathto($2)\line
            if (fpath == "") \'7B\line
                printf("igawk:%s:%d: cannot find %s\'5Cn", \'5C\line
                    input[stackptr], FNR, $2) > "/dev/stderr"\line
                continue\line
            \'7D\line
{            if (! (fpath in processed)) \'7B\line
                processed[fpath] = input[stackptr]\line
                input[++stackptr] = fpath\line
            \'7D else\line
                print $2, "included in", input[stackptr], \'5C\line
                    "already included in", \'5C\line
                    processed[fpath] > "/dev/stderr"\line
        \'7D\par
\pard\keep\li720{}}{        close(input[stackptr])\line
    \'7D\line
\'7D' /tmp/ig.s.$$ > /tmp/ig.e.$$\par
\pard\keep\li720{}}}\par
\pard\f0{}The last step is to call {\f1{}gawk} with the expanded program and the original options and command line arguments that the user supplied.  {\f1{}gawk}'s exit status is passed back on to {\f1{}igawk}'s calling program.\par
\par
{\pard\keep\li720\f1{}eval gawk -f /tmp/ig.e.$$ $opts -- "$@"\line
\line
exit $?\par
\pard\f0{}}\par
\pard{}This version of {\f1{}igawk} represents my third attempt at this program.  There are three key simplifications that made the program work better.\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}1. \tab{}Using {\f1{}@include} even for the files named with {\f1{}-f} makes building the initial collected {\f1{}awk} program much simpler; all the {\f1{}@include} processing can be done once.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}2. \tab{}The {\f1{}pathto} function doesn't try to save the line read with {\f1{}getline} when testing for the file's accessibility.  Trying to save this line for use with the main program complicates things considerably.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}3. \tab{}Using a {\f1{}getline} loop in the {\f1{}BEGIN} rule does it all in one place.  It is not necessary to call out to a separate loop for processing nested {\f1{}@include} statements.\par
\pard{}}\par
\pard{}Also, this program illustrates that it is often worthwhile to combine {\f1{}sh} and {\f1{}awk} programming together.  You can usually accomplish quite a lot, without having to resort to low-level programming in C or C++, and it is frequently easier to do certain kinds of string and argument manipulation using the shell than it is in {\f1{}awk}.\par
\par
\pard{}Finally, {\f1{}igawk} shows that it is not always necessary to add new features to a program; they can often be layered on top.  With {\f1{}igawk}, there is no real reason to build {\f1{}@include} processing into {\f1{}gawk} itself.\par
\par
\pard{}As an additional example of this, consider the idea of having two files in a directory in the search path.\par
\par
{\pard{}{\f1{}default.awk}\par
\pard\li720{}This file would contain a set of default library functions, such as {\f1{}getopt} and {\f1{}assert}.\par
\par
\pard{}{\f1{}site.awk}\par
\pard\li720{}This file would contain library functions that are specific to a site or installation, i.e. locally developed functions.  Having a separate file allows {\f1{}default.awk} to change with new {\f1{}gawk} releases, without requiring the system administrator to update it each time by adding the local functions.\par
\pard{}}\par
\pard{}One user suggested that {\f1{}gawk} be modified to automatically read these files upon startup.  Instead, it would be very simple to modify {\f1{}igawk} to do this. Since {\f1{}igawk} can process nested {\f1{}@include} directives, {\f1{}default.awk} could simply contain {\f1{}@include} statements for the desired library functions.\par
\par
\page\pard#{\footnote Igawk_Program_1}
\pard{}(1) On some very old versions of {\f1{}awk}, the test {\f1{}getline junk < t} can loop forever if the file exists but is empty.  Caveat Emptor.\par
\par
\page\pard Node: {\b Language History}, \keepn Next: {\uldb Gawk Summary}{\v Gawk_Summary}, Prev: {\uldb Sample Programs}{\v Sample_Programs}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Language History}
#{\footnote Language_History}
${\footnote \pard{}The Evolution of the {\f1{}awk} Language}\par
\pard{\fs24\b The Evolution of the {\f1{}awk} Language}\par
\par
\pard{}This Info file describes the GNU implementation of {\f1{}awk}, which follows the POSIX specification.  Many {\f1{}awk} users are only familiar with the original {\f1{}awk} implementation in Version 7 Unix.  (This implementation was the basis for {\f1{}awk} in Berkeley Unix, through 4.3-Reno.  The 4.4 release of Berkeley Unix uses {\f1{}gawk} 2.15.2 for its version of {\f1{}awk}.) This chapter briefly describes the evolution of the {\f1{}awk} language, with cross references to other parts of the Info file where you can find more information.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb V7/SVR3.1}{\v V7_SVR3_1}\tab The major changes between V7 and System V Release 3.1.\par
{\uldb SVR4}{\v SVR4}\tab Minor changes between System V Releases 3.1 and 4.\par
{\uldb POSIX}{\v POSIX}\tab New features from the POSIX standard.\par
{\uldb BTL}{\v BTL}\tab New features from the Bell Laboratories version of {\f1{}awk}.\par
{\uldb POSIX/GNU}{\v POSIX_GNU}\tab The extensions in {\f1{}gawk} not in POSIX {\f1{}awk}.\par
\pard{}}\par
\page\pard Node: {\b V7/SVR3.1}, \keepn Next: {\uldb SVR4}{\v SVR4}, Prev: {\uldb Language History}{\v Language_History}, Up: {\uldb Language History}{\v Language_History}\line
K{\footnote K V7/SVR3.1}
#{\footnote V7_SVR3_1}
${\footnote \pard{}Major Changes between V7 and SVR3.1}\par
\pard{\fs24\b Major Changes between V7 and SVR3.1}\par
\par
\pard{}The {\f1{}awk} language evolved considerably between the release of Version 7 Unix (1978) and the new version first made generally available in System V Release 3.1 (1987).  This section summarizes the changes, with cross-references to further details.\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The requirement for {\f1{};} to separate rules on a line (see {\uldb {\f1{}awk} Statements Versus Lines}{\v Statements_Lines}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}User-defined functions, and the {\f1{}return} statement (see {\uldb User-defined Functions}{\v User_defined}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}delete} statement (see {\uldb The {\f1{}delete} Statement}{\v Delete}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}do}-{\f1{}while} statement (see {\uldb The {\f1{}do}-{\f1{}while} Statement}{\v Do_Statement}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The built-in functions {\f1{}atan2}, {\f1{}cos}, {\f1{}sin}, {\f1{}rand} and {\f1{}srand} (see {\uldb Numeric Built-in Functions}{\v Numeric_Functions}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The built-in functions {\f1{}gsub}, {\f1{}sub}, and {\f1{}match} (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The built-in functions {\f1{}close}, and {\f1{}system} (see {\uldb Built-in Functions for Input/Output}{\v I_O_Functions}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}ARGC}, {\f1{}ARGV}, {\f1{}FNR}, {\f1{}RLENGTH}, {\f1{}RSTART}, and {\f1{}SUBSEP} built-in variables (see {\uldb Built-in Variables}{\v Built_in_Variables}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The conditional expression using the ternary operator {\f1{}?:} (see {\uldb Conditional Expressions}{\v Conditional_Exp}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The exponentiation operator {\f1{}^} (see {\uldb Arithmetic Operators}{\v Arithmetic_Ops}) and its assignment operator form {\f1{}^=} (see {\uldb Assignment Expressions}{\v Assignment_Ops}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}C-compatible operator precedence, which breaks some old {\f1{}awk} programs (see {\uldb Operator Precedence (How Operators Nest)}{\v Precedence}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Regexps as the value of {\f1{}FS} (see {\uldb Specifying How Fields are Separated}{\v Field_Separators}), and as the third argument to the {\f1{}split} function (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Dynamic regexps as operands of the {\f1{}~} and {\f1{}!~} operators (see {\uldb How to Use Regular Expressions}{\v Regexp_Usage}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The escape sequences {\f1{}\'5Cb}, {\f1{}\'5Cf}, and {\f1{}\'5Cr} (see {\uldb Escape Sequences}{\v Escape_Sequences}).  (Some vendors have updated their old versions of {\f1{}awk} to recognize {\f1{}\'5Cr}, {\f1{}\'5Cb}, and {\f1{}\'5Cf}, but this is not something you can rely on.)\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Redirection of input for the {\f1{}getline} function (see {\uldb Explicit Input with {\f1{}getline}}{\v Getline}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Multiple {\f1{}BEGIN} and {\f1{}END} rules (see {\uldb The {\f1{}BEGIN} and {\f1{}END} Special Patterns}{\v BEGIN_END}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Multi-dimensional arrays (see {\uldb Multi-dimensional Arrays}{\v Multi_dimensional}).\par
\pard{}}\par
\page\pard Node: {\b SVR4}, \keepn Next: {\uldb POSIX}{\v POSIX}, Prev: {\uldb V7/SVR3.1}{\v V7_SVR3_1}, Up: {\uldb Language History}{\v Language_History}\line
K{\footnote K SVR4}
#{\footnote SVR4}
${\footnote \pard{}Changes between SVR3.1 and SVR4}\par
\pard{\fs24\b Changes between SVR3.1 and SVR4}\par
\par
\pard{}{K{\footnote K {\f1{}awk} language, V.4 version}}The System V Release 4 version of Unix {\f1{}awk} added these features (some of which originated in {\f1{}gawk}):\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}ENVIRON} variable (see {\uldb Built-in Variables}{\v Built_in_Variables}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Multiple {\f1{}-f} options on the command line (see {\uldb Command Line Options}{\v Options}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}-v} option for assigning variables before program execution begins (see {\uldb Command Line Options}{\v Options}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}--} option for terminating command line options.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}\'5Ca}, {\f1{}\'5Cv}, and {\f1{}\'5Cx} escape sequences (see {\uldb Escape Sequences}{\v Escape_Sequences}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}A defined return value for the {\f1{}srand} built-in function (see {\uldb Numeric Built-in Functions}{\v Numeric_Functions}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}toupper} and {\f1{}tolower} built-in string functions for case translation (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}A cleaner specification for the {\f1{}%c} format-control letter in the {\f1{}printf} function (see {\uldb Format-Control Letters}{\v Control_Letters}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The ability to dynamically pass the field width and precision ({\f1{}"%*.*d"}) in the argument list of the {\f1{}printf} function (see {\uldb Format-Control Letters}{\v Control_Letters}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The use of regexp constants such as {\f1{}/foo/} as expressions, where they are equivalent to using the matching operator, as in {\f1{}$0 ~ /foo/} (see {\uldb Using Regular Expression Constants}{\v Using_Constant_Regexps}).\par
\pard{}}\par
\page\pard Node: {\b POSIX}, \keepn Next: {\uldb BTL}{\v BTL}, Prev: {\uldb SVR4}{\v SVR4}, Up: {\uldb Language History}{\v Language_History}\line
K{\footnote K POSIX}
#{\footnote POSIX}
${\footnote \pard{}Changes between SVR4 and POSIX {\f1{}awk}}\par
\pard{\fs24\b Changes between SVR4 and POSIX {\f1{}awk}}\par
\par
\pard{}The POSIX Command Language and Utilities standard for {\f1{}awk} introduced the following changes into the language:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The use of {\f1{}-W} for implementation-specific options.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The use of {\f1{}CONVFMT} for controlling the conversion of numbers to strings (see {\uldb Conversion of Strings and Numbers}{\v Conversion}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The concept of a numeric string, and tighter comparison rules to go with it (see {\uldb Variable Typing and Comparison Expressions}{\v Typing_and_Comparison}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}More complete documentation of many of the previously undocumented features of the language.\par
\pard{}}\par
\pard{}The following common extensions are not permitted by the POSIX standard:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}{\f1{}\'5Cx} escape sequences are not recognized (see {\uldb Escape Sequences}{\v Escape_Sequences}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Newlines do not act as whitespace to separate fields when {\f1{}FS} is equal to a single space.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The synonym {\f1{}func} for the keyword {\f1{}function} is not recognized (see {\uldb Function Definition Syntax}{\v Definition_Syntax}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The operators {\f1{}**} and {\f1{}**=} cannot be used in place of {\f1{}^} and {\f1{}^=} (see {\uldb Arithmetic Operators}{\v Arithmetic_Ops}, and also see {\uldb Assignment Expressions}{\v Assignment_Ops}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Specifying {\f1{}-Ft} on the command line does not set the value of {\f1{}FS} to be a single tab character (see {\uldb Specifying How Fields are Separated}{\v Field_Separators}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}fflush} built-in function is not supported (see {\uldb Built-in Functions for Input/Output}{\v I_O_Functions}).\par
\pard{}}\par
\page\pard Node: {\b BTL}, \keepn Next: {\uldb POSIX/GNU}{\v POSIX_GNU}, Prev: {\uldb POSIX}{\v POSIX}, Up: {\uldb Language History}{\v Language_History}\line
K{\footnote K BTL}
#{\footnote BTL}
${\footnote \pard{}Extensions in the Bell Laboratories {\f1{}awk}}\par
\pard{\fs24\b Extensions in the Bell Laboratories {\f1{}awk}}\par
\par
\pard{}{K{\footnote K Kernighan, Brian}}Brian Kernighan, one of the original designers of Unix {\f1{}awk}, has made his version available via anonymous {\f1{}ftp} (see {\uldb Other Freely Available {\f1{}awk} Implementations}{\v Other_Versions}).  This section describes extensions in his version of {\f1{}awk} that are not in POSIX {\f1{}awk}.\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}-mf {\i NNN}} and {\f1{}-mr {\i NNN}} command line options to set the maximum number of fields, and the maximum record size, respectively (see {\uldb Command Line Options}{\v Options}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}fflush} built-in function for flushing buffered output (see {\uldb Built-in Functions for Input/Output}{\v I_O_Functions}).\par
\par
\pard{}}\par
\page\pard Node: {\b POSIX/GNU}, \keepn Next: {\uldb }{\v }, Prev: {\uldb BTL}{\v BTL}, Up: {\uldb Language History}{\v Language_History}\line
K{\footnote K POSIX/GNU}
#{\footnote POSIX_GNU}
${\footnote \pard{}Extensions in {\f1{}gawk} Not in POSIX {\f1{}awk}}\par
\pard{\fs24\b Extensions in {\f1{}gawk} Not in POSIX {\f1{}awk}}\par
\par
\pard{}{K{\footnote K compatibility mode}}The GNU implementation, {\f1{}gawk}, adds a number of features.  This sections lists them in the order they were added to {\f1{}gawk}.  They can all be disabled with either the {\f1{}--traditional} or {\f1{}--posix} options (see {\uldb Command Line Options}{\v Options}).\par
\par
\pard{}Version 2.10 of {\f1{}gawk} introduced these features:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}AWKPATH} environment variable for specifying a path search for the {\f1{}-f} command line option (see {\uldb Command Line Options}{\v Options}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}IGNORECASE} variable and its effects (see {\uldb Case-sensitivity in Matching}{\v Case_sensitivity}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}/dev/stdin}, {\f1{}/dev/stdout}, {\f1{}/dev/stderr}, and {\f1{}/dev/fd/{\i n}} file name interpretation (see {\uldb Special File Names in {\f1{}gawk}}{\v Special_Files}).\par
\pard{}}\par
\pard{}Version 2.13 of {\f1{}gawk} introduced these features:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}FIELDWIDTHS} variable and its effects (see {\uldb Reading Fixed-width Data}{\v Constant_Size}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}systime} and {\f1{}strftime} built-in functions for obtaining and printing time stamps (see {\uldb Functions for Dealing with Time Stamps}{\v Time_Functions}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}-W lint} option to provide source code and run time error and portability checking (see {\uldb Command Line Options}{\v Options}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}-W compat} option to turn off these extensions (see {\uldb Command Line Options}{\v Options}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}-W posix} option for full POSIX compliance (see {\uldb Command Line Options}{\v Options}).\par
\pard{}}\par
\pard{}Version 2.14 of {\f1{}gawk} introduced these features:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}next file} statement for skipping to the next data file (see {\uldb The {\f1{}nextfile} Statement}{\v Nextfile_Statement}).\par
\pard{}}\par
\pard{}Version 2.15 of {\f1{}gawk} introduced these features:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}ARGIND} variable, that tracks the movement of {\f1{}FILENAME} through {\f1{}ARGV}  (see {\uldb Built-in Variables}{\v Built_in_Variables}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}ERRNO} variable, that contains the system error message when {\f1{}getline} returns -1, or when {\f1{}close} fails (see {\uldb Built-in Variables}{\v Built_in_Variables}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The ability to use GNU-style long named options that start with {\f1{}--} (see {\uldb Command Line Options}{\v Options}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}--source} option for mixing command line and library file source code (see {\uldb Command Line Options}{\v Options}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}/dev/pid}, {\f1{}/dev/ppid}, {\f1{}/dev/pgrpid}, and {\f1{}/dev/user} file name interpretation (see {\uldb Special File Names in {\f1{}gawk}}{\v Special_Files}).\par
\pard{}}\par
\pard{}Version 3.0 of {\f1{}gawk} introduced these features:\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}next file} statement became {\f1{}nextfile} (see {\uldb The {\f1{}nextfile} Statement}{\v Nextfile_Statement}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}--lint-old} option to warn about constructs that are not available in the original Version 7 Unix version of {\f1{}awk} (see {\uldb Major Changes between V7 and SVR3.1}{\v V7_SVR3_1}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}--traditional} option was added as a better name for {\f1{}--compat} (see {\uldb Command Line Options}{\v Options}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The ability for {\f1{}FS} to be a null string, and for the third argument to {\f1{}split} to be the null string (see {\uldb Making Each Character a Separate Field}{\v Single_Character_Fields}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The ability for {\f1{}RS} to be a regexp (see {\uldb How Input is Split into Records}{\v Records}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}RT} variable (see {\uldb How Input is Split into Records}{\v Records}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}gensub} function for more powerful text manipulation (see {\uldb Built-in Functions for String Manipulation}{\v String_Functions}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}strftime} function acquired a default time format, allowing it to be called with no arguments (see {\uldb Functions for Dealing with Time Stamps}{\v Time_Functions}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Full support for both POSIX and GNU regexps (see {\uldb Regular Expressions}{\v Regexp}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}--re-interval} option to provide interval expressions in regexps (see {\uldb Regular Expression Operators}{\v Regexp_Operators}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}{\f1{}IGNORECASE} changed, now applying to string comparison as well as regexp operations (see {\uldb Case-sensitivity in Matching}{\v Case_sensitivity}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The {\f1{}-m} option and the {\f1{}fflush} function from the Bell Labs research version of {\f1{}awk} (see {\uldb Command Line Options}{\v Options}; also see {\uldb Built-in Functions for Input/Output}{\v I_O_Functions}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}The use of GNU Autoconf to control the configuration process (see {\uldb Compiling {\f1{}gawk} for Unix}{\v Quick_Installation}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}{\f2\'B7}\tab{}Amiga support (see {\uldb Installing {\f1{}gawk} on an Amiga}{\v Amiga_Installation}).\par
\par
\pard{}}\par
\page\pard Node: {\b Gawk Summary}, \keepn Next: {\uldb Installation}{\v Installation}, Prev: {\uldb Language History}{\v Language_History}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Gawk Summary}
#{\footnote Gawk_Summary}
${\footnote {\f1{}\pard{}gawk} Summary}\par
\pard{\fs24\b {\f1{}gawk} Summary}\par
\par
\pard{}This appendix provides a brief summary of the {\f1{}gawk} command line and the {\f1{}awk} language.  It is designed to serve as "quick reference."  It is therefore terse, but complete.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Command Line Summary}{\v Command_Line_Summary}\tab Recapitulation of the command line.\par
{\uldb Language Summary}{\v Language_Summary}\tab A terse review of the language.\par
{\uldb Variables/Fields}{\v Variables_Fields}\tab Variables, fields, and arrays.\par
{\uldb Rules Summary}{\v Rules_Summary}\tab Patterns and Actions, and their component parts.\par
{\uldb Actions Summary}{\v Actions_Summary}\tab Quick overview of actions.\par
{\uldb Functions Summary}{\v Functions_Summary}\tab Defining and calling functions.\par
{\uldb Historical Features}{\v Historical_Features}\tab Some undocumented but supported ``features''.\par
\pard{}}\par
\page\pard Node: {\b Command Line Summary}, \keepn Next: {\uldb Language Summary}{\v Language_Summary}, Prev: {\uldb Gawk Summary}{\v Gawk_Summary}, Up: {\uldb Gawk Summary}{\v Gawk_Summary}\line
K{\footnote K Command Line Summary}
#{\footnote Command_Line_Summary}
${\footnote \pard{}Command Line Options Summary}\par
\pard{\fs24\b Command Line Options Summary}\par
\par
\pard{}The command line consists of options to {\f1{}gawk} itself, the {\f1{}awk} program text (if not supplied via the {\f1{}-f} option), and values to be made available in the {\f1{}ARGC} and {\f1{}ARGV} predefined {\f1{}awk} variables:\par
\par
{\pard\keep\li720\f1{}gawk [{\i POSIX or GNU style options}] -f {\i source-file} [{\f1{}--}] {\i file} ...\line
gawk [{\i POSIX or GNU style options}] [{\f1{}--}] '{\i program}' {\i file} ...\par
\pard\f0{}}\par
\pard{}The options that {\f1{}gawk} accepts are:\par
\par
{\pard{}{\f1{}-F {\i fs}}\par
\pard{}{\f1{}--field-separator {\i fs}}\par
\pard\li720{}Use {\i fs} for the input field separator (the value of the {\f1{}FS} predefined variable).\par
\par
\pard{}{\f1{}-f {\i program-file}}\par
\pard{}{\f1{}--file {\i program-file}}\par
\pard\li720{}Read the {\f1{}awk} program source from the file {\i program-file}, instead of from the first command line argument.\par
\par
\pard{}{\f1{}-mf {\i NNN}}\par
\pard{}{\f1{}-mr {\i NNN}}\par
\pard\li720{}The {\f1{}f} flag sets the maximum number of fields, and the {\f1{}r} flag sets the maximum record size.  These options are ignored by {\f1{}gawk}, since {\f1{}gawk} has no predefined limits; they are only for compatibility with the Bell Labs research version of Unix {\f1{}awk}.\par
\par
\pard{}{\f1{}-v {\i var}={\i val}}\par
\pard{}{\f1{}--assign {\i var}={\i val}}\par
\pard\li720{}Assign the variable {\i var} the value {\i val} before program execution begins.\par
\par
\pard{}{\f1{}-W traditional}\par
\pard{}{\f1{}-W compat}\par
\pard{}{\f1{}--traditional}\par
\pard{}{\f1{}--compat}\par
\pard\li720{}Use compatibility mode, in which {\f1{}gawk} extensions are turned off.\par
\par
\pard{}{\f1{}-W copyleft}\par
\pard{}{\f1{}-W copyright}\par
\pard{}{\f1{}--copyleft}\par
\pard{}{\f1{}--copyright}\par
\pard\li720{}Print the short version of the General Public License on the standard output, and exit.  This option may disappear in a future version of {\f1{}gawk}.\par
\par
\pard{}{\f1{}-W help}\par
\pard{}{\f1{}-W usage}\par
\pard{}{\f1{}--help}\par
\pard{}{\f1{}--usage}\par
\pard\li720{}Print a relatively short summary of the available options on the standard output, and exit.\par
\par
\pard{}{\f1{}-W lint}\par
\pard{}{\f1{}--lint}\par
\pard\li720{}Give warnings about dubious or non-portable {\f1{}awk} constructs.\par
\par
\pard{}{\f1{}-W lint-old}\par
\pard{}{\f1{}--lint-old}\par
\pard\li720{}Warn about constructs that are not available in the original Version 7 Unix version of {\f1{}awk}.\par
\par
\pard{}{\f1{}-W posix}\par
\pard{}{\f1{}--posix}\par
\pard\li720{}Use POSIX compatibility mode, in which {\f1{}gawk} extensions are turned off and additional restrictions apply.\par
\par
\pard{}{\f1{}-W re-interval}\par
\pard{}{\f1{}--re-interval}\par
\pard\li720{}Allow interval expressions (see {\uldb Regular Expression Operators}{\v Regexp_Operators}), in regexps.\par
\par
\pard{}{\f1{}-W source={\i program-text}}\par
\pard{}{\f1{}--source {\i program-text}}\par
\pard\li720{}Use {\i program-text} as {\f1{}awk} program source code.  This option allows mixing command line source code with source code from files, and is particularly useful for mixing command line programs with library functions.\par
\par
\pard{}{\f1{}-W version}\par
\pard{}{\f1{}--version}\par
\pard\li720{}Print version information for this particular copy of {\f1{}gawk} on the error output.\par
\par
\pard{}{\f1{}--}\par
\pard\li720{}Signal the end of options.  This is useful to allow further arguments to the {\f1{}awk} program itself to start with a {\f1{}-}.  This is mainly for consistency with POSIX argument parsing conventions.\par
\pard{}}\par
\pard{}Any other options are flagged as invalid, but are otherwise ignored.  See {\uldb Command Line Options}{\v Options}, for more details.\par
\par
\page\pard Node: {\b Language Summary}, \keepn Next: {\uldb Variables/Fields}{\v Variables_Fields}, Prev: {\uldb Command Line Summary}{\v Command_Line_Summary}, Up: {\uldb Gawk Summary}{\v Gawk_Summary}\line
K{\footnote K Language Summary}
#{\footnote Language_Summary}
${\footnote \pard{}Language Summary}\par
\pard{\fs24\b Language Summary}\par
\par
\pard{}An {\f1{}awk} program consists of a sequence of zero or more pattern-action statements and optional function definitions.  One or the other of the pattern and action may be omitted.\par
\par
{{\i \pard\li720\f1{}pattern}    \'7B {\i action statements} \'7D\line
{\i pattern}\line
          \'7B {\i action statements} \'7D\line
\line
function {\i name}({\i parameter list})     \'7B {\i action statements} \'7D\par
\pard\f0{}}\par
{\f1{}\pard{}gawk} first reads the program source from the {\i program-file}(s), if specified, or from the first non-option argument on the command line.  The {\f1{}-f} option may be used multiple times on the command line.  {\f1{}gawk} reads the program text from all the {\i program-file} files, effectively concatenating them in the order they are specified.  This is useful for building libraries of {\f1{}awk} functions, without having to include them in each new {\f1{}awk} program that uses them.  To use a library function in a file from a program typed in on the command line, specify {\f1{}--source '{\i program}'}, and type your program in between the single quotes.  See {\uldb Command Line Options}{\v Options}.\par
\par
\pard{}The environment variable {\f1{}AWKPATH} specifies a search path to use when finding source files named with the {\f1{}-f} option.  The default path, which is {\f1{}.:/usr/local/share/awk}({\ul 1}{\v Language_Summary_1}) is used if {\f1{}AWKPATH} is not set.  If a file name given to the {\f1{}-f} option contains a {\f1{}/} character, no path search is performed.  See {\uldb The {\f1{}AWKPATH} Environment Variable}{\v AWKPATH_Variable}.\par
\par
{\f1{}\pard{}gawk} compiles the program into an internal form, and then proceeds to read each file named in the {\f1{}ARGV} array.  The initial values of {\f1{}ARGV} come from the command line arguments.  If there are no files named on the command line, {\f1{}gawk} reads the standard input.\par
\par
\pard{}If a "file" named on the command line has the form {\f1{}{\i var}={\i val}}, it is treated as a variable assignment: the variable {\i var} is assigned the value {\i val}.  If any of the files have a value that is the null string, that element in the list is skipped.\par
\par
\pard{}For each record in the input, {\f1{}gawk} tests to see if it matches any {\i pattern} in the {\f1{}awk} program.  For each pattern that the record matches, the associated {\i action} is executed.\par
\par
\page\pard#{\footnote Language_Summary_1}
\pard{}(1) The path may use a directory other than {\f1{}/usr/local/share/awk}, depending upon how {\f1{}gawk} was built and installed.\par
\par
\page\pard Node: {\b Variables/Fields}, \keepn Next: {\uldb Rules Summary}{\v Rules_Summary}, Prev: {\uldb Language Summary}{\v Language_Summary}, Up: {\uldb Gawk Summary}{\v Gawk_Summary}\line
K{\footnote K Variables/Fields}
#{\footnote Variables_Fields}
${\footnote \pard{}Variables and Fields}\par
\pard{\fs24\b Variables and Fields}\par
\par
{\f1{}\pard{}awk} variables are not declared; they come into existence when they are first used.  Their values are either floating-point numbers or strings.  {\f1{}awk} also has one-dimensional arrays; multiple-dimensional arrays may be simulated.  There are several predefined variables that {\f1{}awk} sets as a program runs; these are summarized below.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Fields Summary}{\v Fields_Summary}\tab Input field splitting.\par
{\uldb Built-in Summary}{\v Built_in_Summary}\tab {\f1{}awk}'s built-in variables.\par
{\uldb Arrays Summary}{\v Arrays_Summary}\tab Using arrays.\par
{\uldb Data Type Summary}{\v Data_Type_Summary}\tab Values in {\f1{}awk} are numbers or strings.\par
\pard{}}\par
\page\pard Node: {\b Fields Summary}, \keepn Next: {\uldb Built-in Summary}{\v Built_in_Summary}, Prev: {\uldb Variables/Fields}{\v Variables_Fields}, Up: {\uldb Variables/Fields}{\v Variables_Fields}\line
K{\footnote K Fields Summary}
#{\footnote Fields_Summary}
${\footnote \pard{}Fields}\par
\pard{\fs24\b Fields}\par
\par
\pard{}As each input line is read, {\f1{}gawk} splits the line into {\i fields}, using the value of the {\f1{}FS} variable as the field separator.  If {\f1{}FS} is a single character, fields are separated by that character.  Otherwise, {\f1{}FS} is expected to be a full regular expression.  In the special case that {\f1{}FS} is a single space, fields are separated by runs of spaces, tabs and/or newlines.({\ul 1}{\v Fields_Summary_1}) If {\f1{}FS} is the null string ({\f1{}""}), then each individual character in the record becomes a separate field.  Note that the value of {\f1{}IGNORECASE} (see {\uldb Case-sensitivity in Matching}{\v Case_sensitivity}) also affects how fields are split when {\f1{}FS} is a regular expression.\par
\par
\pard{}Each field in the input line may be referenced by its position, {\f1{}$1}, {\f1{}$2}, and so on.  {\f1{}$0} is the whole line.  The value of a field may be assigned to as well.  Field numbers need not be constants:\par
\par
{\pard\keep\li720\f1{}n = 5\line
print $n\par
\pard\f0{}}\par
\pard{}prints the fifth field in the input line.  The variable {\f1{}NF} is set to the total number of fields in the input line.\par
\par
\pard{}References to non-existent fields (i.e. fields after {\f1{}$NF}) return the null string.  However, assigning to a non-existent field (e.g., {\f1{}$(NF+2) = 5}) increases the value of {\f1{}NF}, creates any intervening fields with the null string as their value, and causes the value of {\f1{}$0} to be recomputed, with the fields being separated by the value of {\f1{}OFS}.  Decrementing {\f1{}NF} causes the values of fields past the new value to be lost, and the value of {\f1{}$0} to be recomputed, with the fields being separated by the value of {\f1{}OFS}.  See {\uldb Reading Input Files}{\v Reading_Files}.\par
\par
\page\pard#{\footnote Fields_Summary_1}
\pard{}(1) In POSIX {\f1{}awk}, newline does not separate fields.\par
\par
\page\pard Node: {\b Built-in Summary}, \keepn Next: {\uldb Arrays Summary}{\v Arrays_Summary}, Prev: {\uldb Fields Summary}{\v Fields_Summary}, Up: {\uldb Variables/Fields}{\v Variables_Fields}\line
K{\footnote K Built-in Summary}
#{\footnote Built_in_Summary}
${\footnote \pard{}Built-in Variables}\par
\pard{\fs24\b Built-in Variables}\par
\par
{\f1{}\pard{}gawk}'s built-in variables are:\par
\par
{\pard{}{\f1{}ARGC}\par
\pard\li720{}The number of elements in {\f1{}ARGV}. See below for what is actually included in {\f1{}ARGV}.\par
\par
\pard{}{\f1{}ARGIND}\par
\pard\li720{}The index in {\f1{}ARGV} of the current file being processed.  When {\f1{}gawk} is processing the input data files, it is always true that {\f1{}FILENAME == ARGV[ARGIND]}.\par
\par
\pard{}{\f1{}ARGV}\par
\pard\li720{}The array of command line arguments.  The array is indexed from zero to {\f1{}ARGC} - 1.  Dynamically changing {\f1{}ARGC} and the contents of {\f1{}ARGV} can control the files used for data.  A null-valued element in {\f1{}ARGV} is ignored. {\f1{}ARGV} does not include the options to {\f1{}awk} or the text of the {\f1{}awk} program itself.\par
\par
\pard{}{\f1{}CONVFMT}\par
\pard\li720{}The conversion format to use when converting numbers to strings.\par
\par
\pard{}{\f1{}FIELDWIDTHS}\par
\pard\li720{}A space separated list of numbers describing the fixed-width input data.\par
\par
\pard{}{\f1{}ENVIRON}\par
\pard\li720{}An array of environment variable values.  The array is indexed by variable name, each element being the value of that variable.  Thus, the environment variable {\f1{}HOME} is {\f1{}ENVIRON["HOME"]}.  One possible value might be {\f1{}/home/arnold}.\par
\par
\pard\li720{}Changing this array does not affect the environment seen by programs which {\f1{}gawk} spawns via redirection or the {\f1{}system} function.  (This may change in a future version of {\f1{}gawk}.)\par
\par
\pard\li720{}Some operating systems do not have environment variables.  The {\f1{}ENVIRON} array is empty when running on these systems.\par
\par
\pard{}{\f1{}ERRNO}\par
\pard\li720{}The system error message when an error occurs using {\f1{}getline} or {\f1{}close}.\par
\par
\pard{}{\f1{}FILENAME}\par
\pard\li720{}The name of the current input file.  If no files are specified on the command line, the value of {\f1{}FILENAME} is the null string.\par
\par
\pard{}{\f1{}FNR}\par
\pard\li720{}The input record number in the current input file.\par
\par
\pard{}{\f1{}FS}\par
\pard\li720{}The input field separator, a space by default.\par
\par
\pard{}{\f1{}IGNORECASE}\par
\pard\li720{}The case-sensitivity flag for string comparisons and regular expression operations.  If {\f1{}IGNORECASE} has a non-zero value, then pattern matching in rules, record separating with {\f1{}RS}, field splitting with {\f1{}FS}, regular expression matching with {\f1{}~} and {\f1{}!~}, and the {\f1{}gensub}, {\f1{}gsub}, {\f1{}index}, {\f1{}match}, {\f1{}split} and {\f1{}sub} built-in functions all ignore case when doing regular expression operations, and all string comparisons are done ignoring case.  The value of {\f1{}IGNORECASE} does {\i not} affect array subscripting.\par
\par
\pard{}{\f1{}NF}\par
\pard\li720{}The number of fields in the current input record.\par
\par
\pard{}{\f1{}NR}\par
\pard\li720{}The total number of input records seen so far.\par
\par
\pard{}{\f1{}OFMT}\par
\pard\li720{}The output format for numbers for the {\f1{}print} statement, {\f1{}"%.6g"} by default.\par
\par
\pard{}{\f1{}OFS}\par
\pard\li720{}The output field separator, a space by default.\par
\par
\pard{}{\f1{}ORS}\par
\pard\li720{}The output record separator, by default a newline.\par
\par
\pard{}{\f1{}RS}\par
\pard\li720{}The input record separator, by default a newline.  If {\f1{}RS} is set to the null string, then records are separated by blank lines.  When {\f1{}RS} is set to the null string, then the newline character always acts as a field separator, in addition to whatever value {\f1{}FS} may have.  If {\f1{}RS} is set to a multi-character string, it denotes a regexp; input text matching the regexp separates records.\par
\par
\pard{}{\f1{}RT}\par
\pard\li720{}The input text that matched the text denoted by {\f1{}RS}, the record separator.\par
\par
\pard{}{\f1{}RSTART}\par
\pard\li720{}The index of the first character last matched by {\f1{}match}; zero if no match.\par
\par
\pard{}{\f1{}RLENGTH}\par
\pard\li720{}The length of the string last matched by {\f1{}match}; -1 if no match.\par
\par
\pard{}{\f1{}SUBSEP}\par
\pard\li720{}The string used to separate multiple subscripts in array elements, by default {\f1{}"\'5C034"}.\par
\pard{}}\par
\pard{}See {\uldb Built-in Variables}{\v Built_in_Variables}, for more information.\par
\par
\page\pard Node: {\b Arrays Summary}, \keepn Next: {\uldb Data Type Summary}{\v Data_Type_Summary}, Prev: {\uldb Built-in Summary}{\v Built_in_Summary}, Up: {\uldb Variables/Fields}{\v Variables_Fields}\line
K{\footnote K Arrays Summary}
#{\footnote Arrays_Summary}
${\footnote \pard{}Arrays}\par
\pard{\fs24\b Arrays}\par
\par
\pard{}Arrays are subscripted with an expression between square brackets ({\f1{}[} and {\f1{}]}).  Array subscripts are {\i always} strings; numbers are converted to strings as necessary, following the standard conversion rules (see {\uldb Conversion of Strings and Numbers}{\v Conversion}).\par
\par
\pard{}If you use multiple expressions separated by commas inside the square brackets, then the array subscript is a string consisting of the concatenation of the individual subscript values, converted to strings, separated by the subscript separator (the value of {\f1{}SUBSEP}).\par
\par
\pard{}The special operator {\f1{}in} may be used in a conditional context to see if an array has an index consisting of a particular value.\par
\par
{\pard\keep\li720\f1{}if (val in array)\line
        print array[val]\par
\pard\f0{}}\par
\pard{}If the array has multiple subscripts, use {\f1{}(i, j, ...) in {\i array}} to test for existence of an element.\par
\par
\pard{}The {\f1{}in} construct may also be used in a {\f1{}for} loop to iterate over all the elements of an array.  See {\uldb Scanning All Elements of an Array}{\v Scanning_an_Array}.\par
\par
\pard{}You can remove an element from an array using the {\f1{}delete} statement.\par
\par
\pard{}You can clear an entire array using {\f1{}delete {\i array}}.\par
\par
\pard{}See {\uldb Arrays in {\f1{}awk}}{\v Arrays}.\par
\par
\page\pard Node: {\b Data Type Summary}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Arrays Summary}{\v Arrays_Summary}, Up: {\uldb Variables/Fields}{\v Variables_Fields}\line
K{\footnote K Data Type Summary}
#{\footnote Data_Type_Summary}
${\footnote \pard{}Data Types}\par
\pard{\fs24\b Data Types}\par
\par
\pard{}The value of an {\f1{}awk} expression is always either a number or a string.\par
\par
\pard{}Some contexts (such as arithmetic operators) require numeric values.  They convert strings to numbers by interpreting the text of the string as a number.  If the string does not look like a number, it converts to zero.\par
\par
\pard{}Other contexts (such as concatenation) require string values.  They convert numbers to strings by effectively printing them with {\f1{}sprintf}.  See {\uldb Conversion of Strings and Numbers}{\v Conversion}, for the details.\par
\par
\pard{}To force conversion of a string value to a number, simply add zero to it.  If the value you start with is already a number, this does not change it.\par
\par
\pard{}To force conversion of a numeric value to a string, concatenate it with the null string.\par
\par
\pard{}Comparisons are done numerically if both operands are numeric, or if one is numeric and the other is a numeric string.  Otherwise one or both operands are converted to strings and a string comparison is performed.  Fields, {\f1{}getline} input, {\f1{}FILENAME}, {\f1{}ARGV} elements, {\f1{}ENVIRON} elements and the elements of an array created by {\f1{}split} are the only items that can be numeric strings. String constants, such as {\f1{}"3.1415927"} are not numeric strings, they are string constants.  The full rules for comparisons are described in {\uldb Variable Typing and Comparison Expressions}{\v Typing_and_Comparison}.\par
\par
\pard{}Uninitialized variables have the string value {\f1{}""} (the null, or empty, string).  In contexts where a number is required, this is equivalent to zero.\par
\par
\pard{}See {\uldb Variables}{\v Variables}, for more information on variable naming and initialization; see {\uldb Conversion of Strings and Numbers}{\v Conversion}, for more information on how variable values are interpreted.\par
\par
\page\pard Node: {\b Rules Summary}, \keepn Next: {\uldb Actions Summary}{\v Actions_Summary}, Prev: {\uldb Variables/Fields}{\v Variables_Fields}, Up: {\uldb Gawk Summary}{\v Gawk_Summary}\line
K{\footnote K Rules Summary}
#{\footnote Rules_Summary}
${\footnote \pard{}Patterns}\par
\pard{\fs24\b Patterns}\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Pattern Summary}{\v Pattern_Summary}\tab Quick overview of patterns.\par
{\uldb Regexp Summary}{\v Regexp_Summary}\tab Quick overview of regular expressions.\par
\pard{}}\par
\pard{}An {\f1{}awk} program is mostly composed of rules, each consisting of a pattern followed by an action.  The action is enclosed in {\f1{}\'7B} and {\f1{}\'7D}.  Either the pattern may be missing, or the action may be missing, but not both.  If the pattern is missing, the action is executed for every input record.  A missing action is equivalent to {\f1{}\'7B print \'7D}, which prints the entire line.\par
\par
\pard{}Comments begin with the {\f1{}#} character, and continue until the end of the line.  Blank lines may be used to separate statements.  Statements normally end with a newline; however, this is not the case for lines ending in a {\f1{},}, {\f1{}\'7B}, {\f1{}?}, {\f1{}:}, {\f1{}&&}, or {\f1{}||}.  Lines ending in {\f1{}do} or {\f1{}else} also have their statements automatically continued on the following line.  In other cases, a line can be continued by ending it with a {\f1{}\'5C}, in which case the newline is ignored.\par
\par
\pard{}Multiple statements may be put on one line by separating each one with a {\f1{};}.  This applies to both the statements within the action part of a rule (the usual case), and to the rule statements.\par
\par
\pard{}See {\uldb Comments in {\f1{}awk} Programs}{\v Comments}, for information on {\f1{}awk}'s commenting convention; see {\uldb {\f1{}awk} Statements Versus Lines}{\v Statements_Lines}, for a description of the line continuation mechanism in {\f1{}awk}.\par
\par
\page\pard Node: {\b Pattern Summary}, \keepn Next: {\uldb Regexp Summary}{\v Regexp_Summary}, Prev: {\uldb Rules Summary}{\v Rules_Summary}, Up: {\uldb Rules Summary}{\v Rules_Summary}\line
K{\footnote K Pattern Summary}
#{\footnote Pattern_Summary}
${\footnote \pard{}Pattern Summary}\par
\pard{\fs24\b Pattern Summary}\par
\par
{\f1{}\pard{}awk} patterns may be one of the following:\par
\par
{\pard\keep\li720\f1{}/{\i regular expression}/\line
{\i relational expression}\line
{\i pattern} && {\i pattern}\line
{\i pattern} || {\i pattern}\line
{\i pattern} ? {\i pattern} : {\i pattern}\line
({\i pattern})\line
! {\i pattern}\line
{\i pattern1}, {\i pattern2}\line
BEGIN\line
END\par
\pard\f0{}}\par
{\f1{}\pard{}BEGIN} and {\f1{}END} are two special kinds of patterns that are not tested against the input.  The action parts of all {\f1{}BEGIN} rules are concatenated as if all the statements had been written in a single {\f1{}BEGIN} rule.  They are executed before any of the input is read.  Similarly, all the {\f1{}END} rules are concatenated, and executed when all the input is exhausted (or when an {\f1{}exit} statement is executed).  {\f1{}BEGIN} and {\f1{}END} patterns cannot be combined with other patterns in pattern expressions.  {\f1{}BEGIN} and {\f1{}END} rules cannot have missing action parts.\par
\par
\pard{}For {\f1{}/{\i regular-expression}/} patterns, the associated statement is executed for each input record that matches the regular expression.  Regular expressions are summarized below.\par
\par
\pard{}A {\i relational expression} may use any of the operators defined below in the section on actions.  These generally test whether certain fields match certain regular expressions.\par
\par
\pard{}The {\f1{}&&}, {\f1{}||}, and {\f1{}!} operators are logical "and," logical "or," and logical "not," respectively, as in C.  They do short-circuit evaluation, also as in C, and are used for combining more primitive pattern expressions.  As in most languages, parentheses may be used to change the order of evaluation.\par
\par
\pard{}The {\f1{}?:} operator is like the same operator in C.  If the first pattern matches, then the second pattern is matched against the input record; otherwise, the third is matched.  Only one of the second and third patterns is matched.\par
\par
\pard{}The {\f1{}{\i pattern1}, {\i pattern2}} form of a pattern is called a range pattern.  It matches all input lines starting with a line that matches {\i pattern1}, and continuing until a line that matches {\i pattern2}, inclusive.  A range pattern cannot be used as an operand of any of the pattern operators.\par
\par
\pard{}See {\uldb Pattern Elements}{\v Pattern_Overview}.\par
\par
\page\pard Node: {\b Regexp Summary}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Pattern Summary}{\v Pattern_Summary}, Up: {\uldb Rules Summary}{\v Rules_Summary}\line
K{\footnote K Regexp Summary}
#{\footnote Regexp_Summary}
${\footnote \pard{}Regular Expressions}\par
\pard{\fs24\b Regular Expressions}\par
\par
\pard{}Regular expressions are based on POSIX EREs (extended regular expressions).  The escape sequences allowed in string constants are also valid in regular expressions (see {\uldb Escape Sequences}{\v Escape_Sequences}).  Regexps are composed of characters as follows:\par
\par
{\pard{}{\f1{}{\i c}}\par
\pard\li720{}matches the character {\i c} (assuming {\i c} is none of the characters listed below).\par
\par
\pard{}{\f1{}\'5C{\i c}}\par
\pard\li720{}matches the literal character {\i c}.\par
\par
\pard{}{\f1{}.}\par
\pard\li720{}matches any character, {\i including} newline.  In strict POSIX mode, {\f1{}.} does not match the {\scaps\fs16{}nul} character, which is a character with all bits equal to zero.\par
\par
\pard{}{\f1{}^}\par
\pard\li720{}matches the beginning of a string.\par
\par
\pard{}{\f1{}$}\par
\pard\li720{}matches the end of a string.\par
\par
\pard{}{\f1{}[{\i abc}...]}\par
\pard\li720{}matches any of the characters {\i abc}... (character list).\par
\par
\pard{}{\f1{}[[:{\i class}:]]}\par
\pard\li720{}matches any character in the character class {\i class}. Allowable classes are {\f1{}alnum}, {\f1{}alpha}, {\f1{}blank}, {\f1{}cntrl}, {\f1{}digit}, {\f1{}graph}, {\f1{}lower}, {\f1{}print}, {\f1{}punct}, {\f1{}space}, {\f1{}upper}, and {\f1{}xdigit}.\par
\par
\pard{}{\f1{}[[.{\i symbol}.]]}\par
\pard\li720{}matches the multi-character collating symbol {\i symbol}.  {\f1{}gawk} does not currently support collating symbols.\par
\par
\pard{}{\f1{}[[={\i classname}=]]}\par
\pard\li720{}matches any of the equivalent characters in the current locale named by the equivalence class {\i classname}.  {\f1{}gawk} does not currently support equivalence classes.\par
\par
\pard{}{\f1{}[^{\i abc}...]}\par
\pard\li720{}matches any character except {\i abc}... (negated character list).\par
\par
\pard{}{\f1{}{\i r1}|{\i r2}}\par
\pard\li720{}matches either {\i r1} or {\i r2} (alternation).\par
\par
\pard{}{\f1{}{\i r1r2}}\par
\pard\li720{}matches {\i r1}, and then {\i r2} (concatenation).\par
\par
\pard{}{\f1{}{\i r}+}\par
\pard\li720{}matches one or more {\i r}'s.\par
\par
\pard{}{\f1{}{\i r}*}\par
\pard\li720{}matches zero or more {\i r}'s.\par
\par
\pard{}{\f1{}{\i r}?}\par
\pard\li720{}matches zero or one {\i r}'s.\par
\par
\pard{}{\f1{}({\i r})}\par
\pard\li720{}matches {\i r} (grouping).\par
\par
\pard{}{\f1{}{\i r}\'7B{\i n}\'7D}\par
\pard{}{\f1{}{\i r}\'7B{\i n},\'7D}\par
\pard{}{\f1{}{\i r}\'7B{\i n},{\i m}\'7D}\par
\pard\li720{}matches at least {\i n}, {\i n} to any number, or {\i n} to {\i m} occurrences of {\i r} (interval expressions).\par
\par
\pard{}{\f1{}\'5Cy}\par
\pard\li720{}matches the empty string at either the beginning or the end of a word.\par
\par
\pard{}{\f1{}\'5CB}\par
\pard\li720{}matches the empty string within a word.\par
\par
\pard{}{\f1{}\'5C<}\par
\pard\li720{}matches the empty string at the beginning of a word.\par
\par
\pard{}{\f1{}\'5C>}\par
\pard\li720{}matches the empty string at the end of a word.\par
\par
\pard{}{\f1{}\'5Cw}\par
\pard\li720{}matches any word-constituent character (alphanumeric characters and the underscore).\par
\par
\pard{}{\f1{}\'5CW}\par
\pard\li720{}matches any character that is not word-constituent.\par
\par
\pard{}{\f1{}\'5C`}\par
\pard\li720{}matches the empty string at the beginning of a buffer (same as a string in {\f1{}gawk}).\par
\par
\pard{}{\f1{}\'5C'}\par
\pard\li720{}matches the empty string at the end of a buffer.\par
\pard{}}\par
\pard{}The various command line options control how {\f1{}gawk} interprets characters in regexps.\par
\par
{\pard{}No options\par
\pard\li720{}In the default case, {\f1{}gawk} provide all the facilities of POSIX regexps and the GNU regexp operators described above.  However, interval expressions are not supported.\par
\par
\pard{}{\f1{}--posix}\par
\pard\li720{}Only POSIX regexps are supported, the GNU operators are not special (e.g., {\f1{}\'5Cw} matches a literal {\f1{}w}).  Interval expressions are allowed.\par
\par
\pard{}{\f1{}--traditional}\par
\pard\li720{}Traditional Unix {\f1{}awk} regexps are matched. The GNU operators are not special, interval expressions are not available, and neither are the POSIX character classes ({\f1{}[[:alnum:]]} and so on).  Characters described by octal and hexadecimal escape sequences are treated literally, even if they represent regexp metacharacters.\par
\par
\pard{}{\f1{}--re-interval}\par
\pard\li720{}Allow interval expressions in regexps, even if {\f1{}--traditional} has been provided.\par
\pard{}}\par
\pard{}See {\uldb Regular Expressions}{\v Regexp}.\par
\par
\page\pard Node: {\b Actions Summary}, \keepn Next: {\uldb Functions Summary}{\v Functions_Summary}, Prev: {\uldb Rules Summary}{\v Rules_Summary}, Up: {\uldb Gawk Summary}{\v Gawk_Summary}\line
K{\footnote K Actions Summary}
#{\footnote Actions_Summary}
${\footnote \pard{}Actions}\par
\pard{\fs24\b Actions}\par
\par
\pard{}Action statements are enclosed in braces, {\f1{}\'7B} and {\f1{}\'7D}.  A missing action statement is equivalent to {\f1{}\'7B print \'7D}.\par
\par
\pard{}Action statements consist of the usual assignment, conditional, and looping statements found in most languages.  The operators, control statements, and Input/Output statements available are similar to those in C.\par
\par
\pard{}Comments begin with the {\f1{}#} character, and continue until the end of the line.  Blank lines may be used to separate statements.  Statements normally end with a newline; however, this is not the case for lines ending in a {\f1{},}, {\f1{}\'7B}, {\f1{}?}, {\f1{}:}, {\f1{}&&}, or {\f1{}||}.  Lines ending in {\f1{}do} or {\f1{}else} also have their statements automatically continued on the following line.  In other cases, a line can be continued by ending it with a {\f1{}\'5C}, in which case the newline is ignored.\par
\par
\pard{}Multiple statements may be put on one line by separating each one with a {\f1{};}.  This applies to both the statements within the action part of a rule (the usual case), and to the rule statements.\par
\par
\pard{}See {\uldb Comments in {\f1{}awk} Programs}{\v Comments}, for information on {\f1{}awk}'s commenting convention; see {\uldb {\f1{}awk} Statements Versus Lines}{\v Statements_Lines}, for a description of the line continuation mechanism in {\f1{}awk}.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Operator Summary}{\v Operator_Summary}\tab {\f1{}awk} operators.\par
{\uldb Control Flow Summary}{\v Control_Flow_Summary}\tab The control statements.\par
{\uldb I/O Summary}{\v I_O_Summary}\tab The I/O statements.\par
{\uldb Printf Summary}{\v Printf_Summary}\tab A summary of {\f1{}printf}.\par
{\uldb Special File Summary}{\v Special_File_Summary}\tab Special file names interpreted internally.\par
{\uldb Built-in Functions Summary}{\v Built_in_Functions_Summary}\tab Built-in numeric and string functions.\par
{\uldb Time Functions Summary}{\v Time_Functions_Summary}\tab Built-in time functions.\par
{\uldb String Constants Summary}{\v String_Constants_Summary}\tab Escape sequences in strings.\par
\pard{}}\par
\page\pard Node: {\b Operator Summary}, \keepn Next: {\uldb Control Flow Summary}{\v Control_Flow_Summary}, Prev: {\uldb Actions Summary}{\v Actions_Summary}, Up: {\uldb Actions Summary}{\v Actions_Summary}\line
K{\footnote K Operator Summary}
#{\footnote Operator_Summary}
${\footnote \pard{}Operators}\par
\pard{\fs24\b Operators}\par
\par
\pard{}The operators in {\f1{}awk}, in order of decreasing precedence, are:\par
\par
{\pard{}{\f1{}(...)}\par
\pard\li720{}Grouping.\par
\par
\pard{}{\f1{}$}\par
\pard\li720{}Field reference.\par
\par
\pard{}{\f1{}++ --}\par
\pard\li720{}Increment and decrement, both prefix and postfix.\par
\par
\pard{}{\f1{}^}\par
\pard\li720{}Exponentiation ({\f1{}**} may also be used, and {\f1{}**=} for the assignment operator, but they are not specified in the POSIX standard).\par
\par
\pard{}{\f1{}+ - !}\par
\pard\li720{}Unary plus, unary minus, and logical negation.\par
\par
\pard{}{\f1{}* / %}\par
\pard\li720{}Multiplication, division, and modulus.\par
\par
\pard{}{\f1{}+ -}\par
\pard\li720{}Addition and subtraction.\par
\par
\pard{}{\f1{}{\i space}}\par
\pard\li720{}String concatenation.\par
\par
\pard{}{\f1{}< <= > >= != ==}\par
\pard\li720{}The usual relational operators.\par
\par
\pard{}{\f1{}~ !~}\par
\pard\li720{}Regular expression match, negated match.\par
\par
\pard{}{\f1{}in}\par
\pard\li720{}Array membership.\par
\par
\pard{}{\f1{}&&}\par
\pard\li720{}Logical "and".\par
\par
\pard{}{\f1{}||}\par
\pard\li720{}Logical "or".\par
\par
\pard{}{\f1{}?:}\par
\pard\li720{}A conditional expression.  This has the form {\f1{}{\i expr1} ?  {\i expr2} : {\i expr3}}.  If {\i expr1} is true, the value of the expression is {\i expr2}; otherwise it is {\i expr3}.  Only one of {\i expr2} and {\i expr3} is evaluated.\par
\par
\pard{}{\f1{}= += -= *= /= %= ^=}\par
\pard\li720{}Assignment.  Both absolute assignment ({\f1{}{\i var}={\i value}}) and operator assignment (the other forms) are supported.\par
\pard{}}\par
\pard{}See {\uldb Expressions}{\v Expressions}.\par
\par
\page\pard Node: {\b Control Flow Summary}, \keepn Next: {\uldb I/O Summary}{\v I_O_Summary}, Prev: {\uldb Operator Summary}{\v Operator_Summary}, Up: {\uldb Actions Summary}{\v Actions_Summary}\line
K{\footnote K Control Flow Summary}
#{\footnote Control_Flow_Summary}
${\footnote \pard{}Control Statements}\par
\pard{\fs24\b Control Statements}\par
\par
\pard{}The control statements are as follows:\par
\par
{\pard\keep\li720\f1{}if ({\i condition}) {\i statement} [ else {\i statement} ]\line
while ({\i condition}) {\i statement}\line
do {\i statement} while ({\i condition})\line
for ({\i expr1}; {\i expr2}; {\i expr3}) {\i statement}\line
for ({\i var} in {\i array}) {\i statement}\line
break\line
continue\line
delete {\i array}[{\i index}]\line
delete {\i array}\line
exit [ {\i expression} ]\line
\'7B {\i statements} \'7D\par
\pard\f0{}}\par
\pard{}See {\uldb Control Statements in Actions}{\v Statements}.\par
\par
\page\pard Node: {\b I/O Summary}, \keepn Next: {\uldb Printf Summary}{\v Printf_Summary}, Prev: {\uldb Control Flow Summary}{\v Control_Flow_Summary}, Up: {\uldb Actions Summary}{\v Actions_Summary}\line
K{\footnote K I/O Summary}
#{\footnote I_O_Summary}
${\footnote \pard{}I/O Statements}\par
\pard{\fs24\b I/O Statements}\par
\par
\pard{}The Input/Output statements are as follows:\par
\par
{\pard{}{\f1{}getline}\par
\pard\li720{}Set {\f1{}$0} from next input record; set {\f1{}NF}, {\f1{}NR}, {\f1{}FNR}.  See {\uldb Explicit Input with {\f1{}getline}}{\v Getline}.\par
\par
\pard{}{\f1{}getline <{\i file}}\par
\pard\li720{}Set {\f1{}$0} from next record of {\i file}; set {\f1{}NF}.\par
\par
\pard{}{\f1{}getline {\i var}}\par
\pard\li720{}Set {\i var} from next input record; set {\f1{}NR}, {\f1{}FNR}.\par
\par
\pard{}{\f1{}getline {\i var} <{\i file}}\par
\pard\li720{}Set {\i var} from next record of {\i file}.\par
\par
\pard{}{\f1{}{\i command} | getline}\par
\pard\li720{}Run {\i command}, piping its output into {\f1{}getline}; sets {\f1{}$0}, {\f1{}NF}, {\f1{}NR}.\par
\par
\pard{}{\f1{}{\i command} | getline {\f1{}var}}\par
\pard\li720{}Run {\i command}, piping its output into {\f1{}getline}; sets {\i var}.\par
\par
\pard{}{\f1{}next}\par
\pard\li720{}Stop processing the current input record.  The next input record is read and processing starts over with the first pattern in the {\f1{}awk} program.  If the end of the input data is reached, the {\f1{}END} rule(s), if any, are executed.  See {\uldb The {\f1{}next} Statement}{\v Next_Statement}.\par
\par
\pard{}{\f1{}nextfile}\par
\pard\li720{}Stop processing the current input file.  The next input record read comes from the next input file.  {\f1{}FILENAME} is updated, {\f1{}FNR} is set to one, {\f1{}ARGIND} is incremented, and processing starts over with the first pattern in the {\f1{}awk} program.  If the end of the input data is reached, the {\f1{}END} rule(s), if any, are executed.  Earlier versions of {\f1{}gawk} used {\f1{}next file}; this usage is still supported, but is considered to be deprecated.  See {\uldb The {\f1{}nextfile} Statement}{\v Nextfile_Statement}.\par
\par
\pard{}{\f1{}print}\par
\pard\li720{}Prints the current record.  See {\uldb Printing Output}{\v Printing}.\par
\par
\pard{}{\f1{}print {\i expr-list}}\par
\pard\li720{}Prints expressions.\par
\par
\pard{}{\f1{}print {\i expr-list} > {\i file}}\par
\pard\li720{}Prints expressions to {\i file}. If {\i file} does not exist, it is created. If it does exist, its contents are deleted the first time the {\f1{}print} is executed.\par
\par
\pard{}{\f1{}print {\i expr-list} >> {\i file}}\par
\pard\li720{}Prints expressions to {\i file}.  The previous contents of {\i file} are retained, and the output of {\f1{}print} is appended to the file.\par
\par
\pard{}{\f1{}print {\i expr-list} | {\i command}}\par
\pard\li720{}Prints expressions, sending the output down a pipe to {\i command}.  The pipeline to the command stays open until the {\f1{}close} function is called.\par
\par
\pard{}{\f1{}printf {\i fmt, expr-list}}\par
\pard\li720{}Format and print.\par
\par
\pard{}{\f1{}printf {\i fmt, expr-list} > file}\par
\pard\li720{}Format and print to {\i file}. If {\i file} does not exist, it is created. If it does exist, its contents are deleted the first time the {\f1{}printf} is executed.\par
\par
\pard{}{\f1{}printf {\i fmt, expr-list} >> {\i file}}\par
\pard\li720{}Format and print to {\i file}.  The previous contents of {\i file} are retained, and the output of {\f1{}printf} is appended to the file.\par
\par
\pard{}{\f1{}printf {\i fmt, expr-list} | {\i command}}\par
\pard\li720{}Format and print, sending the output down a pipe to {\i command}.  The pipeline to the command stays open until the {\f1{}close} function is called.\par
\pard{}}\par
{\f1{}\pard{}getline} returns zero on end of file, and -1 on an error.  In the event of an error, {\f1{}getline} will set {\f1{}ERRNO} to the value of a system-dependent string that describes the error.\par
\par
\page\pard Node: {\b Printf Summary}, \keepn Next: {\uldb Special File Summary}{\v Special_File_Summary}, Prev: {\uldb I/O Summary}{\v I_O_Summary}, Up: {\uldb Actions Summary}{\v Actions_Summary}\line
K{\footnote K Printf Summary}
#{\footnote Printf_Summary}
${\footnote {\f1{}\pard{}printf} Summary}\par
\pard{\fs24\b {\f1{}printf} Summary}\par
\par
\pard{}Conversion specification have the form {\f1{}%}[{\i flag}][{\i width}][{\f1{}.}{\i prec}]{\i format}.  Items in brackets are optional.\par
\par
\pard{}The {\f1{}awk} {\f1{}printf} statement and {\f1{}sprintf} function accept the following conversion specification formats:\par
\par
{\pard{}{\f1{}%c}\par
\pard\li720{}An ASCII character.  If the argument used for {\f1{}%c} is numeric, it is treated as a character and printed.  Otherwise, the argument is assumed to be a string, and the only first character of that string is printed.\par
\par
\pard{}{\f1{}%d}\par
\pard{}{\f1{}%i}\par
\pard\li720{}A decimal number (the integer part).\par
\par
\pard{}{\f1{}%e}\par
\pard{}{\f1{}%E}\par
\pard\li720{}A floating point number of the form {\f1{}[-]d.dddddde[+-]dd}.  The {\f1{}%E} format uses {\f1{}E} instead of {\f1{}e}.\par
\par
\pard{}{\f1{}%f}\par
\pard\li720{}A floating point number of the form [{\f1{}-}]{\f1{}ddd.dddddd}.\par
\par
\pard{}{\f1{}%g}\par
\pard{}{\f1{}%G}\par
\pard\li720{}Use either the {\f1{}%e} or {\f1{}%f} formats, whichever produces a shorter string, with non-significant zeros suppressed.  {\f1{}%G} will use {\f1{}%E} instead of {\f1{}%e}.\par
\par
\pard{}{\f1{}%o}\par
\pard\li720{}An unsigned octal number (again, an integer).\par
\par
\pard{}{\f1{}%s}\par
\pard\li720{}A character string.\par
\par
\pard{}{\f1{}%x}\par
\pard{}{\f1{}%X}\par
\pard\li720{}An unsigned hexadecimal number (an integer).  The {\f1{}%X} format uses {\f1{}A} through {\f1{}F} instead of {\f1{}a} through {\f1{}f} for decimal 10 through 15.\par
\par
\pard{}{\f1{}%%}\par
\pard\li720{}A single {\f1{}%} character; no argument is converted.\par
\pard{}}\par
\pard{}There are optional, additional parameters that may lie between the {\f1{}%} and the control letter:\par
\par
{\pard{}{\f1{}-}\par
\pard\li720{}The expression should be left-justified within its field.\par
\par
\pard{}{\f1{}{\i space}}\par
\pard\li720{}For numeric conversions, prefix positive values with a space, and negative values with a minus sign.\par
\par
\pard{}{\f1{}+}\par
\pard\li720{}The plus sign, used before the width modifier (see below), says to always supply a sign for numeric conversions, even if the data to be formatted is positive. The {\f1{}+} overrides the space modifier.\par
\par
\pard{}{\f1{}#}\par
\pard\li720{}Use an "alternate form" for certain control letters.  For {\f1{}o}, supply a leading zero.  For {\f1{}x}, and {\f1{}X}, supply a leading {\f1{}0x} or {\f1{}0X} for a non-zero result.  For {\f1{}e}, {\f1{}E}, and {\f1{}f}, the result will always contain a decimal point.  For {\f1{}g}, and {\f1{}G}, trailing zeros are not removed from the result.\par
\par
\pard{}{\f1{}0}\par
\pard\li720{}A leading {\f1{}0} (zero) acts as a flag, that indicates output should be padded with zeros instead of spaces.  This applies even to non-numeric output formats.  This flag only has an effect when the field width is wider than the value to be printed.\par
\par
\pard{}{\f1{}{\i width}}\par
\pard\li720{}The field should be padded to this width. The field is normally padded with spaces.  If the {\f1{}0} flag has been used, it is padded with zeros.\par
\par
\pard{}{\f1{}.{\i prec}}\par
\pard\li720{}A number that specifies the precision to use when printing.  For the {\f1{}e}, {\f1{}E}, and {\f1{}f} formats, this specifies the number of digits you want printed to the right of the decimal point.  For the {\f1{}g}, and {\f1{}G} formats, it specifies the maximum number of significant digits.  For the {\f1{}d}, {\f1{}o}, {\f1{}i}, {\f1{}u}, {\f1{}x}, and {\f1{}X} formats, it specifies the minimum number of digits to print.  For the {\f1{}s} format, it specifies the maximum number of characters from the string that should be printed.\par
\pard{}}\par
\pard{}Either or both of the {\i width} and {\i prec} values may be specified as {\f1{}*}.  In that case, the particular value is taken from the argument list.\par
\par
\pard{}See {\uldb Using {\f1{}printf} Statements for Fancier Printing}{\v Printf}.\par
\par
\page\pard Node: {\b Special File Summary}, \keepn Next: {\uldb Built-in Functions Summary}{\v Built_in_Functions_Summary}, Prev: {\uldb Printf Summary}{\v Printf_Summary}, Up: {\uldb Actions Summary}{\v Actions_Summary}\line
K{\footnote K Special File Summary}
#{\footnote Special_File_Summary}
${\footnote \pard{}Special File Names}\par
\pard{\fs24\b Special File Names}\par
\par
\pard{}When doing I/O redirection from either {\f1{}print} or {\f1{}printf} into a file, or via {\f1{}getline} from a file, {\f1{}gawk} recognizes certain special file names internally.  These file names allow access to open file descriptors inherited from {\f1{}gawk}'s parent process (usually the shell).  The file names are:\par
\par
{\pard{}{\f1{}/dev/stdin}\par
\pard\li720{}The standard input.\par
\par
\pard{}{\f1{}/dev/stdout}\par
\pard\li720{}The standard output.\par
\par
\pard{}{\f1{}/dev/stderr}\par
\pard\li720{}The standard error output.\par
\par
\pard{}{\f1{}/dev/fd/{\i n}}\par
\pard\li720{}The file denoted by the open file descriptor {\i n}.\par
\pard{}}\par
\pard{}In addition, reading the following files provides process related information about the running {\f1{}gawk} program.  All returned records are terminated with a newline.\par
\par
{\pard{}{\f1{}/dev/pid}\par
\pard\li720{}Returns the process ID of the current process.\par
\par
\pard{}{\f1{}/dev/ppid}\par
\pard\li720{}Returns the parent process ID of the current process.\par
\par
\pard{}{\f1{}/dev/pgrpid}\par
\pard\li720{}Returns the process group ID of the current process.\par
\par
\pard{}{\f1{}/dev/user}\par
\pard\li720{}At least four space-separated fields, containing the return values of the {\f1{}getuid}, {\f1{}geteuid}, {\f1{}getgid}, and {\f1{}getegid} system calls.  If there are any additional fields, they are the group IDs returned by {\f1{}getgroups} system call.  (Multiple groups may not be supported on all systems.)\par
\pard{}}\par
\pard{}These file names may also be used on the command line to name data files.  These file names are only recognized internally if you do not actually have files with these names on your system.\par
\par
\pard{}See {\uldb Special File Names in {\f1{}gawk}}{\v Special_Files}, for a longer description that provides the motivation for this feature.\par
\par
\page\pard Node: {\b Built-in Functions Summary}, \keepn Next: {\uldb Time Functions Summary}{\v Time_Functions_Summary}, Prev: {\uldb Special File Summary}{\v Special_File_Summary}, Up: {\uldb Actions Summary}{\v Actions_Summary}\line
K{\footnote K Built-in Functions Summary}
#{\footnote Built_in_Functions_Summary}
${\footnote \pard{}Built-in Functions}\par
\pard{\fs24\b Built-in Functions}\par
\par
{\f1{}\pard{}awk} provides a number of built-in functions for performing numeric operations, string related operations, and I/O related operations.\par
\par
\pard{}The built-in arithmetic functions are:\par
\par
{\pard{}{\f1{}atan2({\i y}, {\i x})}\par
\pard\li720{}the arctangent of {\i y/x} in radians.\par
\par
\pard{}{\f1{}cos({\i expr})}\par
\pard\li720{}the cosine of {\i expr}, which is in radians.\par
\par
\pard{}{\f1{}exp({\i expr})}\par
\pard\li720{}the exponential function ({\f1{}e ^ {\i expr}}).\par
\par
\pard{}{\f1{}int({\i expr})}\par
\pard\li720{}truncates to integer.\par
\par
\pard{}{\f1{}log({\i expr})}\par
\pard\li720{}the natural logarithm of {\f1{}expr}.\par
\par
\pard{}{\f1{}rand()}\par
\pard\li720{}a random number between zero and one.\par
\par
\pard{}{\f1{}sin({\i expr})}\par
\pard\li720{}the sine of {\i expr}, which is in radians.\par
\par
\pard{}{\f1{}sqrt({\i expr})}\par
\pard\li720{}the square root function.\par
\par
\pard{}{\f1{}srand([{\i expr}])}\par
\pard\li720{}use {\i expr} as a new seed for the random number generator.  If no {\i expr} is provided, the time of day is used.  The return value is the previous seed for the random number generator.\par
\pard{}}\par
{\f1{}\pard{}awk} has the following built-in string functions:\par
\par
{\pard{}{\f1{}gensub({\i regex}, {\i subst}, {\i how} [, {\i target}])}\par
\pard\li720{}If {\i how} is a string beginning with {\f1{}g} or {\f1{}G}, then replace each match of {\i regex} in {\i target} with {\i subst}.  Otherwise, replace the {\i how}'th occurrence. If {\i target} is not supplied, use {\f1{}$0}.  The return value is the changed string; the original {\i target} is not modified. Within {\i subst}, {\f1{}\'5C{\i n}}, where {\i n} is a digit from one to nine, can be used to indicate the text that matched the {\i n}'th parenthesized subexpression.  This function is {\f1{}gawk}-specific.\par
\par
\pard{}{\f1{}gsub({\i regex}, {\i subst} [, {\i target}])}\par
\pard\li720{}for each substring matching the regular expression {\i regex} in the string {\i target}, substitute the string {\i subst}, and return the number of substitutions. If {\i target} is not supplied, use {\f1{}$0}.\par
\par
\pard{}{\f1{}index({\i str}, {\i search})}\par
\pard\li720{}returns the index of the string {\i search} in the string {\i str}, or zero if {\i search} is not present.\par
\par
\pard{}{\f1{}length([{\i str}])}\par
\pard\li720{}returns the length of the string {\i str}.  The length of {\f1{}$0} is returned if no argument is supplied.\par
\par
\pard{}{\f1{}match({\i str}, {\i regex})}\par
\pard\li720{}returns the position in {\i str} where the regular expression {\i regex} occurs, or zero if {\i regex} is not present, and sets the values of {\f1{}RSTART} and {\f1{}RLENGTH}.\par
\par
\pard{}{\f1{}split({\i str}, {\i arr} [, {\i regex}])}\par
\pard\li720{}splits the string {\i str} into the array {\i arr} on the regular expression {\i regex}, and returns the number of elements.  If {\i regex} is omitted, {\f1{}FS} is used instead. {\i regex} can be the null string, causing each character to be placed into its own array element.  The array {\i arr} is cleared first.\par
\par
\pard{}{\f1{}sprintf({\i fmt}, {\i expr-list})}\par
\pard\li720{}prints {\i expr-list} according to {\i fmt}, and returns the resulting string.\par
\par
\pard{}{\f1{}sub({\i regex}, {\i subst} [, {\i target}])}\par
\pard\li720{}just like {\f1{}gsub}, but only the first matching substring is replaced.\par
\par
\pard{}{\f1{}substr({\i str}, {\i index} [, {\i len}])}\par
\pard\li720{}returns the {\i len}-character substring of {\i str} starting at {\i index}.  If {\i len} is omitted, the rest of {\i str} is used.\par
\par
\pard{}{\f1{}tolower({\i str})}\par
\pard\li720{}returns a copy of the string {\i str}, with all the upper-case characters in {\i str} translated to their corresponding lower-case counterparts.  Non-alphabetic characters are left unchanged.\par
\par
\pard{}{\f1{}toupper({\i str})}\par
\pard\li720{}returns a copy of the string {\i str}, with all the lower-case characters in {\i str} translated to their corresponding upper-case counterparts.  Non-alphabetic characters are left unchanged.\par
\pard{}}\par
\pard{}The I/O related functions are:\par
\par
{\pard{}{\f1{}close({\i expr})}\par
\pard\li720{}Close the open file or pipe denoted by {\i expr}.\par
\par
\pard{}{\f1{}fflush([{\i expr}])}\par
\pard\li720{}Flush any buffered output for the output file or pipe denoted by {\i expr}.  If {\i expr} is omitted, standard output is flushed.  If {\i expr} is the null string ({\f1{}""}), all output buffers are flushed.\par
\par
\pard{}{\f1{}system({\i cmd-line})}\par
\pard\li720{}Execute the command {\i cmd-line}, and return the exit status.  If your operating system does not support {\f1{}system}, calling it will generate a fatal error.\par
\par
{\f1{}\pard\li720{}system("")} can be used to force {\f1{}awk} to flush any pending output.  This is more portable, but less obvious, than calling {\f1{}fflush}.\par
\pard{}}\par
\page\pard Node: {\b Time Functions Summary}, \keepn Next: {\uldb String Constants Summary}{\v String_Constants_Summary}, Prev: {\uldb Built-in Functions Summary}{\v Built_in_Functions_Summary}, Up: {\uldb Actions Summary}{\v Actions_Summary}\line
K{\footnote K Time Functions Summary}
#{\footnote Time_Functions_Summary}
${\footnote \pard{}Time Functions}\par
\pard{\fs24\b Time Functions}\par
\par
\pard{}The following two functions are available for getting the current time of day, and for formatting time stamps.  They are specific to {\f1{}gawk}.\par
\par
{\pard{}{\f1{}systime()}\par
\pard\li720{}returns the current time of day as the number of seconds since a particular epoch (Midnight, January 1, 1970 UTC, on POSIX systems).\par
\par
\pard{}{\f1{}strftime([{\i format}[, {\i timestamp}]])}\par
\pard\li720{}formats {\i timestamp} according to the specification in {\i format}.  The current time of day is used if no {\i timestamp} is supplied.  A default format equivalent to the output of the {\f1{}date} utility is used if no {\i format} is supplied.  See {\uldb Functions for Dealing with Time Stamps}{\v Time_Functions}, for the details on the conversion specifiers that {\f1{}strftime} accepts.\par
\pard{}}\par
\page\pard Node: {\b String Constants Summary}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Time Functions Summary}{\v Time_Functions_Summary}, Up: {\uldb Actions Summary}{\v Actions_Summary}\line
K{\footnote K String Constants Summary}
#{\footnote String_Constants_Summary}
${\footnote \pard{}String Constants}\par
\pard{\fs24\b String Constants}\par
\par
\pard{}String constants in {\f1{}awk} are sequences of characters enclosed in double quotes ({\f1{}"}).  Within strings, certain \'A2escape sequences\'A2 are recognized, as in C.  These are:\par
\par
{\pard{}{\f1{}\'5C\'5C}\par
\pard\li720{}A literal backslash.\par
\par
\pard{}{\f1{}\'5Ca}\par
\pard\li720{}The "alert" character; usually the ASCII BEL character.\par
\par
\pard{}{\f1{}\'5Cb}\par
\pard\li720{}Backspace.\par
\par
\pard{}{\f1{}\'5Cf}\par
\pard\li720{}Formfeed.\par
\par
\pard{}{\f1{}\'5Cn}\par
\pard\li720{}Newline.\par
\par
\pard{}{\f1{}\'5Cr}\par
\pard\li720{}Carriage return.\par
\par
\pard{}{\f1{}\'5Ct}\par
\pard\li720{}Horizontal tab.\par
\par
\pard{}{\f1{}\'5Cv}\par
\pard\li720{}Vertical tab.\par
\par
\pard{}{\f1{}\'5Cx{\i hex digits}}\par
\pard\li720{}The character represented by the string of hexadecimal digits following the {\f1{}\'5Cx}.  As in ANSI C, all following hexadecimal digits are considered part of the escape sequence.  E.g., {\f1{}"\'5Cx1B"} is a string containing the ASCII ESC (escape) character.  (The {\f1{}\'5Cx} escape sequence is not in POSIX {\f1{}awk}.)\par
\par
\pard{}{\f1{}\'5C{\i ddd}}\par
\pard\li720{}The character represented by the one, two, or three digit sequence of octal digits.  Thus, {\f1{}"\'5C033"} is also a string containing the ASCII ESC (escape) character.\par
\par
\pard{}{\f1{}\'5C{\i c}}\par
\pard\li720{}The literal character {\i c}, if {\i c} is not one of the above.\par
\pard{}}\par
\pard{}The escape sequences may also be used inside constant regular expressions (e.g., the regexp {\f1{}/[ \'5Ct\'5Cf\'5Cn\'5Cr\'5Cv]/} matches whitespace characters).\par
\par
\pard{}See {\uldb Escape Sequences}{\v Escape_Sequences}.\par
\par
\page\pard Node: {\b Functions Summary}, \keepn Next: {\uldb Historical Features}{\v Historical_Features}, Prev: {\uldb Actions Summary}{\v Actions_Summary}, Up: {\uldb Gawk Summary}{\v Gawk_Summary}\line
K{\footnote K Functions Summary}
#{\footnote Functions_Summary}
${\footnote \pard{}User-defined Functions}\par
\pard{\fs24\b User-defined Functions}\par
\par
\pard{}Functions in {\f1{}awk} are defined as follows:\par
\par
{\pard\keep\li720\f1{}function {\i name}({\i parameter list}) \'7B {\i statements} \'7D\par
\pard\f0{}}\par
\pard{}Actual parameters supplied in the function call are used to instantiate the formal parameters declared in the function.  Arrays are passed by reference, other variables are passed by value.\par
\par
\pard{}If there are fewer arguments passed than there are names in {\i parameter-list}, the extra names are given the null string as their value.  Extra names have the effect of local variables.\par
\par
\pard{}The open-parenthesis in a function call of a user-defined function must immediately follow the function name, without any intervening white space.  This is to avoid a syntactic ambiguity with the concatenation operator.\par
\par
\pard{}The word {\f1{}func} may be used in place of {\f1{}function} (but not in POSIX {\f1{}awk}).\par
\par
\pard{}Use the {\f1{}return} statement to return a value from a function.\par
\par
\pard{}See {\uldb User-defined Functions}{\v User_defined}.\par
\par
\page\pard Node: {\b Historical Features}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Functions Summary}{\v Functions_Summary}, Up: {\uldb Gawk Summary}{\v Gawk_Summary}\line
K{\footnote K Historical Features}
#{\footnote Historical_Features}
${\footnote \pard{}Historical Features}\par
\pard{\fs24\b Historical Features}\par
\par
\pard{}{K{\footnote K historical features}}There are two features of historical {\f1{}awk} implementations that {\f1{}gawk} supports.\par
\par
\pard{}First, it is possible to call the {\f1{}length} built-in function not only with no arguments, but even without parentheses!\par
\par
{\pard\keep\li720\f1{}a = length\par
\pard\f0{}}\par
\pard{}is the same as either of\par
\par
{\pard\keep\li720\f1{}a = length()\line
a = length($0)\par
\pard\f0{}}\par
\pard{}For example:\par
\par
{\pard\keep\li720\f1{}$ echo abcdef | awk '\'7B print length \'7D'\line
-| 6\par
\pard\f0{}}\par
\pard{}This feature is marked as "deprecated" in the POSIX standard, and {\f1{}gawk} will issue a warning about its use if {\f1{}--lint} is specified on the command line.  (The ability to use {\f1{}length} this way was actually an accident of the original Unix {\f1{}awk} implementation.  If any built-in function used {\f1{}$0} as its default argument, it was possible to call that function without the parentheses.  In particular, it was common practice to use the {\f1{}length} function in this fashion, and this usage was documented in the {\f1{}awk} manual page.)\par
\par
\pard{}The other historical feature is the use of either the {\f1{}break} statement, or the {\f1{}continue} statement outside the body of a {\f1{}while}, {\f1{}for}, or {\f1{}do} loop.  Traditional {\f1{}awk} implementations have treated such usage as equivalent to the {\f1{}next} statement.  More recent versions of Unix {\f1{}awk} do not allow it. {\f1{}gawk} supports this usage if {\f1{}--traditional} has been specified.\par
\par
\pard{}See {\uldb Command Line Options}{\v Options}, for more information about the {\f1{}--posix} and {\f1{}--lint} options.\par
\par
\page\pard Node: {\b Installation}, \keepn Next: {\uldb Notes}{\v Notes}, Prev: {\uldb Gawk Summary}{\v Gawk_Summary}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Installation}
#{\footnote Installation}
${\footnote \pard{}Installing {\f1{}gawk}}\par
\pard{\fs24\b Installing {\f1{}gawk}}\par
\par
\pard{}This appendix provides instructions for installing {\f1{}gawk} on the various platforms that are supported by the developers.  The primary developers support Unix (and one day, GNU), while the other ports were contributed.  The file {\f1{}ACKNOWLEDGMENT} in the {\f1{}gawk} distribution lists the electronic mail addresses of the people who did the respective ports, and they are also provided in {\uldb Reporting Problems and Bugs}{\v Bugs}.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Gawk Distribution}{\v Gawk_Distribution}\tab What is in the {\f1{}gawk} distribution.\par
{\uldb Unix Installation}{\v Unix_Installation}\tab Installing {\f1{}gawk} under various versions of Unix.\par
{\uldb VMS Installation}{\v VMS_Installation}\tab Installing {\f1{}gawk} on VMS.\par
{\uldb PC Installation}{\v PC_Installation}\tab Installing and Compiling {\f1{}gawk} on MS-DOS and OS/2\par
{\uldb Atari Installation}{\v Atari_Installation}\tab Installing {\f1{}gawk} on the Atari ST.\par
{\uldb Amiga Installation}{\v Amiga_Installation}\tab Installing {\f1{}gawk} on an Amiga.\par
{\uldb Bugs}{\v Bugs}\tab Reporting Problems and Bugs.\par
{\uldb Other Versions}{\v Other_Versions}\tab Other freely available {\f1{}awk} implementations.\par
\pard{}}\par
\page\pard Node: {\b Gawk Distribution}, \keepn Next: {\uldb Unix Installation}{\v Unix_Installation}, Prev: {\uldb Installation}{\v Installation}, Up: {\uldb Installation}{\v Installation}\line
K{\footnote K Gawk Distribution}
#{\footnote Gawk_Distribution}
${\footnote \pard{}The {\f1{}gawk} Distribution}\par
\pard{\fs24\b The {\f1{}gawk} Distribution}\par
\par
\pard{}This section first describes how to get the {\f1{}gawk} distribution, how to extract it, and then what is in the various files and subdirectories.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Getting}{\v Getting}\tab How to get the distribution.\par
{\uldb Extracting}{\v Extracting}\tab How to extract the distribution.\par
{\uldb Distribution contents}{\v Distribution_contents}\tab What is in the distribution.\par
\pard{}}\par
\page\pard Node: {\b Getting}, \keepn Next: {\uldb Extracting}{\v Extracting}, Prev: {\uldb Gawk Distribution}{\v Gawk_Distribution}, Up: {\uldb Gawk Distribution}{\v Gawk_Distribution}\line
K{\footnote K Getting}
#{\footnote Getting}
${\footnote \pard{}Getting the {\f1{}gawk} Distribution}\par
\pard{\fs24\b Getting the {\f1{}gawk} Distribution}\par
\par
\pard{}{K{\footnote K getting {\f1{}gawk}}}{K{\footnote K anonymous {\f1{}ftp}}}{K{\footnote K {\f1{}ftp}, anonymous}}{K{\footnote K Free Software Foundation}}There are three ways you can get GNU software.\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}1. \tab{}You can copy it from someone else who already has it.\par
\par
\pard\li720{}{K{\footnote K Free Software Foundation}}\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}2. \tab{}You can order {\f1{}gawk} directly from the Free Software Foundation.  Software distributions are available for Unix, MS-DOS, and VMS, on tape and CD-ROM.  The address is:\par
\par
{\pard\li1440{}Free Software Foundation\par
\pard\li1440{}59 Temple Place--Suite 330\par
\pard\li1440{}Boston, MA  02111-1307 USA\par
\pard\li1440{}Phone: +1-617-542-5942\par
\pard\li1440{}Fax (including Japan): +1-617-542-2652\par
\pard\li1440{}E-mail: {\f1{}gnu@gnu.org}\par
\pard\li720{}}\par
\pard\li720{}Ordering from the FSF directly contributes to the support of the foundation and to the production of more free software.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}3. \tab{}You can get {\f1{}gawk} by using anonymous {\f1{}ftp} to the Internet host {\f1{}gnudist.gnu.org}, in the directory {\f1{}/gnu/gawk}.\par
\par
\pard\li720{}Here is a list of alternate {\f1{}ftp} sites from which you can obtain GNU software.  When a site is listed as "{\i site}{\f1{}:}{\i directory}" the {\i directory} indicates the directory where GNU software is kept.  You should use a site that is geographically close to you.\par
\par
{\pard\li720{}Asia:\par
{
\pard\li1440{}{\f1{}cair-archive.kaist.ac.kr:/pub/gnu}\par
\pard\li1440{}{\f1{}ftp.cs.titech.ac.jp}\par
\pard\li1440{}{\f1{}ftp.nectec.or.th:/pub/mirrors/gnu}\par
\pard\li1440{}{\f1{}utsun.s.u-tokyo.ac.jp:/ftpsync/prep}\par
\pard\li1440{}}\par
\pard\li720{}Australia:\par
{
\pard\li1440{}{\f1{}archie.au:/gnu}\par
\pard\li2160{}({\f1{}archie.oz} or {\f1{}archie.oz.au} for ACSnet)\par
\pard\li1440{}}\par
\pard\li720{}Africa:\par
{
\pard\li1440{}{\f1{}ftp.sun.ac.za:/pub/gnu}\par
\pard\li1440{}}\par
\pard\li720{}Middle East:\par
{
\pard\li1440{}{\f1{}ftp.technion.ac.il:/pub/unsupported/gnu}\par
\pard\li1440{}}\par
\pard\li720{}Europe:\par
{
\pard\li1440{}{\f1{}archive.eu.net}\par
\pard\li1440{}{\f1{}ftp.denet.dk}\par
\pard\li1440{}{\f1{}ftp.eunet.ch}\par
\pard\li1440{}{\f1{}ftp.funet.fi:/pub/gnu}\par
\pard\li1440{}{\f1{}ftp.ieunet.ie:pub/gnu}\par
\pard\li1440{}{\f1{}ftp.informatik.rwth-aachen.de:/pub/gnu}\par
\pard\li1440{}{\f1{}ftp.informatik.tu-muenchen.de}\par
\pard\li1440{}{\f1{}ftp.luth.se:/pub/unix/gnu}\par
\pard\li1440{}{\f1{}ftp.mcc.ac.uk}\par
\pard\li1440{}{\f1{}ftp.stacken.kth.se}\par
\pard\li1440{}{\f1{}ftp.sunet.se:/pub/gnu}\par
\pard\li1440{}{\f1{}ftp.univ-lyon1.fr:pub/gnu}\par
\pard\li1440{}{\f1{}ftp.win.tue.nl:/pub/gnu}\par
\pard\li1440{}{\f1{}irisa.irisa.fr:/pub/gnu}\par
\pard\li1440{}{\f1{}isy.liu.se}\par
\pard\li1440{}{\f1{}nic.switch.ch:/mirror/gnu}\par
\pard\li1440{}{\f1{}src.doc.ic.ac.uk:/gnu}\par
\pard\li1440{}{\f1{}unix.hensa.ac.uk:/pub/uunet/systems/gnu}\par
\pard\li1440{}}\par
\pard\li720{}South America:\par
{
\pard\li1440{}{\f1{}ftp.inf.utfsm.cl:/pub/gnu}\par
\pard\li1440{}{\f1{}ftp.unicamp.br:/pub/gnu}\par
\pard\li1440{}}\par
\pard\li720{}Western Canada:\par
{
\pard\li1440{}{\f1{}ftp.cs.ubc.ca:/mirror2/gnu}\par
\pard\li1440{}}\par
\pard\li720{}USA:\par
{
\pard\li1440{}{\f1{}col.hp.com:/mirrors/gnu}\par
\pard\li1440{}{\f1{}f.ms.uky.edu:/pub3/gnu}\par
\pard\li1440{}{\f1{}ftp.cc.gatech.edu:/pub/gnu}\par
\pard\li1440{}{\f1{}ftp.cs.columbia.edu:/archives/gnu/prep}\par
\pard\li1440{}{\f1{}ftp.digex.net:/pub/gnu}\par
\pard\li1440{}{\f1{}ftp.hawaii.edu:/mirrors/gnu}\par
\pard\li1440{}{\f1{}ftp.kpc.com:/pub/mirror/gnu}\par
\pard\li1440{}}\par
\pard\li720{}USA (continued):\par
{\pard\li1440{}{\f1{}ftp.uu.net:/systems/gnu}\par
\pard\li1440{}{\f1{}gatekeeper.dec.com:/pub/GNU}\par
\pard\li1440{}{\f1{}jaguar.utah.edu:/gnustuff}\par
\pard\li1440{}{\f1{}labrea.stanford.edu}\par
\pard\li1440{}{\f1{}mrcnext.cso.uiuc.edu:/pub/gnu}\par
\pard\li1440{}{\f1{}vixen.cso.uiuc.edu:/gnu}\par
\pard\li1440{}{\f1{}wuarchive.wustl.edu:/systems/gnu}\par
\pard\li1440{}}}}\par
\page\pard Node: {\b Extracting}, \keepn Next: {\uldb Distribution contents}{\v Distribution_contents}, Prev: {\uldb Getting}{\v Getting}, Up: {\uldb Gawk Distribution}{\v Gawk_Distribution}\line
K{\footnote K Extracting}
#{\footnote Extracting}
${\footnote \pard{}Extracting the Distribution}\par
\pard{\fs24\b Extracting the Distribution}\par
\par
{\f1{}\pard{}gawk} is distributed as a {\f1{}tar} file compressed with the GNU Zip program, {\f1{}gzip}.\par
\par
\pard{}Once you have the distribution (for example, {\f1{}gawk-3.0.4.tar.gz}), first use {\f1{}gzip} to expand the file, and then use {\f1{}tar} to extract it.  You can use the following pipeline to produce the {\f1{}gawk} distribution:\par
\par
{\pard\keep\li720\f1{}# Under System V, add 'o' to the tar flags\line
gzip -d -c gawk-3.0.4.tar.gz | tar -xvpf -\par
\pard\f0{}}\par
\pard{}This will create a directory named {\f1{}gawk-3.0.4} in the current directory.\par
\par
\pard{}The distribution file name is of the form {\f1{}gawk-{\i V}.{\i R}.{\i n}.tar.gz}.  The {\i V} represents the major version of {\f1{}gawk}, the {\i R} represents the current release of version {\i V}, and the {\i n} represents a \'A2patch level\'A2, meaning that minor bugs have been fixed in the release.  The current patch level is 4, but when retrieving distributions, you should get the version with the highest version, release, and patch level.  (Note that release levels greater than or equal to 90 denote "beta," or non-production software; you may not wish to retrieve such a version unless you don't mind experimenting.)\par
\par
\pard{}If you are not on a Unix system, you will need to make other arrangements for getting and extracting the {\f1{}gawk} distribution.  You should consult a local expert.\par
\par
\page\pard Node: {\b Distribution contents}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Extracting}{\v Extracting}, Up: {\uldb Gawk Distribution}{\v Gawk_Distribution}\line
K{\footnote K Distribution contents}
#{\footnote Distribution_contents}
${\footnote \pard{}Contents of the {\f1{}gawk} Distribution}\par
\pard{\fs24\b Contents of the {\f1{}gawk} Distribution}\par
\par
\pard{}The {\f1{}gawk} distribution has a number of C source files, documentation files, subdirectories and files related to the configuration process (see {\uldb Compiling and Installing {\f1{}gawk} on Unix}{\v Unix_Installation}), and several subdirectories related to different, non-Unix, operating systems.\par
\par
{\pard{}various {\f1{}.c}, {\f1{}.y}, and {\f1{}.h} files\par
\pard\li720{}These files are the actual {\f1{}gawk} source code.\par
\pard{}}\par
{\pard{}{\f1{}README}\par
\pard{}{\f1{}README_d/README.*}\par
\pard\li720{}Descriptive files: {\f1{}README} for {\f1{}gawk} under Unix, and the rest for the various hardware and software combinations.\par
\par
\pard{}{\f1{}INSTALL}\par
\pard\li720{}A file providing an overview of the configuration and installation process.\par
\par
\pard{}{\f1{}PORTS}\par
\pard\li720{}A list of systems to which {\f1{}gawk} has been ported, and which have successfully run the test suite.\par
\par
\pard{}{\f1{}ACKNOWLEDGMENT}\par
\pard\li720{}A list of the people who contributed major parts of the code or documentation.\par
\par
\pard{}{\f1{}ChangeLog}\par
\pard\li720{}A detailed list of source code changes as bugs are fixed or improvements made.\par
\par
\pard{}{\f1{}NEWS}\par
\pard\li720{}A list of changes to {\f1{}gawk} since the last release or patch.\par
\par
\pard{}{\f1{}COPYING}\par
\pard\li720{}The GNU General Public License.\par
\par
\pard{}{\f1{}FUTURES}\par
\pard\li720{}A brief list of features and/or changes being contemplated for future releases, with some indication of the time frame for the feature, based on its difficulty.\par
\par
\pard{}{\f1{}LIMITATIONS}\par
\pard\li720{}A list of those factors that limit {\f1{}gawk}'s performance.  Most of these depend on the hardware or operating system software, and are not limits in {\f1{}gawk} itself.\par
\par
\pard{}{\f1{}POSIX.STD}\par
\pard\li720{}A description of one area where the POSIX standard for {\f1{}awk} is incorrect, and how {\f1{}gawk} handles the problem.\par
\par
\pard{}{\f1{}PROBLEMS}\par
\pard\li720{}A file describing known problems with the current release.\par
\par
\pard\li720{}{K{\footnote K artificial intelligence, using {\f1{}gawk}}}{K{\footnote K AI programming, using {\f1{}gawk}}}\par
\par
\pard{}{\f1{}doc/awkforai.txt}\par
\pard\li720{}A short article describing why {\f1{}gawk} is a good language for AI (Artificial Intelligence) programming.\par
\par
\pard{}{\f1{}doc/README.card}\par
\pard{}{\f1{}doc/ad.block}\par
\pard{}{\f1{}doc/awkcard.in}\par
\pard{}{\f1{}doc/cardfonts}\par
\pard{}{\f1{}doc/colors}\par
\pard{}{\f1{}doc/macros}\par
\pard{}{\f1{}doc/no.colors}\par
\pard{}{\f1{}doc/setter.outline}\par
\pard\li720{}The {\f1{}troff} source for a five-color {\f1{}awk} reference card.  A modern version of {\f1{}troff}, such as GNU Troff ({\f1{}groff}) is needed to produce the color version. See the file {\f1{}README.card} for instructions if you have an older {\f1{}troff}.\par
\par
\pard{}{\f1{}doc/gawk.1}\par
\pard\li720{}The {\f1{}troff} source for a manual page describing {\f1{}gawk}.  This is distributed for the convenience of Unix users.\par
\par
\pard{}{\f1{}doc/gawk.texi}\par
\pard\li720{}The Texinfo source file for this Info file.  It should be processed with TeX to produce a printed document, and with {\f1{}makeinfo} to produce an Info file.\par
\par
\pard{}{\f1{}doc/gawk.info}\par
\pard\li720{}The generated Info file for this Info file.\par
\par
\pard{}{\f1{}doc/igawk.1}\par
\pard\li720{}The {\f1{}troff} source for a manual page describing the {\f1{}igawk} program presented in {\uldb An Easy Way to Use Library Functions}{\v Igawk_Program}.\par
\par
\pard{}{\f1{}doc/Makefile.in}\par
\pard\li720{}The input file used during the configuration process to generate the actual {\f1{}Makefile} for creating the documentation.\par
\par
\pard{}{\f1{}Makefile.in}\par
\pard{}{\f1{}acconfig.h}\par
\pard{}{\f1{}aclocal.m4}\par
\pard{}{\f1{}configh.in}\par
\pard{}{\f1{}configure.in}\par
\pard{}{\f1{}configure}\par
\pard{}{\f1{}custom.h}\par
\pard{}{\f1{}missing/*}\par
\pard\li720{}These files and subdirectory are used when configuring {\f1{}gawk} for various Unix systems.  They are explained in detail in {\uldb Compiling and Installing {\f1{}gawk} on Unix}{\v Unix_Installation}.\par
\par
\pard{}{\f1{}awklib/extract.awk}\par
\pard{}{\f1{}awklib/Makefile.in}\par
\pard\li720{}The {\f1{}awklib} directory contains a copy of {\f1{}extract.awk} (see {\uldb Extracting Programs from Texinfo Source Files}{\v Extract_Program}), which can be used to extract the sample programs from the Texinfo source file for this Info file, and a {\f1{}Makefile.in} file, which {\f1{}configure} uses to generate a {\f1{}Makefile}.  As part of the process of building {\f1{}gawk}, the library functions from {\uldb A Library of {\f1{}awk} Functions}{\v Library_Functions}, and the {\f1{}igawk} program from {\uldb An Easy Way to Use Library Functions}{\v Igawk_Program}, are extracted into ready to use files.  They are installed as part of the installation process.\par
\par
\pard{}{\f1{}atari/*}\par
\pard\li720{}Files needed for building {\f1{}gawk} on an Atari ST.  See {\uldb Installing {\f1{}gawk} on the Atari ST}{\v Atari_Installation}, for details.\par
\par
\pard{}{\f1{}pc/*}\par
\pard\li720{}Files needed for building {\f1{}gawk} under MS-DOS and OS/2.  See {\uldb MS-DOS and OS/2 Installation and Compilation}{\v PC_Installation}, for details.\par
\par
\pard{}{\f1{}vms/*}\par
\pard\li720{}Files needed for building {\f1{}gawk} under VMS.  See {\uldb How to Compile and Install {\f1{}gawk} on VMS}{\v VMS_Installation}, for details.\par
\par
\pard{}{\f1{}test/*}\par
\pard\li720{}A test suite for {\f1{}gawk}.  You can use {\f1{}make check} from the top level {\f1{}gawk} directory to run your version of {\f1{}gawk} against the test suite.  If {\f1{}gawk} successfully passes {\f1{}make check} then you can be confident of a successful port.\par
\pard{}}\par
\page\pard Node: {\b Unix Installation}, \keepn Next: {\uldb VMS Installation}{\v VMS_Installation}, Prev: {\uldb Gawk Distribution}{\v Gawk_Distribution}, Up: {\uldb Installation}{\v Installation}\line
K{\footnote K Unix Installation}
#{\footnote Unix_Installation}
${\footnote \pard{}Compiling and Installing {\f1{}gawk} on Unix}\par
\pard{\fs24\b Compiling and Installing {\f1{}gawk} on Unix}\par
\par
\pard{}Usually, you can compile and install {\f1{}gawk} by typing only two commands.  However, if you do use an unusual system, you may need to configure {\f1{}gawk} for your system yourself.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Quick Installation}{\v Quick_Installation}\tab Compiling {\f1{}gawk} under Unix.\par
{\uldb Configuration Philosophy}{\v Configuration_Philosophy}\tab How it's all supposed to work.\par
\pard{}}\par
\page\pard Node: {\b Quick Installation}, \keepn Next: {\uldb Configuration Philosophy}{\v Configuration_Philosophy}, Prev: {\uldb Unix Installation}{\v Unix_Installation}, Up: {\uldb Unix Installation}{\v Unix_Installation}\line
K{\footnote K Quick Installation}
#{\footnote Quick_Installation}
${\footnote \pard{}Compiling {\f1{}gawk} for Unix}\par
\pard{\fs24\b Compiling {\f1{}gawk} for Unix}\par
\par
\pard{}{K{\footnote K installation, unix}}After you have extracted the {\f1{}gawk} distribution, {\f1{}cd} to {\f1{}gawk-3.0.4}.  Like most GNU software, {\f1{}gawk} is configured automatically for your Unix system by running the {\f1{}configure} program.  This program is a Bourne shell script that was generated automatically using GNU {\f1{}autoconf}.  {(The {\f1{}autoconf} software is described fully starting with {\uldb Introduction}{\v Top @autoconf.hlp}.)  }\par
\par
\pard{}To configure {\f1{}gawk}, simply run {\f1{}configure}:\par
\par
{\pard\keep\li720\f1{}sh ./configure\par
\pard\f0{}}\par
\pard{}This produces a {\f1{}Makefile} and {\f1{}config.h} tailored to your system.  The {\f1{}config.h} file describes various facts about your system.  You may wish to edit the {\f1{}Makefile} to change the {\f1{}CFLAGS} variable, which controls the command line options that are passed to the C compiler (such as optimization levels, or compiling for debugging).\par
\par
\pard{}Alternatively, you can add your own values for most {\f1{}make} variables, such as {\f1{}CC} and {\f1{}CFLAGS}, on the command line when running {\f1{}configure}:\par
\par
{\pard\keep\li720\f1{}CC=cc CFLAGS=-g sh ./configure\par
\pard\f0{}}\par
\pard{}See the file {\f1{}INSTALL} in the {\f1{}gawk} distribution for all the details.\par
\par
\pard{}After you have run {\f1{}configure}, and possibly edited the {\f1{}Makefile}, type:\par
\par
{\pard\keep\li720\f1{}make\par
\pard\f0{}}\par
\pard{}and shortly thereafter, you should have an executable version of {\f1{}gawk}.  That's all there is to it!  (If these steps do not work, please send in a bug report; see {\uldb Reporting Problems and Bugs}{\v Bugs}.)\par
\par
\page\pard Node: {\b Configuration Philosophy}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Quick Installation}{\v Quick_Installation}, Up: {\uldb Unix Installation}{\v Unix_Installation}\line
K{\footnote K Configuration Philosophy}
#{\footnote Configuration_Philosophy}
${\footnote \pard{}The Configuration Process}\par
\pard{\fs24\b The Configuration Process}\par
\par
\pard{}{K{\footnote K configuring {\f1{}gawk}}}(This section is of interest only if you know something about using the C language and the Unix operating system.)\par
\par
\pard{}The source code for {\f1{}gawk} generally attempts to adhere to formal standards wherever possible.  This means that {\f1{}gawk} uses library routines that are specified by the ANSI C standard and by the POSIX operating system interface standard.  When using an ANSI C compiler, function prototypes are used to help improve the compile-time checking.\par
\par
\pard{}Many Unix systems do not support all of either the ANSI or the POSIX standards.  The {\f1{}missing} subdirectory in the {\f1{}gawk} distribution contains replacement versions of those subroutines that are most likely to be missing.\par
\par
\pard{}The {\f1{}config.h} file that is created by the {\f1{}configure} program contains definitions that describe features of the particular operating system where you are attempting to compile {\f1{}gawk}.  The three things described by this file are what header files are available, so that they can be correctly included, what (supposedly) standard functions are actually available in your C libraries, and other miscellaneous facts about your variant of Unix.  For example, there may not be an {\f1{}st_blksize} element in the {\f1{}stat} structure.  In this case {\f1{}HAVE_ST_BLKSIZE} would be undefined.\par
\par
\pard{}{K{\footnote K {\f1{}custom.h} configuration file}}It is possible for your C compiler to lie to {\f1{}configure}. It may do so by not exiting with an error when a library function is not available.  To get around this, you can edit the file {\f1{}custom.h}.  Use an {\f1{}#ifdef} that is appropriate for your system, and either {\f1{}#define} any constants that {\f1{}configure} should have defined but didn't, or {\f1{}#undef} any constants that {\f1{}configure} defined and should not have.  {\f1{}custom.h} is automatically included by {\f1{}config.h}.\par
\par
\pard{}It is also possible that the {\f1{}configure} program generated by {\f1{}autoconf} will not work on your system in some other fashion.  If you do have a problem, the file {\f1{}configure.in} is the input for {\f1{}autoconf}.  You may be able to change this file, and generate a new version of {\f1{}configure} that will work on your system.  See {\uldb Reporting Problems and Bugs}{\v Bugs}, for information on how to report problems in configuring {\f1{}gawk}.  The same mechanism may be used to send in updates to {\f1{}configure.in} and/or {\f1{}custom.h}.\par
\par
\page\pard Node: {\b VMS Installation}, \keepn Next: {\uldb PC Installation}{\v PC_Installation}, Prev: {\uldb Unix Installation}{\v Unix_Installation}, Up: {\uldb Installation}{\v Installation}\line
K{\footnote K VMS Installation}
#{\footnote VMS_Installation}
${\footnote \pard{}How to Compile and Install {\f1{}gawk} on VMS}\par
\pard{\fs24\b How to Compile and Install {\f1{}gawk} on VMS}\par
\par
\pard{}{K{\footnote K installation, vms}}This section describes how to compile and install {\f1{}gawk} under VMS.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb VMS Compilation}{\v VMS_Compilation}\tab How to compile {\f1{}gawk} under VMS.\par
{\uldb VMS Installation Details}{\v VMS_Installation_Details}\tab How to install {\f1{}gawk} under VMS.\par
{\uldb VMS Running}{\v VMS_Running}\tab How to run {\f1{}gawk} under VMS.\par
{\uldb VMS POSIX}{\v VMS_POSIX}\tab Alternate instructions for VMS POSIX.\par
\pard{}}\par
\page\pard Node: {\b VMS Compilation}, \keepn Next: {\uldb VMS Installation Details}{\v VMS_Installation_Details}, Prev: {\uldb VMS Installation}{\v VMS_Installation}, Up: {\uldb VMS Installation}{\v VMS_Installation}\line
K{\footnote K VMS Compilation}
#{\footnote VMS_Compilation}
${\footnote \pard{}Compiling {\f1{}gawk} on VMS}\par
\pard{\fs24\b Compiling {\f1{}gawk} on VMS}\par
\par
\pard{}To compile {\f1{}gawk} under VMS, there is a {\f1{}DCL} command procedure that will issue all the necessary {\f1{}CC} and {\f1{}LINK} commands, and there is also a {\f1{}Makefile} for use with the {\f1{}MMS} utility.  From the source directory, use either\par
\par
{\pard\keep\li720\f1{}$ @[.VMS]VMSBUILD.COM\par
\pard\f0{}}\par
\pard{}or\par
\par
{\pard\keep\li720\f1{}$ MMS/DESCRIPTION=[.VMS]DESCRIP.MMS GAWK\par
\pard\f0{}}\par
\pard{}Depending upon which C compiler you are using, follow one of the sets of instructions in this table:\par
\par
{\pard{}VAX C V3.x\par
\pard\li720{}Use either {\f1{}vmsbuild.com} or {\f1{}descrip.mms} as is.  These use {\f1{}CC/OPTIMIZE=NOLINE}, which is essential for Version 3.0.\par
\par
\pard{}VAX C V2.x\par
\pard\li720{}You must have Version 2.3 or 2.4; older ones won't work.  Edit either {\f1{}vmsbuild.com} or {\f1{}descrip.mms} according to the comments in them.  For {\f1{}vmsbuild.com}, this just entails removing two {\f1{}!} delimiters.  Also edit {\f1{}config.h} (which is a copy of file {\f1{}[.config]vms-conf.h}) and comment out or delete the two lines {\f1{}#define __STDC__ 0} and {\f1{}#define VAXC_BUILTINS} near the end.\par
\par
\pard{}GNU C\par
\pard\li720{}Edit {\f1{}vmsbuild.com} or {\f1{}descrip.mms}; the changes are different from those for VAX C V2.x, but equally straightforward.  No changes to {\f1{}config.h} should be needed.\par
\par
\pard{}DEC C\par
\pard\li720{}Edit {\f1{}vmsbuild.com} or {\f1{}descrip.mms} according to their comments.  No changes to {\f1{}config.h} should be needed.\par
\pard{}}\par
{\f1{}\pard{}gawk} has been tested under VAX/VMS 5.5-1 using VAX C V3.2, GNU C 1.40 and 2.3.  It should work without modifications for VMS V4.6 and up.\par
\par
\page\pard Node: {\b VMS Installation Details}, \keepn Next: {\uldb VMS Running}{\v VMS_Running}, Prev: {\uldb VMS Compilation}{\v VMS_Compilation}, Up: {\uldb VMS Installation}{\v VMS_Installation}\line
K{\footnote K VMS Installation Details}
#{\footnote VMS_Installation_Details}
${\footnote \pard{}Installing {\f1{}gawk} on VMS}\par
\pard{\fs24\b Installing {\f1{}gawk} on VMS}\par
\par
\pard{}To install {\f1{}gawk}, all you need is a "foreign" command, which is a {\f1{}DCL} symbol whose value begins with a dollar sign. For example:\par
\par
{\pard\keep\li720\f1{}$ GAWK :== $disk1:[gnubin]GAWK\par
\pard\f0{}}\par
\pard{}(Substitute the actual location of {\f1{}gawk.exe} for {\f1{}$disk1:[gnubin]}.) The symbol should be placed in the {\f1{}login.com} of any user who wishes to run {\f1{}gawk}, so that it will be defined every time the user logs on.  Alternatively, the symbol may be placed in the system-wide {\f1{}sylogin.com} procedure, which will allow all users to run {\f1{}gawk}.\par
\par
\pard{}Optionally, the help entry can be loaded into a VMS help library:\par
\par
{\pard\keep\li720\f1{}$ LIBRARY/HELP SYS$HELP:HELPLIB [.VMS]GAWK.HLP\par
\pard\f0{}}\par
\pard{}(You may want to substitute a site-specific help library rather than the standard VMS library {\f1{}HELPLIB}.)  After loading the help text,\par
\par
{\pard\keep\li720\f1{}$ HELP GAWK\par
\pard\f0{}}\par
\pard{}will provide information about both the {\f1{}gawk} implementation and the {\f1{}awk} programming language.\par
\par
\pard{}The logical name {\f1{}AWK_LIBRARY} can designate a default location for {\f1{}awk} program files.  For the {\f1{}-f} option, if the specified filename has no device or directory path information in it, {\f1{}gawk} will look in the current directory first, then in the directory specified by the translation of {\f1{}AWK_LIBRARY} if the file was not found.  If after searching in both directories, the file still is not found, then {\f1{}gawk} appends the suffix {\f1{}.awk} to the filename and the file search will be re-tried.  If {\f1{}AWK_LIBRARY} is not defined, that portion of the file search will fail benignly.\par
\par
\page\pard Node: {\b VMS Running}, \keepn Next: {\uldb VMS POSIX}{\v VMS_POSIX}, Prev: {\uldb VMS Installation Details}{\v VMS_Installation_Details}, Up: {\uldb VMS Installation}{\v VMS_Installation}\line
K{\footnote K VMS Running}
#{\footnote VMS_Running}
${\footnote \pard{}Running {\f1{}gawk} on VMS}\par
\pard{\fs24\b Running {\f1{}gawk} on VMS}\par
\par
\pard{}Command line parsing and quoting conventions are significantly different on VMS, so examples in this Info file or from other sources often need minor changes.  They {\i are} minor though, and all {\f1{}awk} programs should run correctly.\par
\par
\pard{}Here are a couple of trivial tests:\par
\par
{\pard\keep\li720\f1{}$ gawk -- "BEGIN \'7Bprint ""Hello, World!""\'7D"\line
$ gawk -"W" version\line
! could also be -"W version" or "-W version"\par
\pard\f0{}}\par
\pard{}Note that upper-case and mixed-case text must be quoted.\par
\par
\pard{}The VMS port of {\f1{}gawk} includes a {\f1{}DCL}-style interface in addition to the original shell-style interface (see the help entry for details).  One side-effect of dual command line parsing is that if there is only a single parameter (as in the quoted string program above), the command becomes ambiguous.  To work around this, the normally optional {\f1{}--} flag is required to force Unix style rather than {\f1{}DCL} parsing.  If any other dash-type options (or multiple parameters such as data files to be processed) are present, there is no ambiguity and {\f1{}--} can be omitted.\par
\par
\pard{}The default search path when looking for {\f1{}awk} program files specified by the {\f1{}-f} option is {\f1{}"SYS$DISK:[],AWK_LIBRARY:"}.  The logical name {\f1{}AWKPATH} can be used to override this default.  The format of {\f1{}AWKPATH} is a comma-separated list of directory specifications.  When defining it, the value should be quoted so that it retains a single translation, and not a multi-translation {\f1{}RMS} searchlist.\par
\par
\page\pard Node: {\b VMS POSIX}, \keepn Next: {\uldb }{\v }, Prev: {\uldb VMS Running}{\v VMS_Running}, Up: {\uldb VMS Installation}{\v VMS_Installation}\line
K{\footnote K VMS POSIX}
#{\footnote VMS_POSIX}
${\footnote \pard{}Building and Using {\f1{}gawk} on VMS POSIX}\par
\pard{\fs24\b Building and Using {\f1{}gawk} on VMS POSIX}\par
\par
\pard{}Ignore the instructions above, although {\f1{}vms/gawk.hlp} should still be made available in a help library.  The source tree should be unpacked into a container file subsystem rather than into the ordinary VMS file system.  Make sure that the two scripts, {\f1{}configure} and {\f1{}vms/posix-cc.sh}, are executable; use {\f1{}chmod +x} on them if necessary.  Then execute the following two commands:\par
\par
{{\pard\keep\li720\f1{}psx> CC=vms/posix-cc.sh configure\line
psx> make CC=c89 gawk\par
\pard\keep\li720{}}}\par
\pard\f0{}The first command will construct files {\f1{}config.h} and {\f1{}Makefile} out of templates, using a script to make the C compiler fit {\f1{}configure}'s expectations.  The second command will compile and link {\f1{}gawk} using the C compiler directly; ignore any warnings from {\f1{}make} about being unable to redefine {\f1{}CC}.  {\f1{}configure} will take a very long time to execute, but at least it provides incremental feedback as it runs.\par
\par
\pard{}This has been tested with VAX/VMS V6.2, VMS POSIX V2.0, and DEC C V5.2.\par
\par
\pard{}Once built, {\f1{}gawk} will work like any other shell utility.  Unlike the normal VMS port of {\f1{}gawk}, no special command line manipulation is needed in the VMS POSIX environment.\par
\par
\page\pard Node: {\b PC Installation}, \keepn Next: {\uldb Atari Installation}{\v Atari_Installation}, Prev: {\uldb VMS Installation}{\v VMS_Installation}, Up: {\uldb Installation}{\v Installation}\line
K{\footnote K PC Installation}
#{\footnote PC_Installation}
${\footnote \pard{}MS-DOS and OS/2 Installation and Compilation}\par
\pard{\fs24\b MS-DOS and OS/2 Installation and Compilation}\par
\par
\pard{}{K{\footnote K installation, MS-DOS and OS/2}}If you have received a binary distribution prepared by the DOS maintainers, then {\f1{}gawk} and the necessary support files will appear under the {\f1{}gnu} directory, with executables in {\f1{}gnu/bin}, libraries in {\f1{}gnu/lib/awk}, and manual pages under {\f1{}gnu/man}.  This is designed for easy installation to a {\f1{}/gnu} directory on your drive, but the files can be installed anywhere provided {\f1{}AWKPATH} is set properly.  Regardless of the installation directory, the first line of {\f1{}igawk.cmd} and {\f1{}igawk.bat} (in {\f1{}gnu/bin}) may need to be edited.\par
\par
\pard{}The binary distribution will contain a separate file describing the contents. In particular, it may include more than one version of the {\f1{}gawk} executable. OS/2 binary distributions may have a different arrangement, but installation is similar.\par
\par
\pard{}The OS/2 and MS-DOS versions of {\f1{}gawk} search for program files as described in {\uldb The {\f1{}AWKPATH} Environment Variable}{\v AWKPATH_Variable}.  However, semicolons (rather than colons) separate elements in the {\f1{}AWKPATH} variable. If {\f1{}AWKPATH} is not set or is empty, then the default search path is {\f1{}".;c:/lib/awk;c:/gnu/lib/awk"}.\par
\par
\pard{}An {\f1{}sh}-like shell (as opposed to {\f1{}command.com} under MS-DOS or {\f1{}cmd.exe} under OS/2) may be useful for {\f1{}awk} programming.  Ian Stewartson has written an excellent shell for MS-DOS and OS/2, and a {\f1{}ksh} clone and GNU Bash are available for OS/2. The file {\f1{}README_d/README.pc} in the {\f1{}gawk} distribution contains information on these shells. Users of Stewartson's shell on DOS should examine its documentation on handling of command-lines. In particular, the setting for {\f1{}gawk} in the shell configuration may need to be changed, and the {\f1{}ignoretype} option may also be of interest.\par
\par
{\f1{}\pard{}gawk} can be compiled for MS-DOS and OS/2 using the GNU development tools from DJ Delorie (DJGPP, MS-DOS-only) or Eberhard Mattes (EMX, MS-DOS and OS/2).  Microsoft C can be used to build 16-bit versions for MS-DOS and OS/2.  The file {\f1{}README_d/README.pc} in the {\f1{}gawk} distribution contains additional notes, and {\f1{}pc/Makefile} contains important notes on compilation options.\par
\par
\pard{}To build {\f1{}gawk}, copy the files in the {\f1{}pc} directory ({\i except} for {\f1{}ChangeLog}) to the directory with the rest of the {\f1{}gawk} sources. The {\f1{}Makefile} contains a configuration section with comments, and may need to be edited in order to work with your {\f1{}make} utility.\par
\par
\pard{}The {\f1{}Makefile} contains a number of targets for building various MS-DOS and OS/2 versions. A list of targets will be printed if the {\f1{}make} command is given without a target. As an example, to build {\f1{}gawk} using the DJGPP tools, enter {\f1{}make djgpp}.\par
\par
\pard{}Using {\f1{}make} to run the standard tests and to install {\f1{}gawk} requires additional Unix-like tools, including {\f1{}sh}, {\f1{}sed}, and {\f1{}cp}. In order to run the tests, the {\f1{}test/*.ok} files may need to be converted so that they have the usual DOS-style end-of-line markers. Most of the tests will work properly with Stewartson's shell along with the companion utilities or appropriate GNU utilities.  However, some editing of {\f1{}test/Makefile} is required. It is recommended that the file {\f1{}pc/Makefile.tst} be copied to {\f1{}test/Makefile} as a replacement. Details can be found in {\f1{}README_d/README.pc}.\par
\par
\page\pard Node: {\b Atari Installation}, \keepn Next: {\uldb Amiga Installation}{\v Amiga_Installation}, Prev: {\uldb PC Installation}{\v PC_Installation}, Up: {\uldb Installation}{\v Installation}\line
K{\footnote K Atari Installation}
#{\footnote Atari_Installation}
${\footnote \pard{}Installing {\f1{}gawk} on the Atari ST}\par
\pard{\fs24\b Installing {\f1{}gawk} on the Atari ST}\par
\par
\pard{}{K{\footnote K atari}}{K{\footnote K installation, atari}}There are no substantial differences when installing {\f1{}gawk} on various Atari models.  Compiled {\f1{}gawk} executables do not require a large amount of memory with most {\f1{}awk} programs and should run on all Motorola processor based models (called further ST, even if that is not exactly right).\par
\par
\pard{}In order to use {\f1{}gawk}, you need to have a shell, either text or graphics, that does not map all the characters of a command line to upper-case.  Maintaining case distinction in option flags is very important (see {\uldb Command Line Options}{\v Options}).  These days this is the default, and it may only be a problem for some very old machines.  If your system does not preserve the case of option flags, you will need to upgrade your tools.  Support for I/O redirection is necessary to make it easy to import {\f1{}awk} programs from other environments.  Pipes are nice to have, but not vital.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Atari Compiling}{\v Atari_Compiling}\tab Compiling {\f1{}gawk} on Atari\par
{\uldb Atari Using}{\v Atari_Using}\tab Running {\f1{}gawk} on Atari\par
\pard{}}\par
\page\pard Node: {\b Atari Compiling}, \keepn Next: {\uldb Atari Using}{\v Atari_Using}, Prev: {\uldb Atari Installation}{\v Atari_Installation}, Up: {\uldb Atari Installation}{\v Atari_Installation}\line
K{\footnote K Atari Compiling}
#{\footnote Atari_Compiling}
${\footnote \pard{}Compiling {\f1{}gawk} on the Atari ST}\par
\pard{\fs24\b Compiling {\f1{}gawk} on the Atari ST}\par
\par
\pard{}A proper compilation of {\f1{}gawk} sources when {\f1{}sizeof(int)} differs from {\f1{}sizeof(void *)} requires an ANSI C compiler. An initial port was done with {\f1{}gcc}.  You may actually prefer executables where {\f1{}int}s are four bytes wide, but the other variant works as well.\par
\par
\pard{}You may need quite a bit of memory when trying to recompile the {\f1{}gawk} sources, as some source files ({\f1{}regex.c} in particular) are quite big.  If you run out of memory compiling such a file, try reducing the optimization level for this particular file; this may help.\par
\par
\pard{}{K{\footnote K Linux}}With a reasonable shell (Bash will do), and in particular if you run Linux, MiNT or a similar operating system, you have a pretty good chance that the {\f1{}configure} utility will succeed.  Otherwise sample versions of {\f1{}config.h} and {\f1{}Makefile.st} are given in the {\f1{}atari} subdirectory and can be edited and copied to the corresponding files in the main source directory.  Even if {\f1{}configure} produced something, it might be advisable to compare its results with the sample versions and possibly make adjustments.\par
\par
\pard{}Some {\f1{}gawk} source code fragments depend on a preprocessor define {\f1{}atarist}.  This basically assumes the TOS environment with {\f1{}gcc}.  Modify these sections as appropriate if they are not right for your environment.  Also see the remarks about {\f1{}AWKPATH} and {\f1{}envsep} in {\uldb Running {\f1{}gawk} on the Atari ST}{\v Atari_Using}.\par
\par
\pard{}As shipped, the sample {\f1{}config.h} claims that the {\f1{}system} function is missing from the libraries, which is not true, and an alternative implementation of this function is provided in {\f1{}atari/system.c}.  Depending upon your particular combination of shell and operating system, you may wish to change the file to indicate that {\f1{}system} is available.\par
\par
\page\pard Node: {\b Atari Using}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Atari Compiling}{\v Atari_Compiling}, Up: {\uldb Atari Installation}{\v Atari_Installation}\line
K{\footnote K Atari Using}
#{\footnote Atari_Using}
${\footnote \pard{}Running {\f1{}gawk} on the Atari ST}\par
\pard{\fs24\b Running {\f1{}gawk} on the Atari ST}\par
\par
\pard{}An executable version of {\f1{}gawk} should be placed, as usual, anywhere in your {\f1{}PATH} where your shell can find it.\par
\par
\pard{}While executing, {\f1{}gawk} creates a number of temporary files.  When using {\f1{}gcc} libraries for TOS, {\f1{}gawk} looks for either of the environment variables {\f1{}TEMP} or {\f1{}TMPDIR}, in that order.  If either one is found, its value is assumed to be a directory for temporary files.  This directory must exist, and if you can spare the memory, it is a good idea to put it on a RAM drive.  If neither {\f1{}TEMP} nor {\f1{}TMPDIR} are found, then {\f1{}gawk} uses the current directory for its temporary files.\par
\par
\pard{}The ST version of {\f1{}gawk} searches for its program files as described in {\uldb The {\f1{}AWKPATH} Environment Variable}{\v AWKPATH_Variable}.  The default value for the {\f1{}AWKPATH} variable is taken from {\f1{}DEFPATH} defined in {\f1{}Makefile}. The sample {\f1{}gcc}/TOS {\f1{}Makefile} for the ST in the distribution sets {\f1{}DEFPATH} to {\f1{}".,c:\'5Clib\'5Cawk,c:\'5Cgnu\'5Clib\'5Cawk"}.  The search path can be modified by explicitly setting {\f1{}AWKPATH} to whatever you wish.  Note that colons cannot be used on the ST to separate elements in the {\f1{}AWKPATH} variable, since they have another, reserved, meaning.  Instead, you must use a comma to separate elements in the path.  When recompiling, the separating character can be modified by initializing the {\f1{}envsep} variable in {\f1{}atari/gawkmisc.atr} to another value.\par
\par
\pard{}Although {\f1{}awk} allows great flexibility in doing I/O redirections from within a program, this facility should be used with care on the ST running under TOS.  In some circumstances the OS routines for file handle pool processing lose track of certain events, causing the computer to crash, and requiring a reboot.  Often a warm reboot is sufficient.  Fortunately, this happens infrequently, and in rather esoteric situations.  In particular, avoid having one part of an {\f1{}awk} program using {\f1{}print} statements explicitly redirected to {\f1{}"/dev/stdout"}, while other {\f1{}print} statements use the default standard output, and a calling shell has redirected standard output to a file.\par
\par
\pard{}When {\f1{}gawk} is compiled with the ST version of {\f1{}gcc} and its usual libraries, it will accept both {\f1{}/} and {\f1{}\'5C} as path separators.  While this is convenient, it should be remembered that this removes one, technically valid, character ({\f1{}/}) from your file names, and that it may create problems for external programs, called via the {\f1{}system} function, which may not support this convention.  Whenever it is possible that a file created by {\f1{}gawk} will be used by some other program, use only backslashes.  Also remember that in {\f1{}awk}, backslashes in strings have to be doubled in order to get literal backslashes (see {\uldb Escape Sequences}{\v Escape_Sequences}).\par
\par
\page\pard Node: {\b Amiga Installation}, \keepn Next: {\uldb Bugs}{\v Bugs}, Prev: {\uldb Atari Installation}{\v Atari_Installation}, Up: {\uldb Installation}{\v Installation}\line
K{\footnote K Amiga Installation}
#{\footnote Amiga_Installation}
${\footnote \pard{}Installing {\f1{}gawk} on an Amiga}\par
\pard{\fs24\b Installing {\f1{}gawk} on an Amiga}\par
\par
\pard{}{K{\footnote K amiga}}{K{\footnote K installation, amiga}}You can install {\f1{}gawk} on an Amiga system using a Unix emulation environment available via anonymous {\f1{}ftp} from {\f1{}ftp.ninemoons.com} in the directory {\f1{}pub/ade/current}.  This includes a shell based on {\f1{}pdksh}.  The primary component of this environment is a Unix emulation library, {\f1{}ixemul.lib}.\par
\par
\pard{}A more complete distribution for the Amiga is available on the Geek Gadgets CD-ROM from:\par
\par
{\pard\li720{}CRONUS\par
\pard\li720{}1840 E. Warner Road #105-265\par
\pard\li720{}Tempe, AZ 85284  USA\par
\pard\li720{}US Toll Free: (800) 804-0833\par
\pard\li720{}Phone: +1-602-491-0442\par
\pard\li720{}FAX: +1-602-491-0048\par
\pard\li720{}Email:  {\f1{}info@ninemoons.com}\par
\pard\li720{}WWW: {\f1{}http://www.ninemoons.com}\par
\pard\li720{}Anonymous {\f1{}ftp} site: {\f1{}ftp.ninemoons.com}\par
\pard{}}\par
\pard{}Once you have the distribution, you can configure {\f1{}gawk} simply by running {\f1{}configure}:\par
\par
{\pard\keep\li720\f1{}configure -v m68k-amigaos\par
\pard\f0{}}\par
\pard{}Then run {\f1{}make}, and you should be all set!  (If these steps do not work, please send in a bug report; see {\uldb Reporting Problems and Bugs}{\v Bugs}.)\par
\par
\page\pard Node: {\b Bugs}, \keepn Next: {\uldb Other Versions}{\v Other_Versions}, Prev: {\uldb Amiga Installation}{\v Amiga_Installation}, Up: {\uldb Installation}{\v Installation}\line
K{\footnote K Bugs}
#{\footnote Bugs}
${\footnote \pard{}Reporting Problems and Bugs}\par
\pard{\fs24\b Reporting Problems and Bugs}\par
\par
{\pard\li720\f1{}There is nothing more dangerous than a bored archeologist.\line
The Hitchhiker's Guide to the Galaxy\par
\pard\f0{}}\par
\pard{}If you have problems with {\f1{}gawk} or think that you have found a bug, please report it to the developers; we cannot promise to do anything but we might well want to fix it.\par
\par
\pard{}Before reporting a bug, make sure you have actually found a real bug.  Carefully reread the documentation and see if it really says you can do what you're trying to do.  If it's not clear whether you should be able to do something or not, report that too; it's a bug in the documentation!\par
\par
\pard{}Before reporting a bug or trying to fix it yourself, try to isolate it to the smallest possible {\f1{}awk} program and input data file that reproduces the problem.  Then send us the program and data file, some idea of what kind of Unix system you're using, and the exact results {\f1{}gawk} gave you.  Also say what you expected to occur; this will help us decide whether the problem was really in the documentation.\par
\par
\pard{}Once you have a precise problem, there are two e-mail addresses you can send mail to.\par
\par
{\pard{}Internet:\par
{\f1{}\pard\li720{}bug-gnu-utils@gnu.org}\par
\par
\pard{}UUCP:\par
{\f1{}\pard\li720{}uunet!gnu.org!bug-gnu-utils}\par
\pard{}}\par
\pard{}Please include the version number of {\f1{}gawk} you are using.  You can get this information with the command {\f1{}gawk --version}.  You should send a carbon copy of your mail to Arnold Robbins, who can be reached at {\f1{}arnold@gnu.org}.\par
\par
\pard{}{K{\footnote K {\f1{}comp.lang.awk}}}{\b Important!} Do {\i not} try to report bugs in {\f1{}gawk} by posting to the Usenet/Internet newsgroup {\f1{}comp.lang.awk}.  While the {\f1{}gawk} developers do occasionally read this newsgroup, there is no guarantee that we will see your posting.  The steps described above are the official, recognized ways for reporting bugs.\par
\par
\pard{}Non-bug suggestions are always welcome as well.  If you have questions about things that are unclear in the documentation or are just obscure features, ask Arnold Robbins; he will try to help you out, although he may not have the time to fix the problem.  You can send him electronic mail at the Internet address above.\par
\par
\pard{}If you find bugs in one of the non-Unix ports of {\f1{}gawk}, please send an electronic mail message to the person who maintains that port.  They are listed below, and also in the {\f1{}README} file in the {\f1{}gawk} distribution.  Information in the {\f1{}README} file should be considered authoritative if it conflicts with this Info file.\par
\par
\pard{}The people maintaining the non-Unix ports of {\f1{}gawk} are:\par
\par
\pard{}{K{\footnote K Deifik, Scott}}{K{\footnote K Fish, Fred}}{K{\footnote K Hankerson, Darrel}}{K{\footnote K Jaegermann, Michal}}{K{\footnote K Rankin, Pat}}{K{\footnote K Rommel, Kai Uwe}}{\par
\pard{}MS-DOS\par
\pard\li720{}Scott Deifik, {\f1{}scottd@amgen.com}, and Darrel Hankerson, {\f1{}hankedr@mail.auburn.edu}.\par
\par
\pard{}OS/2\par
\pard\li720{}Kai Uwe Rommel, {\f1{}rommel@ars.de}.\par
\par
\pard{}VMS\par
\pard\li720{}Pat Rankin, {\f1{}rankin@eql.caltech.edu}.\par
\par
\pard{}Atari ST\par
\pard\li720{}Michal Jaegermann, {\f1{}michal@gortel.phys.ualberta.ca}.\par
\par
\pard{}Amiga\par
\pard\li720{}Fred Fish, {\f1{}fnf@ninemoons.com}.\par
\pard{}}\par
\pard{}If your bug is also reproducible under Unix, please send copies of your report to the general GNU bug list, as well as to Arnold Robbins, at the addresses listed above.\par
\par
\page\pard Node: {\b Other Versions}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Bugs}{\v Bugs}, Up: {\uldb Installation}{\v Installation}\line
K{\footnote K Other Versions}
#{\footnote Other_Versions}
${\footnote \pard{}Other Freely Available {\f1{}awk} Implementations}\par
\pard{\fs24\b Other Freely Available {\f1{}awk} Implementations}\par
\par
\pard{}{K{\footnote K Brennan, Michael}}{\par
\pard\li720\f1{}It's kind of fun to put comments like this in your awk code.\line
      {\f1{}// Do C++ comments work? answer: yes! of course}\line
Michael Brennan\par
\pard\f0{}}\par
\pard{}There are two other freely available {\f1{}awk} implementations.  This section briefly describes where to get them.\par
\par
{\pard\li720{}{K{\footnote K Kernighan, Brian}}{K{\footnote K anonymous {\f1{}ftp}}}{K{\footnote K {\f1{}ftp}, anonymous}}\par
\par
\pard{}Unix {\f1{}awk}\par
\pard\li720{}Brian Kernighan has been able to make his implementation of {\f1{}awk} freely available.  You can get it via anonymous {\f1{}ftp} to the host {\f1{}netlib.bell-labs.com}.  Change directory to {\f1{}/netlib/research}. Use "binary" or "image" mode, and retrieve {\f1{}awk.bundle.gz}.\par
\par
\pard\li720{}This is a shell archive that has been compressed with the GNU {\f1{}gzip} utility. It can be uncompressed with the {\f1{}gunzip} utility.\par
\par
\pard\li720{}You can also retrieve this version via the World Wide Web from Brian Kernighan's home page (http://cm.bell-labs.com/who/bwk).\par
\par
\pard\li720{}This version requires an ANSI C compiler; GCC (the GNU C compiler) works quite nicely.\par
\par
\pard\li720{}{K{\footnote K Brennan, Michael}}{K{\footnote K {\f1{}mawk}}}\par
\par
\pard{}{\f1{}mawk}\par
\pard\li720{}Michael Brennan has written an independent implementation of {\f1{}awk}, called {\f1{}mawk}.  It is available under the GPL (see {\uldb GNU GENERAL PUBLIC LICENSE}{\v Copying}), just as {\f1{}gawk} is.\par
\par
\pard\li720{}You can get it via anonymous {\f1{}ftp} to the host {\f1{}ftp.whidbey.net}.  Change directory to {\f1{}/pub/brennan}.  Use "binary" or "image" mode, and retrieve {\f1{}mawk1.3.3.tar.gz} (or the latest version that is there).\par
\par
{\f1{}\pard\li720{}gunzip} may be used to decompress this file. Installation is similar to {\f1{}gawk}'s (see {\uldb Compiling and Installing {\f1{}gawk} on Unix}{\v Unix_Installation}).\par
\pard{}}\par
\page\pard Node: {\b Notes}, \keepn Next: {\uldb Glossary}{\v Glossary}, Prev: {\uldb Installation}{\v Installation}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Notes}
#{\footnote Notes}
${\footnote \pard{}Implementation Notes}\par
\pard{\fs24\b Implementation Notes}\par
\par
\pard{}This appendix contains information mainly of interest to implementors and maintainers of {\f1{}gawk}.  Everything in it applies specifically to {\f1{}gawk}, and not to other implementations.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Compatibility Mode}{\v Compatibility_Mode}\tab How to disable certain {\f1{}gawk} extensions.\par
{\uldb Additions}{\v Additions}\tab Making Additions To {\f1{}gawk}.\par
{\uldb Future Extensions}{\v Future_Extensions}\tab New features that may be implemented one day.\par
{\uldb Improvements}{\v Improvements}\tab Suggestions for improvements by volunteers.\par
\pard{}}\par
\page\pard Node: {\b Compatibility Mode}, \keepn Next: {\uldb Additions}{\v Additions}, Prev: {\uldb Notes}{\v Notes}, Up: {\uldb Notes}{\v Notes}\line
K{\footnote K Compatibility Mode}
#{\footnote Compatibility_Mode}
${\footnote \pard{}Downward Compatibility and Debugging}\par
\pard{\fs24\b Downward Compatibility and Debugging}\par
\par
\pard{}See {\uldb Extensions in {\f1{}gawk} Not in POSIX {\f1{}awk}}{\v POSIX_GNU}, for a summary of the GNU extensions to the {\f1{}awk} language and program.  All of these features can be turned off by invoking {\f1{}gawk} with the {\f1{}--traditional} option, or with the {\f1{}--posix} option.\par
\par
\pard{}If {\f1{}gawk} is compiled for debugging with {\f1{}-DDEBUG}, then there is one more option available on the command line:\par
\par
{\pard{}{\f1{}-W parsedebug}\par
\pard{}{\f1{}--parsedebug}\par
\pard\li720{}Print out the parse stack information as the program is being parsed.\par
\pard{}}\par
\pard{}This option is intended only for serious {\f1{}gawk} developers, and not for the casual user.  It probably has not even been compiled into your version of {\f1{}gawk}, since it slows down execution.\par
\par
\page\pard Node: {\b Additions}, \keepn Next: {\uldb Future Extensions}{\v Future_Extensions}, Prev: {\uldb Compatibility Mode}{\v Compatibility_Mode}, Up: {\uldb Notes}{\v Notes}\line
K{\footnote K Additions}
#{\footnote Additions}
${\footnote \pard{}Making Additions to {\f1{}gawk}}\par
\pard{\fs24\b Making Additions to {\f1{}gawk}}\par
\par
\pard{}If you should find that you wish to enhance {\f1{}gawk} in a significant fashion, you are perfectly free to do so.  That is the point of having free software; the source code is available, and you are free to change it as you wish (see {\uldb GNU GENERAL PUBLIC LICENSE}{\v Copying}).\par
\par
\pard{}This section discusses the ways you might wish to change {\f1{}gawk}, and any considerations you should bear in mind.\par
\par
{\par
\pard\keep\fi-2880\li2880\tx2880{}{\uldb Adding Code}{\v Adding_Code}\tab Adding code to the main body of {\f1{}gawk}.\par
{\uldb New Ports}{\v New_Ports}\tab Porting {\f1{}gawk} to a new operating system.\par
\pard{}}\par
\page\pard Node: {\b Adding Code}, \keepn Next: {\uldb New Ports}{\v New_Ports}, Prev: {\uldb Additions}{\v Additions}, Up: {\uldb Additions}{\v Additions}\line
K{\footnote K Adding Code}
#{\footnote Adding_Code}
${\footnote \pard{}Adding New Features}\par
\pard{\fs24\b Adding New Features}\par
\par
\pard{}{K{\footnote K adding new features}}{K{\footnote K features, adding}}You are free to add any new features you like to {\f1{}gawk}.  However, if you want your changes to be incorporated into the {\f1{}gawk} distribution, there are several steps that you need to take in order to make it possible for me to include your changes.\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}1. \tab{}Get the latest version.  It is much easier for me to integrate changes if they are relative to the most recent distributed version of {\f1{}gawk}.  If your version of {\f1{}gawk} is very old, I may not be able to integrate them at all.  See {\uldb Getting the {\f1{}gawk} Distribution}{\v Getting}, for information on getting the latest version of {\f1{}gawk}.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}2. \tab{}{See See {\uldb Top}{\v Top @Version.hlp} standards, GNU Coding Standards.  }This document describes how GNU software should be written. If you haven't read it, please do so, preferably {\i before} starting to modify {\f1{}gawk}.  (The {\i GNU Coding Standards} are available as part of the Autoconf distribution, from the FSF.)\par
\par
\pard\li720{}{K{\footnote K {\f1{}gawk} coding style}}{K{\footnote K coding style used in {\f1{}gawk}}}\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}3. \tab{}Use the {\f1{}gawk} coding style.  The C code for {\f1{}gawk} follows the instructions in the {\i GNU Coding Standards}, with minor exceptions.  The code is formatted using the traditional "K&R" style, particularly as regards the placement of braces and the use of tabs.  In brief, the coding rules for {\f1{}gawk} are:\par
\par
{\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}Use old style (non-prototype) function headers when defining functions.\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}Put the name of the function at the beginning of its own line.\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}Put the return type of the function, even if it is {\f1{}int}, on the line above the line with the name and arguments of the function.\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}The declarations for the function arguments should not be indented.\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}Put spaces around parentheses used in control structures ({\f1{}if}, {\f1{}while}, {\f1{}for}, {\f1{}do}, {\f1{}switch} and {\f1{}return}).\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}Do not put spaces in front of parentheses used in function calls.\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}Put spaces around all C operators, and after commas in function calls.\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}Do not use the comma operator to produce multiple side-effects, except in {\f1{}for} loop initialization and increment parts, and in macro bodies.\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}Use real tabs for indenting, not spaces.\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}Use the "K&R" brace layout style.\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}Use comparisons against {\f1{}NULL} and {\f1{}'\'5C0'} in the conditions of {\f1{}if}, {\f1{}while} and {\f1{}for} statements, and in the {\f1{}case}s of {\f1{}switch} statements, instead of just the plain pointer or character value.\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}Use the {\f1{}TRUE}, {\f1{}FALSE}, and {\f1{}NULL} symbolic constants, and the character constant {\f1{}'\'5C0'} where appropriate, instead of {\f1{}1} and {\f1{}0}.\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}Provide one-line descriptive comments for each function.\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}Do not use {\f1{}#elif}. Many older Unix C compilers cannot handle it.\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}{\f2\'B7}\tab{}Do not use the {\f1{}alloca} function for allocating memory off the stack.  Its use causes more portability trouble than the minor benefit of not having to free the storage. Instead, use {\f1{}malloc} and {\f1{}free}.\par
\pard\li720{}}\par
\pard\li720{}If I have to reformat your code to follow the coding style used in {\f1{}gawk}, I may not bother.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}4. \tab{}Be prepared to sign the appropriate paperwork.  In order for the FSF to distribute your changes, you must either place those changes in the public domain, and submit a signed statement to that effect, or assign the copyright in your changes to the FSF.  Both of these actions are easy to do, and {\i many} people have done so already. If you have questions, please contact me (see {\uldb Reporting Problems and Bugs}{\v Bugs}), or {\f1{}gnu@gnu.org}.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}5. \tab{}Update the documentation.  Along with your new code, please supply new sections and or chapters for this Info file.  If at all possible, please use real Texinfo, instead of just supplying unformatted ASCII text (although even that is better than no documentation at all).  Conventions to be followed in {\i Effective AWK Programming} are provided after the {\f1{}@bye} at the end of the Texinfo source file.  If possible, please update the man page as well.\par
\par
\pard\li720{}You will also have to sign paperwork for your documentation changes.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}6. \tab{}Submit changes as context diffs or unified diffs.  Use {\f1{}diff -c -r -N} or {\f1{}diff -u -r -N} to compare the original {\f1{}gawk} source tree with your version.  (I find context diffs to be more readable, but unified diffs are more compact.)  I recommend using the GNU version of {\f1{}diff}.  Send the output produced by either run of {\f1{}diff} to me when you submit your changes.  See {\uldb Reporting Problems and Bugs}{\v Bugs}, for the electronic mail information.\par
\par
\pard\li720{}Using this format makes it easy for me to apply your changes to the master version of the {\f1{}gawk} source code (using {\f1{}patch}).  If I have to apply the changes manually, using a text editor, I may not do so, particularly if there are lots of changes.\par
\pard{}}\par
\pard{}Although this sounds like a lot of work, please remember that while you may write the new code, I have to maintain it and support it, and if it isn't possible for me to do that with a minimum of extra work, then I probably will not.\par
\par
\page\pard Node: {\b New Ports}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Adding Code}{\v Adding_Code}, Up: {\uldb Additions}{\v Additions}\line
K{\footnote K New Ports}
#{\footnote New_Ports}
${\footnote \pard{}Porting {\f1{}gawk} to a New Operating System}\par
\pard{\fs24\b Porting {\f1{}gawk} to a New Operating System}\par
\par
\pard{}{K{\footnote K porting {\f1{}gawk}}}If you wish to port {\f1{}gawk} to a new operating system, there are several steps to follow.\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}1. \tab{}Follow the guidelines in {\uldb Adding New Features}{\v Adding_Code}, concerning coding style, submission of diffs, and so on.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}2. \tab{}When doing a port, bear in mind that your code must co-exist peacefully with the rest of {\f1{}gawk}, and the other ports. Avoid gratuitous changes to the system-independent parts of the code. If at all possible, avoid sprinkling {\f1{}#ifdef}s just for your port throughout the code.\par
\par
\pard\li720{}If the changes needed for a particular system affect too much of the code, I probably will not accept them.  In such a case, you will, of course, be able to distribute your changes on your own, as long as you comply with the GPL (see {\uldb GNU GENERAL PUBLIC LICENSE}{\v Copying}).\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}3. \tab{}A number of the files that come with {\f1{}gawk} are maintained by other people at the Free Software Foundation.  Thus, you should not change them unless it is for a very good reason. I.e. changes are not out of the question, but changes to these files will be scrutinized extra carefully.  The files are {\f1{}alloca.c}, {\f1{}getopt.h}, {\f1{}getopt.c}, {\f1{}getopt1.c}, {\f1{}regex.h}, {\f1{}regex.c}, {\f1{}dfa.h}, {\f1{}dfa.c}, {\f1{}install-sh}, and {\f1{}mkinstalldirs}.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}4. \tab{}Be willing to continue to maintain the port.  Non-Unix operating systems are supported by volunteers who maintain the code needed to compile and run {\f1{}gawk} on their systems. If no-one volunteers to maintain a port, that port becomes unsupported, and it may be necessary to remove it from the distribution.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}5. \tab{}Supply an appropriate {\f1{}gawkmisc.???} file.  Each port has its own {\f1{}gawkmisc.???} that implements certain operating system specific functions. This is cleaner than a plethora of {\f1{}#ifdef}s scattered throughout the code.  The {\f1{}gawkmisc.c} in the main source directory includes the appropriate {\f1{}gawkmisc.???} file from each subdirectory.  Be sure to update it as well.\par
\par
\pard\li720{}Each port's {\f1{}gawkmisc.???} file has a suffix reminiscent of the machine or operating system for the port. For example, {\f1{}pc/gawkmisc.pc} and {\f1{}vms/gawkmisc.vms}. The use of separate suffixes, instead of plain {\f1{}gawkmisc.c}, makes it possible to move files from a port's subdirectory into the main subdirectory, without accidentally destroying the real {\f1{}gawkmisc.c} file.  (Currently, this is only an issue for the MS-DOS and OS/2 ports.)\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}6. \tab{}Supply a {\f1{}Makefile} and any other C source and header files that are necessary for your operating system.  All your code should be in a separate subdirectory, with a name that is the same as, or reminiscent of, either your operating system or the computer system.  If possible, try to structure things so that it is not necessary to move files out of the subdirectory into the main source directory.  If that is not possible, then be sure to avoid using names for your files that duplicate the names of files in the main source directory.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}7. \tab{}Update the documentation.  Please write a section (or sections) for this Info file describing the installation and compilation steps needed to install and/or compile {\f1{}gawk} for your system.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}8. \tab{}Be prepared to sign the appropriate paperwork.  In order for the FSF to distribute your code, you must either place your code in the public domain, and submit a signed statement to that effect, or assign the copyright in your code to the FSF.  {Both of these actions are easy to do, and {\i many} people have done so already. If you have questions, please contact me, or {\f1{}gnu@gnu.org}.  }\par
\pard{}}\par
\pard{}Following these steps will make it much easier to integrate your changes into {\f1{}gawk}, and have them co-exist happily with the code for other operating systems that is already there.\par
\par
\pard{}In the code that you supply, and that you maintain, feel free to use a coding style and brace layout that suits your taste.\par
\par
\page\pard Node: {\b Future Extensions}, \keepn Next: {\uldb Improvements}{\v Improvements}, Prev: {\uldb Additions}{\v Additions}, Up: {\uldb Notes}{\v Notes}\line
K{\footnote K Future Extensions}
#{\footnote Future_Extensions}
${\footnote \pard{}Probable Future Extensions}\par
\pard{\fs24\b Probable Future Extensions}\par
\par
\pard{}{K{\footnote K PERL}}{K{\footnote K Wall, Larry}}{\par
\pard\li720\f1{}AWK is a language similar to PERL, only considerably more elegant.\line
Arnold Robbins\line
\line
Hey!\line
Larry Wall\par
\pard\f0{}}\par
\pard{}This section briefly lists extensions and possible improvements that indicate the directions we are currently considering for {\f1{}gawk}.  The file {\f1{}FUTURES} in the {\f1{}gawk} distributions lists these extensions as well.\par
\par
\pard{}This is a list of probable future changes that will be usable by the {\f1{}awk} language programmer.\par
\par
{\pard{}Localization\par
\pard\li720{}The GNU project is starting to support multiple languages.  It will at least be possible to make {\f1{}gawk} print its warnings and error messages in languages other than English.  It may be possible for {\f1{}awk} programs to also use the multiple language facilities, separate from {\f1{}gawk} itself.\par
\par
\pard{}Databases\par
\pard\li720{}It may be possible to map a GDBM/NDBM/SDBM file into an {\f1{}awk} array.\par
\par
\pard{}A {\f1{}PROCINFO} Array\par
\pard\li720{}The special files that provide process-related information (see {\uldb Special File Names in {\f1{}gawk}}{\v Special_Files}) may be superseded by a {\f1{}PROCINFO} array that would provide the same information, in an easier to access fashion.\par
\par
\pard{}More {\f1{}lint} warnings\par
\pard\li720{}There are more things that could be checked for portability.\par
\par
\pard{}Control of subprocess environment\par
\pard\li720{}Changes made in {\f1{}gawk} to the array {\f1{}ENVIRON} may be propagated to subprocesses run by {\f1{}gawk}.\par
\par
\pard{}}\par
\pard{}This is a list of probable improvements that will make {\f1{}gawk} perform better.\par
\par
{\pard{}An Improved Version of {\f1{}dfa}\par
\pard\li720{}The {\f1{}dfa} pattern matcher from GNU {\f1{}grep} has some problems. Either a new version or a fixed one will deal with some important regexp matching issues.\par
\par
\pard{}Use of GNU {\f1{}malloc}\par
\pard\li720{}The GNU version of {\f1{}malloc} could potentially speed up {\f1{}gawk}, since it relies heavily on the use of dynamic memory allocation.\par
\par
\pard{}}\par
\page\pard Node: {\b Improvements}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Future Extensions}{\v Future_Extensions}, Up: {\uldb Notes}{\v Notes}\line
K{\footnote K Improvements}
#{\footnote Improvements}
${\footnote \pard{}Suggestions for Improvements}\par
\pard{\fs24\b Suggestions for Improvements}\par
\par
\pard{}Here are some projects that would-be {\f1{}gawk} hackers might like to take on.  They vary in size from a few days to a few weeks of programming, depending on which one you choose and how fast a programmer you are.  Please send any improvements you write to the maintainers at the GNU project.  See {\uldb Adding New Features}{\v Adding_Code}, for guidelines to follow when adding new features to {\f1{}gawk}.  See {\uldb Reporting Problems and Bugs}{\v Bugs}, for information on contacting the maintainers.\par
\par
{\pard\fi-720\li720\tx144\tx720{}\tab{}1. \tab{}Compilation of {\f1{}awk} programs: {\f1{}gawk} uses a Bison (YACC-like) parser to convert the script given it into a syntax tree; the syntax tree is then executed by a simple recursive evaluator.  This method incurs a lot of overhead, since the recursive evaluator performs many procedure calls to do even the simplest things.\par
\par
\pard\li720{}It should be possible for {\f1{}gawk} to convert the script's parse tree into a C program which the user would then compile, using the normal C compiler and a special {\f1{}gawk} library to provide all the needed functions (regexps, fields, associative arrays, type coercion, and so on).\par
\par
\pard\li720{}An easier possibility might be for an intermediate phase of {\f1{}awk} to convert the parse tree into a linear byte code form like the one used in GNU Emacs Lisp.  The recursive evaluator would then be replaced by a straight line byte code interpreter that would be intermediate in speed between running a compiled program and doing what {\f1{}gawk} does now.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}2. \tab{}The programs in the test suite could use documenting in this Info file.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}3. \tab{}See the {\f1{}FUTURES} file for more ideas.  Contact us if you would seriously like to tackle any of the items listed there.\par
\pard{}}\par
\page\pard Node: {\b Glossary}, \keepn Next: {\uldb Copying}{\v Copying}, Prev: {\uldb Notes}{\v Notes}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Glossary}
#{\footnote Glossary}
${\footnote \pard{}Glossary}\par
\pard{\fs24\b Glossary}\par
\par
{\pard{}Action\par
\pard\li720{}A series of {\f1{}awk} statements attached to a rule.  If the rule's pattern matches an input record, {\f1{}awk} executes the rule's action.  Actions are always enclosed in curly braces.  See {\uldb Overview of Actions}{\v Action_Overview}.\par
\par
\pard{}Amazing {\f1{}awk} Assembler\par
\pard\li720{}Henry Spencer at the University of Toronto wrote a retargetable assembler completely as {\f1{}awk} scripts.  It is thousands of lines long, including machine descriptions for several eight-bit microcomputers.  It is a good example of a program that would have been better written in another language.\par
\par
\pard{}Amazingly Workable Formatter ({\f1{}awf})\par
\pard\li720{}Henry Spencer at the University of Toronto wrote a formatter that accepts a large subset of the {\f1{}nroff -ms} and {\f1{}nroff -man} formatting commands, using {\f1{}awk} and {\f1{}sh}.\par
\par
\pard{}ANSI\par
\pard\li720{}The American National Standards Institute.  This organization produces many standards, among them the standards for the C and C++ programming languages.\par
\par
\pard{}Assignment\par
\pard\li720{}An {\f1{}awk} expression that changes the value of some {\f1{}awk} variable or data object.  An object that you can assign to is called an \'A2lvalue\'A2.  The assigned values are called \'A2rvalues\'A2.  See {\uldb Assignment Expressions}{\v Assignment_Ops}.\par
\par
\pard{}{\f1{}awk} Language\par
\pard\li720{}The language in which {\f1{}awk} programs are written.\par
\par
\pard{}{\f1{}awk} Program\par
\pard\li720{}An {\f1{}awk} program consists of a series of \'A2patterns\'A2 and \'A2actions\'A2, collectively known as \'A2rules\'A2.  For each input record given to the program, the program's rules are all processed in turn.  {\f1{}awk} programs may also contain function definitions.\par
\par
\pard{}{\f1{}awk} Script\par
\pard\li720{}Another name for an {\f1{}awk} program.\par
\par
\pard{}Bash\par
\pard\li720{}The GNU version of the standard shell (the Bourne-Again shell).  See "Bourne Shell."\par
\par
\pard{}BBS\par
\pard\li720{}See "Bulletin Board System."\par
\par
\pard{}Boolean Expression\par
\pard\li720{}Named after the English mathematician Boole. See "Logical Expression."\par
\par
\pard{}Bourne Shell\par
\pard\li720{}The standard shell ({\f1{}/bin/sh}) on Unix and Unix-like systems, originally written by Steven R. Bourne.  Many shells (Bash, {\f1{}ksh}, {\f1{}pdksh}, {\f1{}zsh}) are generally upwardly compatible with the Bourne shell.\par
\par
\pard{}Built-in Function\par
\pard\li720{}The {\f1{}awk} language provides built-in functions that perform various numerical, time stamp related, and string computations.  Examples are {\f1{}sqrt} (for the square root of a number) and {\f1{}substr} (for a substring of a string).  See {\uldb Built-in Functions}{\v Built_in}.\par
\par
\pard{}Built-in Variable\par
{\f1{}\pard\li720{}ARGC}, {\f1{}ARGIND}, {\f1{}ARGV}, {\f1{}CONVFMT}, {\f1{}ENVIRON}, {\f1{}ERRNO}, {\f1{}FIELDWIDTHS}, {\f1{}FILENAME}, {\f1{}FNR}, {\f1{}FS}, {\f1{}IGNORECASE}, {\f1{}NF}, {\f1{}NR}, {\f1{}OFMT}, {\f1{}OFS}, {\f1{}ORS}, {\f1{}RLENGTH}, {\f1{}RSTART}, {\f1{}RS}, {\f1{}RT}, and {\f1{}SUBSEP}, are the variables that have special meaning to {\f1{}awk}.  Changing some of them affects {\f1{}awk}'s running environment.  Several of these variables are specific to {\f1{}gawk}.  See {\uldb Built-in Variables}{\v Built_in_Variables}.\par
\par
\pard{}Braces\par
\pard\li720{}See "Curly Braces."\par
\par
\pard{}Bulletin Board System\par
\pard\li720{}A computer system allowing users to log in and read and/or leave messages for other users of the system, much like leaving paper notes on a bulletin board.\par
\par
\pard{}C\par
\pard\li720{}The system programming language that most GNU software is written in.  The {\f1{}awk} programming language has C-like syntax, and this Info file points out similarities between {\f1{}awk} and C when appropriate.\par
\par
\pard\li720{}{K{\footnote K ISO 8859-1}}{K{\footnote K ISO Latin-1}}\par
\par
\pard{}Character Set\par
\pard\li720{}The set of numeric codes used by a computer system to represent the characters (letters, numbers, punctuation, etc.) of a particular country or place. The most common character set in use today is ASCII (American Standard Code for Information Interchange).  Many European countries use an extension of ASCII known as ISO-8859-1 (ISO Latin-1).\par
\par
\pard{}CHEM\par
\pard\li720{}A preprocessor for {\f1{}pic} that reads descriptions of molecules and produces {\f1{}pic} input for drawing them.  It was written in {\f1{}awk} by Brian Kernighan and Jon Bentley, and is available from <netlib@research.bell-labs.com>.\par
\par
\pard{}Compound Statement\par
\pard\li720{}A series of {\f1{}awk} statements, enclosed in curly braces.  Compound statements may be nested.  See {\uldb Control Statements in Actions}{\v Statements}.\par
\par
\pard{}Concatenation\par
\pard\li720{}Concatenating two strings means sticking them together, one after another, giving a new string.  For example, the string {\f1{}foo} concatenated with the string {\f1{}bar} gives the string {\f1{}foobar}.  See {\uldb String Concatenation}{\v Concatenation}.\par
\par
\pard{}Conditional Expression\par
\pard\li720{}An expression using the {\f1{}?:} ternary operator, such as {\f1{}{\i expr1} ? {\i expr2} : {\i expr3}}.  The expression {\i expr1} is evaluated; if the result is true, the value of the whole expression is the value of {\i expr2}, otherwise the value is {\i expr3}.  In either case, only one of {\i expr2} and {\i expr3} is evaluated.  See {\uldb Conditional Expressions}{\v Conditional_Exp}.\par
\par
\pard{}Comparison Expression\par
\pard\li720{}A relation that is either true or false, such as {\f1{}(a < b)}.  Comparison expressions are used in {\f1{}if}, {\f1{}while}, {\f1{}do}, and {\f1{}for} statements, and in patterns to select which input records to process.  See {\uldb Variable Typing and Comparison Expressions}{\v Typing_and_Comparison}.\par
\par
\pard{}Curly Braces\par
\pard\li720{}The characters {\f1{}\'7B} and {\f1{}\'7D}.  Curly braces are used in {\f1{}awk} for delimiting actions, compound statements, and function bodies.\par
\par
\pard{}Dark Corner\par
\pard\li720{}An area in the language where specifications often were (or still are) not clear, leading to unexpected or undesirable behavior.  Such areas are marked in this Info file with "(d.c.)" in the text, and are indexed under the heading "dark corner."\par
\par
\pard{}Data Objects\par
\pard\li720{}These are numbers and strings of characters.  Numbers are converted into strings and vice versa, as needed.  See {\uldb Conversion of Strings and Numbers}{\v Conversion}.\par
\par
\pard{}Double Precision\par
\pard\li720{}An internal representation of numbers that can have fractional parts.  Double precision numbers keep track of more digits than do single precision numbers, but operations on them are more expensive.  This is the way {\f1{}awk} stores numeric values.  It is the C type {\f1{}double}.\par
\par
\pard{}Dynamic Regular Expression\par
\pard\li720{}A dynamic regular expression is a regular expression written as an ordinary expression.  It could be a string constant, such as {\f1{}"foo"}, but it may also be an expression whose value can vary.  See {\uldb Using Dynamic Regexps}{\v Computed_Regexps}.\par
\par
\pard{}Environment\par
\pard\li720{}A collection of strings, of the form {\i name{\f1{}=}val}, that each program has available to it. Users generally place values into the environment in order to provide information to various programs. Typical examples are the environment variables {\f1{}HOME} and {\f1{}PATH}.\par
\par
\pard{}Empty String\par
\pard\li720{}See "Null String."\par
\par
\pard{}Escape Sequences\par
\pard\li720{}A special sequence of characters used for describing non-printing characters, such as {\f1{}\'5Cn} for newline, or {\f1{}\'5C033} for the ASCII ESC (escape) character.  See {\uldb Escape Sequences}{\v Escape_Sequences}.\par
\par
\pard{}Field\par
\pard\li720{}When {\f1{}awk} reads an input record, it splits the record into pieces separated by whitespace (or by a separator regexp which you can change by setting the built-in variable {\f1{}FS}).  Such pieces are called fields.  If the pieces are of fixed length, you can use the built-in variable {\f1{}FIELDWIDTHS} to describe their lengths.  See {\uldb Specifying How Fields are Separated}{\v Field_Separators}, and also see See {\uldb Reading Fixed-width Data}{\v Constant_Size}.\par
\par
\pard{}Floating Point Number\par
\pard\li720{}Often referred to in mathematical terms as a "rational" number, this is just a number that can have a fractional part.  See "Double Precision" and "Single Precision."\par
\par
\pard{}Format\par
\pard\li720{}Format strings are used to control the appearance of output in the {\f1{}printf} statement.  Also, data conversions from numbers to strings are controlled by the format string contained in the built-in variable {\f1{}CONVFMT}.  See {\uldb Format-Control Letters}{\v Control_Letters}.\par
\par
\pard{}Function\par
\pard\li720{}A specialized group of statements used to encapsulate general or program-specific tasks.  {\f1{}awk} has a number of built-in functions, and also allows you to define your own.  See {\uldb Built-in Functions}{\v Built_in}, and {\uldb User-defined Functions}{\v User_defined}.\par
\par
\pard{}FSF\par
\pard\li720{}See "Free Software Foundation."\par
\par
\pard{}Free Software Foundation\par
\pard\li720{}A non-profit organization dedicated to the production and distribution of freely distributable software.  It was founded by Richard M. Stallman, the author of the original Emacs editor.  GNU Emacs is the most widely used version of Emacs today.\par
\par
\pard{}{\f1{}gawk}\par
\pard\li720{}The GNU implementation of {\f1{}awk}.\par
\par
\pard{}General Public License\par
\pard\li720{}This document describes the terms under which {\f1{}gawk} and its source code may be distributed. (see {\uldb GNU GENERAL PUBLIC LICENSE}{\v Copying})\par
\par
\pard{}GNU\par
\pard\li720{}"GNU's not Unix".  An on-going project of the Free Software Foundation to create a complete, freely distributable, POSIX-compliant computing environment.\par
\par
\pard{}GPL\par
\pard\li720{}See "General Public License."\par
\par
\pard{}Hexadecimal\par
\pard\li720{}Base 16 notation, where the digits are {\f1{}0}-{\f1{}9} and {\f1{}A}-{\f1{}F}, with {\f1{}A} representing 10, {\f1{}B} representing 11, and so on up to {\f1{}F} for 15.  Hexadecimal numbers are written in C using a leading {\f1{}0x}, to indicate their base.  Thus, {\f1{}0x12} is 18 (one times 16 plus 2).\par
\par
\pard{}I/O\par
\pard\li720{}Abbreviation for "Input/Output," the act of moving data into and/or out of a running program.\par
\par
\pard{}Input Record\par
\pard\li720{}A single chunk of data read in by {\f1{}awk}.  Usually, an {\f1{}awk} input record consists of one line of text.  See {\uldb How Input is Split into Records}{\v Records}.\par
\par
\pard{}Integer\par
\pard\li720{}A whole number, i.e. a number that does not have a fractional part.\par
\par
\pard{}Keyword\par
\pard\li720{}In the {\f1{}awk} language, a keyword is a word that has special meaning.  Keywords are reserved and may not be used as variable names.\par
\par
{\f1{}\pard\li720{}gawk}'s keywords are: {\f1{}BEGIN}, {\f1{}END}, {\f1{}if}, {\f1{}else}, {\f1{}while}, {\f1{}do...while}, {\f1{}for}, {\f1{}for...in}, {\f1{}break}, {\f1{}continue}, {\f1{}delete}, {\f1{}next}, {\f1{}nextfile}, {\f1{}function}, {\f1{}func}, and {\f1{}exit}.\par
\par
\pard{}Logical Expression\par
\pard\li720{}An expression using the operators for logic, AND, OR, and NOT, written {\f1{}&&}, {\f1{}||}, and {\f1{}!} in {\f1{}awk}. Often called Boolean expressions, after the mathematician who pioneered this kind of mathematical logic.\par
\par
\pard{}Lvalue\par
\pard\li720{}An expression that can appear on the left side of an assignment operator.  In most languages, lvalues can be variables or array elements.  In {\f1{}awk}, a field designator can also be used as an lvalue.\par
\par
\pard{}Null String\par
\pard\li720{}A string with no characters in it.  It is represented explicitly in {\f1{}awk} programs by placing two double-quote characters next to each other ({\f1{}""}).  It can appear in input data by having two successive occurrences of the field separator appear next to each other.\par
\par
\pard{}Number\par
\pard\li720{}A numeric valued data object.  The {\f1{}gawk} implementation uses double precision floating point to represent numbers.  Very old {\f1{}awk} implementations use single precision floating point.\par
\par
\pard{}Octal\par
\pard\li720{}Base-eight notation, where the digits are {\f1{}0}-{\f1{}7}.  Octal numbers are written in C using a leading {\f1{}0}, to indicate their base.  Thus, {\f1{}013} is 11 (one times 8 plus 3).\par
\par
\pard{}Pattern\par
\pard\li720{}Patterns tell {\f1{}awk} which input records are interesting to which rules.\par
\par
\pard\li720{}A pattern is an arbitrary conditional expression against which input is tested.  If the condition is satisfied, the pattern is said to \'A2match\'A2 the input record.  A typical pattern might compare the input record against a regular expression.  See {\uldb Pattern Elements}{\v Pattern_Overview}.\par
\par
\pard{}POSIX\par
\pard\li720{}The name for a series of standards being developed by the IEEE that specify a Portable Operating System interface.  The "IX" denotes the Unix heritage of these standards.  The main standard of interest for {\f1{}awk} users is {\i IEEE Standard for Information Technology, Standard 1003.2-1992, Portable Operating System Interface (POSIX) Part 2: Shell and Utilities}.  Informally, this standard is often referred to as simply "P1003.2."\par
\par
\pard{}Private\par
\pard\li720{}Variables and/or functions that are meant for use exclusively by library functions, and not for the main {\f1{}awk} program. Special care must be taken when naming such variables and functions.  See {\uldb Naming Library Function Global Variables}{\v Library_Names}.\par
\par
\pard{}Range (of input lines)\par
\pard\li720{}A sequence of consecutive lines from the input file.  A pattern can specify ranges of input lines for {\f1{}awk} to process, or it can specify single lines.  See {\uldb Pattern Elements}{\v Pattern_Overview}.\par
\par
\pard{}Recursion\par
\pard\li720{}When a function calls itself, either directly or indirectly.  If this isn't clear, refer to the entry for "recursion."\par
\par
\pard{}Redirection\par
\pard\li720{}Redirection means performing input from other than the standard input stream, or output to other than the standard output stream.\par
\par
\pard\li720{}You can redirect the output of the {\f1{}print} and {\f1{}printf} statements to a file or a system command, using the {\f1{}>}, {\f1{}>>}, and {\f1{}|} operators.  You can redirect input to the {\f1{}getline} statement using the {\f1{}<} and {\f1{}|} operators.  See {\uldb Redirecting Output of {\f1{}print} and {\f1{}printf}}{\v Redirection}, and {\uldb Explicit Input with {\f1{}getline}}{\v Getline}.\par
\par
\pard{}Regexp\par
\pard\li720{}Short for \'A2regular expression\'A2.  A regexp is a pattern that denotes a set of strings, possibly an infinite set.  For example, the regexp {\f1{}R.*xp} matches any string starting with the letter {\f1{}R} and ending with the letters {\f1{}xp}.  In {\f1{}awk}, regexps are used in patterns and in conditional expressions.  Regexps may contain escape sequences.  See {\uldb Regular Expressions}{\v Regexp}.\par
\par
\pard{}Regular Expression\par
\pard\li720{}See "regexp."\par
\par
\pard{}Regular Expression Constant\par
\pard\li720{}A regular expression constant is a regular expression written within slashes, such as {\f1{}/foo/}.  This regular expression is chosen when you write the {\f1{}awk} program, and cannot be changed doing its execution.  See {\uldb How to Use Regular Expressions}{\v Regexp_Usage}.\par
\par
\pard{}Rule\par
\pard\li720{}A segment of an {\f1{}awk} program that specifies how to process single input records.  A rule consists of a \'A2pattern\'A2 and an \'A2action\'A2.  {\f1{}awk} reads an input record; then, for each rule, if the input record satisfies the rule's pattern, {\f1{}awk} executes the rule's action.  Otherwise, the rule does nothing for that input record.\par
\par
\pard{}Rvalue\par
\pard\li720{}A value that can appear on the right side of an assignment operator.  In {\f1{}awk}, essentially every expression has a value. These values are rvalues.\par
\par
\pard{}{\f1{}sed}\par
\pard\li720{}See "Stream Editor."\par
\par
\pard{}Short-Circuit\par
\pard\li720{}The nature of the {\f1{}awk} logical operators {\f1{}&&} and {\f1{}||}.  If the value of the entire expression can be deduced from evaluating just the left-hand side of these operators, the right-hand side will not be evaluated (see {\uldb Boolean Expressions}{\v Boolean_Ops}).\par
\par
\pard{}Side Effect\par
\pard\li720{}A side effect occurs when an expression has an effect aside from merely producing a value.  Assignment expressions, increment and decrement expressions and function calls have side effects.  See {\uldb Assignment Expressions}{\v Assignment_Ops}.\par
\par
\pard{}Single Precision\par
\pard\li720{}An internal representation of numbers that can have fractional parts.  Single precision numbers keep track of fewer digits than do double precision numbers, but operations on them are less expensive in terms of CPU time.  This is the type used by some very old versions of {\f1{}awk} to store numeric values.  It is the C type {\f1{}float}.\par
\par
\pard{}Space\par
\pard\li720{}The character generated by hitting the space bar on the keyboard.\par
\par
\pard{}Special File\par
\pard\li720{}A file name interpreted internally by {\f1{}gawk}, instead of being handed directly to the underlying operating system.  For example, {\f1{}/dev/stderr}.  See {\uldb Special File Names in {\f1{}gawk}}{\v Special_Files}.\par
\par
\pard{}Stream Editor\par
\pard\li720{}A program that reads records from an input stream and processes them one or more at a time.  This is in contrast with batch programs, which may expect to read their input files in entirety before starting to do anything, and with interactive programs, which require input from the user.\par
\par
\pard{}String\par
\pard\li720{}A datum consisting of a sequence of characters, such as {\f1{}I am a string}.  Constant strings are written with double-quotes in the {\f1{}awk} language, and may contain escape sequences.  See {\uldb Escape Sequences}{\v Escape_Sequences}.\par
\par
\pard{}Tab\par
\pard\li720{}The character generated by hitting the {\f1{}TAB} key on the keyboard.  It usually expands to up to eight spaces upon output.\par
\par
\pard{}Unix\par
\pard\li720{}A computer operating system originally developed in the early 1970's at AT&T Bell Laboratories.  It initially became popular in universities around the world, and later moved into commercial evnironments as a software development system and network server system. There are many commercial versions of Unix, as well as several work-alike systems whose source code is freely available (such as Linux, NetBSD, and FreeBSD).\par
\par
\pard{}Whitespace\par
\pard\li720{}A sequence of space, tab, or newline characters occurring inside an input record or a string.\par
\pard{}}\par
\page\pard Node: {\b Copying}, \keepn Next: {\uldb Index}{\v Index}, Prev: {\uldb Glossary}{\v Glossary}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Copying}
#{\footnote Copying}
${\footnote \pard{}GNU GENERAL PUBLIC LICENSE}\par
\pard{\fs24\b GNU GENERAL PUBLIC LICENSE}\par
\par
\pard{}Version 2, June 1991\qc{}\par
\par
{\pard\keep\li720\f1{}Copyright (C) 1989, 1991 Free Software Foundation, Inc.\line
59 Temple Place --- Suite 330, Boston, MA 02111-1307, USA\line
\line
Everyone is permitted to copy and distribute verbatim copies\line
of this license document, but changing it is not allowed.\par
\pard\f0{}}\par
\pard{\b Preamble}\par
\par
\pard{}The licenses for most software are designed to take away your freedom to share and change it.  By contrast, the GNU General Public License is intended to guarantee your freedom to share and change free software--to make sure the software is free for all its users.  This General Public License applies to most of the Free Software Foundation's software and to any other program whose authors commit to using it.  (Some other Free Software Foundation software is covered by the GNU Library General Public License instead.)  You can apply it to your programs, too.\par
\par
\pard{}When we speak of free software, we are referring to freedom, not price.  Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs; and that you know you can do these things.\par
\par
\pard{}To protect your rights, we need to make restrictions that forbid anyone to deny you these rights or to ask you to surrender the rights.  These restrictions translate to certain responsibilities for you if you distribute copies of the software, or if you modify it.\par
\par
\pard{}For example, if you distribute copies of such a program, whether gratis or for a fee, you must give the recipients all the rights that you have.  You must make sure that they, too, receive or can get the source code.  And you must show them these terms so they know their rights.\par
\par
\pard{}We protect your rights with two steps: (1) copyright the software, and (2) offer you this license which gives you legal permission to copy, distribute and/or modify the software.\par
\par
\pard{}Also, for each author's protection and ours, we want to make certain that everyone understands that there is no warranty for this free software.  If the software is modified by someone else and passed on, we want its recipients to know that what they have is not the original, so that any problems introduced by others will not reflect on the original authors' reputations.\par
\par
\pard{}Finally, any free program is threatened constantly by software patents.  We wish to avoid the danger that redistributors of a free program will individually obtain patent licenses, in effect making the program proprietary.  To prevent this, we have made it clear that any patent must be licensed for everyone's free use or not licensed at all.\par
\par
\pard{}The precise terms and conditions for copying, distribution and modification follow.\par
\par
{\pard{}TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\qc{}\par
\par
}{\pard\fi-720\li720\tx144\tx720{}\tab{}0. \tab{}This License applies to any program or other work which contains a notice placed by the copyright holder saying it may be distributed under the terms of this General Public License.  The "Program", below, refers to any such program or work, and a "work based on the Program" means either the Program or any derivative work under copyright law: that is to say, a work containing the Program or a portion of it, either verbatim or with modifications and/or translated into another language.  (Hereinafter, translation is included without limitation in the term "modification".)  Each licensee is addressed as "you".\par
\par
\pard\li720{}Activities other than copying, distribution and modification are not covered by this License; they are outside its scope.  The act of running the Program is not restricted, and the output from the Program is covered only if its contents constitute a work based on the Program (independent of having been made by running the Program).  Whether that is true depends on what the Program does.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}1. \tab{}You may copy and distribute verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and give any other recipients of the Program a copy of this License along with the Program.\par
\par
\pard\li720{}You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}2. \tab{}You may modify your copy or copies of the Program or any portion of it, thus forming a work based on the Program, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions:\par
\par
{\pard\fi-720\li1440\tx864\tx1440{}\tab{}a.\tab{}You must cause the modified files to carry prominent notices stating that you changed the files and the date of any change.\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}b.\tab{}You must cause any work that you distribute or publish, that in whole or in part contains or is derived from the Program or any part thereof, to be licensed as a whole at no charge to all third parties under the terms of this License.\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}c.\tab{}If the modified program normally reads commands interactively when run, you must cause it, when started running for such interactive use in the most ordinary way, to print or display an announcement including an appropriate copyright notice and a notice that there is no warranty (or else, saying that you provide a warranty) and that users may redistribute the program under these conditions, and telling the user how to view a copy of this License.  (Exception: if the Program itself is interactive but does not normally print such an announcement, your work based on the Program is not required to print an announcement.)\par
\pard\li720{}}\par
\pard\li720{}These requirements apply to the modified work as a whole.  If identifiable sections of that work are not derived from the Program, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works.  But when you distribute the same sections as part of a whole which is a work based on the Program, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it.\par
\par
\pard\li720{}Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Program.\par
\par
\pard\li720{}In addition, mere aggregation of another work not based on the Program with the Program (or with a work based on the Program) on a volume of a storage or distribution medium does not bring the other work under the scope of this License.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}3. \tab{}You may copy and distribute the Program (or a work based on it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you also do one of the following:\par
\par
{\pard\fi-720\li1440\tx864\tx1440{}\tab{}a.\tab{}Accompany it with the complete corresponding machine-readable source code, which must be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or,\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}b.\tab{}Accompany it with a written offer, valid for at least three years, to give any third party, for a charge no more than your cost of physically performing source distribution, a complete machine-readable copy of the corresponding source code, to be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or,\par
\par
\pard\fi-720\li1440\tx864\tx1440{}\tab{}c.\tab{}Accompany it with the information you received as to the offer to distribute corresponding source code.  (This alternative is allowed only for non-commercial distribution and only if you received the program in object code or executable form with such an offer, in accord with Subsection b above.)\par
\pard\li720{}}\par
\pard\li720{}The source code for a work means the preferred form of the work for making modifications to it.  For an executable work, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the executable.  However, as a special exception, the source code distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable.\par
\par
\pard\li720{}If distribution of executable or object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place counts as distribution of the source code, even though third parties are not compelled to copy the source along with the object code.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}4. \tab{}You may not copy, modify, sublicense, or distribute the Program except as expressly provided under this License.  Any attempt otherwise to copy, modify, sublicense or distribute the Program is void, and will automatically terminate your rights under this License.  However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}5. \tab{}You are not required to accept this License, since you have not signed it.  However, nothing else grants you permission to modify or distribute the Program or its derivative works.  These actions are prohibited by law if you do not accept this License.  Therefore, by modifying or distributing the Program (or any work based on the Program), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Program or works based on it.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}6. \tab{}Each time you redistribute the Program (or any work based on the Program), the recipient automatically receives a license from the original licensor to copy, distribute or modify the Program subject to these terms and conditions.  You may not impose any further restrictions on the recipients' exercise of the rights granted herein.  You are not responsible for enforcing compliance by third parties to this License.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}7. \tab{}If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License.  If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Program at all.  For example, if a patent license would not permit royalty-free redistribution of the Program by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Program.\par
\par
\pard\li720{}If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply and the section as a whole is intended to apply in other circumstances.\par
\par
\pard\li720{}It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system, which is implemented by public license practices.  Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice.\par
\par
\pard\li720{}This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}8. \tab{}If the distribution and/or use of the Program is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Program under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded.  In such case, this License incorporates the limitation as if written in the body of this License.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}9. \tab{}The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time.  Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.\par
\par
\pard\li720{}Each version is given a distinguishing version number.  If the Program specifies a version number of this License which applies to it and "any later version", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation.  If the Program does not specify a version number of this License, you may choose any version ever published by the Free Software Foundation.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}10. \tab{}If you wish to incorporate parts of the Program into other free programs whose distribution conditions are different, write to the author to ask for permission.  For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this.  Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally.\par
\par
{\pard\li720{}NO WARRANTY\qc{}\par
\par
}\pard\fi-720\li720\tx144\tx720{}\tab{}11. \tab{}BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\par
\par
\pard\fi-720\li720\tx144\tx720{}\tab{}12. \tab{}IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\par
\pard{}}\par
{\pard{}END OF TERMS AND CONDITIONS\qc{}\par
\par
}\pard{\b How to Apply These Terms to Your New Programs}\par
\par
\pard{}If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.\par
\par
\pard{}To do so, attach the following notices to the program.  It is safest to attach them to the start of each source file to most effectively convey the exclusion of warranty; and each file should have at least the "copyright" line and a pointer to where the full notice is found.\par
\par
{{\i \pard\li720\f1{}one line to give the program's name and an idea of what it does.}\line
Copyright (C) 19{\i yy}  {\i name of author}\line
\line
This program is free software; you can redistribute it and/or\line
modify it under the terms of the GNU General Public License\line
as published by the Free Software Foundation; either version 2\line
of the License, or (at your option) any later version.\line
\line
This program is distributed in the hope that it will be useful,\line
but WITHOUT ANY WARRANTY; without even the implied warranty of\line
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\line
GNU General Public License for more details.\line
\line
You should have received a copy of the GNU General Public License\line
along with this program; if not, write to the Free Software\line
Foundation, Inc., 59 Temple Place --- Suite 330, Boston, MA 02111-1307, USA.\par
\pard\f0{}}\par
\pard{}Also add information on how to contact you by electronic and paper mail.\par
\par
\pard{}If the program is interactive, make it output a short notice like this when it starts in an interactive mode:\par
\par
{\pard\keep\li720\f1{}Gnomovision version 69, Copyright (C) 19{\i yy} {\i name of author}\line
Gnomovision comes with ABSOLUTELY NO WARRANTY; for details\line
type `show w'.  This is free software, and you are welcome\line
to redistribute it under certain conditions; type `show c'\line
for details.\par
\pard\f0{}}\par
\pard{}The hypothetical commands {\f1{}show w} and {\f1{}show c} should show the appropriate parts of the General Public License.  Of course, the commands you use may be called something other than {\f1{}show w} and {\f1{}show c}; they could even be mouse-clicks or menu items--whatever suits your program.\par
\par
\pard{}You should also get your employer (if you work as a programmer) or your school, if any, to sign a "copyright disclaimer" for the program, if necessary.  Here is a sample; alter the names:\par
\par
{{\pard\keep\li720\f1{}Yoyodyne, Inc., hereby disclaims all copyright\line
interest in the program `Gnomovision'\line
(which makes passes at compilers) written\line
by James Hacker.\line
\line
{\i signature of Ty Coon}, 1 April 1989\line
Ty Coon, President of Vice\par
\pard\keep\li720{}}}\par
\pard\f0{}This General Public License does not permit incorporating your program into proprietary programs.  If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library.  If this is what you want to do, use the GNU Library General Public License instead of this License.\par
\par
\page\pard Node: {\b Index}, \keepn Next: {\uldb }{\v }, Prev: {\uldb Copying}{\v Copying}, Up: {\uldb Top}{\v Top}\line
K{\footnote K Index}
#{\footnote Index}
${\footnote \pard{}Index}\par
\pard{\fs24\b Index}\par
\par
{\fi-2880\li2880\tx2880_gr_init:\tab {\uldb Group Functions}{\v Group_Functions}.\par}{\fi-2880\li2880\tx2880_pw_init:\tab {\uldb Passwd Functions}{\v Passwd_Functions}.\par}{\fi-2880\li2880\tx2880_tm_addup:\tab {\uldb Mktime Function}{\v Mktime_Function}.\par}{\fi-2880\li2880\tx2880_tm_isleap:\tab {\uldb Mktime Function}{\v Mktime_Function}.\par}{\fi-2880\li2880\tx2880accessing fields:\tab {\uldb Fields}{\v Fields}.\par}{\fi-2880\li2880\tx2880account information <1>:\tab {\uldb Group Functions}{\v Group_Functions}.\par}{\fi-2880\li2880\tx2880account information:\tab {\uldb Passwd Functions}{\v Passwd_Functions}.\par}{\fi-2880\li2880\tx2880acronym:\tab {\uldb History}{\v History}.\par}{\fi-2880\li2880\tx2880action, curly braces:\tab {\uldb Action Overview}{\v Action_Overview}.\par}{\fi-2880\li2880\tx2880action, default:\tab {\uldb Very Simple}{\v Very_Simple}.\par}{\fi-2880\li2880\tx2880action, definition of:\tab {\uldb Action Overview}{\v Action_Overview}.\par}{\fi-2880\li2880\tx2880action, empty:\tab {\uldb Very Simple}{\v Very_Simple}.\par}{\fi-2880\li2880\tx2880action, separating statements:\tab {\uldb Action Overview}{\v Action_Overview}.\par}{\fi-2880\li2880\tx2880adding new features:\tab {\uldb Adding Code}{\v Adding_Code}.\par}{\fi-2880\li2880\tx2880addition:\tab {\uldb Arithmetic Ops}{\v Arithmetic_Ops}.\par}{\fi-2880\li2880\tx2880Aho, Alfred:\tab {\uldb History}{\v History}.\par}{\fi-2880\li2880\tx2880AI programming, using {\f1{}gawk}:\tab {\uldb Distribution contents}{\v Distribution_contents}.\par}{\fi-2880\li2880\tx2880alarm.awk:\tab {\uldb Alarm Program}{\v Alarm_Program}.\par}{\fi-2880\li2880\tx2880amiga:\tab {\uldb Amiga Installation}{\v Amiga_Installation}.\par}{\fi-2880\li2880\tx2880anchors in regexps:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880and operator:\tab {\uldb Boolean Ops}{\v Boolean_Ops}.\par}{\fi-2880\li2880\tx2880anonymous {\f1{}ftp} <1>:\tab {\uldb Getting}{\v Getting}.\par}{\fi-2880\li2880\tx2880anonymous {\f1{}ftp}:\tab {\uldb Other Versions}{\v Other_Versions}.\par}{\fi-2880\li2880\tx2880applications of {\f1{}awk}:\tab {\uldb When}{\v When}.\par}{\fi-2880\li2880\tx2880ARGC:\tab {\uldb Auto-set}{\v Auto_set}.\par}{\fi-2880\li2880\tx2880ARGIND <1>:\tab {\uldb Other Arguments}{\v Other_Arguments}.\par}{\fi-2880\li2880\tx2880ARGIND:\tab {\uldb Auto-set}{\v Auto_set}.\par}{\fi-2880\li2880\tx2880argument processing:\tab {\uldb Getopt Function}{\v Getopt_Function}.\par}{\fi-2880\li2880\tx2880arguments in function call:\tab {\uldb Function Calls}{\v Function_Calls}.\par}{\fi-2880\li2880\tx2880arguments, command line:\tab {\uldb Invoking Gawk}{\v Invoking_Gawk}.\par}{\fi-2880\li2880\tx2880ARGV <1>:\tab {\uldb Auto-set}{\v Auto_set}.\par}{\fi-2880\li2880\tx2880ARGV:\tab {\uldb Other Arguments}{\v Other_Arguments}.\par}{\fi-2880\li2880\tx2880arithmetic operators:\tab {\uldb Arithmetic Ops}{\v Arithmetic_Ops}.\par}{\fi-2880\li2880\tx2880array assignment:\tab {\uldb Assigning Elements}{\v Assigning_Elements}.\par}{\fi-2880\li2880\tx2880array reference:\tab {\uldb Reference to Elements}{\v Reference_to_Elements}.\par}{\fi-2880\li2880\tx2880Array subscripts and {\f1{}IGNORECASE}:\tab {\uldb Array Intro}{\v Array_Intro}.\par}{\fi-2880\li2880\tx2880array subscripts, uninitialized variables:\tab {\uldb Uninitialized Subscripts}{\v Uninitialized_Subscripts}.\par}{\fi-2880\li2880\tx2880arrays:\tab {\uldb Array Intro}{\v Array_Intro}.\par}{\fi-2880\li2880\tx2880arrays, associative:\tab {\uldb Array Intro}{\v Array_Intro}.\par}{\fi-2880\li2880\tx2880arrays, definition of:\tab {\uldb Array Intro}{\v Array_Intro}.\par}{\fi-2880\li2880\tx2880arrays, deleting an element:\tab {\uldb Delete}{\v Delete}.\par}{\fi-2880\li2880\tx2880arrays, deleting entire contents:\tab {\uldb Delete}{\v Delete}.\par}{\fi-2880\li2880\tx2880arrays, multi-dimensional subscripts:\tab {\uldb Multi-dimensional}{\v Multi_dimensional}.\par}{\fi-2880\li2880\tx2880arrays, presence of elements:\tab {\uldb Reference to Elements}{\v Reference_to_Elements}.\par}{\fi-2880\li2880\tx2880arrays, sparse:\tab {\uldb Array Intro}{\v Array_Intro}.\par}{\fi-2880\li2880\tx2880arrays, special {\f1{}for} statement:\tab {\uldb Scanning an Array}{\v Scanning_an_Array}.\par}{\fi-2880\li2880\tx2880arrays, the {\f1{}in} operator:\tab {\uldb Reference to Elements}{\v Reference_to_Elements}.\par}{\fi-2880\li2880\tx2880artificial intelligence, using {\f1{}gawk}:\tab {\uldb Distribution contents}{\v Distribution_contents}.\par}{\fi-2880\li2880\tx2880ASCII:\tab {\uldb Ordinal Functions}{\v Ordinal_Functions}.\par}{\fi-2880\li2880\tx2880assert:\tab {\uldb Assert Function}{\v Assert_Function}.\par}{\fi-2880\li2880\tx2880assertions:\tab {\uldb Assert Function}{\v Assert_Function}.\par}{\fi-2880\li2880\tx2880assignment operators:\tab {\uldb Assignment Ops}{\v Assignment_Ops}.\par}{\fi-2880\li2880\tx2880assignment to fields:\tab {\uldb Changing Fields}{\v Changing_Fields}.\par}{\fi-2880\li2880\tx2880associative arrays:\tab {\uldb Array Intro}{\v Array_Intro}.\par}{\fi-2880\li2880\tx2880atan2:\tab {\uldb Numeric Functions}{\v Numeric_Functions}.\par}{\fi-2880\li2880\tx2880atari:\tab {\uldb Atari Installation}{\v Atari_Installation}.\par}{\fi-2880\li2880\tx2880automatic initialization:\tab {\uldb More Complex}{\v More_Complex}.\par}{\fi-2880\li2880\tx2880backslash continuation <1>:\tab {\uldb Statements/Lines}{\v Statements_Lines}.\par}{\fi-2880\li2880\tx2880backslash continuation:\tab {\uldb Egrep Program}{\v Egrep_Program}.\par}{\fi-2880\li2880\tx2880backslash continuation and comments:\tab {\uldb Statements/Lines}{\v Statements_Lines}.\par}{\fi-2880\li2880\tx2880backslash continuation in {\f1{}csh} <1>:\tab {\uldb More Complex}{\v More_Complex}.\par}{\fi-2880\li2880\tx2880backslash continuation in {\f1{}csh}:\tab {\uldb Statements/Lines}{\v Statements_Lines}.\par}{\fi-2880\li2880\tx2880basic function of {\f1{}awk}:\tab {\uldb Getting Started}{\v Getting_Started}.\par}{\fi-2880\li2880\tx2880beginfile:\tab {\uldb Filetrans Function}{\v Filetrans_Function}.\par}{\fi-2880\li2880\tx2880body of a loop:\tab {\uldb While Statement}{\v While_Statement}.\par}{\fi-2880\li2880\tx2880book, using this:\tab {\uldb This Manual}{\v This_Manual}.\par}{\fi-2880\li2880\tx2880boolean expressions:\tab {\uldb Boolean Ops}{\v Boolean_Ops}.\par}{\fi-2880\li2880\tx2880boolean operators:\tab {\uldb Boolean Ops}{\v Boolean_Ops}.\par}{\fi-2880\li2880\tx2880Brennan, Michael <1>:\tab {\uldb Other Versions}{\v Other_Versions}.\par}{\fi-2880\li2880\tx2880Brennan, Michael <2>:\tab {\uldb Simple Sed}{\v Simple_Sed}.\par}{\fi-2880\li2880\tx2880Brennan, Michael:\tab {\uldb Delete}{\v Delete}.\par}{\fi-2880\li2880\tx2880buffer matching operators:\tab {\uldb GNU Regexp Operators}{\v GNU_Regexp_Operators}.\par}{\fi-2880\li2880\tx2880buffering output:\tab {\uldb I/O Functions}{\v I_O_Functions}.\par}{\fi-2880\li2880\tx2880buffering, interactive vs. non-interactive:\tab {\uldb I/O Functions}{\v I_O_Functions}.\par}{\fi-2880\li2880\tx2880buffering, non-interactive vs. interactive:\tab {\uldb I/O Functions}{\v I_O_Functions}.\par}{\fi-2880\li2880\tx2880buffers, flushing:\tab {\uldb I/O Functions}{\v I_O_Functions}.\par}{\fi-2880\li2880\tx2880bugs, known in {\f1{}gawk}:\tab {\uldb Known Bugs}{\v Known_Bugs}.\par}{\fi-2880\li2880\tx2880built-in functions:\tab {\uldb Built-in}{\v Built_in}.\par}{\fi-2880\li2880\tx2880built-in variables:\tab {\uldb Built-in Variables}{\v Built_in_Variables}.\par}{\fi-2880\li2880\tx2880built-in variables, convey information:\tab {\uldb Auto-set}{\v Auto_set}.\par}{\fi-2880\li2880\tx2880built-in variables, user modifiable:\tab {\uldb User-modified}{\v User_modified}.\par}{\fi-2880\li2880\tx2880call by reference:\tab {\uldb Function Caveats}{\v Function_Caveats}.\par}{\fi-2880\li2880\tx2880call by value:\tab {\uldb Function Caveats}{\v Function_Caveats}.\par}{\fi-2880\li2880\tx2880calling a function <1>:\tab {\uldb Function Calls}{\v Function_Calls}.\par}{\fi-2880\li2880\tx2880calling a function:\tab {\uldb Function Caveats}{\v Function_Caveats}.\par}{\fi-2880\li2880\tx2880case conversion:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880case sensitivity:\tab {\uldb Case-sensitivity}{\v Case_sensitivity}.\par}{\fi-2880\li2880\tx2880changing contents of a field:\tab {\uldb Changing Fields}{\v Changing_Fields}.\par}{\fi-2880\li2880\tx2880changing the record separator:\tab {\uldb Records}{\v Records}.\par}{\fi-2880\li2880\tx2880character classes:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880character encodings:\tab {\uldb Ordinal Functions}{\v Ordinal_Functions}.\par}{\fi-2880\li2880\tx2880character list:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880character list, complemented:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880character sets:\tab {\uldb Ordinal Functions}{\v Ordinal_Functions}.\par}{\fi-2880\li2880\tx2880chr:\tab {\uldb Ordinal Functions}{\v Ordinal_Functions}.\par}{\fi-2880\li2880\tx2880close <1>:\tab {\uldb I/O Functions}{\v I_O_Functions}.\par}{\fi-2880\li2880\tx2880close:\tab {\uldb Close Files And Pipes}{\v Close_Files_And_Pipes}.\par}{\fi-2880\li2880\tx2880closing input files and pipes:\tab {\uldb Close Files And Pipes}{\v Close_Files_And_Pipes}.\par}{\fi-2880\li2880\tx2880closing output files and pipes:\tab {\uldb Close Files And Pipes}{\v Close_Files_And_Pipes}.\par}{\fi-2880\li2880\tx2880coding style used in {\f1{}gawk}:\tab {\uldb Adding Code}{\v Adding_Code}.\par}{\fi-2880\li2880\tx2880collating elements:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880collating symbols:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880command line:\tab {\uldb Invoking Gawk}{\v Invoking_Gawk}.\par}{\fi-2880\li2880\tx2880command line formats:\tab {\uldb Running gawk}{\v Running_gawk}.\par}{\fi-2880\li2880\tx2880command line, setting {\f1{}FS} on:\tab {\uldb Command Line Field Separator}{\v Command_Line_Field_Separator}.\par}{\fi-2880\li2880\tx2880comments:\tab {\uldb Comments}{\v Comments}.\par}{\fi-2880\li2880\tx2880comments and backslash continuation:\tab {\uldb Statements/Lines}{\v Statements_Lines}.\par}{\fi-2880\li2880\tx2880common mistakes <1>:\tab {\uldb Computed Regexps}{\v Computed_Regexps}.\par}{\fi-2880\li2880\tx2880common mistakes <2>:\tab {\uldb Basic Field Splitting}{\v Basic_Field_Splitting}.\par}{\fi-2880\li2880\tx2880common mistakes <3>:\tab {\uldb Print Examples}{\v Print_Examples}.\par}{\fi-2880\li2880\tx2880common mistakes:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880comparison expressions:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880comparisons, string vs. regexp:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880compatibility mode <1>:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880compatibility mode:\tab {\uldb POSIX/GNU}{\v POSIX_GNU}.\par}{\fi-2880\li2880\tx2880complemented character list:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880compound statement:\tab {\uldb Statements}{\v Statements}.\par}{\fi-2880\li2880\tx2880computed regular expressions:\tab {\uldb Computed Regexps}{\v Computed_Regexps}.\par}{\fi-2880\li2880\tx2880concatenation:\tab {\uldb Concatenation}{\v Concatenation}.\par}{\fi-2880\li2880\tx2880conditional expression:\tab {\uldb Conditional Exp}{\v Conditional_Exp}.\par}{\fi-2880\li2880\tx2880configuring {\f1{}gawk}:\tab {\uldb Configuration Philosophy}{\v Configuration_Philosophy}.\par}{\fi-2880\li2880\tx2880constants, types of:\tab {\uldb Constants}{\v Constants}.\par}{\fi-2880\li2880\tx2880continuation of lines:\tab {\uldb Statements/Lines}{\v Statements_Lines}.\par}{\fi-2880\li2880\tx2880control statement:\tab {\uldb Statements}{\v Statements}.\par}{\fi-2880\li2880\tx2880conversion of case:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880conversion of strings and numbers:\tab {\uldb Conversion}{\v Conversion}.\par}{\fi-2880\li2880\tx2880conversions, during subscripting:\tab {\uldb Numeric Array Subscripts}{\v Numeric_Array_Subscripts}.\par}{\fi-2880\li2880\tx2880converting dates to timestamps:\tab {\uldb Mktime Function}{\v Mktime_Function}.\par}{\fi-2880\li2880\tx2880CONVFMT <1>:\tab {\uldb User-modified}{\v User_modified}.\par}{\fi-2880\li2880\tx2880CONVFMT <2>:\tab {\uldb Numeric Array Subscripts}{\v Numeric_Array_Subscripts}.\par}{\fi-2880\li2880\tx2880CONVFMT:\tab {\uldb Conversion}{\v Conversion}.\par}{\fi-2880\li2880\tx2880cos:\tab {\uldb Numeric Functions}{\v Numeric_Functions}.\par}{\fi-2880\li2880\tx2880curly braces:\tab {\uldb Action Overview}{\v Action_Overview}.\par}{\fi-2880\li2880\tx2880cut.awk:\tab {\uldb Cut Program}{\v Cut_Program}.\par}{\fi-2880\li2880\tx2880d.c., see "dark corner":\tab {\uldb This Manual}{\v This_Manual}.\par}{\fi-2880\li2880\tx2880dark corner <1>:\tab {\uldb Field Splitting Summary}{\v Field_Splitting_Summary}.\par}{\fi-2880\li2880\tx2880dark corner <2>:\tab {\uldb Multiple Line}{\v Multiple_Line}.\par}{\fi-2880\li2880\tx2880dark corner <3>:\tab {\uldb Break Statement}{\v Break_Statement}.\par}{\fi-2880\li2880\tx2880dark corner <4>:\tab {\uldb Truth Values}{\v Truth_Values}.\par}{\fi-2880\li2880\tx2880dark corner <5>:\tab {\uldb Conversion}{\v Conversion}.\par}{\fi-2880\li2880\tx2880dark corner <6>:\tab {\uldb Single Character Fields}{\v Single_Character_Fields}.\par}{\fi-2880\li2880\tx2880dark corner <7>:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880dark corner <8>:\tab {\uldb Assignment Options}{\v Assignment_Options}.\par}{\fi-2880\li2880\tx2880dark corner <9>:\tab {\uldb Format Modifiers}{\v Format_Modifiers}.\par}{\fi-2880\li2880\tx2880dark corner <10>:\tab {\uldb Escape Sequences}{\v Escape_Sequences}.\par}{\fi-2880\li2880\tx2880dark corner <11>:\tab {\uldb Uninitialized Subscripts}{\v Uninitialized_Subscripts}.\par}{\fi-2880\li2880\tx2880dark corner <12>:\tab {\uldb Using BEGIN/END}{\v Using_BEGIN_END}.\par}{\fi-2880\li2880\tx2880dark corner <13>:\tab {\uldb Using Constant Regexps}{\v Using_Constant_Regexps}.\par}{\fi-2880\li2880\tx2880dark corner <14>:\tab {\uldb Getline Summary}{\v Getline_Summary}.\par}{\fi-2880\li2880\tx2880dark corner <15>:\tab {\uldb Other Arguments}{\v Other_Arguments}.\par}{\fi-2880\li2880\tx2880dark corner <16>:\tab {\uldb Plain Getline}{\v Plain_Getline}.\par}{\fi-2880\li2880\tx2880dark corner <17>:\tab {\uldb Using Constant Regexps}{\v Using_Constant_Regexps}.\par}{\fi-2880\li2880\tx2880dark corner <18>:\tab {\uldb Continue Statement}{\v Continue_Statement}.\par}{\fi-2880\li2880\tx2880dark corner <19>:\tab {\uldb OFMT}{\v OFMT}.\par}{\fi-2880\li2880\tx2880dark corner <20>:\tab {\uldb Auto-set}{\v Auto_set}.\par}{\fi-2880\li2880\tx2880dark corner <21>:\tab {\uldb Exit Statement}{\v Exit_Statement}.\par}{\fi-2880\li2880\tx2880dark corner <22>:\tab {\uldb Invoking Gawk}{\v Invoking_Gawk}.\par}{\fi-2880\li2880\tx2880dark corner <23>:\tab {\uldb This Manual}{\v This_Manual}.\par}{\fi-2880\li2880\tx2880dark corner <24>:\tab {\uldb Control Letters}{\v Control_Letters}.\par}{\fi-2880\li2880\tx2880dark corner:\tab {\uldb Records}{\v Records}.\par}{\fi-2880\li2880\tx2880data-driven languages:\tab {\uldb Getting Started}{\v Getting_Started}.\par}{\fi-2880\li2880\tx2880dates, converting to timestamps:\tab {\uldb Mktime Function}{\v Mktime_Function}.\par}{\fi-2880\li2880\tx2880decrement operators:\tab {\uldb Increment Ops}{\v Increment_Ops}.\par}{\fi-2880\li2880\tx2880default action:\tab {\uldb Very Simple}{\v Very_Simple}.\par}{\fi-2880\li2880\tx2880default pattern:\tab {\uldb Very Simple}{\v Very_Simple}.\par}{\fi-2880\li2880\tx2880defining functions:\tab {\uldb Definition Syntax}{\v Definition_Syntax}.\par}{\fi-2880\li2880\tx2880Deifik, Scott <1>:\tab {\uldb Bugs}{\v Bugs}.\par}{\fi-2880\li2880\tx2880Deifik, Scott:\tab {\uldb Acknowledgements}{\v Acknowledgements}.\par}{\fi-2880\li2880\tx2880deleting elements of arrays:\tab {\uldb Delete}{\v Delete}.\par}{\fi-2880\li2880\tx2880deleting entire arrays:\tab {\uldb Delete}{\v Delete}.\par}{\fi-2880\li2880\tx2880deprecated features:\tab {\uldb Obsolete}{\v Obsolete}.\par}{\fi-2880\li2880\tx2880deprecated options:\tab {\uldb Obsolete}{\v Obsolete}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <1>:\tab {\uldb Arithmetic Ops}{\v Arithmetic_Ops}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <2>:\tab {\uldb Scalar Constants}{\v Scalar_Constants}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <3>:\tab {\uldb AWKPATH Variable}{\v AWKPATH_Variable}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <4>:\tab {\uldb Records}{\v Records}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <5>:\tab {\uldb Using Constant Regexps}{\v Using_Constant_Regexps}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <6>:\tab {\uldb Case-sensitivity}{\v Case_sensitivity}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <7>:\tab {\uldb Conditional Exp}{\v Conditional_Exp}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <8>:\tab {\uldb Close Files And Pipes}{\v Close_Files_And_Pipes}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <9>:\tab {\uldb Nextfile Statement}{\v Nextfile_Statement}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <10>:\tab {\uldb ARGC and ARGV}{\v ARGC_and_ARGV}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <11>:\tab {\uldb I/O And BEGIN/END}{\v I_O_And_BEGIN_END}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <12>:\tab {\uldb Getline Summary}{\v Getline_Summary}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <13>:\tab {\uldb Single Character Fields}{\v Single_Character_Fields}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <14>:\tab {\uldb Delete}{\v Delete}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <15>:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <16>:\tab {\uldb Redirection}{\v Redirection}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <17>:\tab {\uldb Special Files}{\v Special_Files}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <18>:\tab {\uldb Calling Built-in}{\v Calling_Built_in}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <19>:\tab {\uldb Close Files And Pipes}{\v Close_Files_And_Pipes}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk} <20>:\tab {\uldb Getline Intro}{\v Getline_Intro}.\par}{\fi-2880\li2880\tx2880differences between {\f1{}gawk} and {\f1{}awk}:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880directory search:\tab {\uldb AWKPATH Variable}{\v AWKPATH_Variable}.\par}{\fi-2880\li2880\tx2880division:\tab {\uldb Arithmetic Ops}{\v Arithmetic_Ops}.\par}{\fi-2880\li2880\tx2880documenting {\f1{}awk} programs <1>:\tab {\uldb Library Names}{\v Library_Names}.\par}{\fi-2880\li2880\tx2880documenting {\f1{}awk} programs:\tab {\uldb Comments}{\v Comments}.\par}{\fi-2880\li2880\tx2880dupword.awk:\tab {\uldb Dupword Program}{\v Dupword_Program}.\par}{\fi-2880\li2880\tx2880dynamic regular expressions:\tab {\uldb Computed Regexps}{\v Computed_Regexps}.\par}{\fi-2880\li2880\tx2880EBCDIC:\tab {\uldb Ordinal Functions}{\v Ordinal_Functions}.\par}{\fi-2880\li2880\tx2880egrep.awk:\tab {\uldb Egrep Program}{\v Egrep_Program}.\par}{\fi-2880\li2880\tx2880element assignment:\tab {\uldb Assigning Elements}{\v Assigning_Elements}.\par}{\fi-2880\li2880\tx2880element of array:\tab {\uldb Reference to Elements}{\v Reference_to_Elements}.\par}{\fi-2880\li2880\tx2880empty action:\tab {\uldb Very Simple}{\v Very_Simple}.\par}{\fi-2880\li2880\tx2880empty pattern:\tab {\uldb Empty}{\v Empty}.\par}{\fi-2880\li2880\tx2880empty program:\tab {\uldb Invoking Gawk}{\v Invoking_Gawk}.\par}{\fi-2880\li2880\tx2880empty string <1>:\tab {\uldb Records}{\v Records}.\par}{\fi-2880\li2880\tx2880empty string <2>:\tab {\uldb Truth Values}{\v Truth_Values}.\par}{\fi-2880\li2880\tx2880empty string <3>:\tab {\uldb Conversion}{\v Conversion}.\par}{\fi-2880\li2880\tx2880empty string:\tab {\uldb Regexp Field Splitting}{\v Regexp_Field_Splitting}.\par}{\fi-2880\li2880\tx2880endfile:\tab {\uldb Filetrans Function}{\v Filetrans_Function}.\par}{\fi-2880\li2880\tx2880endgrent:\tab {\uldb Group Functions}{\v Group_Functions}.\par}{\fi-2880\li2880\tx2880endpwent:\tab {\uldb Passwd Functions}{\v Passwd_Functions}.\par}{\fi-2880\li2880\tx2880ENVIRON:\tab {\uldb Auto-set}{\v Auto_set}.\par}{\fi-2880\li2880\tx2880environment variable, {\f1{}AWKPATH}:\tab {\uldb AWKPATH Variable}{\v AWKPATH_Variable}.\par}{\fi-2880\li2880\tx2880environment variable, {\f1{}POSIXLY_CORRECT}:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880equivalence classes:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880ERRNO <1>:\tab {\uldb Close Files And Pipes}{\v Close_Files_And_Pipes}.\par}{\fi-2880\li2880\tx2880ERRNO <2>:\tab {\uldb Auto-set}{\v Auto_set}.\par}{\fi-2880\li2880\tx2880ERRNO:\tab {\uldb Getline Intro}{\v Getline_Intro}.\par}{\fi-2880\li2880\tx2880errors, common <1>:\tab {\uldb Computed Regexps}{\v Computed_Regexps}.\par}{\fi-2880\li2880\tx2880errors, common <2>:\tab {\uldb Basic Field Splitting}{\v Basic_Field_Splitting}.\par}{\fi-2880\li2880\tx2880errors, common <3>:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880errors, common:\tab {\uldb Print Examples}{\v Print_Examples}.\par}{\fi-2880\li2880\tx2880escape processing, {\f1{}sub} et. al.:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880escape sequence notation:\tab {\uldb Escape Sequences}{\v Escape_Sequences}.\par}{\fi-2880\li2880\tx2880evaluation, order of:\tab {\uldb Calling Built-in}{\v Calling_Built_in}.\par}{\fi-2880\li2880\tx2880examining fields:\tab {\uldb Fields}{\v Fields}.\par}{\fi-2880\li2880\tx2880executable scripts:\tab {\uldb Executable Scripts}{\v Executable_Scripts}.\par}{\fi-2880\li2880\tx2880exp:\tab {\uldb Numeric Functions}{\v Numeric_Functions}.\par}{\fi-2880\li2880\tx2880explicit input:\tab {\uldb Getline}{\v Getline}.\par}{\fi-2880\li2880\tx2880exponentiation:\tab {\uldb Arithmetic Ops}{\v Arithmetic_Ops}.\par}{\fi-2880\li2880\tx2880expression:\tab {\uldb Expressions}{\v Expressions}.\par}{\fi-2880\li2880\tx2880expression, assignment:\tab {\uldb Assignment Ops}{\v Assignment_Ops}.\par}{\fi-2880\li2880\tx2880expression, boolean:\tab {\uldb Boolean Ops}{\v Boolean_Ops}.\par}{\fi-2880\li2880\tx2880expression, comparison:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880expression, conditional:\tab {\uldb Conditional Exp}{\v Conditional_Exp}.\par}{\fi-2880\li2880\tx2880expression, matching:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880extract.awk:\tab {\uldb Extract Program}{\v Extract_Program}.\par}{\fi-2880\li2880\tx2880features, adding:\tab {\uldb Adding Code}{\v Adding_Code}.\par}{\fi-2880\li2880\tx2880fflush:\tab {\uldb I/O Functions}{\v I_O_Functions}.\par}{\fi-2880\li2880\tx2880field operator {\f1{}$}:\tab {\uldb Fields}{\v Fields}.\par}{\fi-2880\li2880\tx2880field separator, choice of:\tab {\uldb Basic Field Splitting}{\v Basic_Field_Splitting}.\par}{\fi-2880\li2880\tx2880field separator, on command line:\tab {\uldb Command Line Field Separator}{\v Command_Line_Field_Separator}.\par}{\fi-2880\li2880\tx2880field separator, {\f1{}FS}:\tab {\uldb Basic Field Splitting}{\v Basic_Field_Splitting}.\par}{\fi-2880\li2880\tx2880field, changing contents of:\tab {\uldb Changing Fields}{\v Changing_Fields}.\par}{\fi-2880\li2880\tx2880fields:\tab {\uldb Fields}{\v Fields}.\par}{\fi-2880\li2880\tx2880fields, separating:\tab {\uldb Basic Field Splitting}{\v Basic_Field_Splitting}.\par}{\fi-2880\li2880\tx2880FIELDWIDTHS:\tab {\uldb User-modified}{\v User_modified}.\par}{\fi-2880\li2880\tx2880file descriptors:\tab {\uldb Special Files}{\v Special_Files}.\par}{\fi-2880\li2880\tx2880file, {\f1{}awk} program:\tab {\uldb Long}{\v Long}.\par}{\fi-2880\li2880\tx2880FILENAME <1>:\tab {\uldb Reading Files}{\v Reading_Files}.\par}{\fi-2880\li2880\tx2880FILENAME <2>:\tab {\uldb Getline Summary}{\v Getline_Summary}.\par}{\fi-2880\li2880\tx2880FILENAME:\tab {\uldb Auto-set}{\v Auto_set}.\par}{\fi-2880\li2880\tx2880Fish, Fred:\tab {\uldb Bugs}{\v Bugs}.\par}{\fi-2880\li2880\tx2880flushing buffers:\tab {\uldb I/O Functions}{\v I_O_Functions}.\par}{\fi-2880\li2880\tx2880FNR <1>:\tab {\uldb Auto-set}{\v Auto_set}.\par}{\fi-2880\li2880\tx2880FNR:\tab {\uldb Records}{\v Records}.\par}{\fi-2880\li2880\tx2880format specifier:\tab {\uldb Control Letters}{\v Control_Letters}.\par}{\fi-2880\li2880\tx2880format string:\tab {\uldb Basic Printf}{\v Basic_Printf}.\par}{\fi-2880\li2880\tx2880format, numeric output:\tab {\uldb OFMT}{\v OFMT}.\par}{\fi-2880\li2880\tx2880formatted output:\tab {\uldb Printf}{\v Printf}.\par}{\fi-2880\li2880\tx2880formatted timestamps:\tab {\uldb Gettimeofday Function}{\v Gettimeofday_Function}.\par}{\fi-2880\li2880\tx2880Free Software Foundation <1>:\tab {\uldb Manual History}{\v Manual_History}.\par}{\fi-2880\li2880\tx2880Free Software Foundation:\tab {\uldb Getting}{\v Getting}.\par}{\fi-2880\li2880\tx2880FreeBSD:\tab {\uldb Manual History}{\v Manual_History}.\par}{\fi-2880\li2880\tx2880Friedl, Jeffrey:\tab {\uldb Acknowledgements}{\v Acknowledgements}.\par}{\fi-2880\li2880\tx2880FS <1>:\tab {\uldb Basic Field Splitting}{\v Basic_Field_Splitting}.\par}{\fi-2880\li2880\tx2880FS:\tab {\uldb User-modified}{\v User_modified}.\par}{\fi-2880\li2880\tx2880function call <1>:\tab {\uldb Function Calls}{\v Function_Calls}.\par}{\fi-2880\li2880\tx2880function call:\tab {\uldb Function Caveats}{\v Function_Caveats}.\par}{\fi-2880\li2880\tx2880function definition:\tab {\uldb Definition Syntax}{\v Definition_Syntax}.\par}{\fi-2880\li2880\tx2880function, recursive:\tab {\uldb Definition Syntax}{\v Definition_Syntax}.\par}{\fi-2880\li2880\tx2880functions, undefined:\tab {\uldb Function Caveats}{\v Function_Caveats}.\par}{\fi-2880\li2880\tx2880functions, user-defined:\tab {\uldb User-defined}{\v User_defined}.\par}{\fi-2880\li2880\tx2880gensub:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880getgrent:\tab {\uldb Group Functions}{\v Group_Functions}.\par}{\fi-2880\li2880\tx2880getgrgid:\tab {\uldb Group Functions}{\v Group_Functions}.\par}{\fi-2880\li2880\tx2880getgrnam:\tab {\uldb Group Functions}{\v Group_Functions}.\par}{\fi-2880\li2880\tx2880getgruser:\tab {\uldb Group Functions}{\v Group_Functions}.\par}{\fi-2880\li2880\tx2880getline:\tab {\uldb Getline}{\v Getline}.\par}{\fi-2880\li2880\tx2880getopt:\tab {\uldb Getopt Function}{\v Getopt_Function}.\par}{\fi-2880\li2880\tx2880getpwent:\tab {\uldb Passwd Functions}{\v Passwd_Functions}.\par}{\fi-2880\li2880\tx2880getpwnam:\tab {\uldb Passwd Functions}{\v Passwd_Functions}.\par}{\fi-2880\li2880\tx2880getpwuid:\tab {\uldb Passwd Functions}{\v Passwd_Functions}.\par}{\fi-2880\li2880\tx2880gettimeofday:\tab {\uldb Gettimeofday Function}{\v Gettimeofday_Function}.\par}{\fi-2880\li2880\tx2880getting {\f1{}gawk}:\tab {\uldb Getting}{\v Getting}.\par}{\fi-2880\li2880\tx2880GNU Project:\tab {\uldb Manual History}{\v Manual_History}.\par}{\fi-2880\li2880\tx2880grcat.c:\tab {\uldb Group Functions}{\v Group_Functions}.\par}{\fi-2880\li2880\tx2880group file:\tab {\uldb Group Functions}{\v Group_Functions}.\par}{\fi-2880\li2880\tx2880group information:\tab {\uldb Group Functions}{\v Group_Functions}.\par}{\fi-2880\li2880\tx2880gsub:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880Hankerson, Darrel <1>:\tab {\uldb Bugs}{\v Bugs}.\par}{\fi-2880\li2880\tx2880Hankerson, Darrel:\tab {\uldb Acknowledgements}{\v Acknowledgements}.\par}{\fi-2880\li2880\tx2880historical features <1>:\tab {\uldb Continue Statement}{\v Continue_Statement}.\par}{\fi-2880\li2880\tx2880historical features <2>:\tab {\uldb Command Line Field Separator}{\v Command_Line_Field_Separator}.\par}{\fi-2880\li2880\tx2880historical features <3>:\tab {\uldb Historical Features}{\v Historical_Features}.\par}{\fi-2880\li2880\tx2880historical features <4>:\tab {\uldb Break Statement}{\v Break_Statement}.\par}{\fi-2880\li2880\tx2880historical features:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880history of {\f1{}awk}:\tab {\uldb History}{\v History}.\par}{\fi-2880\li2880\tx2880histsort.awk:\tab {\uldb History Sorting}{\v History_Sorting}.\par}{\fi-2880\li2880\tx2880how {\f1{}awk} works:\tab {\uldb Two Rules}{\v Two_Rules}.\par}{\fi-2880\li2880\tx2880Hughes, Phil:\tab {\uldb Acknowledgements}{\v Acknowledgements}.\par}{\fi-2880\li2880\tx2880I/O from {\f1{}BEGIN} and {\f1{}END}:\tab {\uldb I/O And BEGIN/END}{\v I_O_And_BEGIN_END}.\par}{\fi-2880\li2880\tx2880id.awk:\tab {\uldb Id Program}{\v Id_Program}.\par}{\fi-2880\li2880\tx2880igawk.sh:\tab {\uldb Igawk Program}{\v Igawk_Program}.\par}{\fi-2880\li2880\tx2880IGNORECASE <1>:\tab {\uldb User-modified}{\v User_modified}.\par}{\fi-2880\li2880\tx2880IGNORECASE <2>:\tab {\uldb Case-sensitivity}{\v Case_sensitivity}.\par}{\fi-2880\li2880\tx2880IGNORECASE:\tab {\uldb Array Intro}{\v Array_Intro}.\par}{\fi-2880\li2880\tx2880ignoring case:\tab {\uldb Case-sensitivity}{\v Case_sensitivity}.\par}{\fi-2880\li2880\tx2880implementation limits <1>:\tab {\uldb Getline Summary}{\v Getline_Summary}.\par}{\fi-2880\li2880\tx2880implementation limits:\tab {\uldb Redirection}{\v Redirection}.\par}{\fi-2880\li2880\tx2880increment operators:\tab {\uldb Increment Ops}{\v Increment_Ops}.\par}{\fi-2880\li2880\tx2880index:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880initialization, automatic:\tab {\uldb More Complex}{\v More_Complex}.\par}{\fi-2880\li2880\tx2880input:\tab {\uldb Reading Files}{\v Reading_Files}.\par}{\fi-2880\li2880\tx2880input file, sample:\tab {\uldb Sample Data Files}{\v Sample_Data_Files}.\par}{\fi-2880\li2880\tx2880input files, skipping:\tab {\uldb Nextfile Function}{\v Nextfile_Function}.\par}{\fi-2880\li2880\tx2880input pipeline:\tab {\uldb Getline/Pipe}{\v Getline_Pipe}.\par}{\fi-2880\li2880\tx2880input redirection:\tab {\uldb Getline/File}{\v Getline_File}.\par}{\fi-2880\li2880\tx2880input, explicit:\tab {\uldb Getline}{\v Getline}.\par}{\fi-2880\li2880\tx2880input, multiple line records:\tab {\uldb Multiple Line}{\v Multiple_Line}.\par}{\fi-2880\li2880\tx2880input, standard:\tab {\uldb Read Terminal}{\v Read_Terminal}.\par}{\fi-2880\li2880\tx2880input, {\f1{}getline} command:\tab {\uldb Getline}{\v Getline}.\par}{\fi-2880\li2880\tx2880installation, amiga:\tab {\uldb Amiga Installation}{\v Amiga_Installation}.\par}{\fi-2880\li2880\tx2880installation, atari:\tab {\uldb Atari Installation}{\v Atari_Installation}.\par}{\fi-2880\li2880\tx2880installation, MS-DOS and OS/2:\tab {\uldb PC Installation}{\v PC_Installation}.\par}{\fi-2880\li2880\tx2880installation, unix:\tab {\uldb Quick Installation}{\v Quick_Installation}.\par}{\fi-2880\li2880\tx2880installation, vms:\tab {\uldb VMS Installation}{\v VMS_Installation}.\par}{\fi-2880\li2880\tx2880int:\tab {\uldb Numeric Functions}{\v Numeric_Functions}.\par}{\fi-2880\li2880\tx2880interaction, {\f1{}awk} and other programs:\tab {\uldb I/O Functions}{\v I_O_Functions}.\par}{\fi-2880\li2880\tx2880interactive buffering vs. non-interactive:\tab {\uldb I/O Functions}{\v I_O_Functions}.\par}{\fi-2880\li2880\tx2880interval expressions:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880invocation of {\f1{}gawk}:\tab {\uldb Invoking Gawk}{\v Invoking_Gawk}.\par}{\fi-2880\li2880\tx2880ISO 8601:\tab {\uldb Time Functions}{\v Time_Functions}.\par}{\fi-2880\li2880\tx2880ISO 8859-1 <1>:\tab {\uldb Case-sensitivity}{\v Case_sensitivity}.\par}{\fi-2880\li2880\tx2880ISO 8859-1:\tab {\uldb Glossary}{\v Glossary}.\par}{\fi-2880\li2880\tx2880ISO Latin-1 <1>:\tab {\uldb Glossary}{\v Glossary}.\par}{\fi-2880\li2880\tx2880ISO Latin-1:\tab {\uldb Case-sensitivity}{\v Case_sensitivity}.\par}{\fi-2880\li2880\tx2880Jaegermann, Michal <1>:\tab {\uldb Bugs}{\v Bugs}.\par}{\fi-2880\li2880\tx2880Jaegermann, Michal:\tab {\uldb Acknowledgements}{\v Acknowledgements}.\par}{\fi-2880\li2880\tx2880join:\tab {\uldb Join Function}{\v Join_Function}.\par}{\fi-2880\li2880\tx2880Kernighan, Brian <1>:\tab {\uldb Other Versions}{\v Other_Versions}.\par}{\fi-2880\li2880\tx2880Kernighan, Brian <2>:\tab {\uldb History}{\v History}.\par}{\fi-2880\li2880\tx2880Kernighan, Brian <3>:\tab {\uldb BTL}{\v BTL}.\par}{\fi-2880\li2880\tx2880Kernighan, Brian <4>:\tab {\uldb Concatenation}{\v Concatenation}.\par}{\fi-2880\li2880\tx2880Kernighan, Brian:\tab {\uldb Acknowledgements}{\v Acknowledgements}.\par}{\fi-2880\li2880\tx2880known bugs:\tab {\uldb Known Bugs}{\v Known_Bugs}.\par}{\fi-2880\li2880\tx2880labels.awk:\tab {\uldb Labels Program}{\v Labels_Program}.\par}{\fi-2880\li2880\tx2880language, data-driven:\tab {\uldb Getting Started}{\v Getting_Started}.\par}{\fi-2880\li2880\tx2880language, procedural:\tab {\uldb Getting Started}{\v Getting_Started}.\par}{\fi-2880\li2880\tx2880language, {\f1{}awk}:\tab {\uldb This Manual}{\v This_Manual}.\par}{\fi-2880\li2880\tx2880leftmost longest match <1>:\tab {\uldb Leftmost Longest}{\v Leftmost_Longest}.\par}{\fi-2880\li2880\tx2880leftmost longest match:\tab {\uldb Multiple Line}{\v Multiple_Line}.\par}{\fi-2880\li2880\tx2880length:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880limitations <1>:\tab {\uldb Getline Summary}{\v Getline_Summary}.\par}{\fi-2880\li2880\tx2880limitations:\tab {\uldb Redirection}{\v Redirection}.\par}{\fi-2880\li2880\tx2880line break:\tab {\uldb Statements/Lines}{\v Statements_Lines}.\par}{\fi-2880\li2880\tx2880line continuation <1>:\tab {\uldb Print Examples}{\v Print_Examples}.\par}{\fi-2880\li2880\tx2880line continuation <2>:\tab {\uldb Boolean Ops}{\v Boolean_Ops}.\par}{\fi-2880\li2880\tx2880line continuation <3>:\tab {\uldb Statements/Lines}{\v Statements_Lines}.\par}{\fi-2880\li2880\tx2880line continuation:\tab {\uldb Conditional Exp}{\v Conditional_Exp}.\par}{\fi-2880\li2880\tx2880Linux <1>:\tab {\uldb Manual History}{\v Manual_History}.\par}{\fi-2880\li2880\tx2880Linux:\tab {\uldb Atari Compiling}{\v Atari_Compiling}.\par}{\fi-2880\li2880\tx2880locale, definition of:\tab {\uldb Time Functions}{\v Time_Functions}.\par}{\fi-2880\li2880\tx2880log:\tab {\uldb Numeric Functions}{\v Numeric_Functions}.\par}{\fi-2880\li2880\tx2880logical false:\tab {\uldb Truth Values}{\v Truth_Values}.\par}{\fi-2880\li2880\tx2880logical operations:\tab {\uldb Boolean Ops}{\v Boolean_Ops}.\par}{\fi-2880\li2880\tx2880logical true:\tab {\uldb Truth Values}{\v Truth_Values}.\par}{\fi-2880\li2880\tx2880login information:\tab {\uldb Passwd Functions}{\v Passwd_Functions}.\par}{\fi-2880\li2880\tx2880long options:\tab {\uldb Invoking Gawk}{\v Invoking_Gawk}.\par}{\fi-2880\li2880\tx2880loop:\tab {\uldb While Statement}{\v While_Statement}.\par}{\fi-2880\li2880\tx2880loops, exiting:\tab {\uldb Break Statement}{\v Break_Statement}.\par}{\fi-2880\li2880\tx2880lvalue:\tab {\uldb Assignment Ops}{\v Assignment_Ops}.\par}{\fi-2880\li2880\tx2880mark parity:\tab {\uldb Ordinal Functions}{\v Ordinal_Functions}.\par}{\fi-2880\li2880\tx2880match:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880matching ranges of lines:\tab {\uldb Ranges}{\v Ranges}.\par}{\fi-2880\li2880\tx2880matching, leftmost longest <1>:\tab {\uldb Leftmost Longest}{\v Leftmost_Longest}.\par}{\fi-2880\li2880\tx2880matching, leftmost longest:\tab {\uldb Multiple Line}{\v Multiple_Line}.\par}{\fi-2880\li2880\tx2880merging strings:\tab {\uldb Join Function}{\v Join_Function}.\par}{\fi-2880\li2880\tx2880metacharacters:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880mistakes, common <1>:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880mistakes, common <2>:\tab {\uldb Computed Regexps}{\v Computed_Regexps}.\par}{\fi-2880\li2880\tx2880mistakes, common <3>:\tab {\uldb Print Examples}{\v Print_Examples}.\par}{\fi-2880\li2880\tx2880mistakes, common:\tab {\uldb Basic Field Splitting}{\v Basic_Field_Splitting}.\par}{\fi-2880\li2880\tx2880mktime:\tab {\uldb Mktime Function}{\v Mktime_Function}.\par}{\fi-2880\li2880\tx2880modifiers (in format specifiers):\tab {\uldb Format Modifiers}{\v Format_Modifiers}.\par}{\fi-2880\li2880\tx2880multi-dimensional subscripts:\tab {\uldb Multi-dimensional}{\v Multi_dimensional}.\par}{\fi-2880\li2880\tx2880multiple line records:\tab {\uldb Multiple Line}{\v Multiple_Line}.\par}{\fi-2880\li2880\tx2880multiple passes over data:\tab {\uldb Other Arguments}{\v Other_Arguments}.\par}{\fi-2880\li2880\tx2880multiple statements on one line:\tab {\uldb Statements/Lines}{\v Statements_Lines}.\par}{\fi-2880\li2880\tx2880multiplication:\tab {\uldb Arithmetic Ops}{\v Arithmetic_Ops}.\par}{\fi-2880\li2880\tx2880names, use of:\tab {\uldb Definition Syntax}{\v Definition_Syntax}.\par}{\fi-2880\li2880\tx2880namespace issues in {\f1{}awk}:\tab {\uldb Library Names}{\v Library_Names}.\par}{\fi-2880\li2880\tx2880namespaces:\tab {\uldb Definition Syntax}{\v Definition_Syntax}.\par}{\fi-2880\li2880\tx2880NetBSD:\tab {\uldb Manual History}{\v Manual_History}.\par}{\fi-2880\li2880\tx2880new {\f1{}awk}:\tab {\uldb History}{\v History}.\par}{\fi-2880\li2880\tx2880new {\f1{}awk} vs. old {\f1{}awk}:\tab {\uldb Names}{\v Names}.\par}{\fi-2880\li2880\tx2880newline:\tab {\uldb Statements/Lines}{\v Statements_Lines}.\par}{\fi-2880\li2880\tx2880NF <1>:\tab {\uldb Fields}{\v Fields}.\par}{\fi-2880\li2880\tx2880NF:\tab {\uldb Auto-set}{\v Auto_set}.\par}{\fi-2880\li2880\tx2880non-interactive buffering vs. interactive:\tab {\uldb I/O Functions}{\v I_O_Functions}.\par}{\fi-2880\li2880\tx2880not operator:\tab {\uldb Boolean Ops}{\v Boolean_Ops}.\par}{\fi-2880\li2880\tx2880NR <1>:\tab {\uldb Auto-set}{\v Auto_set}.\par}{\fi-2880\li2880\tx2880NR:\tab {\uldb Records}{\v Records}.\par}{\fi-2880\li2880\tx2880null string <1>:\tab {\uldb Regexp Field Splitting}{\v Regexp_Field_Splitting}.\par}{\fi-2880\li2880\tx2880null string <2>:\tab {\uldb Conversion}{\v Conversion}.\par}{\fi-2880\li2880\tx2880null string:\tab {\uldb Truth Values}{\v Truth_Values}.\par}{\fi-2880\li2880\tx2880null string, as array subscript:\tab {\uldb Uninitialized Subscripts}{\v Uninitialized_Subscripts}.\par}{\fi-2880\li2880\tx2880number of fields, {\f1{}NF}:\tab {\uldb Fields}{\v Fields}.\par}{\fi-2880\li2880\tx2880number of records, {\f1{}NR}, {\f1{}FNR}:\tab {\uldb Records}{\v Records}.\par}{\fi-2880\li2880\tx2880numbers, used as subscripts:\tab {\uldb Numeric Array Subscripts}{\v Numeric_Array_Subscripts}.\par}{\fi-2880\li2880\tx2880numeric character values:\tab {\uldb Ordinal Functions}{\v Ordinal_Functions}.\par}{\fi-2880\li2880\tx2880numeric constant:\tab {\uldb Scalar Constants}{\v Scalar_Constants}.\par}{\fi-2880\li2880\tx2880numeric output format:\tab {\uldb OFMT}{\v OFMT}.\par}{\fi-2880\li2880\tx2880numeric string:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880numeric value:\tab {\uldb Scalar Constants}{\v Scalar_Constants}.\par}{\fi-2880\li2880\tx2880obsolete features:\tab {\uldb Obsolete}{\v Obsolete}.\par}{\fi-2880\li2880\tx2880obsolete options:\tab {\uldb Obsolete}{\v Obsolete}.\par}{\fi-2880\li2880\tx2880OFMT <1>:\tab {\uldb Conversion}{\v Conversion}.\par}{\fi-2880\li2880\tx2880OFMT <2>:\tab {\uldb User-modified}{\v User_modified}.\par}{\fi-2880\li2880\tx2880OFMT:\tab {\uldb OFMT}{\v OFMT}.\par}{\fi-2880\li2880\tx2880OFS <1>:\tab {\uldb User-modified}{\v User_modified}.\par}{\fi-2880\li2880\tx2880OFS:\tab {\uldb Output Separators}{\v Output_Separators}.\par}{\fi-2880\li2880\tx2880old {\f1{}awk}:\tab {\uldb History}{\v History}.\par}{\fi-2880\li2880\tx2880old {\f1{}awk} vs. new {\f1{}awk}:\tab {\uldb Names}{\v Names}.\par}{\fi-2880\li2880\tx2880one-liners:\tab {\uldb One-liners}{\v One_liners}.\par}{\fi-2880\li2880\tx2880operations, logical:\tab {\uldb Boolean Ops}{\v Boolean_Ops}.\par}{\fi-2880\li2880\tx2880operator precedence:\tab {\uldb Precedence}{\v Precedence}.\par}{\fi-2880\li2880\tx2880operators, arithmetic:\tab {\uldb Arithmetic Ops}{\v Arithmetic_Ops}.\par}{\fi-2880\li2880\tx2880operators, assignment:\tab {\uldb Assignment Ops}{\v Assignment_Ops}.\par}{\fi-2880\li2880\tx2880operators, boolean:\tab {\uldb Boolean Ops}{\v Boolean_Ops}.\par}{\fi-2880\li2880\tx2880operators, decrement:\tab {\uldb Increment Ops}{\v Increment_Ops}.\par}{\fi-2880\li2880\tx2880operators, increment:\tab {\uldb Increment Ops}{\v Increment_Ops}.\par}{\fi-2880\li2880\tx2880operators, regexp matching:\tab {\uldb Regexp Usage}{\v Regexp_Usage}.\par}{\fi-2880\li2880\tx2880operators, relational:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880operators, short-circuit:\tab {\uldb Boolean Ops}{\v Boolean_Ops}.\par}{\fi-2880\li2880\tx2880operators, string:\tab {\uldb Concatenation}{\v Concatenation}.\par}{\fi-2880\li2880\tx2880operators, string-matching:\tab {\uldb Regexp Usage}{\v Regexp_Usage}.\par}{\fi-2880\li2880\tx2880options, command line:\tab {\uldb Invoking Gawk}{\v Invoking_Gawk}.\par}{\fi-2880\li2880\tx2880options, long:\tab {\uldb Invoking Gawk}{\v Invoking_Gawk}.\par}{\fi-2880\li2880\tx2880or operator:\tab {\uldb Boolean Ops}{\v Boolean_Ops}.\par}{\fi-2880\li2880\tx2880ord:\tab {\uldb Ordinal Functions}{\v Ordinal_Functions}.\par}{\fi-2880\li2880\tx2880order of evaluation:\tab {\uldb Calling Built-in}{\v Calling_Built_in}.\par}{\fi-2880\li2880\tx2880ORS <1>:\tab {\uldb User-modified}{\v User_modified}.\par}{\fi-2880\li2880\tx2880ORS:\tab {\uldb Output Separators}{\v Output_Separators}.\par}{\fi-2880\li2880\tx2880output:\tab {\uldb Printing}{\v Printing}.\par}{\fi-2880\li2880\tx2880output field separator, {\f1{}OFS}:\tab {\uldb Output Separators}{\v Output_Separators}.\par}{\fi-2880\li2880\tx2880output format specifier, {\f1{}OFMT}:\tab {\uldb OFMT}{\v OFMT}.\par}{\fi-2880\li2880\tx2880output record separator, {\f1{}ORS}:\tab {\uldb Output Separators}{\v Output_Separators}.\par}{\fi-2880\li2880\tx2880output redirection:\tab {\uldb Redirection}{\v Redirection}.\par}{\fi-2880\li2880\tx2880output, buffering:\tab {\uldb I/O Functions}{\v I_O_Functions}.\par}{\fi-2880\li2880\tx2880output, formatted:\tab {\uldb Printf}{\v Printf}.\par}{\fi-2880\li2880\tx2880output, piping:\tab {\uldb Redirection}{\v Redirection}.\par}{\fi-2880\li2880\tx2880passes, multiple:\tab {\uldb Other Arguments}{\v Other_Arguments}.\par}{\fi-2880\li2880\tx2880password file:\tab {\uldb Passwd Functions}{\v Passwd_Functions}.\par}{\fi-2880\li2880\tx2880path, search:\tab {\uldb AWKPATH Variable}{\v AWKPATH_Variable}.\par}{\fi-2880\li2880\tx2880pattern, default:\tab {\uldb Very Simple}{\v Very_Simple}.\par}{\fi-2880\li2880\tx2880pattern, definition of:\tab {\uldb Patterns and Actions}{\v Patterns_and_Actions}.\par}{\fi-2880\li2880\tx2880pattern, empty:\tab {\uldb Empty}{\v Empty}.\par}{\fi-2880\li2880\tx2880pattern, range:\tab {\uldb Ranges}{\v Ranges}.\par}{\fi-2880\li2880\tx2880pattern, regular expressions:\tab {\uldb Regexp}{\v Regexp}.\par}{\fi-2880\li2880\tx2880pattern, {\f1{}BEGIN}:\tab {\uldb BEGIN/END}{\v BEGIN_END}.\par}{\fi-2880\li2880\tx2880pattern, {\f1{}END}:\tab {\uldb BEGIN/END}{\v BEGIN_END}.\par}{\fi-2880\li2880\tx2880patterns, types of:\tab {\uldb Kinds of Patterns}{\v Kinds_of_Patterns}.\par}{\fi-2880\li2880\tx2880per file initialization and clean-up:\tab {\uldb Filetrans Function}{\v Filetrans_Function}.\par}{\fi-2880\li2880\tx2880PERL:\tab {\uldb Future Extensions}{\v Future_Extensions}.\par}{\fi-2880\li2880\tx2880pipeline, input:\tab {\uldb Getline/Pipe}{\v Getline_Pipe}.\par}{\fi-2880\li2880\tx2880pipes for output:\tab {\uldb Redirection}{\v Redirection}.\par}{\fi-2880\li2880\tx2880portability issues <1>:\tab {\uldb Portability Notes}{\v Portability_Notes}.\par}{\fi-2880\li2880\tx2880portability issues <2>:\tab {\uldb Escape Sequences}{\v Escape_Sequences}.\par}{\fi-2880\li2880\tx2880portability issues <3>:\tab {\uldb Delete}{\v Delete}.\par}{\fi-2880\li2880\tx2880portability issues <4>:\tab {\uldb I/O Functions}{\v I_O_Functions}.\par}{\fi-2880\li2880\tx2880portability issues <5>:\tab {\uldb Statements/Lines}{\v Statements_Lines}.\par}{\fi-2880\li2880\tx2880portability issues <6>:\tab {\uldb Definition Syntax}{\v Definition_Syntax}.\par}{\fi-2880\li2880\tx2880portability issues <7>:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880portability issues:\tab {\uldb Close Files And Pipes}{\v Close_Files_And_Pipes}.\par}{\fi-2880\li2880\tx2880porting {\f1{}gawk}:\tab {\uldb New Ports}{\v New_Ports}.\par}{\fi-2880\li2880\tx2880POSIX mode:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880POSIX {\f1{}awk} <1>:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880POSIX {\f1{}awk} <2>:\tab {\uldb Conversion}{\v Conversion}.\par}{\fi-2880\li2880\tx2880POSIX {\f1{}awk} <3>:\tab {\uldb User-modified}{\v User_modified}.\par}{\fi-2880\li2880\tx2880POSIX {\f1{}awk} <4>:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880POSIX {\f1{}awk} <5>:\tab {\uldb Assignment Ops}{\v Assignment_Ops}.\par}{\fi-2880\li2880\tx2880POSIX {\f1{}awk} <6>:\tab {\uldb Precedence}{\v Precedence}.\par}{\fi-2880\li2880\tx2880POSIX {\f1{}awk} <7>:\tab {\uldb Next Statement}{\v Next_Statement}.\par}{\fi-2880\li2880\tx2880POSIX {\f1{}awk} <8>:\tab {\uldb Format Modifiers}{\v Format_Modifiers}.\par}{\fi-2880\li2880\tx2880POSIX {\f1{}awk} <9>:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880POSIX {\f1{}awk} <10>:\tab {\uldb Continue Statement}{\v Continue_Statement}.\par}{\fi-2880\li2880\tx2880POSIX {\f1{}awk} <11>:\tab {\uldb Definition Syntax}{\v Definition_Syntax}.\par}{\fi-2880\li2880\tx2880POSIX {\f1{}awk} <12>:\tab {\uldb Escape Sequences}{\v Escape_Sequences}.\par}{\fi-2880\li2880\tx2880POSIX {\f1{}awk} <13>:\tab {\uldb Precedence}{\v Precedence}.\par}{\fi-2880\li2880\tx2880POSIX {\f1{}awk} <14>:\tab {\uldb OFMT}{\v OFMT}.\par}{\fi-2880\li2880\tx2880POSIX {\f1{}awk} <15>:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880POSIX {\f1{}awk} <16>:\tab {\uldb Field Splitting Summary}{\v Field_Splitting_Summary}.\par}{\fi-2880\li2880\tx2880POSIX {\f1{}awk} <17>:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880POSIX {\f1{}awk} <18>:\tab {\uldb Break Statement}{\v Break_Statement}.\par}{\fi-2880\li2880\tx2880POSIX {\f1{}awk}:\tab {\uldb Arithmetic Ops}{\v Arithmetic_Ops}.\par}{\fi-2880\li2880\tx2880precedence:\tab {\uldb Precedence}{\v Precedence}.\par}{\fi-2880\li2880\tx2880precedence, regexp operators:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880printing:\tab {\uldb Printing}{\v Printing}.\par}{\fi-2880\li2880\tx2880procedural languages:\tab {\uldb Getting Started}{\v Getting_Started}.\par}{\fi-2880\li2880\tx2880process information:\tab {\uldb Special Files}{\v Special_Files}.\par}{\fi-2880\li2880\tx2880processing arguments:\tab {\uldb Getopt Function}{\v Getopt_Function}.\par}{\fi-2880\li2880\tx2880program file:\tab {\uldb Long}{\v Long}.\par}{\fi-2880\li2880\tx2880program, definition of:\tab {\uldb Getting Started}{\v Getting_Started}.\par}{\fi-2880\li2880\tx2880program, self contained:\tab {\uldb Executable Scripts}{\v Executable_Scripts}.\par}{\fi-2880\li2880\tx2880program, {\f1{}awk}:\tab {\uldb This Manual}{\v This_Manual}.\par}{\fi-2880\li2880\tx2880programs, documenting <1>:\tab {\uldb Library Names}{\v Library_Names}.\par}{\fi-2880\li2880\tx2880programs, documenting:\tab {\uldb Comments}{\v Comments}.\par}{\fi-2880\li2880\tx2880pwcat.c:\tab {\uldb Passwd Functions}{\v Passwd_Functions}.\par}{\fi-2880\li2880\tx2880quotient:\tab {\uldb Arithmetic Ops}{\v Arithmetic_Ops}.\par}{\fi-2880\li2880\tx2880quoting, shell <1>:\tab {\uldb Read Terminal}{\v Read_Terminal}.\par}{\fi-2880\li2880\tx2880quoting, shell:\tab {\uldb Long}{\v Long}.\par}{\fi-2880\li2880\tx2880Rakitzis, Byron:\tab {\uldb History Sorting}{\v History_Sorting}.\par}{\fi-2880\li2880\tx2880rand:\tab {\uldb Numeric Functions}{\v Numeric_Functions}.\par}{\fi-2880\li2880\tx2880random numbers, seed of:\tab {\uldb Numeric Functions}{\v Numeric_Functions}.\par}{\fi-2880\li2880\tx2880range pattern:\tab {\uldb Ranges}{\v Ranges}.\par}{\fi-2880\li2880\tx2880Rankin, Pat <1>:\tab {\uldb Acknowledgements}{\v Acknowledgements}.\par}{\fi-2880\li2880\tx2880Rankin, Pat <2>:\tab {\uldb Bugs}{\v Bugs}.\par}{\fi-2880\li2880\tx2880Rankin, Pat:\tab {\uldb Assignment Ops}{\v Assignment_Ops}.\par}{\fi-2880\li2880\tx2880reading files:\tab {\uldb Reading Files}{\v Reading_Files}.\par}{\fi-2880\li2880\tx2880reading files, multiple line records:\tab {\uldb Multiple Line}{\v Multiple_Line}.\par}{\fi-2880\li2880\tx2880reading files, {\f1{}getline} command:\tab {\uldb Getline}{\v Getline}.\par}{\fi-2880\li2880\tx2880record separator, {\f1{}RS}:\tab {\uldb Records}{\v Records}.\par}{\fi-2880\li2880\tx2880record terminator, {\f1{}RT}:\tab {\uldb Records}{\v Records}.\par}{\fi-2880\li2880\tx2880record, definition of:\tab {\uldb Records}{\v Records}.\par}{\fi-2880\li2880\tx2880records, multiple line:\tab {\uldb Multiple Line}{\v Multiple_Line}.\par}{\fi-2880\li2880\tx2880recursive function:\tab {\uldb Definition Syntax}{\v Definition_Syntax}.\par}{\fi-2880\li2880\tx2880redirection of input:\tab {\uldb Getline/File}{\v Getline_File}.\par}{\fi-2880\li2880\tx2880redirection of output:\tab {\uldb Redirection}{\v Redirection}.\par}{\fi-2880\li2880\tx2880reference to array:\tab {\uldb Reference to Elements}{\v Reference_to_Elements}.\par}{\fi-2880\li2880\tx2880regexp:\tab {\uldb Regexp}{\v Regexp}.\par}{\fi-2880\li2880\tx2880regexp as expression:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880regexp comparison vs. string comparison:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880regexp constant:\tab {\uldb Regexp Usage}{\v Regexp_Usage}.\par}{\fi-2880\li2880\tx2880regexp constants, difference between slashes and quotes:\tab {\uldb Computed Regexps}{\v Computed_Regexps}.\par}{\fi-2880\li2880\tx2880regexp match/non-match operators <1>:\tab {\uldb Regexp Usage}{\v Regexp_Usage}.\par}{\fi-2880\li2880\tx2880regexp match/non-match operators:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880regexp matching operators:\tab {\uldb Regexp Usage}{\v Regexp_Usage}.\par}{\fi-2880\li2880\tx2880regexp operators:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880regexp operators, GNU specific:\tab {\uldb GNU Regexp Operators}{\v GNU_Regexp_Operators}.\par}{\fi-2880\li2880\tx2880regexp operators, precedence of:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880regexp, anchors:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880regexp, dynamic:\tab {\uldb Computed Regexps}{\v Computed_Regexps}.\par}{\fi-2880\li2880\tx2880regexp, effect of command line options:\tab {\uldb GNU Regexp Operators}{\v GNU_Regexp_Operators}.\par}{\fi-2880\li2880\tx2880regular expression:\tab {\uldb Regexp}{\v Regexp}.\par}{\fi-2880\li2880\tx2880regular expression metacharacters:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880regular expressions as field separators:\tab {\uldb Basic Field Splitting}{\v Basic_Field_Splitting}.\par}{\fi-2880\li2880\tx2880regular expressions as patterns:\tab {\uldb Regexp}{\v Regexp}.\par}{\fi-2880\li2880\tx2880regular expressions as record separators:\tab {\uldb Records}{\v Records}.\par}{\fi-2880\li2880\tx2880regular expressions, computed:\tab {\uldb Computed Regexps}{\v Computed_Regexps}.\par}{\fi-2880\li2880\tx2880relational operators:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880remainder:\tab {\uldb Arithmetic Ops}{\v Arithmetic_Ops}.\par}{\fi-2880\li2880\tx2880removing elements of arrays:\tab {\uldb Delete}{\v Delete}.\par}{\fi-2880\li2880\tx2880RFC-1036:\tab {\uldb Time Functions}{\v Time_Functions}.\par}{\fi-2880\li2880\tx2880RFC-822:\tab {\uldb Time Functions}{\v Time_Functions}.\par}{\fi-2880\li2880\tx2880RLENGTH <1>:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880RLENGTH:\tab {\uldb Auto-set}{\v Auto_set}.\par}{\fi-2880\li2880\tx2880Robbins, Miriam:\tab {\uldb Acknowledgements}{\v Acknowledgements}.\par}{\fi-2880\li2880\tx2880Rommel, Kai Uwe <1>:\tab {\uldb Bugs}{\v Bugs}.\par}{\fi-2880\li2880\tx2880Rommel, Kai Uwe:\tab {\uldb Acknowledgements}{\v Acknowledgements}.\par}{\fi-2880\li2880\tx2880round:\tab {\uldb Round Function}{\v Round_Function}.\par}{\fi-2880\li2880\tx2880rounding:\tab {\uldb Round Function}{\v Round_Function}.\par}{\fi-2880\li2880\tx2880RS <1>:\tab {\uldb User-modified}{\v User_modified}.\par}{\fi-2880\li2880\tx2880RS:\tab {\uldb Records}{\v Records}.\par}{\fi-2880\li2880\tx2880RSTART <1>:\tab {\uldb Auto-set}{\v Auto_set}.\par}{\fi-2880\li2880\tx2880RSTART:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880RT <1>:\tab {\uldb Auto-set}{\v Auto_set}.\par}{\fi-2880\li2880\tx2880RT <2>:\tab {\uldb Records}{\v Records}.\par}{\fi-2880\li2880\tx2880RT:\tab {\uldb Multiple Line}{\v Multiple_Line}.\par}{\fi-2880\li2880\tx2880rule, definition of:\tab {\uldb Getting Started}{\v Getting_Started}.\par}{\fi-2880\li2880\tx2880running long programs:\tab {\uldb Long}{\v Long}.\par}{\fi-2880\li2880\tx2880running {\f1{}awk} programs:\tab {\uldb Running gawk}{\v Running_gawk}.\par}{\fi-2880\li2880\tx2880rvalue:\tab {\uldb Assignment Ops}{\v Assignment_Ops}.\par}{\fi-2880\li2880\tx2880sample input file:\tab {\uldb Sample Data Files}{\v Sample_Data_Files}.\par}{\fi-2880\li2880\tx2880scanning an array:\tab {\uldb Scanning an Array}{\v Scanning_an_Array}.\par}{\fi-2880\li2880\tx2880script, definition of:\tab {\uldb Getting Started}{\v Getting_Started}.\par}{\fi-2880\li2880\tx2880scripts, executable:\tab {\uldb Executable Scripts}{\v Executable_Scripts}.\par}{\fi-2880\li2880\tx2880scripts, shell:\tab {\uldb Executable Scripts}{\v Executable_Scripts}.\par}{\fi-2880\li2880\tx2880search path:\tab {\uldb AWKPATH Variable}{\v AWKPATH_Variable}.\par}{\fi-2880\li2880\tx2880search path, for source files:\tab {\uldb AWKPATH Variable}{\v AWKPATH_Variable}.\par}{\fi-2880\li2880\tx2880seed for random numbers:\tab {\uldb Numeric Functions}{\v Numeric_Functions}.\par}{\fi-2880\li2880\tx2880self contained programs:\tab {\uldb Executable Scripts}{\v Executable_Scripts}.\par}{\fi-2880\li2880\tx2880shell quoting <1>:\tab {\uldb Long}{\v Long}.\par}{\fi-2880\li2880\tx2880shell quoting:\tab {\uldb Read Terminal}{\v Read_Terminal}.\par}{\fi-2880\li2880\tx2880shell scripts:\tab {\uldb Executable Scripts}{\v Executable_Scripts}.\par}{\fi-2880\li2880\tx2880short-circuit operators:\tab {\uldb Boolean Ops}{\v Boolean_Ops}.\par}{\fi-2880\li2880\tx2880side effect:\tab {\uldb Assignment Ops}{\v Assignment_Ops}.\par}{\fi-2880\li2880\tx2880simple stream editor:\tab {\uldb Simple Sed}{\v Simple_Sed}.\par}{\fi-2880\li2880\tx2880sin:\tab {\uldb Numeric Functions}{\v Numeric_Functions}.\par}{\fi-2880\li2880\tx2880single character fields:\tab {\uldb Single Character Fields}{\v Single_Character_Fields}.\par}{\fi-2880\li2880\tx2880single quotes, why needed:\tab {\uldb One-shot}{\v One_shot}.\par}{\fi-2880\li2880\tx2880skipping input files:\tab {\uldb Nextfile Function}{\v Nextfile_Function}.\par}{\fi-2880\li2880\tx2880skipping lines between markers:\tab {\uldb Ranges}{\v Ranges}.\par}{\fi-2880\li2880\tx2880sparse arrays:\tab {\uldb Array Intro}{\v Array_Intro}.\par}{\fi-2880\li2880\tx2880split:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880split.awk:\tab {\uldb Split Program}{\v Split_Program}.\par}{\fi-2880\li2880\tx2880sprintf:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880sqrt:\tab {\uldb Numeric Functions}{\v Numeric_Functions}.\par}{\fi-2880\li2880\tx2880srand:\tab {\uldb Numeric Functions}{\v Numeric_Functions}.\par}{\fi-2880\li2880\tx2880Stallman, Richard <1>:\tab {\uldb Acknowledgements}{\v Acknowledgements}.\par}{\fi-2880\li2880\tx2880Stallman, Richard:\tab {\uldb Manual History}{\v Manual_History}.\par}{\fi-2880\li2880\tx2880standard error output:\tab {\uldb Special Files}{\v Special_Files}.\par}{\fi-2880\li2880\tx2880standard input <1>:\tab {\uldb Special Files}{\v Special_Files}.\par}{\fi-2880\li2880\tx2880standard input <2>:\tab {\uldb Read Terminal}{\v Read_Terminal}.\par}{\fi-2880\li2880\tx2880standard input:\tab {\uldb Reading Files}{\v Reading_Files}.\par}{\fi-2880\li2880\tx2880standard output:\tab {\uldb Special Files}{\v Special_Files}.\par}{\fi-2880\li2880\tx2880statement, compound:\tab {\uldb Statements}{\v Statements}.\par}{\fi-2880\li2880\tx2880stream editor:\tab {\uldb Field Splitting Summary}{\v Field_Splitting_Summary}.\par}{\fi-2880\li2880\tx2880stream editor, simple:\tab {\uldb Simple Sed}{\v Simple_Sed}.\par}{\fi-2880\li2880\tx2880strftime:\tab {\uldb Time Functions}{\v Time_Functions}.\par}{\fi-2880\li2880\tx2880string comparison vs. regexp comparison:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880string constants:\tab {\uldb Constants}{\v Constants}.\par}{\fi-2880\li2880\tx2880string operators:\tab {\uldb Concatenation}{\v Concatenation}.\par}{\fi-2880\li2880\tx2880string-matching operators:\tab {\uldb Regexp Usage}{\v Regexp_Usage}.\par}{\fi-2880\li2880\tx2880sub:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880subscripts in arrays:\tab {\uldb Multi-dimensional}{\v Multi_dimensional}.\par}{\fi-2880\li2880\tx2880SUBSEP <1>:\tab {\uldb User-modified}{\v User_modified}.\par}{\fi-2880\li2880\tx2880SUBSEP:\tab {\uldb Multi-dimensional}{\v Multi_dimensional}.\par}{\fi-2880\li2880\tx2880substr:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880subtraction:\tab {\uldb Arithmetic Ops}{\v Arithmetic_Ops}.\par}{\fi-2880\li2880\tx2880system:\tab {\uldb I/O Functions}{\v I_O_Functions}.\par}{\fi-2880\li2880\tx2880systime:\tab {\uldb Time Functions}{\v Time_Functions}.\par}{\fi-2880\li2880\tx2880Tcl:\tab {\uldb Library Names}{\v Library_Names}.\par}{\fi-2880\li2880\tx2880tee.awk:\tab {\uldb Tee Program}{\v Tee_Program}.\par}{\fi-2880\li2880\tx2880terminator, record:\tab {\uldb Records}{\v Records}.\par}{\fi-2880\li2880\tx2880time of day:\tab {\uldb Time Functions}{\v Time_Functions}.\par}{\fi-2880\li2880\tx2880timestamps:\tab {\uldb Time Functions}{\v Time_Functions}.\par}{\fi-2880\li2880\tx2880timestamps, converting from dates:\tab {\uldb Mktime Function}{\v Mktime_Function}.\par}{\fi-2880\li2880\tx2880timestamps, formatted:\tab {\uldb Gettimeofday Function}{\v Gettimeofday_Function}.\par}{\fi-2880\li2880\tx2880tolower:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880toupper:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880translate.awk:\tab {\uldb Translate Program}{\v Translate_Program}.\par}{\fi-2880\li2880\tx2880Trueman, David:\tab {\uldb Acknowledgements}{\v Acknowledgements}.\par}{\fi-2880\li2880\tx2880truth values:\tab {\uldb Truth Values}{\v Truth_Values}.\par}{\fi-2880\li2880\tx2880type conversion:\tab {\uldb Conversion}{\v Conversion}.\par}{\fi-2880\li2880\tx2880types of variables <1>:\tab {\uldb Assignment Ops}{\v Assignment_Ops}.\par}{\fi-2880\li2880\tx2880types of variables:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880undefined functions:\tab {\uldb Function Caveats}{\v Function_Caveats}.\par}{\fi-2880\li2880\tx2880undocumented features:\tab {\uldb Undocumented}{\v Undocumented}.\par}{\fi-2880\li2880\tx2880uninitialized variables, as array subscripts:\tab {\uldb Uninitialized Subscripts}{\v Uninitialized_Subscripts}.\par}{\fi-2880\li2880\tx2880uniq.awk:\tab {\uldb Uniq Program}{\v Uniq_Program}.\par}{\fi-2880\li2880\tx2880use of comments:\tab {\uldb Comments}{\v Comments}.\par}{\fi-2880\li2880\tx2880user information:\tab {\uldb Passwd Functions}{\v Passwd_Functions}.\par}{\fi-2880\li2880\tx2880user-defined functions:\tab {\uldb User-defined}{\v User_defined}.\par}{\fi-2880\li2880\tx2880user-defined variables:\tab {\uldb Using Variables}{\v Using_Variables}.\par}{\fi-2880\li2880\tx2880uses of {\f1{}awk}:\tab {\uldb What Is Awk}{\v What_Is_Awk}.\par}{\fi-2880\li2880\tx2880using this book:\tab {\uldb This Manual}{\v This_Manual}.\par}{\fi-2880\li2880\tx2880values of characters as numbers:\tab {\uldb Ordinal Functions}{\v Ordinal_Functions}.\par}{\fi-2880\li2880\tx2880variable shadowing:\tab {\uldb Definition Syntax}{\v Definition_Syntax}.\par}{\fi-2880\li2880\tx2880variable typing:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880variables, user-defined:\tab {\uldb Using Variables}{\v Using_Variables}.\par}{\fi-2880\li2880\tx2880Wall, Larry:\tab {\uldb Future Extensions}{\v Future_Extensions}.\par}{\fi-2880\li2880\tx2880wc.awk:\tab {\uldb Wc Program}{\v Wc_Program}.\par}{\fi-2880\li2880\tx2880Weinberger, Peter:\tab {\uldb History}{\v History}.\par}{\fi-2880\li2880\tx2880when to use {\f1{}awk}:\tab {\uldb When}{\v When}.\par}{\fi-2880\li2880\tx2880word boundaries, matching:\tab {\uldb GNU Regexp Operators}{\v GNU_Regexp_Operators}.\par}{\fi-2880\li2880\tx2880word, regexp definition of:\tab {\uldb GNU Regexp Operators}{\v GNU_Regexp_Operators}.\par}{\fi-2880\li2880\tx2880wordfreq.sh:\tab {\uldb Word Sorting}{\v Word_Sorting}.\par}{\fi-2880\li2880\tx2880{\f1{}!=} operator:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880{\f1{}!} operator:\tab {\uldb Boolean Ops}{\v Boolean_Ops}.\par}{\fi-2880\li2880\tx2880{\f1{}!~} operator <1>:\tab {\uldb Computed Regexps}{\v Computed_Regexps}.\par}{\fi-2880\li2880\tx2880{\f1{}!~} operator <2>:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880{\f1{}!~} operator <3>:\tab {\uldb Regexp Constants}{\v Regexp_Constants}.\par}{\fi-2880\li2880\tx2880{\f1{}!~} operator <4>:\tab {\uldb Case-sensitivity}{\v Case_sensitivity}.\par}{\fi-2880\li2880\tx2880{\f1{}!~} operator:\tab {\uldb Regexp Usage}{\v Regexp_Usage}.\par}{\fi-2880\li2880\tx2880{\f1{}#!} (executable scripts):\tab {\uldb Executable Scripts}{\v Executable_Scripts}.\par}{\fi-2880\li2880\tx2880{\f1{}#} (comment):\tab {\uldb Comments}{\v Comments}.\par}{\fi-2880\li2880\tx2880{\f1{}$} (field operator):\tab {\uldb Fields}{\v Fields}.\par}{\fi-2880\li2880\tx2880{\f1{}&&} operator:\tab {\uldb Boolean Ops}{\v Boolean_Ops}.\par}{\fi-2880\li2880\tx2880{\f1{}--assign} option:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880{\f1{}--compat} option:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880{\f1{}--copyleft} option:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880{\f1{}--copyright} option:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880{\f1{}--field-separator} option:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880{\f1{}--file} option:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880{\f1{}--help} option:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880{\f1{}--lint-old} option:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880{\f1{}--lint} option:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880{\f1{}--posix} option:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880{\f1{}--source} option:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880{\f1{}--traditional} option:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880{\f1{}--usage} option:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880{\f1{}--version} option:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880{\f1{}-f} option:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880{\f1{}-F} option:\tab {\uldb Command Line Field Separator}{\v Command_Line_Field_Separator}.\par}{\fi-2880\li2880\tx2880{\f1{}-f} option:\tab {\uldb Long}{\v Long}.\par}{\fi-2880\li2880\tx2880{\f1{}-F} option:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880{\f1{}-v} option:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880{\f1{}-W} option:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880{\f1{}/dev/fd}:\tab {\uldb Special Files}{\v Special_Files}.\par}{\fi-2880\li2880\tx2880{\f1{}/dev/pgrpid}:\tab {\uldb Special Files}{\v Special_Files}.\par}{\fi-2880\li2880\tx2880{\f1{}/dev/pid}:\tab {\uldb Special Files}{\v Special_Files}.\par}{\fi-2880\li2880\tx2880{\f1{}/dev/ppid}:\tab {\uldb Special Files}{\v Special_Files}.\par}{\fi-2880\li2880\tx2880{\f1{}/dev/stderr}:\tab {\uldb Special Files}{\v Special_Files}.\par}{\fi-2880\li2880\tx2880{\f1{}/dev/stdin}:\tab {\uldb Special Files}{\v Special_Files}.\par}{\fi-2880\li2880\tx2880{\f1{}/dev/stdout}:\tab {\uldb Special Files}{\v Special_Files}.\par}{\fi-2880\li2880\tx2880{\f1{}/dev/user} <1>:\tab {\uldb Special Files}{\v Special_Files}.\par}{\fi-2880\li2880\tx2880{\f1{}/dev/user}:\tab {\uldb Passwd Functions}{\v Passwd_Functions}.\par}{\fi-2880\li2880\tx2880{\f1{}<=} operator:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880{\f1{}<} operator:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880{\f1{}==} operator:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880{\f1{}>=} operator:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880{\f1{}>} operator:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880{\f1{}\'5C'} regexp operator:\tab {\uldb GNU Regexp Operators}{\v GNU_Regexp_Operators}.\par}{\fi-2880\li2880\tx2880{\f1{}\'5C<} regexp operator:\tab {\uldb GNU Regexp Operators}{\v GNU_Regexp_Operators}.\par}{\fi-2880\li2880\tx2880{\f1{}\'5C>} regexp operator:\tab {\uldb GNU Regexp Operators}{\v GNU_Regexp_Operators}.\par}{\fi-2880\li2880\tx2880{\f1{}\'5C`} regexp operator:\tab {\uldb GNU Regexp Operators}{\v GNU_Regexp_Operators}.\par}{\fi-2880\li2880\tx2880{\f1{}\'5CB} regexp operator:\tab {\uldb GNU Regexp Operators}{\v GNU_Regexp_Operators}.\par}{\fi-2880\li2880\tx2880{\f1{}\'5CW} regexp operator:\tab {\uldb GNU Regexp Operators}{\v GNU_Regexp_Operators}.\par}{\fi-2880\li2880\tx2880{\f1{}\'5Cw} regexp operator:\tab {\uldb GNU Regexp Operators}{\v GNU_Regexp_Operators}.\par}{\fi-2880\li2880\tx2880{\f1{}\'5Cy} regexp operator:\tab {\uldb GNU Regexp Operators}{\v GNU_Regexp_Operators}.\par}{\fi-2880\li2880\tx2880{\f1{}assert}, C version:\tab {\uldb Assert Function}{\v Assert_Function}.\par}{\fi-2880\li2880\tx2880{\f1{}AWKPATH} environment variable:\tab {\uldb AWKPATH Variable}{\v AWKPATH_Variable}.\par}{\fi-2880\li2880\tx2880{\f1{}awksed}:\tab {\uldb Simple Sed}{\v Simple_Sed}.\par}{\fi-2880\li2880\tx2880{\f1{}awk} language, POSIX version <1>:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880{\f1{}awk} language, POSIX version <2>:\tab {\uldb Format Modifiers}{\v Format_Modifiers}.\par}{\fi-2880\li2880\tx2880{\f1{}awk} language, POSIX version <3>:\tab {\uldb Assignment Ops}{\v Assignment_Ops}.\par}{\fi-2880\li2880\tx2880{\f1{}awk} language, POSIX version <4>:\tab {\uldb OFMT}{\v OFMT}.\par}{\fi-2880\li2880\tx2880{\f1{}awk} language, POSIX version <5>:\tab {\uldb Escape Sequences}{\v Escape_Sequences}.\par}{\fi-2880\li2880\tx2880{\f1{}awk} language, POSIX version <6>:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880{\f1{}awk} language, POSIX version <7>:\tab {\uldb Field Splitting Summary}{\v Field_Splitting_Summary}.\par}{\fi-2880\li2880\tx2880{\f1{}awk} language, POSIX version <8>:\tab {\uldb Conversion}{\v Conversion}.\par}{\fi-2880\li2880\tx2880{\f1{}awk} language, POSIX version <9>:\tab {\uldb Precedence}{\v Precedence}.\par}{\fi-2880\li2880\tx2880{\f1{}awk} language, POSIX version <10>:\tab {\uldb Arithmetic Ops}{\v Arithmetic_Ops}.\par}{\fi-2880\li2880\tx2880{\f1{}awk} language, POSIX version <11>:\tab {\uldb Continue Statement}{\v Continue_Statement}.\par}{\fi-2880\li2880\tx2880{\f1{}awk} language, POSIX version <12>:\tab {\uldb Break Statement}{\v Break_Statement}.\par}{\fi-2880\li2880\tx2880{\f1{}awk} language, POSIX version <13>:\tab {\uldb Next Statement}{\v Next_Statement}.\par}{\fi-2880\li2880\tx2880{\f1{}awk} language, POSIX version <14>:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880{\f1{}awk} language, POSIX version <15>:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880{\f1{}awk} language, POSIX version <16>:\tab {\uldb User-modified}{\v User_modified}.\par}{\fi-2880\li2880\tx2880{\f1{}awk} language, POSIX version:\tab {\uldb Definition Syntax}{\v Definition_Syntax}.\par}{\fi-2880\li2880\tx2880{\f1{}awk} language, V.4 version <1>:\tab {\uldb Escape Sequences}{\v Escape_Sequences}.\par}{\fi-2880\li2880\tx2880{\f1{}awk} language, V.4 version:\tab {\uldb SVR4}{\v SVR4}.\par}{\fi-2880\li2880\tx2880{\f1{}BBS-list} file:\tab {\uldb Sample Data Files}{\v Sample_Data_Files}.\par}{\fi-2880\li2880\tx2880{\f1{}BEGIN} special pattern:\tab {\uldb BEGIN/END}{\v BEGIN_END}.\par}{\fi-2880\li2880\tx2880{\f1{}break} statement:\tab {\uldb Break Statement}{\v Break_Statement}.\par}{\fi-2880\li2880\tx2880{\f1{}break}, outside of loops:\tab {\uldb Break Statement}{\v Break_Statement}.\par}{\fi-2880\li2880\tx2880{\f1{}comp.lang.awk}:\tab {\uldb Bugs}{\v Bugs}.\par}{\fi-2880\li2880\tx2880{\f1{}continue} statement:\tab {\uldb Continue Statement}{\v Continue_Statement}.\par}{\fi-2880\li2880\tx2880{\f1{}continue}, outside of loops:\tab {\uldb Continue Statement}{\v Continue_Statement}.\par}{\fi-2880\li2880\tx2880{\f1{}csh}, backslash continuation <1>:\tab {\uldb More Complex}{\v More_Complex}.\par}{\fi-2880\li2880\tx2880{\f1{}csh}, backslash continuation:\tab {\uldb Statements/Lines}{\v Statements_Lines}.\par}{\fi-2880\li2880\tx2880{\f1{}custom.h} configuration file:\tab {\uldb Configuration Philosophy}{\v Configuration_Philosophy}.\par}{\fi-2880\li2880\tx2880{\f1{}cut} utility:\tab {\uldb Cut Program}{\v Cut_Program}.\par}{\fi-2880\li2880\tx2880{\f1{}delete} statement:\tab {\uldb Delete}{\v Delete}.\par}{\fi-2880\li2880\tx2880{\f1{}egrep} <1>:\tab {\uldb One-shot}{\v One_shot}.\par}{\fi-2880\li2880\tx2880{\f1{}egrep}:\tab {\uldb Regexp Operators}{\v Regexp_Operators}.\par}{\fi-2880\li2880\tx2880{\f1{}egrep} utility:\tab {\uldb Egrep Program}{\v Egrep_Program}.\par}{\fi-2880\li2880\tx2880{\f1{}END} special pattern:\tab {\uldb BEGIN/END}{\v BEGIN_END}.\par}{\fi-2880\li2880\tx2880{\f1{}exit} statement:\tab {\uldb Exit Statement}{\v Exit_Statement}.\par}{\fi-2880\li2880\tx2880{\f1{}FILENAME}, being set by {\f1{}getline}:\tab {\uldb Getline Summary}{\v Getline_Summary}.\par}{\fi-2880\li2880\tx2880{\f1{}for (x in ...)}:\tab {\uldb Scanning an Array}{\v Scanning_an_Array}.\par}{\fi-2880\li2880\tx2880{\f1{}for} statement:\tab {\uldb For Statement}{\v For_Statement}.\par}{\fi-2880\li2880\tx2880{\f1{}ftp}, anonymous <1>:\tab {\uldb Getting}{\v Getting}.\par}{\fi-2880\li2880\tx2880{\f1{}ftp}, anonymous:\tab {\uldb Other Versions}{\v Other_Versions}.\par}{\fi-2880\li2880\tx2880{\f1{}gawk} coding style:\tab {\uldb Adding Code}{\v Adding_Code}.\par}{\fi-2880\li2880\tx2880{\f1{}getgrent}, C version:\tab {\uldb Group Functions}{\v Group_Functions}.\par}{\fi-2880\li2880\tx2880{\f1{}getline}, return values:\tab {\uldb Getline Intro}{\v Getline_Intro}.\par}{\fi-2880\li2880\tx2880{\f1{}getline}, setting {\f1{}FILENAME}:\tab {\uldb Getline Summary}{\v Getline_Summary}.\par}{\fi-2880\li2880\tx2880{\f1{}getopt}, C version:\tab {\uldb Getopt Function}{\v Getopt_Function}.\par}{\fi-2880\li2880\tx2880{\f1{}getpwent}, C version:\tab {\uldb Passwd Functions}{\v Passwd_Functions}.\par}{\fi-2880\li2880\tx2880{\f1{}grcat} program:\tab {\uldb Group Functions}{\v Group_Functions}.\par}{\fi-2880\li2880\tx2880{\f1{}gsub}, third argument of:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880{\f1{}id} utility:\tab {\uldb Id Program}{\v Id_Program}.\par}{\fi-2880\li2880\tx2880{\f1{}if}-{\f1{}else} statement:\tab {\uldb If Statement}{\v If_Statement}.\par}{\fi-2880\li2880\tx2880{\f1{}IGNORECASE} and array subscripts:\tab {\uldb Array Intro}{\v Array_Intro}.\par}{\fi-2880\li2880\tx2880{\f1{}inventory-shipped} file:\tab {\uldb Sample Data Files}{\v Sample_Data_Files}.\par}{\fi-2880\li2880\tx2880{\f1{}in} operator:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880{\f1{}mawk}:\tab {\uldb Other Versions}{\v Other_Versions}.\par}{\fi-2880\li2880\tx2880{\f1{}next file} statement:\tab {\uldb Nextfile Statement}{\v Nextfile_Statement}.\par}{\fi-2880\li2880\tx2880{\f1{}nextfile} function:\tab {\uldb Nextfile Function}{\v Nextfile_Function}.\par}{\fi-2880\li2880\tx2880{\f1{}nextfile} statement:\tab {\uldb Nextfile Statement}{\v Nextfile_Statement}.\par}{\fi-2880\li2880\tx2880{\f1{}next} statement:\tab {\uldb Next Statement}{\v Next_Statement}.\par}{\fi-2880\li2880\tx2880{\f1{}next}, inside a user-defined function:\tab {\uldb Next Statement}{\v Next_Statement}.\par}{\fi-2880\li2880\tx2880{\f1{}POSIXLY_CORRECT} environment variable:\tab {\uldb Options}{\v Options}.\par}{\fi-2880\li2880\tx2880{\f1{}printf} statement, syntax of:\tab {\uldb Basic Printf}{\v Basic_Printf}.\par}{\fi-2880\li2880\tx2880{\f1{}printf}, format-control characters:\tab {\uldb Control Letters}{\v Control_Letters}.\par}{\fi-2880\li2880\tx2880{\f1{}printf}, modifiers:\tab {\uldb Format Modifiers}{\v Format_Modifiers}.\par}{\fi-2880\li2880\tx2880{\f1{}print} statement:\tab {\uldb Print}{\v Print}.\par}{\fi-2880\li2880\tx2880{\f1{}pwcat} program:\tab {\uldb Passwd Functions}{\v Passwd_Functions}.\par}{\fi-2880\li2880\tx2880{\f1{}return} statement:\tab {\uldb Return Statement}{\v Return_Statement}.\par}{\fi-2880\li2880\tx2880{\f1{}sed} utility <1>:\tab {\uldb Field Splitting Summary}{\v Field_Splitting_Summary}.\par}{\fi-2880\li2880\tx2880{\f1{}sed} utility <2>:\tab {\uldb Igawk Program}{\v Igawk_Program}.\par}{\fi-2880\li2880\tx2880{\f1{}sed} utility:\tab {\uldb Simple Sed}{\v Simple_Sed}.\par}{\fi-2880\li2880\tx2880{\f1{}split} utility:\tab {\uldb Split Program}{\v Split_Program}.\par}{\fi-2880\li2880\tx2880{\f1{}sub}, third argument of:\tab {\uldb String Functions}{\v String_Functions}.\par}{\fi-2880\li2880\tx2880{\f1{}tee} utility:\tab {\uldb Tee Program}{\v Tee_Program}.\par}{\fi-2880\li2880\tx2880{\f1{}uniq} utility:\tab {\uldb Uniq Program}{\v Uniq_Program}.\par}{\fi-2880\li2880\tx2880{\f1{}wc} utility:\tab {\uldb Wc Program}{\v Wc_Program}.\par}{\fi-2880\li2880\tx2880{\f1{}while} statement:\tab {\uldb While Statement}{\v While_Statement}.\par}{\fi-2880\li2880\tx2880{\f1{}||} operator:\tab {\uldb Boolean Ops}{\v Boolean_Ops}.\par}{\fi-2880\li2880\tx2880{\f1{}~} operator <1>:\tab {\uldb Typing and Comparison}{\v Typing_and_Comparison}.\par}{\fi-2880\li2880\tx2880{\f1{}~} operator <2>:\tab {\uldb Case-sensitivity}{\v Case_sensitivity}.\par}{\fi-2880\li2880\tx2880{\f1{}~} operator <3>:\tab {\uldb Computed Regexps}{\v Computed_Regexps}.\par}{\fi-2880\li2880\tx2880{\f1{}~} operator <4>:\tab {\uldb Regexp Constants}{\v Regexp_Constants}.\par}{\fi-2880\li2880\tx2880{\f1{}~} operator:\tab {\uldb Regexp Usage}{\v Regexp_Usage}.\par}\page K{\footnote Makertf}#{\footnote hcMakertf}${\footnote \pard{}About Makertf}\pard{\fs24\b About Makertf}\par\par\pard{}Makertf is a program that converts "Texinfo" files into "Rich Text Format" (RTF) files. It can be used to make WinHelp Files from GNU manuals and other documentation written in Texinfo. Visit http://www.snafu.de/~cschenk/makertf for more information.}